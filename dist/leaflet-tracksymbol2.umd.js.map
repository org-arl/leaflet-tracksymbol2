{"version":3,"file":"leaflet-tracksymbol2.umd.js","sources":["../node_modules/.pnpm/@flatten-js+core@1.6.2/node_modules/@flatten-js/core/dist/main.mjs","../src/trackSymbol.ts","../src/ais/aisTrackSymbol.ts","../src/index.ts"],"sourcesContent":["/**\r\n * Global constant CCW defines counterclockwise direction of arc\r\n * @type {boolean}\r\n */\r\nconst CCW = true;\r\n\r\n/**\r\n * Global constant CW defines clockwise direction of arc\r\n * @type {boolean}\r\n */\r\nconst CW = false;\r\n\r\n/**\r\n * Defines orientation for face of the polygon: clockwise, counterclockwise\r\n * or not orientable in the case of self-intersection\r\n * @type {{CW: number, CCW: number, NOT_ORIENTABLE: number}}\r\n */\r\nconst ORIENTATION = {CCW:-1, CW:1, NOT_ORIENTABLE: 0};\r\n\r\nconst PIx2 = 2 * Math.PI;\r\n\r\nconst INSIDE$2 = 1;\r\nconst OUTSIDE$1 = 0;\r\nconst BOUNDARY$1 = 2;\r\nconst CONTAINS = 3;\r\nconst INTERLACE = 4;\r\n\r\nconst OVERLAP_SAME$1 = 1;\r\nconst OVERLAP_OPPOSITE$1 = 2;\r\n\r\nconst NOT_VERTEX$1 = 0;\r\nconst START_VERTEX$1 = 1;\r\nconst END_VERTEX$1 = 2;\r\n\r\nvar Constants = /*#__PURE__*/Object.freeze({\r\n    __proto__: null,\r\n    BOUNDARY: BOUNDARY$1,\r\n    CCW: CCW,\r\n    CONTAINS: CONTAINS,\r\n    CW: CW,\r\n    END_VERTEX: END_VERTEX$1,\r\n    INSIDE: INSIDE$2,\r\n    INTERLACE: INTERLACE,\r\n    NOT_VERTEX: NOT_VERTEX$1,\r\n    ORIENTATION: ORIENTATION,\r\n    OUTSIDE: OUTSIDE$1,\r\n    OVERLAP_OPPOSITE: OVERLAP_OPPOSITE$1,\r\n    OVERLAP_SAME: OVERLAP_SAME$1,\r\n    PIx2: PIx2,\r\n    START_VERTEX: START_VERTEX$1\r\n});\r\n\r\n/**\r\n * Created by Alex Bol on 2/18/2017.\r\n */\r\n\r\n/**\r\n * Floating point comparison tolerance.\r\n * Default value is 0.000001 (10e-6)\r\n * @type {number}\r\n */\r\nlet DP_TOL = 0.000001;\r\n\r\n/**\r\n * Set new floating point comparison tolerance\r\n * @param {number} tolerance\r\n */\r\nfunction setTolerance(tolerance) {DP_TOL = tolerance;}\r\n\r\n/**\r\n * Get floating point comparison tolerance\r\n * @returns {number}\r\n */\r\nfunction getTolerance() {return DP_TOL;}\r\n\r\nconst DECIMALS = 3;\r\n\r\n/**\r\n * Returns *true* if value comparable to zero\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nfunction EQ_0(x) {\r\n    return (x < DP_TOL && x > -DP_TOL);\r\n}\r\n\r\n/**\r\n * Returns *true* if two values are equal up to DP_TOL\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nfunction EQ(x, y) {\r\n    return (x - y < DP_TOL && x - y > -DP_TOL);\r\n}\r\n\r\n/**\r\n * Returns *true* if first argument greater than second argument up to DP_TOL\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nfunction GT(x, y) {\r\n    return (x - y > DP_TOL);\r\n}\r\n\r\n/**\r\n * Returns *true* if first argument greater than or equal to second argument up to DP_TOL\r\n * @param {number} x\r\n * @param {number} y\r\n * @returns {boolean}\r\n */\r\nfunction GE(x, y) {\r\n    return (x - y > -DP_TOL);\r\n}\r\n\r\n/**\r\n * Returns *true* if first argument less than second argument up to DP_TOL\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nfunction LT(x, y) {\r\n    return (x - y < -DP_TOL)\r\n}\r\n\r\n/**\r\n * Returns *true* if first argument less than or equal to second argument up to DP_TOL\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nfunction LE(x, y) {\r\n    return (x - y < DP_TOL);\r\n}\r\n\r\nvar Utils$1 = /*#__PURE__*/Object.freeze({\r\n    __proto__: null,\r\n    DECIMALS: DECIMALS,\r\n    EQ: EQ,\r\n    EQ_0: EQ_0,\r\n    GE: GE,\r\n    GT: GT,\r\n    LE: LE,\r\n    LT: LT,\r\n    getTolerance: getTolerance,\r\n    setTolerance: setTolerance\r\n});\r\n\r\nlet Flatten = {\r\n    Utils: Utils$1,\r\n    Errors: undefined,\r\n    Matrix: undefined,\r\n    Planar_set: undefined,\r\n    Point: undefined,\r\n    Vector: undefined,\r\n    Line: undefined,\r\n    Circle: undefined,\r\n    Segment: undefined,\r\n    Arc: undefined,\r\n    Box: undefined,\r\n    Edge: undefined,\r\n    Face: undefined,\r\n    Ray: undefined,\r\n    Ray_shooting: undefined,\r\n    Multiline: undefined,\r\n    Polygon: undefined,\r\n    Distance: undefined,\r\n    Inversion: undefined\r\n};\r\n\r\nfor (let c in Constants) {Flatten[c] = Constants[c];}\r\n\r\nObject.defineProperty(Flatten, 'DP_TOL', {\r\n    get:function(){return getTolerance()}, \r\n    set:function(value){setTolerance(value);}\r\n});\r\n\r\n/**\r\n * Created by Alex Bol on 2/19/2017.\r\n */\r\n\r\n\r\n/**\r\n * Class of system errors\r\n */\r\nclass Errors {\r\n    /**\r\n     * Throw error ILLEGAL_PARAMETERS when cannot instantiate from given parameter\r\n     * @returns {ReferenceError}\r\n     */\r\n    static get ILLEGAL_PARAMETERS() {\r\n        return new ReferenceError('Illegal Parameters');\r\n    }\r\n\r\n    /**\r\n     * Throw error ZERO_DIVISION to catch situation of zero division\r\n     * @returns {Error}\r\n     */\r\n    static get ZERO_DIVISION() {\r\n        return new Error('Zero division');\r\n    }\r\n\r\n    /**\r\n     * Error to throw from BooleanOperations module in case when fixBoundaryConflicts not capable to fix it\r\n     * @returns {Error}\r\n     */\r\n    static get UNRESOLVED_BOUNDARY_CONFLICT() {\r\n        return new Error('Unresolved boundary conflict in boolean operation');\r\n    }\r\n\r\n    /**\r\n     * Error to throw from LinkedList:testInfiniteLoop static method\r\n     * in case when circular loop detected in linked list\r\n     * @returns {Error}\r\n     */\r\n    static get INFINITE_LOOP() {\r\n        return new Error('Infinite loop');\r\n    }\r\n\r\n    static get CANNOT_COMPLETE_BOOLEAN_OPERATION() {\r\n        return new Error('Cannot complete boolean operation')\r\n    }\r\n\r\n    static get CANNOT_INVOKE_ABSTRACT_METHOD() {\r\n        return new Error('Abstract method cannot be invoked');\r\n    }\r\n\r\n    static get OPERATION_IS_NOT_SUPPORTED() {\r\n        return new Error('Operation is not supported')\r\n    }\r\n\r\n    static get UNSUPPORTED_SHAPE_TYPE() {\r\n        return new Error('Unsupported shape type')\r\n    }\r\n}\r\n\r\nFlatten.Errors = Errors;\r\n\r\n/**\r\n * Class implements bidirectional non-circular linked list. <br/>\r\n * LinkedListElement - object of any type that has properties next and prev.\r\n */\r\nclass LinkedList {\r\n    constructor(first, last) {\r\n        this.first = first;\r\n        this.last = last || this.first;\r\n    }\r\n\r\n    [Symbol.iterator]() {\r\n        let value = undefined;\r\n        return {\r\n            next: () => {\r\n                value = value ? value.next : this.first;\r\n                return {value: value, done: value === undefined};\r\n            }\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Return number of elements in the list\r\n     * @returns {number}\r\n     */\r\n    get size() {\r\n        let counter = 0;\r\n        for (let edge of this) {\r\n            counter++;\r\n        }\r\n        return counter;\r\n    }\r\n\r\n    /**\r\n     * Return array of elements from start to end,\r\n     * If start or end not defined, take first as start, last as end\r\n     * @returns {Array}\r\n     */\r\n    toArray(start=undefined, end=undefined) {\r\n        let elements = [];\r\n        let from = start || this.first;\r\n        let to = end || this.last;\r\n        let element = from;\r\n        if (element === undefined) return elements;\r\n        do {\r\n            elements.push(element);\r\n            element = element.next;\r\n        } while (element !== to.next);\r\n        return elements;\r\n    }\r\n\r\n\r\n    /**\r\n     * Append new element to the end of the list\r\n     * @param {LinkedListElement} element\r\n     * @returns {LinkedList}\r\n     */\r\n    append(element) {\r\n        if (this.isEmpty()) {\r\n            this.first = element;\r\n        } else {\r\n            element.prev = this.last;\r\n            this.last.next = element;\r\n        }\r\n\r\n        // update edge to be last\r\n        this.last = element;\r\n\r\n        // nullify non-circular links\r\n        this.last.next = undefined;\r\n        this.first.prev = undefined;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Insert new element to the list after elementBefore\r\n     * @param {LinkedListElement} newElement\r\n     * @param {LinkedListElement} elementBefore\r\n     * @returns {LinkedList}\r\n     */\r\n    insert(newElement, elementBefore) {\r\n        if (this.isEmpty()) {\r\n            this.first = newElement;\r\n            this.last = newElement;\r\n        }\r\n        else if (elementBefore === null || elementBefore === undefined) {\r\n            newElement.next = this.first;\r\n            this.first.prev = newElement;\r\n            this.first = newElement;\r\n        }\r\n        else {\r\n            /* set links to new element */\r\n            let elementAfter = elementBefore.next;\r\n            elementBefore.next = newElement;\r\n            if (elementAfter) elementAfter.prev = newElement;\r\n\r\n            /* set links from new element */\r\n            newElement.prev = elementBefore;\r\n            newElement.next = elementAfter;\r\n\r\n            /* extend list if new element added after the last element */\r\n            if (this.last === elementBefore)\r\n                this.last = newElement;\r\n        }\r\n        // nullify non-circular links\r\n        this.last.next = undefined;\r\n        this.first.prev = undefined;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove element from the list\r\n     * @param {LinkedListElement} element\r\n     * @returns {LinkedList}\r\n     */\r\n    remove(element) {\r\n        // special case if last edge removed\r\n        if (element === this.first && element === this.last) {\r\n            this.first = undefined;\r\n            this.last = undefined;\r\n        } else {\r\n            // update linked list\r\n            if (element.prev) element.prev.next = element.next;\r\n            if (element.next) element.next.prev = element.prev;\r\n            // update first if need\r\n            if (element === this.first) {\r\n                this.first = element.next;\r\n            }\r\n            // update last if need\r\n            if (element === this.last) {\r\n                this.last = element.prev;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Return true if list is empty\r\n     * @returns {boolean}\r\n     */\r\n    isEmpty() {\r\n        return this.first === undefined;\r\n    }\r\n\r\n    /**\r\n     * Throw an error if circular loop detected in the linked list\r\n     * @param {LinkedListElement} first element to start iteration\r\n     * @throws {Errors.INFINITE_LOOP}\r\n     */\r\n    static testInfiniteLoop(first) {\r\n        let edge = first;\r\n        let controlEdge = first;\r\n        do {\r\n            if (edge != first && edge === controlEdge) {\r\n                throw Errors.INFINITE_LOOP;  // new Error(\"Infinite loop\")\r\n            }\r\n            edge = edge.next;\r\n            controlEdge = controlEdge.next.next;\r\n        } while (edge != first)\r\n    }\r\n}\r\n\r\nconst defaultAttributes = {\r\n    stroke: \"black\"\r\n};\r\n\r\nclass SVGAttributes {\r\n    constructor(args = defaultAttributes) {\r\n        for(const property in args) {\r\n            this[property] = args[property];\r\n        }\r\n        this.stroke = args.stroke ?? defaultAttributes.stroke;\r\n    }\r\n\r\n    toAttributesString() {\r\n        return Object.keys(this)\r\n            .reduce( (acc, key) =>\r\n                    acc + (this[key] !== undefined ? this.toAttrString(key, this[key]) : \"\")\r\n            , ``)\r\n    }\r\n\r\n    toAttrString(key, value) {\r\n        const SVGKey = key === \"className\" ? \"class\" : this.convertCamelToKebabCase(key);\r\n        return value === null ? `${SVGKey} ` : `${SVGKey}=\"${value.toString()}\" `\r\n    }\r\n\r\n    convertCamelToKebabCase(str) {\r\n        return str\r\n            .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)\r\n            .join('-')\r\n            .toLowerCase();\r\n    }\r\n}\r\n\r\nfunction convertToString(attrs) {\r\n    return new SVGAttributes(attrs).toAttributesString()\r\n}\r\n\r\n/**\r\n * Intersection\r\n *\r\n * */\r\n\r\n\r\nfunction intersectLine2Line(line1, line2) {\r\n    let ip = [];\r\n\r\n    let [A1, B1, C1] = line1.standard;\r\n    let [A2, B2, C2] = line2.standard;\r\n\r\n    /* Cramer's rule */\r\n    let det = A1 * B2 - B1 * A2;\r\n    let detX = C1 * B2 - B1 * C2;\r\n    let detY = A1 * C2 - C1 * A2;\r\n\r\n    if (!Flatten.Utils.EQ_0(det)) {\r\n        let x, y;\r\n\r\n        if (B1 === 0) {        // vertical line x  = C1/A1, where A1 == +1 or -1\r\n            x = C1/A1;\r\n            y = detY / det;\r\n        }\r\n        else if (B2 === 0) {   // vertical line x = C2/A2, where A2 = +1 or -1\r\n            x = C2/A2;\r\n            y = detY / det;\r\n        }\r\n        else if (A1 === 0) {   // horizontal line y = C1/B1, where B1 = +1 or -1\r\n            x = detX / det;\r\n            y = C1/B1;\r\n        }\r\n        else if (A2 === 0) {   // horizontal line y = C2/B2, where B2 = +1 or -1\r\n            x = detX / det;\r\n            y = C2/B2;\r\n        }\r\n        else {\r\n            x = detX / det;\r\n            y = detY / det;\r\n        }\r\n\r\n        ip.push(new Flatten.Point(x, y));\r\n    }\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectLine2Circle(line, circle) {\r\n    let ip = [];\r\n    let prj = circle.pc.projectionOn(line);            // projection of circle center on a line\r\n    let dist = circle.pc.distanceTo(prj)[0];           // distance from circle center to projection\r\n\r\n    if (Flatten.Utils.EQ(dist, circle.r)) {            // line tangent to circle - return single intersection point\r\n        ip.push(prj);\r\n    } else if (Flatten.Utils.LT(dist, circle.r)) {       // return two intersection points\r\n        let delta = Math.sqrt(circle.r * circle.r - dist * dist);\r\n        let v_trans, pt;\r\n\r\n        v_trans = line.norm.rotate90CCW().multiply(delta);\r\n        pt = prj.translate(v_trans);\r\n        ip.push(pt);\r\n\r\n        v_trans = line.norm.rotate90CW().multiply(delta);\r\n        pt = prj.translate(v_trans);\r\n        ip.push(pt);\r\n    }\r\n    return ip;\r\n}\r\n\r\nfunction intersectLine2Box(line, box) {\r\n    let ips = [];\r\n    for (let seg of box.toSegments()) {\r\n        let ips_tmp = intersectSegment2Line(seg, line);\r\n        for (let pt of ips_tmp) {\r\n            if (!ptInIntPoints(pt, ips)) {\r\n                ips.push(pt);\r\n            }\r\n        }\r\n    }\r\n    return ips;\r\n}\r\n\r\nfunction intersectLine2Arc(line, arc) {\r\n    let ip = [];\r\n\r\n    if (intersectLine2Box(line, arc.box).length === 0) {\r\n        return ip;\r\n    }\r\n\r\n    let circle = new Flatten.Circle(arc.pc, arc.r);\r\n    let ip_tmp = intersectLine2Circle(line, circle);\r\n    for (let pt of ip_tmp) {\r\n        if (pt.on(arc)) {\r\n            ip.push(pt);\r\n        }\r\n    }\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectSegment2Line(seg, line) {\r\n    let ip = [];\r\n\r\n    // Boundary cases\r\n    if (seg.ps.on(line)) {\r\n        ip.push(seg.ps);\r\n    }\r\n    // If both ends lay on line, return two intersection points\r\n    if (seg.pe.on(line) && !seg.isZeroLength()) {\r\n        ip.push(seg.pe);\r\n    }\r\n\r\n    if (ip.length > 0) {\r\n        return ip;          // done, intersection found\r\n    }\r\n\r\n    // If zero-length segment and nothing found, return no intersections\r\n    if (seg.isZeroLength()) {\r\n        return ip;\r\n    }\r\n\r\n    // Not a boundary case, check if both points are on the same side and\r\n    // hence there is no intersection\r\n    if (seg.ps.leftTo(line) && seg.pe.leftTo(line) ||\r\n        !seg.ps.leftTo(line) && !seg.pe.leftTo(line)) {\r\n        return ip;\r\n    }\r\n\r\n    // Calculate intersection between lines\r\n    let line1 = new Flatten.Line(seg.ps, seg.pe);\r\n    return intersectLine2Line(line1, line);\r\n}\r\n\r\nfunction intersectSegment2Segment(seg1, seg2) {\r\n    let ip = [];\r\n\r\n    // quick reject\r\n    if (seg1.box.not_intersect(seg2.box)) {\r\n        return ip;\r\n    }\r\n\r\n    // Special case of seg1 zero length\r\n    if (seg1.isZeroLength()) {\r\n        if (seg1.ps.on(seg2)) {\r\n            ip.push(seg1.ps);\r\n        }\r\n        return ip;\r\n    }\r\n\r\n    // Special case of seg2 zero length\r\n    if (seg2.isZeroLength()) {\r\n        if (seg2.ps.on(seg1)) {\r\n            ip.push(seg2.ps);\r\n        }\r\n        return ip;\r\n    }\r\n\r\n    // Neither seg1 nor seg2 is zero length\r\n    let line1 = new Flatten.Line(seg1.ps, seg1.pe);\r\n    let line2 = new Flatten.Line(seg2.ps, seg2.pe);\r\n\r\n    // Check overlapping between segments in case of incidence\r\n    // If segments touching, add one point. If overlapping, add two points\r\n    if (line1.incidentTo(line2)) {\r\n        if (seg1.ps.on(seg2)) {\r\n            ip.push(seg1.ps);\r\n        }\r\n        if (seg1.pe.on(seg2)) {\r\n            ip.push(seg1.pe);\r\n        }\r\n        if (seg2.ps.on(seg1) && !seg2.ps.equalTo(seg1.ps) && !seg2.ps.equalTo(seg1.pe)) {\r\n            ip.push(seg2.ps);\r\n        }\r\n        if (seg2.pe.on(seg1) && !seg2.pe.equalTo(seg1.ps) && !seg2.pe.equalTo(seg1.pe)) {\r\n            ip.push(seg2.pe);\r\n        }\r\n    } else {                /* not incident - parallel or intersect */\r\n        // Calculate intersection between lines\r\n        let new_ip = intersectLine2Line(line1, line2);\r\n        if (new_ip.length > 0) {\r\n            if (isPointInSegmentBox(new_ip[0], seg1) && isPointInSegmentBox(new_ip[0], seg2)) {\r\n                ip.push(new_ip[0]);\r\n            }\r\n        }\r\n    }\r\n    return ip;\r\n}\r\n\r\nfunction isPointInSegmentBox(point, segment) {\r\n    const box = segment.box;\r\n    return Flatten.Utils.LE(point.x, box.xmax) && Flatten.Utils.GE(point.x, box.xmin) &&\r\n        Flatten.Utils.LE(point.y, box.ymax) && Flatten.Utils.GE(point.y, box.ymin)\r\n}\r\n\r\nfunction intersectSegment2Circle(segment, circle) {\r\n    let ips = [];\r\n\r\n    if (segment.box.not_intersect(circle.box)) {\r\n        return ips;\r\n    }\r\n\r\n    // Special case of zero length segment\r\n    if (segment.isZeroLength()) {\r\n        let [dist, _] = segment.ps.distanceTo(circle.pc);\r\n        if (Flatten.Utils.EQ(dist, circle.r)) {\r\n            ips.push(segment.ps);\r\n        }\r\n        return ips;\r\n    }\r\n\r\n    // Non zero-length segment\r\n    let line = new Flatten.Line(segment.ps, segment.pe);\r\n\r\n    let ips_tmp = intersectLine2Circle(line, circle);\r\n\r\n    for (let ip of ips_tmp) {\r\n        if (ip.on(segment)) {\r\n            ips.push(ip);\r\n        }\r\n    }\r\n\r\n    return ips;\r\n}\r\n\r\nfunction intersectSegment2Arc(segment, arc) {\r\n    let ip = [];\r\n\r\n    if (segment.box.not_intersect(arc.box)) {\r\n        return ip;\r\n    }\r\n\r\n    // Special case of zero-length segment\r\n    if (segment.isZeroLength()) {\r\n        if (segment.ps.on(arc)) {\r\n            ip.push(segment.ps);\r\n        }\r\n        return ip;\r\n    }\r\n\r\n    // Non-zero length segment\r\n    let line = new Flatten.Line(segment.ps, segment.pe);\r\n    let circle = new Flatten.Circle(arc.pc, arc.r);\r\n\r\n    let ip_tmp = intersectLine2Circle(line, circle);\r\n\r\n    for (let pt of ip_tmp) {\r\n        if (pt.on(segment) && pt.on(arc)) {\r\n            ip.push(pt);\r\n        }\r\n    }\r\n    return ip;\r\n\r\n}\r\n\r\nfunction intersectSegment2Box(segment, box) {\r\n    let ips = [];\r\n    for (let seg of box.toSegments()) {\r\n        let ips_tmp = intersectSegment2Segment(seg, segment);\r\n        for (let ip of ips_tmp) {\r\n            ips.push(ip);\r\n        }\r\n    }\r\n    return ips;\r\n}\r\n\r\nfunction intersectCircle2Circle(circle1, circle2) {\r\n    let ip = [];\r\n\r\n    if (circle1.box.not_intersect(circle2.box)) {\r\n        return ip;\r\n    }\r\n\r\n    let vec = new Flatten.Vector(circle1.pc, circle2.pc);\r\n\r\n    let r1 = circle1.r;\r\n    let r2 = circle2.r;\r\n\r\n    // Degenerated circle\r\n    if (Flatten.Utils.EQ_0(r1) || Flatten.Utils.EQ_0(r2))\r\n        return ip;\r\n\r\n    // In case of equal circles return one leftmost point\r\n    if (Flatten.Utils.EQ_0(vec.x) && Flatten.Utils.EQ_0(vec.y) && Flatten.Utils.EQ(r1, r2)) {\r\n        ip.push(circle1.pc.translate(-r1, 0));\r\n        return ip;\r\n    }\r\n\r\n    let dist = circle1.pc.distanceTo(circle2.pc)[0];\r\n\r\n    if (Flatten.Utils.GT(dist, r1 + r2))               // circles too far, no intersections\r\n        return ip;\r\n\r\n    if (Flatten.Utils.LT(dist, Math.abs(r1 - r2)))     // one circle is contained within another, no intersections\r\n        return ip;\r\n\r\n    // Normalize vector.\r\n    vec.x /= dist;\r\n    vec.y /= dist;\r\n\r\n    let pt;\r\n\r\n    // Case of touching from outside or from inside - single intersection point\r\n    // TODO: check this specifically not sure if correct\r\n    if (Flatten.Utils.EQ(dist, r1 + r2) || Flatten.Utils.EQ(dist, Math.abs(r1 - r2))) {\r\n        pt = circle1.pc.translate(r1 * vec.x, r1 * vec.y);\r\n        ip.push(pt);\r\n        return ip;\r\n    }\r\n\r\n    // Case of two intersection points\r\n\r\n    // Distance from first center to center of common chord:\r\n    //   a = (r1^2 - r2^2 + d^2) / 2d\r\n    // Separate for better accuracy\r\n    let a = (r1 * r1) / (2 * dist) - (r2 * r2) / (2 * dist) + dist / 2;\r\n\r\n    let mid_pt = circle1.pc.translate(a * vec.x, a * vec.y);\r\n    let h = Math.sqrt(r1 * r1 - a * a);\r\n    // let norm;\r\n\r\n    // norm = vec.rotate90CCW().multiply(h);\r\n    pt = mid_pt.translate(vec.rotate90CCW().multiply(h));\r\n    ip.push(pt);\r\n\r\n    // norm = vec.rotate90CW();\r\n    pt = mid_pt.translate(vec.rotate90CW().multiply(h));\r\n    ip.push(pt);\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectCircle2Box(circle, box) {\r\n    let ips = [];\r\n    for (let seg of box.toSegments()) {\r\n        let ips_tmp = intersectSegment2Circle(seg, circle);\r\n        for (let ip of ips_tmp) {\r\n            ips.push(ip);\r\n        }\r\n    }\r\n    return ips;\r\n}\r\n\r\nfunction intersectArc2Arc(arc1, arc2) {\r\n    let ip = [];\r\n\r\n    if (arc1.box.not_intersect(arc2.box)) {\r\n        return ip;\r\n    }\r\n\r\n    // Special case: overlapping arcs\r\n    // May return up to 4 intersection points\r\n    if (arc1.pc.equalTo(arc2.pc) && Flatten.Utils.EQ(arc1.r, arc2.r)) {\r\n        let pt;\r\n\r\n        pt = arc1.start;\r\n        if (pt.on(arc2))\r\n            ip.push(pt);\r\n\r\n        pt = arc1.end;\r\n        if (pt.on(arc2))\r\n            ip.push(pt);\r\n\r\n        pt = arc2.start;\r\n        if (pt.on(arc1)) ip.push(pt);\r\n\r\n        pt = arc2.end;\r\n        if (pt.on(arc1)) ip.push(pt);\r\n\r\n        return ip;\r\n    }\r\n\r\n    // Common case\r\n    let circle1 = new Flatten.Circle(arc1.pc, arc1.r);\r\n    let circle2 = new Flatten.Circle(arc2.pc, arc2.r);\r\n    let ip_tmp = circle1.intersect(circle2);\r\n    for (let pt of ip_tmp) {\r\n        if (pt.on(arc1) && pt.on(arc2)) {\r\n            ip.push(pt);\r\n        }\r\n    }\r\n    return ip;\r\n}\r\n\r\nfunction intersectArc2Circle(arc, circle) {\r\n    let ip = [];\r\n\r\n    if (arc.box.not_intersect(circle.box)) {\r\n        return ip;\r\n    }\r\n\r\n    // Case when arc center incident to circle center\r\n    // Return arc's end points as 2 intersection points\r\n    if (circle.pc.equalTo(arc.pc) && Flatten.Utils.EQ(circle.r, arc.r)) {\r\n        ip.push(arc.start);\r\n        ip.push(arc.end);\r\n        return ip;\r\n    }\r\n\r\n    // Common case\r\n    let circle1 = circle;\r\n    let circle2 = new Flatten.Circle(arc.pc, arc.r);\r\n    let ip_tmp = intersectCircle2Circle(circle1, circle2);\r\n    for (let pt of ip_tmp) {\r\n        if (pt.on(arc)) {\r\n            ip.push(pt);\r\n        }\r\n    }\r\n    return ip;\r\n}\r\n\r\nfunction intersectArc2Box(arc, box) {\r\n    let ips = [];\r\n    for (let seg of box.toSegments()) {\r\n        let ips_tmp = intersectSegment2Arc(seg, arc);\r\n        for (let ip of ips_tmp) {\r\n            ips.push(ip);\r\n        }\r\n    }\r\n    return ips;\r\n}\r\n\r\nfunction intersectEdge2Segment(edge, segment) {\r\n    return edge.isSegment ? intersectSegment2Segment(edge.shape, segment) : intersectSegment2Arc(segment, edge.shape);\r\n}\r\n\r\nfunction intersectEdge2Arc(edge, arc) {\r\n    return edge.isSegment ? intersectSegment2Arc(edge.shape, arc) : intersectArc2Arc(edge.shape, arc);\r\n}\r\n\r\nfunction intersectEdge2Line(edge, line) {\r\n    return edge.isSegment ? intersectSegment2Line(edge.shape, line) : intersectLine2Arc(line, edge.shape);\r\n}\r\n\r\nfunction intersectEdge2Ray(edge, ray) {\r\n    return edge.isSegment ? intersectRay2Segment(ray, edge.shape) : intersectRay2Arc(ray, edge.shape);\r\n}\r\n\r\nfunction intersectEdge2Circle(edge, circle) {\r\n    return edge.isSegment ? intersectSegment2Circle(edge.shape, circle) : intersectArc2Circle(edge.shape, circle);\r\n}\r\n\r\nfunction intersectSegment2Polygon(segment, polygon) {\r\n    let ip = [];\r\n\r\n    for (let edge of polygon.edges) {\r\n        for (let pt of intersectEdge2Segment(edge, segment)) {\r\n            ip.push(pt);\r\n        }\r\n    }\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectArc2Polygon(arc, polygon) {\r\n    let ip = [];\r\n\r\n    for (let edge of polygon.edges) {\r\n        for (let pt of intersectEdge2Arc(edge, arc)) {\r\n            ip.push(pt);\r\n        }\r\n    }\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectLine2Polygon(line, polygon) {\r\n    let ip = [];\r\n\r\n    if (polygon.isEmpty()) {\r\n        return ip;\r\n    }\r\n\r\n    for (let edge of polygon.edges) {\r\n        for (let pt of intersectEdge2Line(edge, line)) {\r\n            if (!ptInIntPoints(pt, ip)) {\r\n                ip.push(pt);\r\n            }\r\n        }\r\n    }\r\n\r\n    return line.sortPoints(ip);\r\n}\r\n\r\nfunction intersectCircle2Polygon(circle, polygon) {\r\n    let ip = [];\r\n\r\n    if (polygon.isEmpty()) {\r\n        return ip;\r\n    }\r\n\r\n    for (let edge of polygon.edges) {\r\n        for (let pt of intersectEdge2Circle(edge, circle)) {\r\n            ip.push(pt);\r\n        }\r\n    }\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectEdge2Edge(edge1, edge2) {\r\n    if (edge1.isSegment) {\r\n        return intersectEdge2Segment(edge2, edge1.shape)\r\n    }\r\n    else if (edge1.isArc) {\r\n        return intersectEdge2Arc(edge2, edge1.shape)\r\n    }\r\n    else if (edge1.isLine) {\r\n        return intersectEdge2Line(edge2, edge1.shape)\r\n    }\r\n    else if (edge1.isRay) {\r\n        return intersectEdge2Ray(edge2, edge1.shape)\r\n    }\r\n    return []\r\n}\r\n\r\nfunction intersectEdge2Polygon(edge, polygon) {\r\n    let ip = [];\r\n\r\n    if (polygon.isEmpty() || edge.shape.box.not_intersect(polygon.box)) {\r\n        return ip;\r\n    }\r\n\r\n    let resp_edges = polygon.edges.search(edge.shape.box);\r\n\r\n    for (let resp_edge of resp_edges) {\r\n        ip = [...ip, ...intersectEdge2Edge(edge, resp_edge)];\r\n    }\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectMultiline2Polygon(multiline, polygon) {\r\n    let ip = [];\r\n\r\n    if (polygon.isEmpty() || multiline.size === 0) {\r\n        return ip;\r\n    }\r\n\r\n    for (let edge of multiline) {\r\n        ip = [...ip, ...intersectEdge2Polygon(edge, polygon)];\r\n    }\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectPolygon2Polygon(polygon1, polygon2) {\r\n    let ip = [];\r\n\r\n    if (polygon1.isEmpty() || polygon2.isEmpty()) {\r\n        return ip;\r\n    }\r\n\r\n    if (polygon1.box.not_intersect(polygon2.box)) {\r\n        return ip;\r\n    }\r\n\r\n    for (let edge1 of polygon1.edges) {\r\n        ip = [...ip, ...intersectEdge2Polygon(edge1, polygon2)];\r\n    }\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectShape2Polygon(shape, polygon) {\r\n    if (shape instanceof Flatten.Line) {\r\n        return intersectLine2Polygon(shape, polygon);\r\n    }\r\n    else if (shape instanceof Flatten.Segment) {\r\n        return intersectSegment2Polygon(shape, polygon);\r\n    }\r\n    else if (shape instanceof Flatten.Arc) {\r\n        return intersectArc2Polygon(shape, polygon);\r\n    }\r\n    else {\r\n        return [];\r\n    }\r\n}\r\n\r\nfunction ptInIntPoints(new_pt, ip) {\r\n    return ip.some( pt => pt.equalTo(new_pt) )\r\n}\r\n\r\nfunction createLineFromRay(ray) {\r\n    return new Flatten.Line(ray.start, ray.norm)\r\n}\r\nfunction intersectRay2Segment(ray, segment) {\r\n    return intersectSegment2Line(segment, createLineFromRay(ray))\r\n        .filter(pt => ray.contains(pt));\r\n}\r\n\r\nfunction intersectRay2Arc(ray, arc) {\r\n    return intersectLine2Arc(createLineFromRay(ray), arc)\r\n        .filter(pt => ray.contains(pt))\r\n}\r\n\r\nfunction intersectRay2Circle(ray, circle) {\r\n    return intersectLine2Circle(createLineFromRay(ray), circle)\r\n        .filter(pt => ray.contains(pt))\r\n}\r\n\r\nfunction intersectRay2Box(ray, box) {\r\n    return intersectLine2Box(createLineFromRay(ray), box)\r\n        .filter(pt => ray.contains(pt))\r\n}\r\n\r\nfunction intersectRay2Line(ray, line) {\r\n    return intersectLine2Line(createLineFromRay(ray), line)\r\n        .filter(pt => ray.contains(pt))\r\n}\r\n\r\nfunction intersectRay2Ray(ray1, ray2) {\r\n    return intersectLine2Line(createLineFromRay(ray1), createLineFromRay(ray2))\r\n        .filter(pt => ray1.contains(pt))\r\n        .filter(pt => ray2.contains(pt))\r\n}\r\n\r\nfunction intersectRay2Polygon(ray, polygon) {\r\n    return intersectLine2Polygon(createLineFromRay(ray), polygon)\r\n        .filter(pt => ray.contains(pt))\r\n}\r\n\r\nfunction intersectShape2Shape(shape1, shape2) {\r\n    if (shape1.intersect && shape1.intersect instanceof Function) {\r\n        return shape1.intersect(shape2)\r\n    }\r\n    throw Errors.UNSUPPORTED_SHAPE_TYPE\r\n}\r\n\r\nfunction intersectShape2Multiline(shape, multiline) {\r\n    let ip = [];\r\n    for (let edge of multiline) {\r\n        ip = [...ip, ...intersectShape2Shape(shape, edge.shape)];\r\n    }\r\n    return ip;\r\n}\r\n\r\nfunction intersectMultiline2Multiline(multiline1, multiline2) {\r\n    let ip = [];\r\n    for (let edge1 of multiline1) {\r\n        for (let edge2 of multiline2) {\r\n            ip = [...ip, ...intersectShape2Shape(edge1, edge2)];\r\n        }\r\n    }\r\n    return ip;\r\n}\r\n\r\n/**\r\n * Class Multiline represent connected path of [edges]{@link Flatten.Edge}, where each edge may be\r\n * [segment]{@link Flatten.Segment}, [arc]{@link Flatten.Arc}, [line]{@link Flatten.Line} or [ray]{@link Flatten.Ray}\r\n */\r\nlet Multiline$1 = class Multiline extends LinkedList {\r\n    constructor(...args) {\r\n        super();\r\n        this.isInfinite = false;\r\n\r\n        if (args.length === 1 && args[0] instanceof Array && args[0].length > 0) {\r\n            // there may be only one line and\r\n            // only first and last may be rays\r\n            let validShapes = false;\r\n            const shapes = args[0];\r\n            const L = shapes.length;\r\n            const anyShape = (s) =>\r\n                s instanceof Flatten.Segment || s instanceof Flatten.Arc ||\r\n                s instanceof Flatten.Ray || s instanceof Flatten.Line;\r\n            const anyShapeExceptLine = (s) =>\r\n                s instanceof Flatten.Segment || s instanceof Flatten.Arc || s instanceof Flatten.Ray;\r\n            const shapeSegmentOrArc = (s) => s instanceof Flatten.Segment || s instanceof Flatten.Arc;\r\n            validShapes =\r\n                L === 1 && anyShape(shapes[0]) ||\r\n                L > 1 && anyShapeExceptLine(shapes[0]) && anyShapeExceptLine(shapes[L - 1]) &&\r\n                shapes.slice(1, L - 1).every(shapeSegmentOrArc);\r\n\r\n            if (validShapes) {\r\n                this.isInfinite = shapes.some(shape =>\r\n                    shape instanceof Flatten.Ray ||\r\n                    shape instanceof Flatten.Line\r\n                );\r\n\r\n                for (let shape of shapes) {\r\n                    let edge = new Flatten.Edge(shape);\r\n                    this.append(edge);\r\n                }\r\n\r\n                this.setArcLength();\r\n            } else {\r\n                throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * (Getter) Return array of edges\r\n     * @returns {Edge[]}\r\n     */\r\n    get edges() {\r\n        return [...this];\r\n    }\r\n\r\n    /**\r\n     * (Getter) Return bounding box of the multiline\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        return this.edges.reduce( (acc,edge) => acc.merge(edge.box), new Flatten.Box() );\r\n    }\r\n\r\n    /**\r\n     * (Getter) Returns array of vertices\r\n     * @returns {Point[]}\r\n     */\r\n    get vertices() {\r\n        let v = this.edges.map(edge => edge.start);\r\n        v.push(this.last.end);\r\n        return v;\r\n    }\r\n\r\n    /**\r\n     * (Getter) Returns length of the multiline, return POSITIVE_INFINITY if multiline is infinite\r\n     * @returns {number}\r\n     */\r\n    get length() {\r\n        if (this.isEmpty()) return 0;\r\n        if (this.isInfinite) return Number.POSITIVE_INFINITY;\r\n\r\n        let len = 0;\r\n        for (let edge of this) {\r\n            len += edge.length;\r\n        }\r\n        return len\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of Multiline\r\n     * @returns {Multiline}\r\n     */\r\n    clone() {\r\n        return new Multiline(this.toShapes());\r\n    }\r\n\r\n    /**\r\n     * Set arc_length property for each of the edges in the multiline.\r\n     * Arc_length of the edge is the arc length from the multiline start vertex to the edge start vertex\r\n     */\r\n    setArcLength() {\r\n        for (let edge of this) {\r\n            this.setOneEdgeArcLength(edge);\r\n        }\r\n    }\r\n\r\n    setOneEdgeArcLength(edge) {\r\n        if (edge === this.first) {\r\n            edge.arc_length = 0.0;\r\n        } else {\r\n            edge.arc_length = edge.prev.arc_length + edge.prev.length;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return point on multiline at given length from the start of the multiline\r\n     * @param length\r\n     * @returns {Point | null}\r\n     */\r\n    pointAtLength(length) {\r\n        if (length > this.length || length < 0) return null;\r\n        if (this.isInfinite) return null\r\n\r\n        let point = null;\r\n        for (let edge of this) {\r\n            if (length >= edge.arc_length &&\r\n                (edge === this.last || length < edge.next.arc_length)) {\r\n                point = edge.pointAtLength(length - edge.arc_length);\r\n                break;\r\n            }\r\n        }\r\n        return point;\r\n    }\r\n\r\n    /**\r\n     * Split edge and add new vertex, return new edge inserted\r\n     * @param {Point} pt - point on edge that will be added as new vertex\r\n     * @param {Edge} edge - edge to split\r\n     * @returns {Edge}\r\n     */\r\n    addVertex(pt, edge) {\r\n        let shapes = edge.shape.split(pt);\r\n        // if (shapes.length < 2) return;\r\n\r\n        if (shapes[0] === null)   // point incident to edge start vertex, return previous edge\r\n           return edge.prev;\r\n\r\n        if (shapes[1] === null)   // point incident to edge end vertex, return edge itself\r\n           return edge;\r\n\r\n        let newEdge = new Flatten.Edge(shapes[0]);\r\n        let edgeBefore = edge.prev;\r\n\r\n        /* Insert first split edge into linked list after edgeBefore */\r\n        this.insert(newEdge, edgeBefore);     // edge.face ?\r\n\r\n        // Update edge shape with second split edge keeping links\r\n        edge.shape = shapes[1];\r\n\r\n        return newEdge;\r\n    }\r\n\r\n    getChain(edgeFrom, edgeTo) {\r\n        let edges = [];\r\n        for (let edge = edgeFrom; edge !== edgeTo.next; edge = edge.next) {\r\n            edges.push(edge);\r\n        }\r\n        return edges\r\n    }\r\n\r\n    /**\r\n     * Split edges of multiline with intersection points and return mutated multiline\r\n     * @param {Point[]} ip - array of points to be added as new vertices\r\n     * @returns {Multiline}\r\n     */\r\n    split(ip) {\r\n        for (let pt of ip) {\r\n            let edge = this.findEdgeByPoint(pt);\r\n            this.addVertex(pt, edge);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns edge which contains given point\r\n     * @param {Point} pt\r\n     * @returns {Edge}\r\n     */\r\n    findEdgeByPoint(pt) {\r\n        let edgeFound;\r\n        for (let edge of this) {\r\n            if (edge.shape.contains(pt)) {\r\n                edgeFound = edge;\r\n                break;\r\n            }\r\n        }\r\n        return edgeFound;\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment from any shape to multiline\r\n     * @param shape\r\n     * @returns {[number,Flatten.Segment]}\r\n     */\r\n    distanceTo(shape) {\r\n        if (shape instanceof Point) {\r\n            const [dist, shortest_segment] = Flatten.Distance.shape2multiline(shape, this);\r\n            return [dist, shortest_segment.reverse()];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Line) {\r\n            const [dist, shortest_segment] = Flatten.Distance.shape2multiline(shape, this);\r\n            return [dist, shortest_segment.reverse()];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            const [dist, shortest_segment] = Flatten.Distance.shape2multiline(shape, this);\r\n            return [dist, shortest_segment.reverse()];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            const [dist, shortest_segment] = Flatten.Distance.shape2multiline(shape, this);\r\n            return [dist, shortest_segment.reverse()];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            const [dist, shortest_segment] = Flatten.Distance.shape2multiline(shape, this);\r\n            return [dist, shortest_segment.reverse()];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Multiline) {\r\n            return Flatten.Distance.multiline2multiline(this, shape);\r\n        }\r\n\r\n        throw Flatten.Errors.UNSUPPORTED_SHAPE_TYPE;\r\n    }\r\n\r\n    /**\r\n     * Calculate intersection of multiline with other shape\r\n     * @param {Shape} shape\r\n     * @returns {Point[]}\r\n     */\r\n    intersect(shape) {\r\n        if (shape instanceof Flatten.Multiline) {\r\n            return intersectMultiline2Multiline(this, shape);\r\n        }\r\n        else {\r\n            return intersectShape2Multiline(shape, this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return true if multiline contains the shape: no point of shape lies outside\r\n     * @param shape\r\n     * @returns {boolean}\r\n     */\r\n    contains(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            return this.edges.some(edge => edge.shape.contains(shape));\r\n        }\r\n\r\n        throw Flatten.Errors.UNSUPPORTED_SHAPE_TYPE;\r\n    }\r\n\r\n    /**\r\n     * Returns new multiline translated by vector vec\r\n     * @param {Vector} vec\r\n     * @returns {Multiline}\r\n     */\r\n    translate(vec) {\r\n        return new Multiline(this.edges.map( edge => edge.shape.translate(vec)));\r\n    }\r\n\r\n    /**\r\n     * Return new multiline rotated by given angle around given point\r\n     * If point omitted, rotate around origin (0,0)\r\n     * Positive value of angle defines rotation counterclockwise, negative - clockwise\r\n     * @param {number} angle - rotation angle in radians\r\n     * @param {Point} center - rotation center, default is (0,0)\r\n     * @returns {Multiline} - new rotated polygon\r\n     */\r\n    rotate(angle = 0, center = new Flatten.Point()) {\r\n        return new Multiline(this.edges.map( edge => edge.shape.rotate(angle, center) ));\r\n    }\r\n\r\n    /**\r\n     * Return new multiline transformed using affine transformation matrix\r\n     * Method does not support unbounded shapes\r\n     * @param {Matrix} matrix - affine transformation matrix\r\n     * @returns {Multiline} - new multiline\r\n     */\r\n    transform(matrix = new Flatten.Matrix()) {\r\n        return new Multiline(this.edges.map( edge => edge.shape.transform(matrix)));\r\n    }\r\n\r\n    /**\r\n     * Transform multiline into array of shapes\r\n     * @returns {Shape[]}\r\n     */\r\n    toShapes() {\r\n        return this.edges.map(edge => edge.shape.clone())\r\n    }\r\n\r\n    /**\r\n     * This method returns an object that defines how data will be\r\n     * serialized when called JSON.stringify() method\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n        return this.edges.map(edge => edge.toJSON());\r\n    }\r\n\r\n    /**\r\n     * Return string to be inserted into 'points' attribute of <polyline> element\r\n     * @returns {string}\r\n     */\r\n    svgPoints() {\r\n        return this.vertices.map(p => `${p.x},${p.y}`).join(' ')\r\n    }\r\n\r\n    /**\r\n     * Return string to be assigned to 'd' attribute of <path> element\r\n     * @returns {*}\r\n     */\r\n    dpath() {\r\n        let dPathStr = `M${this.first.start.x},${this.first.start.y}`;\r\n        for (let edge of this) {\r\n            dPathStr += edge.svg();\r\n        }\r\n        return dPathStr\r\n    }\r\n\r\n    /**\r\n     * Return string to draw multiline in svg\r\n     * @param attrs  - an object with attributes for svg path element\r\n     * TODO: support semi-infinite Ray and infinite Line\r\n     * @returns {string}\r\n     */\r\n    svg(attrs = {}) {\r\n        let svgStr = `\\n<path ${convertToString({fill: \"none\", ...attrs})} d=\"`;\r\n        svgStr += `\\nM${this.first.start.x},${this.first.start.y}`;\r\n        for (let edge of this) {\r\n            svgStr += edge.svg();\r\n        }\r\n        svgStr += `\" >\\n</path>`;\r\n        return svgStr;\r\n    }\r\n};\r\n\r\nFlatten.Multiline = Multiline$1;\r\n\r\n/**\r\n * Shortcut function to create multiline\r\n * @param args\r\n */\r\nconst multiline = (...args) => new Flatten.Multiline(...args);\r\nFlatten.multiline = multiline;\r\n\r\n/*\r\n    Smart intersections describe intersection points that refers to the edges they intersect\r\n    This function are supposed for internal usage by morphing and relation methods between\r\n */\r\n\r\nfunction addToIntPoints(edge, pt, int_points)\r\n{\r\n    let id = int_points.length;\r\n    let shapes = edge.shape.split(pt);\r\n\r\n    // if (shapes.length < 2) return;\r\n    if (shapes.length === 0) return;     // Point does not belong to edge ?\r\n\r\n    let len = 0;\r\n    if (shapes[0] === null) {   // point incident to edge start vertex\r\n        len = 0;\r\n    }\r\n    else if (shapes[1] === null) {   // point incident to edge end vertex\r\n        len = edge.shape.length;\r\n    }\r\n    else {                             // Edge was split into to edges\r\n        len = shapes[0].length;\r\n    }\r\n\r\n    let is_vertex = NOT_VERTEX$1;\r\n    if (EQ(len, 0)) {\r\n        is_vertex |= START_VERTEX$1;\r\n    }\r\n    if (EQ(len, edge.shape.length)) {\r\n        is_vertex |= END_VERTEX$1;\r\n    }\r\n    // Fix intersection point which is end point of the last edge\r\n    let arc_length;\r\n    if (len === Infinity) {\r\n        arc_length = shapes[0].coord(pt);\r\n    }\r\n    else {\r\n        arc_length = (is_vertex & END_VERTEX$1) && edge.next && edge.next.arc_length === 0 ?\r\n            0 :\r\n            edge.arc_length + len;\r\n    }\r\n\r\n    int_points.push({\r\n        id: id,\r\n        pt: pt,\r\n        arc_length: arc_length,\r\n        edge_before: edge,\r\n        edge_after: undefined,\r\n        face: edge.face,\r\n        is_vertex: is_vertex\r\n    });\r\n}\r\n\r\nfunction sortIntersections(intersections)\r\n{\r\n    // augment intersections with new sorted arrays\r\n    intersections.int_points1_sorted = getSortedArray(intersections.int_points1);\r\n    intersections.int_points2_sorted = getSortedArray(intersections.int_points2);\r\n}\r\n\r\nfunction getSortedArray(int_points)\r\n{\r\n    let faceMap = new Map;\r\n    let id = 0;\r\n    // Create integer id's for faces\r\n    for (let ip of int_points) {\r\n        if (!faceMap.has(ip.face)) {\r\n            faceMap.set(ip.face, id);\r\n            id++;\r\n        }\r\n    }\r\n    // Augment intersection points with face id's\r\n    for (let ip of int_points) {\r\n        ip.faceId = faceMap.get(ip.face);\r\n    }\r\n    // Clone and sort\r\n    let int_points_sorted = int_points.slice().sort(compareFn);\r\n    return int_points_sorted;\r\n}\r\n\r\nfunction compareFn(ip1, ip2)\r\n{\r\n    // compare face id's\r\n    if (ip1.faceId < ip2.faceId) {\r\n        return -1;\r\n    }\r\n    if (ip1.faceId > ip2.faceId) {\r\n        return 1;\r\n    }\r\n    // same face - compare arc_length\r\n    if (ip1.arc_length < ip2.arc_length) {\r\n        return -1;\r\n    }\r\n    if (ip1.arc_length > ip2.arc_length) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\n\r\nfunction filterDuplicatedIntersections(intersections)\r\n{\r\n    if (intersections.int_points1.length < 2) return;\r\n\r\n    let do_squeeze = false;\r\n\r\n    let int_point_ref1;\r\n    let int_point_ref2;\r\n    let int_point_cur1;\r\n    let int_point_cur2;\r\n    for (let i = 0; i < intersections.int_points1_sorted.length; i++) {\r\n\r\n        if (intersections.int_points1_sorted[i].id === -1)\r\n            continue;\r\n\r\n        int_point_ref1 = intersections.int_points1_sorted[i];\r\n        int_point_ref2 = intersections.int_points2[int_point_ref1.id];\r\n\r\n        for (let j=i+1; j < intersections.int_points1_sorted.length; j++) {\r\n            int_point_cur1 = intersections.int_points1_sorted[j];\r\n            if (!EQ(int_point_cur1.arc_length, int_point_ref1.arc_length)) {\r\n                break;\r\n            }\r\n            if (int_point_cur1.id === -1)\r\n                continue;\r\n            int_point_cur2 = intersections.int_points2[int_point_cur1.id];\r\n            if (int_point_cur2.id === -1)\r\n                continue;\r\n            if (int_point_cur1.edge_before === int_point_ref1.edge_before &&\r\n                int_point_cur1.edge_after === int_point_ref1.edge_after &&\r\n                int_point_cur2.edge_before === int_point_ref2.edge_before &&\r\n                int_point_cur2.edge_after === int_point_ref2.edge_after) {\r\n                int_point_cur1.id = -1;\r\n                /* to be deleted */\r\n                int_point_cur2.id = -1;\r\n                /* to be deleted */\r\n                do_squeeze = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    int_point_ref2 = intersections.int_points2_sorted[0];\r\n    int_point_ref1 = intersections.int_points1[int_point_ref2.id];\r\n    for (let i = 1; i < intersections.int_points2_sorted.length; i++) {\r\n        let int_point_cur2 = intersections.int_points2_sorted[i];\r\n\r\n        if (int_point_cur2.id === -1) continue;\r\n        /* already deleted */\r\n\r\n        if (int_point_ref2.id === -1 || /* can't be reference if already deleted */\r\n            !(EQ(int_point_cur2.arc_length, int_point_ref2.arc_length))) {\r\n            int_point_ref2 = int_point_cur2;\r\n            int_point_ref1 = intersections.int_points1[int_point_ref2.id];\r\n            continue;\r\n        }\r\n\r\n        let int_point_cur1 = intersections.int_points1[int_point_cur2.id];\r\n        if (int_point_cur1.edge_before === int_point_ref1.edge_before &&\r\n            int_point_cur1.edge_after === int_point_ref1.edge_after &&\r\n            int_point_cur2.edge_before === int_point_ref2.edge_before &&\r\n            int_point_cur2.edge_after === int_point_ref2.edge_after) {\r\n            int_point_cur1.id = -1;\r\n            /* to be deleted */\r\n            int_point_cur2.id = -1;\r\n            /* to be deleted */\r\n            do_squeeze = true;\r\n        }\r\n    }\r\n\r\n    if (do_squeeze) {\r\n        intersections.int_points1 = intersections.int_points1.filter((int_point) => int_point.id >= 0);\r\n        intersections.int_points2 = intersections.int_points2.filter((int_point) => int_point.id >= 0);\r\n\r\n        // update id's\r\n        intersections.int_points1.forEach((int_point, index) => int_point.id = index);\r\n        intersections.int_points2.forEach((int_point, index) => int_point.id = index);\r\n    }\r\n}\r\n\r\nfunction initializeInclusionFlags(int_points)\r\n{\r\n    for (let int_point of int_points) {\r\n        if (int_point.edge_before) {\r\n            int_point.edge_before.bvStart = undefined;\r\n            int_point.edge_before.bvEnd = undefined;\r\n            int_point.edge_before.bv = undefined;\r\n            int_point.edge_before.overlap = undefined;\r\n        }\r\n\r\n        if (int_point.edge_after) {\r\n            int_point.edge_after.bvStart = undefined;\r\n            int_point.edge_after.bvEnd = undefined;\r\n            int_point.edge_after.bv = undefined;\r\n            int_point.edge_after.overlap = undefined;\r\n        }\r\n    }\r\n\r\n    for (let int_point of int_points) {\r\n        if (int_point.edge_before) int_point.edge_before.bvEnd = BOUNDARY$1;\r\n        if (int_point.edge_after) int_point.edge_after.bvStart = BOUNDARY$1;\r\n    }\r\n}\r\n\r\nfunction calculateInclusionFlags(int_points, polygon)\r\n{\r\n    for (let int_point of int_points) {\r\n        if (int_point.edge_before) int_point.edge_before.setInclusion(polygon);\r\n        if (int_point.edge_after) int_point.edge_after.setInclusion(polygon);\r\n    }\r\n}\r\n\r\nfunction setOverlappingFlags(intersections)\r\n{\r\n    let cur_face = undefined;\r\n    let first_int_point_in_face_id = undefined;\r\n    let next_int_point1 = undefined;\r\n    let num_int_points = intersections.int_points1.length;\r\n\r\n    for (let i = 0; i < num_int_points; i++) {\r\n        let cur_int_point1 = intersections.int_points1_sorted[i];\r\n\r\n        // Find boundary chain in the polygon1\r\n        if (cur_int_point1.face !== cur_face) {                               // next chain started\r\n            first_int_point_in_face_id = i; // cur_int_point1;\r\n            cur_face = cur_int_point1.face;\r\n        }\r\n\r\n        // Skip duplicated points with same <x,y> in \"cur_int_point1\" pool\r\n        let int_points_cur_pool_start = i;\r\n        let int_points_cur_pool_num = intPointsPoolCount(intersections.int_points1_sorted, i, cur_face);\r\n        let next_int_point_id;\r\n        if (int_points_cur_pool_start + int_points_cur_pool_num < num_int_points &&\r\n            intersections.int_points1_sorted[int_points_cur_pool_start + int_points_cur_pool_num].face === cur_face) {\r\n            next_int_point_id = int_points_cur_pool_start + int_points_cur_pool_num;\r\n        } else {                                         // get first point from the same face\r\n            next_int_point_id = first_int_point_in_face_id;\r\n        }\r\n\r\n        // From all points with same ,x,y. in 'next_int_point1' pool choose one that\r\n        // has same face both in res_poly and in wrk_poly\r\n        let int_points_next_pool_num = intPointsPoolCount(intersections.int_points1_sorted, next_int_point_id, cur_face);\r\n        next_int_point1 = null;\r\n        for (let j=next_int_point_id; j < next_int_point_id + int_points_next_pool_num; j++) {\r\n            let next_int_point1_tmp = intersections.int_points1_sorted[j];\r\n            if (next_int_point1_tmp.face === cur_face &&\r\n                intersections.int_points2[next_int_point1_tmp.id].face === intersections.int_points2[cur_int_point1.id].face) {\r\n                next_int_point1 = next_int_point1_tmp;\r\n                break;\r\n            }\r\n        }\r\n        if (next_int_point1 === null)\r\n            continue;\r\n\r\n        let edge_from1 = cur_int_point1.edge_after;\r\n        let edge_to1 = next_int_point1.edge_before;\r\n\r\n        if (!(edge_from1.bv === BOUNDARY$1 && edge_to1.bv === BOUNDARY$1))      // not a boundary chain - skip\r\n            continue;\r\n\r\n        if (edge_from1 !== edge_to1)                    //  one edge chain    TODO: support complex case\r\n            continue;\r\n\r\n        /* Find boundary chain in polygon2 between same intersection points */\r\n        let cur_int_point2 = intersections.int_points2[cur_int_point1.id];\r\n        let next_int_point2 = intersections.int_points2[next_int_point1.id];\r\n\r\n        let edge_from2 = cur_int_point2.edge_after;\r\n        let edge_to2 = next_int_point2.edge_before;\r\n\r\n        /* if [edge_from2..edge_to2] is not a boundary chain, invert it */\r\n        /* check also that chain consist of one or two edges */\r\n        if (!(edge_from2.bv === BOUNDARY$1 && edge_to2.bv === BOUNDARY$1 && edge_from2 === edge_to2)) {\r\n            cur_int_point2 = intersections.int_points2[next_int_point1.id];\r\n            next_int_point2 = intersections.int_points2[cur_int_point1.id];\r\n\r\n            edge_from2 = cur_int_point2.edge_after;\r\n            edge_to2 = next_int_point2.edge_before;\r\n        }\r\n\r\n        if (!(edge_from2.bv === BOUNDARY$1 && edge_to2.bv === BOUNDARY$1 && edge_from2 === edge_to2))\r\n            continue;                           // not an overlapping chain - skip   TODO: fix boundary conflict\r\n\r\n        // Set overlapping flag - one-to-one case\r\n        edge_from1.setOverlap(edge_from2);\r\n    }\r\n}\r\n\r\nfunction intPointsPoolCount(int_points, cur_int_point_num, cur_face)\r\n{\r\n    let int_point_current;\r\n    let int_point_next;\r\n\r\n    let int_points_pool_num = 1;\r\n\r\n    if (int_points.length === 1) return 1;\r\n\r\n    int_point_current = int_points[cur_int_point_num];\r\n\r\n    for (let i = cur_int_point_num + 1; i < int_points.length; i++) {\r\n        if (int_point_current.face !== cur_face) {      /* next face started */\r\n            break;\r\n        }\r\n\r\n        int_point_next = int_points[i];\r\n\r\n        if (!(int_point_next.pt.equalTo(int_point_current.pt) &&\r\n            int_point_next.edge_before === int_point_current.edge_before &&\r\n            int_point_next.edge_after === int_point_current.edge_after)) {\r\n            break;         /* next point is different - break and exit */\r\n        }\r\n\r\n        int_points_pool_num++;     /* duplicated intersection point - increase counter */\r\n    }\r\n    return int_points_pool_num;\r\n}\r\n\r\nfunction splitByIntersections(polygon, int_points)\r\n{\r\n    if (!int_points) return;\r\n    for (let int_point of int_points) {\r\n        let edge = int_point.edge_before;\r\n\r\n        // recalculate vertex flag: it may be changed after previous split\r\n        int_point.is_vertex = NOT_VERTEX$1;\r\n        if (edge.shape.start && edge.shape.start.equalTo(int_point.pt)) {\r\n            int_point.is_vertex |= START_VERTEX$1;\r\n        }\r\n        if (edge.shape.end && edge.shape.end.equalTo(int_point.pt)) {\r\n            int_point.is_vertex |= END_VERTEX$1;\r\n        }\r\n\r\n        if (int_point.is_vertex & START_VERTEX$1) {    // nothing to split\r\n            int_point.edge_before = edge.prev;\r\n            if (edge.prev) {\r\n                int_point.is_vertex = END_VERTEX$1;   // polygon\r\n            }\r\n            continue;\r\n        }\r\n        if (int_point.is_vertex & END_VERTEX$1) {    // nothing to split\r\n            continue;\r\n        }\r\n\r\n        let newEdge = polygon.addVertex(int_point.pt, edge);\r\n        int_point.edge_before = newEdge;\r\n    }\r\n\r\n    for (let int_point of int_points) {\r\n        if (int_point.edge_before) {\r\n            int_point.edge_after = int_point.edge_before.next;\r\n        }\r\n        else {\r\n            if (polygon instanceof Multiline$1 && int_point.is_vertex & START_VERTEX$1) {\r\n                int_point.edge_after = polygon.first;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction insertBetweenIntPoints(int_point1, int_point2, new_edges) {\r\n    const edge_before = int_point1.edge_before;\r\n    const edge_after = int_point2.edge_after;\r\n    const len = new_edges.length;\r\n    edge_before.next = new_edges[0];\r\n    new_edges[0].prev = edge_before;\r\n\r\n    new_edges[len-1].next = edge_after;\r\n    edge_after.prev = new_edges[len-1];\r\n}\r\n\r\nvar smart_intersections = /*#__PURE__*/Object.freeze({\r\n    __proto__: null,\r\n    addToIntPoints: addToIntPoints,\r\n    calculateInclusionFlags: calculateInclusionFlags,\r\n    filterDuplicatedIntersections: filterDuplicatedIntersections,\r\n    getSortedArray: getSortedArray,\r\n    initializeInclusionFlags: initializeInclusionFlags,\r\n    insertBetweenIntPoints: insertBetweenIntPoints,\r\n    intPointsPoolCount: intPointsPoolCount,\r\n    setOverlappingFlags: setOverlappingFlags,\r\n    sortIntersections: sortIntersections,\r\n    splitByIntersections: splitByIntersections\r\n});\r\n\r\n/**\r\n * Created by Alex Bol on 12/02/2018.\r\n */\r\n/**\r\n * @module BooleanOperations\r\n */\r\n\r\nconst {INSIDE: INSIDE$1, OUTSIDE, BOUNDARY, OVERLAP_SAME, OVERLAP_OPPOSITE} = Constants;\r\nconst {NOT_VERTEX, START_VERTEX, END_VERTEX} = Constants;\r\n\r\nconst BOOLEAN_UNION = 1;\r\nconst BOOLEAN_INTERSECT = 2;\r\nconst BOOLEAN_SUBTRACT = 3;\r\n\r\n\r\n/**\r\n * Unify two polygons polygons and returns new polygon. <br/>\r\n * Point belongs to the resulted polygon if it belongs to the first OR to the second polygon\r\n * @param {Polygon} polygon1 - first operand\r\n * @param {Polygon} polygon2 - second operand\r\n * @returns {Polygon}\r\n */\r\nfunction unify(polygon1, polygon2) {\r\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_UNION, true);\r\n    return res_poly;\r\n}\r\n\r\n/**\r\n * Subtract second polygon from the first and returns new polygon\r\n * Point belongs to the resulted polygon if it belongs to the first polygon AND NOT to the second polygon\r\n * @param {Polygon} polygon1 - first operand\r\n * @param {Polygon} polygon2 - second operand\r\n * @returns {Polygon}\r\n */\r\nfunction subtract(polygon1, polygon2) {\r\n    let polygon2_tmp = polygon2.clone();\r\n    let polygon2_reversed = polygon2_tmp.reverse();\r\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2_reversed, BOOLEAN_SUBTRACT, true);\r\n    return res_poly;\r\n}\r\n\r\n/**\r\n * Intersect two polygons and returns new polygon\r\n * Point belongs to the resulted polygon is it belongs to the first AND to the second polygon\r\n * @param {Polygon} polygon1 - first operand\r\n * @param {Polygon} polygon2 - second operand\r\n * @returns {Polygon}\r\n */\r\nfunction intersect$1(polygon1, polygon2) {\r\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_INTERSECT, true);\r\n    return res_poly;\r\n}\r\n\r\n/**\r\n * Returns boundary of intersection between two polygons as two arrays of shapes (Segments/Arcs) <br/>\r\n * The first array are shapes from the first polygon, the second array are shapes from the second\r\n * @param {Polygon} polygon1 - first operand\r\n * @param {Polygon} polygon2 - second operand\r\n * @returns {Shape[][]}\r\n */\r\nfunction innerClip(polygon1, polygon2) {\r\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_INTERSECT, false);\r\n\r\n    let clip_shapes1 = [];\r\n    for (let face of res_poly.faces) {\r\n        clip_shapes1 = [...clip_shapes1, ...[...face.edges].map(edge => edge.shape)];\r\n    }\r\n    let clip_shapes2 = [];\r\n    for (let face of wrk_poly.faces) {\r\n        clip_shapes2 = [...clip_shapes2, ...[...face.edges].map(edge => edge.shape)];\r\n    }\r\n    return [clip_shapes1, clip_shapes2];\r\n}\r\n\r\n/**\r\n * Returns boundary of subtraction of the second polygon from first polygon as array of shapes\r\n * @param {Polygon} polygon1 - first operand\r\n * @param {Polygon} polygon2 - second operand\r\n * @returns {Shape[]}\r\n */\r\nfunction outerClip(polygon1, polygon2) {\r\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_SUBTRACT, false);\r\n\r\n    let clip_shapes1 = [];\r\n    for (let face of res_poly.faces) {\r\n        clip_shapes1 = [...clip_shapes1, ...[...face.edges].map(edge => edge.shape)];\r\n    }\r\n\r\n    return clip_shapes1;\r\n}\r\n\r\n/**\r\n * Returns intersection points between boundaries of two polygons as two array of points <br/>\r\n * Points in the first array belong to first polygon, points from the second - to the second.\r\n * Points in each array are ordered according to the direction of the correspondent polygon\r\n * @param {Polygon} polygon1 - first operand\r\n * @param {Polygon} polygon2 - second operand\r\n * @returns {Point[][]}\r\n */\r\nfunction calculateIntersections(polygon1, polygon2) {\r\n    let res_poly = polygon1.clone();\r\n    let wrk_poly = polygon2.clone();\r\n\r\n    // get intersection points\r\n    let intersections = getIntersections(res_poly, wrk_poly);\r\n\r\n    // sort intersection points\r\n    sortIntersections(intersections);\r\n\r\n    // split by intersection points\r\n    splitByIntersections(res_poly, intersections.int_points1_sorted);\r\n    splitByIntersections(wrk_poly, intersections.int_points2_sorted);\r\n\r\n    // filter duplicated intersection points\r\n    filterDuplicatedIntersections(intersections);\r\n\r\n    // sort intersection points again after filtering\r\n    sortIntersections(intersections);\r\n\r\n    let ip_sorted1 = intersections.int_points1_sorted.map( int_point => int_point.pt);\r\n    let ip_sorted2 = intersections.int_points2_sorted.map( int_point => int_point.pt);\r\n    return [ip_sorted1, ip_sorted2];\r\n}\r\n\r\nfunction filterNotRelevantEdges(res_poly, wrk_poly, intersections, op) {\r\n    // keep not intersected faces for further remove and merge\r\n    let notIntersectedFacesRes = getNotIntersectedFaces(res_poly, intersections.int_points1);\r\n    let notIntersectedFacesWrk = getNotIntersectedFaces(wrk_poly, intersections.int_points2);\r\n\r\n    // calculate inclusion flag for not intersected faces\r\n    calcInclusionForNotIntersectedFaces(notIntersectedFacesRes, wrk_poly);\r\n    calcInclusionForNotIntersectedFaces(notIntersectedFacesWrk, res_poly);\r\n\r\n    // initialize inclusion flags for edges incident to intersections\r\n    initializeInclusionFlags(intersections.int_points1);\r\n    initializeInclusionFlags(intersections.int_points2);\r\n\r\n    // calculate inclusion flags only for edges incident to intersections\r\n    calculateInclusionFlags(intersections.int_points1, wrk_poly);\r\n    calculateInclusionFlags(intersections.int_points2, res_poly);\r\n\r\n    // fix boundary conflicts\r\n    while (fixBoundaryConflicts(res_poly, wrk_poly, intersections.int_points1, intersections.int_points1_sorted, intersections.int_points2, intersections));\r\n    // while (fixBoundaryConflicts(wrk_poly, res_poly, intersections.int_points2, intersections.int_points2_sorted, intersections.int_points1, intersections));\r\n\r\n    // Set overlapping flags for boundary chains: SAME or OPPOSITE\r\n    setOverlappingFlags(intersections);\r\n\r\n    // remove not relevant chains between intersection points\r\n    removeNotRelevantChains(res_poly, op, intersections.int_points1_sorted, true);\r\n    removeNotRelevantChains(wrk_poly, op, intersections.int_points2_sorted, false);\r\n\r\n    // remove not relevant not intersected faces from res_polygon and wrk_polygon\r\n    // if op == UNION, remove faces that are included in wrk_polygon without intersection\r\n    // if op == INTERSECT, remove faces that are not included into wrk_polygon\r\n    removeNotRelevantNotIntersectedFaces(res_poly, notIntersectedFacesRes, op, true);\r\n    removeNotRelevantNotIntersectedFaces(wrk_poly, notIntersectedFacesWrk, op, false);\r\n}\r\n\r\nfunction swapLinksAndRestore(res_poly, wrk_poly, intersections, op) {\r\n\r\n    // add edges of wrk_poly into the edge container of res_poly\r\n    copyWrkToRes(res_poly, wrk_poly, op, intersections.int_points2);\r\n\r\n    // swap links from res_poly to wrk_poly and vice versa\r\n    swapLinks(res_poly, wrk_poly, intersections);\r\n\r\n    // remove old faces\r\n    removeOldFaces(res_poly, intersections.int_points1);\r\n    removeOldFaces(wrk_poly, intersections.int_points2);\r\n\r\n    // restore faces\r\n    restoreFaces(res_poly, intersections.int_points1, intersections.int_points2);\r\n    restoreFaces(res_poly, intersections.int_points2, intersections.int_points1);\r\n\r\n    // merge relevant not intersected faces from wrk_polygon to res_polygon\r\n    // mergeRelevantNotIntersectedFaces(res_poly, wrk_poly);\r\n}\r\n\r\n\r\nfunction booleanOpBinary(polygon1, polygon2, op, restore)\r\n{\r\n    let res_poly = polygon1.clone();\r\n    let wrk_poly = polygon2.clone();\r\n\r\n    // get intersection points\r\n    let intersections = getIntersections(res_poly, wrk_poly);\r\n\r\n    // sort intersection points\r\n    sortIntersections(intersections);\r\n\r\n    // split by intersection points\r\n    splitByIntersections(res_poly, intersections.int_points1_sorted);\r\n    splitByIntersections(wrk_poly, intersections.int_points2_sorted);\r\n\r\n    // filter duplicated intersection points\r\n    filterDuplicatedIntersections(intersections);\r\n\r\n    // sort intersection points again after filtering\r\n    sortIntersections(intersections);\r\n\r\n    // calculate inclusion and remove not relevant edges\r\n    filterNotRelevantEdges(res_poly, wrk_poly, intersections, op);\r\n\r\n    if (restore) {\r\n        swapLinksAndRestore(res_poly, wrk_poly, intersections, op);\r\n    }\r\n\r\n    return [res_poly, wrk_poly];\r\n}\r\n\r\nfunction getIntersections(polygon1, polygon2)\r\n{\r\n    let intersections = {\r\n        int_points1: [],\r\n        int_points2: []\r\n    };\r\n\r\n    // calculate intersections\r\n    for (let edge1 of polygon1.edges) {\r\n\r\n        // request edges of polygon2 in the box of edge1\r\n        let resp = polygon2.edges.search(edge1.box);\r\n\r\n        // for each edge2 in response\r\n        for (let edge2 of resp) {\r\n\r\n            // calculate intersections between edge1 and edge2\r\n            let ip = edge1.shape.intersect(edge2.shape);\r\n\r\n            // for each intersection point\r\n            for (let pt of ip) {\r\n                addToIntPoints(edge1, pt, intersections.int_points1);\r\n                addToIntPoints(edge2, pt, intersections.int_points2);\r\n            }\r\n        }\r\n    }\r\n    return intersections;\r\n}\r\n\r\nfunction getNotIntersectedFaces(poly, int_points)\r\n{\r\n    let notIntersected = [];\r\n    for (let face of poly.faces) {\r\n        if (!int_points.find((ip) => ip.face === face)) {\r\n            notIntersected.push(face);\r\n        }\r\n    }\r\n    return notIntersected;\r\n}\r\n\r\nfunction calcInclusionForNotIntersectedFaces(notIntersectedFaces, poly2)\r\n{\r\n    for (let face of notIntersectedFaces) {\r\n        face.first.bv = face.first.bvStart = face.first.bvEnd = undefined;\r\n        face.first.setInclusion(poly2);\r\n    }\r\n}\r\n\r\nfunction fixBoundaryConflicts(poly1, poly2, int_points1, int_points1_sorted, int_points2, intersections )\r\n{\r\n    let cur_face;\r\n    let first_int_point_in_face_id;\r\n    let next_int_point1;\r\n    let num_int_points = int_points1_sorted.length;\r\n    let iterate_more = false;\r\n\r\n    for (let i = 0; i < num_int_points; i++) {\r\n        let cur_int_point1 = int_points1_sorted[i];\r\n\r\n        // Find boundary chain in the polygon1\r\n        if (cur_int_point1.face !== cur_face) {                               // next chain started\r\n            first_int_point_in_face_id = i; // cur_int_point1;\r\n            cur_face = cur_int_point1.face;\r\n        }\r\n\r\n        // Skip duplicated points with same <x,y> in \"cur_int_point1\" pool\r\n        let int_points_cur_pool_start = i;\r\n        let int_points_cur_pool_num = intPointsPoolCount(int_points1_sorted, i, cur_face);\r\n        let next_int_point_id;\r\n        if (int_points_cur_pool_start + int_points_cur_pool_num < num_int_points &&\r\n            int_points1_sorted[int_points_cur_pool_start + int_points_cur_pool_num].face === cur_face) {\r\n            next_int_point_id = int_points_cur_pool_start + int_points_cur_pool_num;\r\n        } else {                                         // get first point from the same face\r\n            next_int_point_id = first_int_point_in_face_id;\r\n        }\r\n\r\n        // From all points with same ,x,y. in 'next_int_point1' pool choose one that\r\n        // has same face both in res_poly and in wrk_poly\r\n        let int_points_next_pool_num = intPointsPoolCount(int_points1_sorted, next_int_point_id, cur_face);\r\n        next_int_point1 = null;\r\n        for (let j=next_int_point_id; j < next_int_point_id + int_points_next_pool_num; j++) {\r\n            let next_int_point1_tmp = int_points1_sorted[j];\r\n            if (next_int_point1_tmp.face === cur_face &&\r\n                int_points2[next_int_point1_tmp.id].face === int_points2[cur_int_point1.id].face) {\r\n                next_int_point1 = next_int_point1_tmp;\r\n                break;\r\n            }\r\n        }\r\n        if (next_int_point1 === null)\r\n            continue;\r\n\r\n        let edge_from1 = cur_int_point1.edge_after;\r\n        let edge_to1 = next_int_point1.edge_before;\r\n\r\n        // Case #1. One of the ends is not boundary - probably tiny edge wrongly marked as boundary\r\n        if (edge_from1.bv === BOUNDARY && edge_to1.bv != BOUNDARY) {\r\n            edge_from1.bv = edge_to1.bv;\r\n            continue;\r\n        }\r\n\r\n        if (edge_from1.bv != BOUNDARY && edge_to1.bv === BOUNDARY) {\r\n            edge_to1.bv = edge_from1.bv;\r\n            continue;\r\n        }\r\n\r\n        // Set up all boundary values for middle edges. Need for cases 2 and 3\r\n        if ( (edge_from1.bv === BOUNDARY && edge_to1.bv === BOUNDARY && edge_from1 != edge_to1) ||\r\n        (edge_from1.bv === INSIDE$1 && edge_to1.bv === OUTSIDE  || edge_from1.bv === OUTSIDE && edge_to1.bv === INSIDE$1 ) ) {\r\n            let edge_tmp = edge_from1.next;\r\n            while (edge_tmp != edge_to1) {\r\n                edge_tmp.bvStart = undefined;\r\n                edge_tmp.bvEnd = undefined;\r\n                edge_tmp.bv = undefined;\r\n                edge_tmp.setInclusion(poly2);\r\n                edge_tmp = edge_tmp.next;\r\n            }\r\n        }\r\n\r\n        // Case #2. Both of the ends boundary. Check all the edges in the middle\r\n        // If some edges in the middle are not boundary then update bv of 'from' and 'to' edges\r\n        if (edge_from1.bv === BOUNDARY && edge_to1.bv === BOUNDARY && edge_from1 != edge_to1) {\r\n            let edge_tmp = edge_from1.next;\r\n            let new_bv;\r\n            while (edge_tmp != edge_to1) {\r\n                if (edge_tmp.bv != BOUNDARY) {\r\n                    if (new_bv === undefined) {        // first not boundary edge between from and to\r\n                        new_bv = edge_tmp.bv;\r\n                    }\r\n                    else {                            // another not boundary edge between from and to\r\n                        if (edge_tmp.bv != new_bv) {  // and it has different bv - can't resolve conflict\r\n                            throw Errors.UNRESOLVED_BOUNDARY_CONFLICT;\r\n                        }\r\n                    }\r\n                }\r\n                edge_tmp = edge_tmp.next;\r\n            }\r\n\r\n            if (new_bv != undefined) {\r\n                edge_from1.bv = new_bv;\r\n                edge_to1.bv = new_bv;\r\n            }\r\n            continue;         // all middle edges are boundary, proceed with this\r\n        }\r\n\r\n        // Case 3. One of the ends is inner, another is outer\r\n        if (edge_from1.bv === INSIDE$1 && edge_to1.bv === OUTSIDE  || edge_from1.bv === OUTSIDE && edge_to1.bv === INSIDE$1 ) {\r\n            let edge_tmp = edge_from1;\r\n            // Find missing intersection point\r\n            while (edge_tmp != edge_to1) {\r\n                if (edge_tmp.bvStart === edge_from1.bv && edge_tmp.bvEnd === edge_to1.bv) {\r\n                    let [dist, segment] = edge_tmp.shape.distanceTo(poly2);\r\n                    if (dist < 10*Flatten.DP_TOL) {  // it should be very close\r\n                        // let pt = edge_tmp.end;\r\n                        // add to the list of intersections of poly1\r\n                        addToIntPoints(edge_tmp, segment.ps, int_points1);\r\n\r\n                        // split edge_tmp in poly1 if need\r\n                        let int_point1 = int_points1[int_points1.length-1];\r\n                        if (int_point1.is_vertex & START_VERTEX) {        // nothing to split\r\n                            int_point1.edge_after = edge_tmp;\r\n                            int_point1.edge_before = edge_tmp.prev;\r\n                            edge_tmp.bvStart = BOUNDARY;\r\n                            edge_tmp.bv = undefined;\r\n                            edge_tmp.setInclusion(poly2);\r\n                        }\r\n                        else if (int_point1.is_vertex & END_VERTEX) {    // nothing to split\r\n                            int_point1.edge_after = edge_tmp.next;\r\n                            edge_tmp.bvEnd = BOUNDARY;\r\n                            edge_tmp.bv = undefined;\r\n                            edge_tmp.setInclusion(poly2);\r\n                        }\r\n                        else {        // split edge here\r\n                            let newEdge1 = poly2.addVertex(int_point1.pt, edge_tmp);\r\n                            int_point1.edge_before = newEdge1;\r\n                            int_point1.edge_after = newEdge1.next;\r\n\r\n                            newEdge1.setInclusion(poly2);\r\n\r\n                            newEdge1.next.bvStart = BOUNDARY;\r\n                            newEdge1.next.bvEnd = undefined;\r\n                            newEdge1.next.bv = undefined;\r\n                            newEdge1.next.setInclusion(poly2);\r\n                        }\r\n\r\n                        // add to the list of intersections of poly2\r\n                        let edge2 = poly2.findEdgeByPoint(segment.pe);\r\n                        addToIntPoints(edge2, segment.pe, int_points2);\r\n                        // split edge2 in poly2 if need\r\n                        let int_point2 = int_points2[int_points2.length-1];\r\n                        if (int_point2.is_vertex & START_VERTEX) {        // nothing to split\r\n                            int_point2.edge_after = edge2;\r\n                            int_point2.edge_before = edge2.prev;\r\n                        }\r\n                        else if (int_point2.is_vertex & END_VERTEX) {    // nothing to split\r\n                            int_point2.edge_after = edge2.next;\r\n                        }\r\n                        else {        // split edge here\r\n                            // first locate int_points that may refer to edge2 as edge.after\r\n                            // let int_point2_edge_before = int_points2.find( int_point => int_point.edge_before === edge2)\r\n                            let int_point2_edge_after = int_points2.find( int_point => int_point.edge_after === edge2 );\r\n\r\n                            let newEdge2 = poly2.addVertex(int_point2.pt, edge2);\r\n                            int_point2.edge_before = newEdge2;\r\n                            int_point2.edge_after = newEdge2.next;\r\n\r\n                            if (int_point2_edge_after)\r\n                                int_point2_edge_after.edge_after = newEdge2;\r\n\r\n                            newEdge2.bvStart = undefined;\r\n                            newEdge2.bvEnd = BOUNDARY;\r\n                            newEdge2.bv = undefined;\r\n                            newEdge2.setInclusion(poly1);\r\n\r\n                            newEdge2.next.bvStart = BOUNDARY;\r\n                            newEdge2.next.bvEnd = undefined;\r\n                            newEdge2.next.bv = undefined;\r\n                            newEdge2.next.setInclusion(poly1);\r\n                        }\r\n\r\n                        sortIntersections(intersections);\r\n\r\n                        iterate_more = true;\r\n                        break;\r\n                    }\r\n                }\r\n                edge_tmp = edge_tmp.next;\r\n            }\r\n\r\n            // we changed intersections inside loop, have to exit and repair again\r\n            if (iterate_more)\r\n                break;\r\n\r\n            throw Errors.UNRESOLVED_BOUNDARY_CONFLICT;\r\n        }\r\n    }\r\n\r\n    return iterate_more;\r\n}\r\n\r\nfunction removeNotRelevantChains(polygon, op, int_points, is_res_polygon)\r\n{\r\n    if (!int_points) return;\r\n    let cur_face = undefined;\r\n    let first_int_point_in_face_num = undefined;\r\n    let int_point_current;\r\n    let int_point_next;\r\n\r\n    for (let i = 0; i < int_points.length; i++) {\r\n        int_point_current = int_points[i];\r\n\r\n        if (int_point_current.face !== cur_face) {   // next face started\r\n            first_int_point_in_face_num = i;\r\n            cur_face = int_point_current.face;\r\n        }\r\n\r\n        if (cur_face.isEmpty())                // ??\r\n            continue;\r\n\r\n        // Get next int point from the same face that current\r\n\r\n        // Count how many duplicated points with same <x,y> in \"points from\" pool ?\r\n        let int_points_from_pull_start = i;\r\n        let int_points_from_pull_num = intPointsPoolCount(int_points, i, cur_face);\r\n        let next_int_point_num;\r\n        if (int_points_from_pull_start + int_points_from_pull_num < int_points.length &&\r\n            int_points[int_points_from_pull_start + int_points_from_pull_num].face === int_point_current.face) {\r\n            next_int_point_num = int_points_from_pull_start + int_points_from_pull_num;\r\n        } else {                                         // get first point from the same face\r\n            next_int_point_num = first_int_point_in_face_num;\r\n        }\r\n        int_point_next = int_points[next_int_point_num];\r\n\r\n        /* Count how many duplicated points with same <x,y> in \"points to\" pull ? */\r\n        let int_points_to_pull_start = next_int_point_num;\r\n        let int_points_to_pull_num = intPointsPoolCount(int_points, int_points_to_pull_start, cur_face);\r\n\r\n\r\n        let edge_from = int_point_current.edge_after;\r\n        let edge_to = int_point_next.edge_before;\r\n\r\n        if ((edge_from.bv === INSIDE$1 && edge_to.bv === INSIDE$1 && op === BOOLEAN_UNION) ||\r\n            (edge_from.bv === OUTSIDE && edge_to.bv === OUTSIDE && op === BOOLEAN_INTERSECT) ||\r\n            ((edge_from.bv === OUTSIDE || edge_to.bv === OUTSIDE) && op === BOOLEAN_SUBTRACT && !is_res_polygon) ||\r\n            ((edge_from.bv === INSIDE$1 || edge_to.bv === INSIDE$1) && op === BOOLEAN_SUBTRACT && is_res_polygon) ||\r\n            (edge_from.bv === BOUNDARY && edge_to.bv === BOUNDARY && (edge_from.overlap & OVERLAP_SAME) && is_res_polygon) ||\r\n            (edge_from.bv === BOUNDARY && edge_to.bv === BOUNDARY && (edge_from.overlap & OVERLAP_OPPOSITE))) {\r\n\r\n            polygon.removeChain(cur_face, edge_from, edge_to);\r\n\r\n            /* update all points in \"points from\" pull */\r\n            for (let k = int_points_from_pull_start; k < int_points_from_pull_start + int_points_from_pull_num; k++) {\r\n                int_points[k].edge_after = undefined;\r\n            }\r\n\r\n            /* update all points in \"points to\" pull */\r\n            for (let k = int_points_to_pull_start; k < int_points_to_pull_start + int_points_to_pull_num; k++) {\r\n                int_points[k].edge_before = undefined;\r\n            }\r\n        }\r\n\r\n        /* skip to the last point in \"points from\" group */\r\n        i += int_points_from_pull_num - 1;\r\n    }\r\n}\r\nfunction copyWrkToRes(res_polygon, wrk_polygon, op, int_points)\r\n{\r\n    for (let face of wrk_polygon.faces) {\r\n        for (let edge of face) {\r\n            res_polygon.edges.add(edge);\r\n        }\r\n        // If union - add face from wrk_polygon that is not intersected with res_polygon\r\n        if ( /*(op === BOOLEAN_UNION || op == BOOLEAN_SUBTRACT) &&*/\r\n            int_points.find((ip) => (ip.face === face)) === undefined) {\r\n            res_polygon.addFace(face.first, face.last);\r\n        }\r\n    }\r\n}\r\n\r\nfunction swapLinks(res_polygon, wrk_polygon, intersections)\r\n{\r\n    if (intersections.int_points1.length === 0) return;\r\n\r\n    for (let i = 0; i < intersections.int_points1.length; i++) {\r\n        let int_point1 = intersections.int_points1[i];\r\n        let int_point2 = intersections.int_points2[i];\r\n\r\n        // Simple case - find continuation on the other polygon\r\n\r\n        // Process edge from res_polygon\r\n        if (int_point1.edge_before !== undefined && int_point1.edge_after === undefined) {    // swap need\r\n            if (int_point2.edge_before === undefined && int_point2.edge_after !== undefined) {  // simple case\r\n                // Connect edges\r\n                int_point1.edge_before.next = int_point2.edge_after;\r\n                int_point2.edge_after.prev = int_point1.edge_before;\r\n\r\n                // Fill in missed links in intersection points\r\n                int_point1.edge_after = int_point2.edge_after;\r\n                int_point2.edge_before = int_point1.edge_before;\r\n            }\r\n        }\r\n        // Process edge from wrk_polygon\r\n        if (int_point2.edge_before !== undefined && int_point2.edge_after === undefined) {    // swap need\r\n            if (int_point1.edge_before === undefined && int_point1.edge_after !== undefined) {  // simple case\r\n                // Connect edges\r\n                int_point2.edge_before.next = int_point1.edge_after;\r\n                int_point1.edge_after.prev = int_point2.edge_before;\r\n\r\n                // Complete missed links\r\n                int_point2.edge_after = int_point1.edge_after;\r\n                int_point1.edge_before = int_point2.edge_before;\r\n            }\r\n        }\r\n\r\n        // Continuation not found - complex case\r\n        // Continuation will be found on the same polygon.\r\n        // It happens when intersection point is actually touching point\r\n        // Polygon1\r\n        if (int_point1.edge_before !== undefined && int_point1.edge_after === undefined) {    // still swap need\r\n            for (let int_point of intersections.int_points1_sorted) {\r\n                if (int_point === int_point1) continue;     // skip same\r\n                if (int_point.edge_before === undefined && int_point.edge_after !== undefined) {\r\n                    if (int_point.pt.equalTo(int_point1.pt)) {\r\n                        // Connect edges\r\n                        int_point1.edge_before.next = int_point.edge_after;\r\n                        int_point.edge_after.prev = int_point1.edge_before;\r\n\r\n                        // Complete missed links\r\n                        int_point1.edge_after = int_point.edge_after;\r\n                        int_point.edge_before = int_point1.edge_before;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Polygon2\r\n        if (int_point2.edge_before !== undefined && int_point2.edge_after === undefined) {    // still swap need\r\n            for (let int_point of intersections.int_points2_sorted) {\r\n                if (int_point === int_point2) continue;     // skip same\r\n                if (int_point.edge_before === undefined && int_point.edge_after !== undefined) {\r\n                    if (int_point.pt.equalTo(int_point2.pt)) {\r\n                        // Connect edges\r\n                        int_point2.edge_before.next = int_point.edge_after;\r\n                        int_point.edge_after.prev = int_point2.edge_before;\r\n\r\n                        // Complete missed links\r\n                        int_point2.edge_after = int_point.edge_after;\r\n                        int_point.edge_before = int_point2.edge_before;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Sanity check that no dead ends left\r\n}\r\n\r\nfunction removeOldFaces(polygon, int_points)\r\n{\r\n    for (let int_point of int_points) {\r\n        polygon.faces.delete(int_point.face);\r\n        int_point.face = undefined;\r\n        if (int_point.edge_before)\r\n            int_point.edge_before.face = undefined;\r\n        if (int_point.edge_after)\r\n            int_point.edge_after.face = undefined;\r\n    }\r\n}\r\n\r\nfunction restoreFaces(polygon, int_points, other_int_points)\r\n{\r\n    // For each intersection point - create new face\r\n    for (let int_point of int_points) {\r\n        if (int_point.edge_before === undefined || int_point.edge_after === undefined)  // completely deleted\r\n            continue;\r\n        if (int_point.face)            // already restored\r\n            continue;\r\n\r\n        if (int_point.edge_after.face || int_point.edge_before.face)        // Face already created. Possible case in duplicated intersection points\r\n            continue;\r\n\r\n        let first = int_point.edge_after;      // face start\r\n        let last = int_point.edge_before;      // face end;\r\n\r\n        try {\r\n            LinkedList.testInfiniteLoop(first);    // check and throw error if infinite loop found\r\n        }\r\n        catch (error) {\r\n            throw Errors.CANNOT_COMPLETE_BOOLEAN_OPERATION\r\n        }\r\n\r\n        let face = polygon.addFace(first, last);\r\n\r\n        // Mark intersection points from the newly create face\r\n        // to avoid multiple creation of the same face.\r\n        // Face was assigned to each edge of new face in addFace function\r\n        for (let int_point_tmp of int_points) {\r\n            if (int_point_tmp.edge_before && int_point_tmp.edge_after &&\r\n                int_point_tmp.edge_before.face === face && int_point_tmp.edge_after.face === face) {\r\n                int_point_tmp.face = face;\r\n            }\r\n        }\r\n        // Mark other intersection points as well\r\n        for (let int_point_tmp of other_int_points) {\r\n            if (int_point_tmp.edge_before && int_point_tmp.edge_after &&\r\n                int_point_tmp.edge_before.face === face && int_point_tmp.edge_after.face === face) {\r\n                int_point_tmp.face = face;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction removeNotRelevantNotIntersectedFaces(polygon, notIntersectedFaces, op, is_res_polygon)\r\n{\r\n    for (let face of notIntersectedFaces) {\r\n        let rel = face.first.bv;\r\n        if (op === BOOLEAN_UNION && rel === INSIDE$1 ||\r\n            op === BOOLEAN_SUBTRACT && rel === INSIDE$1 && is_res_polygon ||\r\n            op === BOOLEAN_SUBTRACT && rel === OUTSIDE && !is_res_polygon ||\r\n            op === BOOLEAN_INTERSECT && rel === OUTSIDE) {\r\n\r\n            polygon.deleteFace(face);\r\n        }\r\n    }\r\n}\r\n\r\nvar BooleanOperations = /*#__PURE__*/Object.freeze({\r\n    __proto__: null,\r\n    BOOLEAN_INTERSECT: BOOLEAN_INTERSECT,\r\n    BOOLEAN_SUBTRACT: BOOLEAN_SUBTRACT,\r\n    BOOLEAN_UNION: BOOLEAN_UNION,\r\n    calculateIntersections: calculateIntersections,\r\n    innerClip: innerClip,\r\n    intersect: intersect$1,\r\n    outerClip: outerClip,\r\n    removeNotRelevantChains: removeNotRelevantChains,\r\n    removeOldFaces: removeOldFaces,\r\n    restoreFaces: restoreFaces,\r\n    subtract: subtract,\r\n    unify: unify\r\n});\r\n\r\n/*\r\n    Dimensionally extended 9-intersected model\r\n    See https://en.wikipedia.org/wiki/DE-9IM for more details\r\n */\r\n// const DISJOINT = RegExp('FF.FF....');\r\nconst EQUAL = RegExp('T.F..FFF.|T.F...F..');\r\nconst INTERSECT = RegExp('T........|.T.......|...T.....|....T....');\r\nconst TOUCH = RegExp('FT.......|F..T.....|F...T....');\r\nconst INSIDE = RegExp('T.F..F...');\r\nconst COVERED = RegExp('T.F..F...|.TF..F...|..FT.F...|..F.TF...');\r\n\r\nclass DE9IM {\r\n    /**\r\n     * Create new instance of DE9IM matrix\r\n     */\r\n    constructor() {\r\n        /**\r\n         * Array representing 3x3 intersection matrix\r\n         * @type {Shape[]}\r\n         */\r\n        this.m = new Array(9).fill(undefined);\r\n    }\r\n\r\n    /**\r\n     * Get Interior To Interior intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get I2I() {\r\n        return this.m[0];\r\n    }\r\n\r\n    /**\r\n     * Set Interior To Interior intersection\r\n     * @param geom\r\n     */\r\n    set I2I(geom) {\r\n        this.m[0] = geom;\r\n    }\r\n\r\n    /**\r\n     * Get Interior To Boundary intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get I2B() {\r\n        return this.m[1];\r\n    }\r\n\r\n    /**\r\n     * Set Interior to Boundary intersection\r\n     * @param geomc\r\n     */\r\n    set I2B(geom) {\r\n        this.m[1] = geom;\r\n    }\r\n\r\n    /**\r\n     * Get Interior To Exterior intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get I2E() {\r\n        return this.m[2];\r\n    }\r\n\r\n    /**\r\n     * Set Interior to Exterior intersection\r\n     * @param geom\r\n     */\r\n    set I2E(geom) {\r\n        this.m[2] = geom;\r\n    }\r\n\r\n    /**\r\n     * Get Boundary To Interior intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get B2I() {\r\n        return this.m[3];\r\n    }\r\n\r\n    /**\r\n     * Set Boundary to Interior intersection\r\n     * @param geom\r\n     */\r\n    set B2I(geom) {\r\n        this.m[3] = geom;\r\n    }\r\n\r\n    /**\r\n     * Get Boundary To Boundary intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get B2B() {\r\n        return this.m[4];\r\n    }\r\n\r\n    /**\r\n     * Set Boundary to Boundary intersection\r\n     * @param geom\r\n     */\r\n    set B2B(geom) {\r\n        this.m[4] = geom;\r\n    }\r\n\r\n    /**\r\n     * Get Boundary To Exterior intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get B2E() {\r\n        return this.m[5];\r\n    }\r\n\r\n    /**\r\n     * Set Boundary to Exterior intersection\r\n     * @param geom\r\n     */\r\n    set B2E(geom) {\r\n        this.m[5] = geom;\r\n    }\r\n\r\n    /**\r\n     * Get Exterior To Interior intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get E2I() {\r\n        return this.m[6];\r\n    }\r\n\r\n    /**\r\n     * Set Exterior to Interior intersection\r\n     * @param geom\r\n     */\r\n    set E2I(geom) {\r\n        this.m[6] = geom;\r\n    }\r\n\r\n    /**\r\n     * Get Exterior To Boundary intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get E2B() {\r\n        return this.m[7];\r\n    }\r\n\r\n    /**\r\n     * Set Exterior to Boundary intersection\r\n     * @param geom\r\n     */\r\n    set E2B(geom) {\r\n        this.m[7] = geom;\r\n    }\r\n\r\n    /**\r\n     * Get Exterior to Exterior intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get E2E() {\r\n        return this.m[8];\r\n    }\r\n\r\n    /**\r\n     * Set Exterior to Exterior intersection\r\n     * @param geom\r\n     */\r\n    set E2E(geom) {\r\n        this.m[8] = geom;\r\n    }\r\n\r\n    /**\r\n     * Return de9im matrix as string where<br/>\r\n     * - intersection is 'T'<br/>\r\n     * - not intersected is 'F'<br/>\r\n     * - not relevant is '*'<br/>\r\n     * For example, string 'FF**FF****' means 'DISJOINT'\r\n     * @returns {string}\r\n     */\r\n    toString() {\r\n        return this.m.map( e => {\r\n            if (e instanceof Array && e.length > 0) {\r\n                return 'T'\r\n            }\r\n            else if (e instanceof Array && e.length === 0) {\r\n                return 'F'\r\n            }\r\n            else {\r\n                return '*'\r\n            }\r\n        }).join(\"\")\r\n    }\r\n\r\n    equal() {\r\n        return EQUAL.test(this.toString());\r\n    }\r\n\r\n    intersect() {\r\n        return INTERSECT.test(this.toString());\r\n    }\r\n\r\n    touch() {\r\n        return TOUCH.test(this.toString());\r\n    }\r\n\r\n    inside() {\r\n        return INSIDE.test(this.toString());\r\n    }\r\n\r\n    covered() {\r\n        return COVERED.test(this.toString());\r\n    }\r\n}\r\n\r\n/**\r\n * @module RayShoot\r\n */\r\n/**\r\n * Implements ray shooting algorithm. Returns relation between point and polygon: inside, outside or boundary\r\n * @param {Polygon} polygon - polygon to test\r\n * @param {Point} point - point to test\r\n * @returns {INSIDE|OUTSIDE|BOUNDARY}\r\n */\r\nfunction ray_shoot(polygon, point) {\r\n    let contains = undefined;\r\n\r\n    // 1. Quick reject\r\n    // if (polygon.box.not_intersect(point.box)) {\r\n    //     return Flatten.OUTSIDE;\r\n    // }\r\n\r\n    let ray = new Flatten.Ray(point);\r\n    let line = new Flatten.Line(ray.pt, ray.norm);\r\n\r\n    // 2. Locate relevant edges of the polygon\r\n    const searchBox = new Flatten.Box(\r\n        ray.box.xmin-Flatten.DP_TOL, ray.box.ymin-Flatten.DP_TOL,\r\n        ray.box.xmax, ray.box.ymax+Flatten.DP_TOL\r\n    );\r\n\r\n    if (polygon.box.not_intersect(searchBox)) {\r\n        return Flatten.OUTSIDE;\r\n    }\r\n\r\n    let resp_edges = polygon.edges.search(searchBox);\r\n\r\n    if (resp_edges.length === 0) {\r\n        return Flatten.OUTSIDE;\r\n    }\r\n\r\n    // 2.5 Check if boundary\r\n    for (let edge of resp_edges) {\r\n        if (edge.shape.contains(point)) {\r\n            return Flatten.BOUNDARY;\r\n        }\r\n    }\r\n\r\n    let faces = [...polygon.faces];\r\n\r\n    // 3. Calculate intersections\r\n    let intersections = [];\r\n    for (let edge of resp_edges) {\r\n        for (let ip of ray.intersect(edge.shape)) {\r\n\r\n            // If intersection is equal to query point then point lays on boundary\r\n            if (ip.equalTo(point)) {\r\n                return Flatten.BOUNDARY;\r\n            }\r\n\r\n            intersections.push({\r\n                pt: ip,\r\n                edge: edge,\r\n                face_index: faces.indexOf(edge.face)\r\n            });\r\n        }\r\n    }\r\n\r\n    // 4. Sort intersection in x-ascending order\r\n    intersections.sort((i1, i2) => {\r\n        if (LT(i1.pt.x, i2.pt.x)) {\r\n            return -1;\r\n        }\r\n        if (GT(i1.pt.x, i2.pt.x)) {\r\n            return 1;\r\n        }\r\n        if (i1.face_index < i2.face_index) {\r\n            return -1\r\n        }\r\n        if (i1.face_index > i2.face_index) {\r\n            return 1\r\n        }\r\n        if (i1.edge.arc_length < i2.edge.arc_length) {\r\n            return -1\r\n        }\r\n        if (i1.edge.arc_length > i2.edge.arc_length) {\r\n            return 1\r\n        }\r\n        return 0;\r\n    });\r\n\r\n    // 5. Count real intersections, exclude touching\r\n    let counter = 0;\r\n\r\n    for (let i = 0; i < intersections.length; i++) {\r\n        let intersection = intersections[i];\r\n\r\n        if (intersection.pt.equalTo(intersection.edge.shape.start)) {\r\n            /* skip same point between same edges if already counted */\r\n            if (i > 0 && intersection.pt.equalTo(intersections[i - 1].pt) &&\r\n                intersection.face_index === intersections[i - 1].face_index &&\r\n                intersection.edge.prev === intersections[i - 1].edge) {\r\n                continue;\r\n            }\r\n\r\n            let prev_edge = intersection.edge.prev;\r\n            while (EQ_0(prev_edge.length)) {\r\n                prev_edge = prev_edge.prev;\r\n            }\r\n            let prev_tangent = prev_edge.shape.tangentInEnd();\r\n            let prev_point = intersection.pt.translate(prev_tangent);\r\n\r\n            let cur_tangent = intersection.edge.shape.tangentInStart();\r\n            let cur_point = intersection.pt.translate(cur_tangent);\r\n\r\n            let prev_on_the_left = prev_point.leftTo(line);\r\n            let cur_on_the_left = cur_point.leftTo(line);\r\n\r\n            if ((prev_on_the_left && !cur_on_the_left) || (!prev_on_the_left && cur_on_the_left)) {\r\n                counter++;\r\n            }\r\n        } else if (intersection.pt.equalTo(intersection.edge.shape.end)) {\r\n            /* skip same point between same edges if already counted */\r\n            if (i > 0 && intersection.pt.equalTo(intersections[i - 1].pt) &&\r\n                intersection.face_index === intersections[i-1].face_index &&\r\n                intersection.edge.next === intersections[i - 1].edge) {\r\n                continue;\r\n            }\r\n\r\n            let next_edge = intersection.edge.next;\r\n            while (EQ_0(next_edge.length)) {\r\n                next_edge = next_edge.next;\r\n            }\r\n            let next_tangent = next_edge.shape.tangentInStart();\r\n            let next_point = intersection.pt.translate(next_tangent);\r\n\r\n            let cur_tangent = intersection.edge.shape.tangentInEnd();\r\n            let cur_point = intersection.pt.translate(cur_tangent);\r\n\r\n            let next_on_the_left = next_point.leftTo(line);\r\n            let cur_on_the_left = cur_point.leftTo(line);\r\n\r\n            if ((next_on_the_left && !cur_on_the_left) || (!next_on_the_left && cur_on_the_left)) {\r\n                counter++;\r\n            }\r\n        } else {        /* intersection point is not a vertex */\r\n            if (intersection.edge.shape instanceof Flatten.Segment) {\r\n                counter++;\r\n            } else {\r\n                /* Check if ray does not touch the curve in the extremal (top or bottom) point */\r\n                let box = intersection.edge.shape.box;\r\n                if (!(EQ(intersection.pt.y, box.ymin) ||\r\n                    EQ(intersection.pt.y, box.ymax))) {\r\n                    counter++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // 6. Odd or even?\r\n    contains = counter % 2 === 1 ? INSIDE$2 : OUTSIDE$1;\r\n    return contains;\r\n}\r\n\r\n/*\r\n    Calculate relationship between two shapes and return result in the form of\r\n    Dimensionally Extended nine-Intersection Matrix (https://en.wikipedia.org/wiki/DE-9IM)\r\n */\r\n\r\n\r\n/**\r\n * Returns true if shapes are topologically equal:  their interiors intersect and\r\n * no part of the interior or boundary of one geometry intersects the exterior of the other\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\r\nfunction equal(shape1, shape2) {\r\n    return relate(shape1, shape2).equal();\r\n}\r\n\r\n/**\r\n * Returns true if shapes have at least one point in common, same as \"not disjoint\"\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\r\nfunction intersect(shape1, shape2) {\r\n    return relate(shape1, shape2).intersect();\r\n}\r\n\r\n/**\r\n * Returns true if shapes have at least one point in common, but their interiors do not intersect\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\r\nfunction touch(shape1, shape2) {\r\n    return relate(shape1, shape2).touch();\r\n}\r\n\r\n/**\r\n * Returns true if shapes have no points in common neither in interior nor in boundary\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\r\nfunction disjoint(shape1, shape2) {\r\n    return !intersect(shape1, shape2);\r\n}\r\n\r\n/**\r\n * Returns true shape1 lies in the interior of shape2\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\r\nfunction inside(shape1, shape2) {\r\n    return relate(shape1, shape2).inside();\r\n}\r\n\r\n/**\r\n * Returns true if every point in shape1 lies in the interior or on the boundary of shape2\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\r\nfunction covered(shape1, shape2) {\r\n    return  relate(shape1, shape2).covered();\r\n}\r\n\r\n/**\r\n * Returns true shape1's interior contains shape2 <br/>\r\n * Same as inside(shape2, shape1)\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\r\nfunction contain(shape1, shape2) {\r\n    return inside(shape2, shape1);\r\n}\r\n\r\n/**\r\n * Returns true shape1's cover shape2, same as shape2 covered by shape1\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\r\nfunction cover(shape1, shape2) {\r\n    return covered(shape2, shape1);\r\n}\r\n\r\n/**\r\n * Returns relation between two shapes as intersection 3x3 matrix, where each\r\n * element contains relevant intersection as array of shapes.\r\n * If there is no intersection, element contains empty array\r\n * If intersection is irrelevant it left undefined. (For example, intersection\r\n * between two exteriors is usually irrelevant)\r\n * @param shape1\r\n * @param shape2\r\n * @returns {DE9IM}\r\n */\r\nfunction relate(shape1, shape2) {\r\n    if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Line) {\r\n        return relateLine2Line(shape1,  shape2);\r\n    }\r\n    else if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Circle) {\r\n        return relateLine2Circle(shape1, shape2);\r\n    }\r\n    else if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Box) {\r\n        return relateLine2Box(shape1, shape2);\r\n    }\r\n    else if ( shape1 instanceof Flatten.Line  && shape2 instanceof Flatten.Polygon) {\r\n        return relateLine2Polygon(shape1, shape2);\r\n    }\r\n    else if ( (shape1 instanceof Flatten.Segment || shape1 instanceof Flatten.Arc)  && shape2 instanceof Flatten.Polygon) {\r\n        return relateShape2Polygon(shape1, shape2);\r\n    }\r\n    else if ( (shape1 instanceof Flatten.Segment || shape1 instanceof Flatten.Arc)  &&\r\n        (shape2 instanceof Flatten.Circle || shape2 instanceof Flatten.Box) ) {\r\n        return relateShape2Polygon(shape1, new Flatten.Polygon(shape2));\r\n    }\r\n    else if (shape1 instanceof Flatten.Polygon && shape2 instanceof Flatten.Polygon) {\r\n        return relatePolygon2Polygon(shape1, shape2);\r\n    }\r\n    else if ((shape1 instanceof Flatten.Circle || shape1 instanceof Flatten.Box) &&\r\n        (shape2 instanceof  Flatten.Circle || shape2 instanceof Flatten.Box)) {\r\n        return relatePolygon2Polygon(new Flatten.Polygon(shape1), new Flatten.Polygon(shape2));\r\n    }\r\n    else if ((shape1 instanceof Flatten.Circle || shape1 instanceof Flatten.Box) && shape2 instanceof Flatten.Polygon) {\r\n        return relatePolygon2Polygon(new Flatten.Polygon(shape1), shape2);\r\n    }\r\n    else if (shape1 instanceof Flatten.Polygon && (shape2 instanceof Flatten.Circle || shape2 instanceof Flatten.Box)) {\r\n        return relatePolygon2Polygon(shape1, new Flatten.Polygon(shape2));\r\n    }\r\n}\r\n\r\nfunction relateLine2Line(line1, line2) {\r\n    let denim = new DE9IM();\r\n    let ip = intersectLine2Line(line1, line2);\r\n    if (ip.length === 0) {       // parallel or equal ?\r\n        if (line1.contains(line2.pt) && line2.contains(line1.pt)) {\r\n            denim.I2I = [line1];   // equal  'T.F...F..'  - no boundary\r\n            denim.I2E = [];\r\n            denim.E2I = [];\r\n        }\r\n        else {                     // parallel - disjoint 'FFTFF*T**'\r\n            denim.I2I = [];\r\n            denim.I2E = [line1];\r\n            denim.E2I = [line2];\r\n        }\r\n    }\r\n    else {                       // intersect   'T********'\r\n        denim.I2I = ip;\r\n        denim.I2E = line1.split(ip);\r\n        denim.E2I = line2.split(ip);\r\n    }\r\n    return denim;\r\n}\r\n\r\nfunction relateLine2Circle(line,circle) {\r\n    let denim = new DE9IM();\r\n    let ip = intersectLine2Circle(line, circle);\r\n    if (ip.length === 0) {\r\n        denim.I2I = [];\r\n        denim.I2B = [];\r\n        denim.I2E = [line];\r\n        denim.E2I = [circle];\r\n    }\r\n    else if (ip.length === 1) {\r\n        denim.I2I = [];\r\n        denim.I2B = ip;\r\n        denim.I2E = line.split(ip);\r\n\r\n        denim.E2I = [circle];\r\n    }\r\n    else {       // ip.length == 2\r\n        let multiline = new Multiline$1([line]);\r\n        let ip_sorted = line.sortPoints(ip);\r\n        multiline.split(ip_sorted);\r\n        let splitShapes = multiline.toShapes();\r\n\r\n        denim.I2I = [splitShapes[1]];\r\n        denim.I2B = ip_sorted;\r\n        denim.I2E = [splitShapes[0], splitShapes[2]];\r\n\r\n        denim.E2I = new Flatten.Polygon([circle.toArc()]).cutWithLine(line);\r\n    }\r\n\r\n    return denim;\r\n}\r\n\r\nfunction relateLine2Box(line, box) {\r\n    let denim = new DE9IM();\r\n    let ip = intersectLine2Box(line, box);\r\n    if (ip.length === 0) {\r\n        denim.I2I = [];\r\n        denim.I2B = [];\r\n        denim.I2E = [line];\r\n\r\n        denim.E2I = [box];\r\n    }\r\n    else if (ip.length === 1) {\r\n        denim.I2I = [];\r\n        denim.I2B = ip;\r\n        denim.I2E = line.split(ip);\r\n\r\n        denim.E2I = [box];\r\n    }\r\n    else {                     // ip.length == 2\r\n        let multiline = new Multiline$1([line]);\r\n        let ip_sorted = line.sortPoints(ip);\r\n        multiline.split(ip_sorted);\r\n        let splitShapes = multiline.toShapes();\r\n\r\n        /* Are two intersection points on the same segment of the box boundary ? */\r\n        if (box.toSegments().some( segment => segment.contains(ip[0]) && segment.contains(ip[1]) )) {\r\n            denim.I2I = [];                         // case of touching\r\n            denim.I2B = [splitShapes[1]];\r\n            denim.I2E = [splitShapes[0], splitShapes[2]];\r\n\r\n            denim.E2I = [box];\r\n        }\r\n        else {                                       // case of intersection\r\n            denim.I2I = [splitShapes[1]];            // [segment(ip[0], ip[1])];\r\n            denim.I2B = ip_sorted;\r\n            denim.I2E = [splitShapes[0], splitShapes[2]];\r\n\r\n            denim.E2I = new Flatten.Polygon(box.toSegments()).cutWithLine(line);\r\n        }\r\n    }\r\n    return denim;\r\n}\r\n\r\nfunction relateLine2Polygon(line, polygon) {\r\n    let denim = new DE9IM();\r\n    let ip = intersectLine2Polygon(line, polygon);\r\n    let multiline = new Multiline$1([line]);\r\n    let ip_sorted = ip.length > 0 ? ip.slice() : line.sortPoints(ip);\r\n\r\n    multiline.split(ip_sorted);\r\n\r\n    [...multiline].forEach(edge => edge.setInclusion(polygon));\r\n\r\n    denim.I2I = [...multiline].filter(edge => edge.bv === Flatten.INSIDE).map(edge => edge.shape);\r\n    denim.I2B = [...multiline].slice(1).map( (edge) => edge.bv === Flatten.BOUNDARY ? edge.shape : edge.shape.start );\r\n    denim.I2E = [...multiline].filter(edge => edge.bv === Flatten.OUTSIDE).map(edge => edge.shape);\r\n\r\n    denim.E2I = polygon.cutWithLine(line);\r\n\r\n    return denim;\r\n}\r\n\r\nfunction relateShape2Polygon(shape, polygon) {\r\n    let denim = new DE9IM();\r\n    let ip = intersectShape2Polygon(shape, polygon);\r\n    let ip_sorted = ip.length > 0 ? ip.slice() : shape.sortPoints(ip);\r\n\r\n    let multiline = new Multiline$1([shape]);\r\n    multiline.split(ip_sorted);\r\n\r\n    [...multiline].forEach(edge => edge.setInclusion(polygon));\r\n\r\n    denim.I2I = [...multiline].filter(edge => edge.bv === Flatten.INSIDE).map(edge => edge.shape);\r\n    denim.I2B = [...multiline].slice(1).map( (edge) => edge.bv === Flatten.BOUNDARY ? edge.shape : edge.shape.start );\r\n    denim.I2E = [...multiline].filter(edge => edge.bv === Flatten.OUTSIDE).map(edge => edge.shape);\r\n\r\n\r\n    denim.B2I = [];\r\n    denim.B2B = [];\r\n    denim.B2E = [];\r\n    for (let pt of [shape.start, shape.end]) {\r\n        switch (ray_shoot(polygon, pt)) {\r\n            case Flatten.INSIDE:\r\n                denim.B2I.push(pt);\r\n                break;\r\n            case Flatten.BOUNDARY:\r\n                denim.B2B.push(pt);\r\n                break;\r\n            case Flatten.OUTSIDE:\r\n                denim.B2E.push(pt);\r\n                break;\r\n        }\r\n    }\r\n\r\n    // denim.E2I  TODO: calculate, not clear what is expected result\r\n\r\n    return denim;\r\n}\r\n\r\nfunction relatePolygon2Polygon(polygon1, polygon2) {\r\n    let denim = new DE9IM();\r\n\r\n    let [ip_sorted1, ip_sorted2] = calculateIntersections(polygon1, polygon2);\r\n    let boolean_intersection = intersect$1(polygon1, polygon2);\r\n    let boolean_difference1 = subtract(polygon1, polygon2);\r\n    let boolean_difference2 = subtract(polygon2, polygon1);\r\n    let [inner_clip_shapes1, inner_clip_shapes2] = innerClip(polygon1, polygon2);\r\n    let outer_clip_shapes1 = outerClip(polygon1, polygon2);\r\n    let outer_clip_shapes2 = outerClip(polygon2, polygon1);\r\n\r\n    denim.I2I = boolean_intersection.isEmpty() ? [] : [boolean_intersection];\r\n    denim.I2B = inner_clip_shapes2;\r\n    denim.I2E = boolean_difference1.isEmpty() ? [] : [boolean_difference1];\r\n\r\n    denim.B2I = inner_clip_shapes1;\r\n    denim.B2B = ip_sorted1;\r\n    denim.B2E = outer_clip_shapes1;\r\n\r\n    denim.E2I = boolean_difference2.isEmpty() ? [] : [boolean_difference2];\r\n    denim.E2B = outer_clip_shapes2;\r\n    // denim.E2E    not relevant meanwhile\r\n\r\n    return denim;\r\n}\r\n\r\nvar Relations = /*#__PURE__*/Object.freeze({\r\n    __proto__: null,\r\n    contain: contain,\r\n    cover: cover,\r\n    covered: covered,\r\n    disjoint: disjoint,\r\n    equal: equal,\r\n    inside: inside,\r\n    intersect: intersect,\r\n    relate: relate,\r\n    touch: touch\r\n});\r\n\r\n/**\r\n * Class representing an affine transformation 3x3 matrix:\r\n * <pre>\r\n *      [ a  c  tx\r\n * A =    b  d  ty\r\n *        0  0  1  ]\r\n * </pre\r\n * @type {Matrix}\r\n */\r\nclass Matrix {\r\n    /**\r\n     * Construct new instance of affine transformation matrix <br/>\r\n     * If parameters omitted, construct identity matrix a = 1, d = 1\r\n     * @param {number} a - position(0,0)   sx*cos(alpha)\r\n     * @param {number} b - position (0,1)  sx*sin(alpha)\r\n     * @param {number} c - position (1,0)  -sy*sin(alpha)\r\n     * @param {number} d - position (1,1)  sy*cos(alpha)\r\n     * @param {number} tx - position (2,0) translation by x\r\n     * @param {number} ty - position (2,1) translation by y\r\n     */\r\n    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\r\n        this.a = a;\r\n        this.b = b;\r\n        this.c = c;\r\n        this.d = d;\r\n        this.tx = tx;\r\n        this.ty = ty;\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of matrix\r\n     * @return {Matrix}\r\n     **/\r\n    clone() {\r\n        return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);\r\n    };\r\n\r\n    /**\r\n     * Transform vector [x,y] using transformation matrix. <br/>\r\n     * Vector [x,y] is an abstract array[2] of numbers and not a FlattenJS object <br/>\r\n     * The result is also an abstract vector [x',y'] = A * [x,y]:\r\n     * <code>\r\n     * [x'       [ ax + by + tx\r\n     *  y'   =     cx + dy + ty\r\n     *  1]                    1 ]\r\n     * </code>\r\n     * @param {number[]} vector - array[2] of numbers\r\n     * @returns {number[]} transformation result - array[2] of numbers\r\n     */\r\n    transform(vector) {\r\n        return [\r\n            vector[0] * this.a + vector[1] * this.c + this.tx,\r\n            vector[0] * this.b + vector[1] * this.d + this.ty\r\n        ]\r\n    };\r\n\r\n    /**\r\n     * Returns result of multiplication of this matrix by other matrix\r\n     * @param {Matrix} other_matrix - matrix to multiply by\r\n     * @returns {Matrix}\r\n     */\r\n    multiply(other_matrix) {\r\n        return new Matrix(\r\n            this.a * other_matrix.a + this.c * other_matrix.b,\r\n            this.b * other_matrix.a + this.d * other_matrix.b,\r\n            this.a * other_matrix.c + this.c * other_matrix.d,\r\n            this.b * other_matrix.c + this.d * other_matrix.d,\r\n            this.a * other_matrix.tx + this.c * other_matrix.ty + this.tx,\r\n            this.b * other_matrix.tx + this.d * other_matrix.ty + this.ty\r\n        )\r\n    };\r\n\r\n    /**\r\n     * Return new matrix as a result of multiplication of the current matrix\r\n     * by the matrix(1,0,0,1,tx,ty)\r\n     * @param {Vector} vector - Translation by vector or\r\n     * @param {number} tx - translation by x-axis\r\n     * @param {number} ty - translation by y-axis\r\n     * @returns {Matrix}\r\n     */\r\n    translate(...args) {\r\n        let tx, ty;\r\n        if (args.length == 1 &&  !isNaN(args[0].x) && !isNaN(args[0].y)) {\r\n            tx = args[0].x;\r\n            ty = args[0].y;\r\n        } else if (args.length === 2 && typeof (args[0]) == \"number\" && typeof (args[1]) == \"number\") {\r\n            tx = args[0];\r\n            ty = args[1];\r\n        } else {\r\n            throw Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n        return this.multiply(new Matrix(1, 0, 0, 1, tx, ty))\r\n    };\r\n\r\n    /**\r\n     * Return new matrix as a result of multiplication of the current matrix\r\n     * by the matrix that defines rotation by given angle (in radians) around\r\n     * center of rotation (centerX,centerY) in counterclockwise direction\r\n     * @param {number} angle - angle in radians\r\n     * @param {number} centerX - center of rotation\r\n     * @param {number} centerY - center of rotation\r\n     * @returns {Matrix}\r\n     */\r\n    rotate(angle, centerX = 0.0, centerY = 0.0) {\r\n        let cos = Math.cos(angle);\r\n        let sin = Math.sin(angle);\r\n        return this\r\n            .translate(centerX, centerY)\r\n            .multiply(new Matrix(cos, sin, -sin, cos, 0, 0))\r\n            .translate(-centerX, -centerY);\r\n    };\r\n\r\n    /**\r\n     * Return new matrix as a result of multiplication of the current matrix\r\n     * by the matrix (sx,0,0,sy,0,0) that defines scaling\r\n     * @param {number} sx\r\n     * @param {number} sy\r\n     * @returns {Matrix}\r\n     */\r\n    scale(sx, sy) {\r\n        return this.multiply(new Matrix(sx, 0, 0, sy, 0, 0));\r\n    };\r\n\r\n    /**\r\n     * Returns true if two matrix are equal parameter by parameter\r\n     * @param {Matrix} matrix - other matrix\r\n     * @returns {boolean} true if equal, false otherwise\r\n     */\r\n    equalTo(matrix) {\r\n        if (!Flatten.Utils.EQ(this.tx, matrix.tx)) return false;\r\n        if (!Flatten.Utils.EQ(this.ty, matrix.ty)) return false;\r\n        if (!Flatten.Utils.EQ(this.a, matrix.a)) return false;\r\n        if (!Flatten.Utils.EQ(this.b, matrix.b)) return false;\r\n        if (!Flatten.Utils.EQ(this.c, matrix.c)) return false;\r\n        if (!Flatten.Utils.EQ(this.d, matrix.d)) return false;\r\n        return true;\r\n    };\r\n}\r\nFlatten.Matrix = Matrix;\r\n/**\r\n * Function to create matrix equivalent to \"new\" constructor\r\n * @param args\r\n */\r\nconst matrix = (...args) => new Flatten.Matrix(...args);\r\nFlatten.matrix = matrix;\r\n\r\n/**\r\n * Created by Alex Bol on 4/1/2017.\r\n */\r\n\r\n/**\r\n * Interval is a pair of numbers or a pair of any comparable objects on which may be defined predicates\r\n * *equal*, *less* and method *max(p1, p1)* that returns maximum in a pair.\r\n * When interval is an object rather than pair of numbers, this object should have properties *low*, *high*, *max*\r\n * and implement methods *less_than(), equal_to(), intersect(), not_intersect(), clone(), output()*.\r\n * Two static methods *comparable_max(), comparable_less_than()* define how to compare values in pair. <br/>\r\n * This interface is described in typescript definition file *index.d.ts*\r\n *\r\n * Axis aligned rectangle is an example of such interval.\r\n * We may look at rectangle as an interval between its low left and top right corners.\r\n * See **Box** class in [flatten-js](https://github.com/alexbol99/flatten-js) library as the example\r\n * of Interval interface implementation\r\n * @type {Interval}\r\n */\r\nconst Interval = class Interval {\r\n    /**\r\n     * Accept two comparable values and creates new instance of interval\r\n     * Predicate Interval.comparable_less(low, high) supposed to return true on these values\r\n     * @param low\r\n     * @param high\r\n     */\r\n    constructor(low, high) {\r\n        this.low = low;\r\n        this.high = high;\r\n    }\r\n\r\n    /**\r\n     * Clone interval\r\n     * @returns {Interval}\r\n     */\r\n    clone() {\r\n        return new Interval(this.low, this.high);\r\n    }\r\n\r\n    /**\r\n     * Propery max returns clone of this interval\r\n     * @returns {Interval}\r\n     */\r\n    get max() {\r\n        return this.clone();   // this.high;\r\n    }\r\n\r\n    /**\r\n     * Predicate returns true is this interval less than other interval\r\n     * @param other_interval\r\n     * @returns {boolean}\r\n     */\r\n    less_than(other_interval) {\r\n        return this.low < other_interval.low ||\r\n            this.low == other_interval.low && this.high < other_interval.high;\r\n    }\r\n\r\n    /**\r\n     * Predicate returns true is this interval equals to other interval\r\n     * @param other_interval\r\n     * @returns {boolean}\r\n     */\r\n    equal_to(other_interval) {\r\n        return this.low == other_interval.low && this.high == other_interval.high;\r\n    }\r\n\r\n    /**\r\n     * Predicate returns true if this interval intersects other interval\r\n     * @param other_interval\r\n     * @returns {boolean}\r\n     */\r\n    intersect(other_interval) {\r\n        return !this.not_intersect(other_interval);\r\n    }\r\n\r\n    /**\r\n     * Predicate returns true if this interval does not intersect other interval\r\n     * @param other_interval\r\n     * @returns {boolean}\r\n     */\r\n    not_intersect(other_interval) {\r\n        return (this.high < other_interval.low || other_interval.high < this.low);\r\n    }\r\n\r\n    /**\r\n     * Returns new interval merged with other interval\r\n     * @param {Interval} interval - Other interval to merge with\r\n     * @returns {Interval}\r\n     */\r\n    merge(other_interval) {\r\n        return new Interval(\r\n            this.low === undefined ? other_interval.low : Math.min(this.low, other_interval.low),\r\n            this.high === undefined ? other_interval.high : Math.max(this.high, other_interval.high)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns how key should return\r\n     */\r\n    output() {\r\n        return [this.low, this.high];\r\n    }\r\n\r\n    /**\r\n     * Function returns maximum between two comparable values\r\n     * @param interval1\r\n     * @param interval2\r\n     * @returns {Interval}\r\n     */\r\n    static comparable_max(interval1, interval2) {\r\n        return interval1.merge(interval2);\r\n    }\r\n\r\n    /**\r\n     * Predicate returns true if first value less than second value\r\n     * @param val1\r\n     * @param val2\r\n     * @returns {boolean}\r\n     */\r\n    static comparable_less_than(val1, val2 ) {\r\n        return val1 < val2;\r\n    }\r\n};\r\n\r\n/**\r\n * Created by Alex Bol on 3/28/2017.\r\n */\r\n\r\n\r\n// module.exports = {\r\n//     RB_TREE_COLOR_RED: 0,\r\n//     RB_TREE_COLOR_BLACK: 1\r\n// };\r\n\r\nconst RB_TREE_COLOR_RED = 0;\r\nconst RB_TREE_COLOR_BLACK = 1;\r\n\r\n/**\r\n * Created by Alex Bol on 4/1/2017.\r\n */\r\n\r\n\r\nclass Node {\r\n    constructor(key = undefined, value = undefined,\r\n                left = null, right = null, parent = null, color = RB_TREE_COLOR_BLACK) {\r\n        this.left = left;                     // reference to left child node\r\n        this.right = right;                   // reference to right child node\r\n        this.parent = parent;                 // reference to parent node\r\n        this.color = color;\r\n\r\n        this.item = {key: key, value: value};   // key is supposed to be instance of Interval\r\n\r\n        /* If not, this should by an array of two numbers */\r\n        if (key && key instanceof Array && key.length == 2) {\r\n            if (!Number.isNaN(key[0]) && !Number.isNaN(key[1])) {\r\n                this.item.key = new Interval(Math.min(key[0], key[1]), Math.max(key[0], key[1]));\r\n            }\r\n        }\r\n\r\n        this.max = this.item.key ? this.item.key.max : undefined;\r\n    }\r\n\r\n    isNil() {\r\n        return (this.item.key === undefined && this.item.value === undefined &&\r\n            this.left === null && this.right === null && this.color === RB_TREE_COLOR_BLACK);\r\n    }\r\n\r\n    _value_less_than(other_node) {\r\n        return this.item.value && other_node.item.value && this.item.value.less_than ?\r\n            this.item.value.less_than(other_node.item.value) :\r\n            this.item.value < other_node.item.value;\r\n    }\r\n\r\n    less_than(other_node) {\r\n        // if tree stores only keys\r\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\r\n            return this.item.key.less_than(other_node.item.key);\r\n        }\r\n        else {    // if tree stores keys and values\r\n            return this.item.key.less_than(other_node.item.key) ||\r\n                this.item.key.equal_to((other_node.item.key)) && this._value_less_than(other_node)\r\n        }\r\n    }\r\n\r\n    _value_equal(other_node) {\r\n        return this.item.value && other_node.item.value && this.item.value.equal_to ?\r\n            this.item.value.equal_to(other_node.item.value) :\r\n            this.item.value == other_node.item.value;\r\n    }\r\n    equal_to(other_node) {\r\n        // if tree stores only keys\r\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\r\n            return this.item.key.equal_to(other_node.item.key);\r\n        }\r\n        else {    // if tree stores keys and values\r\n            return this.item.key.equal_to(other_node.item.key) && this._value_equal(other_node);\r\n        }\r\n    }\r\n\r\n    intersect(other_node) {\r\n        return this.item.key.intersect(other_node.item.key);\r\n    }\r\n\r\n    copy_data(other_node) {\r\n        this.item.key = other_node.item.key;\r\n        this.item.value = other_node.item.value;\r\n    }\r\n\r\n    update_max() {\r\n        // use key (Interval) max property instead of key.high\r\n        this.max = this.item.key ? this.item.key.max : undefined;\r\n        if (this.right && this.right.max) {\r\n            const comparable_max = this.item.key.constructor.comparable_max;  // static method\r\n            this.max = comparable_max(this.max, this.right.max);\r\n        }\r\n        if (this.left && this.left.max) {\r\n            const comparable_max = this.item.key.constructor.comparable_max;  // static method\r\n            this.max = comparable_max(this.max, this.left.max);\r\n        }\r\n    }\r\n\r\n    // Other_node does not intersect any node of left subtree, if this.left.max < other_node.item.key.low\r\n    not_intersect_left_subtree(search_node) {\r\n        const comparable_less_than = this.item.key.constructor.comparable_less_than;  // static method\r\n        let high = this.left.max.high !== undefined ? this.left.max.high : this.left.max;\r\n        return comparable_less_than(high, search_node.item.key.low);\r\n    }\r\n\r\n    // Other_node does not intersect right subtree if other_node.item.key.high < this.right.key.low\r\n    not_intersect_right_subtree(search_node) {\r\n        const comparable_less_than = this.item.key.constructor.comparable_less_than;  // static method\r\n        let low = this.right.max.low !== undefined ? this.right.max.low : this.right.item.key.low;\r\n        return comparable_less_than(search_node.item.key.high, low);\r\n    }\r\n}\r\n\r\n/**\r\n * Created by Alex Bol on 3/31/2017.\r\n */\r\n\r\n// const nil_node = new Node();\r\n\r\n/**\r\n * Implementation of interval binary search tree <br/>\r\n * Interval tree stores items which are couples of {key:interval, value: value} <br/>\r\n * Interval is an object with high and low properties or simply pair [low,high] of numeric values <br />\r\n * @type {IntervalTree}\r\n */\r\nclass IntervalTree {\r\n    /**\r\n     * Construct new empty instance of IntervalTree\r\n     */\r\n    constructor() {\r\n        this.root = null;\r\n        this.nil_node = new Node();\r\n    }\r\n\r\n    /**\r\n     * Returns number of items stored in the interval tree\r\n     * @returns {number}\r\n     */\r\n    get size() {\r\n        let count = 0;\r\n        this.tree_walk(this.root, () => count++);\r\n        return count;\r\n    }\r\n\r\n    /**\r\n     * Returns array of sorted keys in the ascending order\r\n     * @returns {Array}\r\n     */\r\n    get keys() {\r\n        let res = [];\r\n        this.tree_walk(this.root, (node) => res.push(\r\n            node.item.key.output ? node.item.key.output() : node.item.key\r\n        ));\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Return array of values in the ascending keys order\r\n     * @returns {Array}\r\n     */\r\n    get values() {\r\n        let res = [];\r\n        this.tree_walk(this.root, (node) => res.push(node.item.value));\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Returns array of items (<key,value> pairs) in the ascended keys order\r\n     * @returns {Array}\r\n     */\r\n    get items() {\r\n        let res = [];\r\n        this.tree_walk(this.root, (node) => res.push({\r\n            key: node.item.key.output ? node.item.key.output() : node.item.key,\r\n            value: node.item.value\r\n        }));\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Returns true if tree is empty\r\n     * @returns {boolean}\r\n     */\r\n    isEmpty() {\r\n        return (this.root == null || this.root == this.nil_node);\r\n    }\r\n\r\n    /**\r\n     * Clear tree\r\n     */\r\n    clear() {\r\n        this.root = null;\r\n    }\r\n\r\n    /**\r\n     * Insert new item into interval tree\r\n     * @param {Interval} key - interval object or array of two numbers [low, high]\r\n     * @param {any} value - value representing any object (optional)\r\n     * @returns {Node} returns reference to inserted node as an object {key:interval, value: value}\r\n     */\r\n    insert(key, value = key) {\r\n        if (key === undefined) return;\r\n        let insert_node = new Node(key, value, this.nil_node, this.nil_node, null, RB_TREE_COLOR_RED);\r\n        this.tree_insert(insert_node);\r\n        this.recalc_max(insert_node);\r\n        return insert_node;\r\n    }\r\n\r\n    /**\r\n     * Returns true if item {key,value} exist in the tree\r\n     * @param {Interval} key - interval correspondent to keys stored in the tree\r\n     * @param {any} value - value object to be checked\r\n     * @returns {boolean} true if item {key, value} exist in the tree, false otherwise\r\n     */\r\n    exist(key, value = key) {\r\n        let search_node = new Node(key, value);\r\n        return this.tree_search(this.root, search_node) ? true : false;\r\n    }\r\n\r\n    /**\r\n     * Remove entry {key, value} from the tree\r\n     * @param {Interval} key - interval correspondent to keys stored in the tree\r\n     * @param {any} value - value object\r\n     * @returns {boolean} true if item {key, value} deleted, false if not found\r\n     */\r\n    remove(key, value = key) {\r\n        let search_node = new Node(key, value);\r\n        let delete_node = this.tree_search(this.root, search_node);\r\n        if (delete_node) {\r\n            this.tree_delete(delete_node);\r\n        }\r\n        return delete_node;\r\n    }\r\n\r\n    /**\r\n     * Returns array of entry values which keys intersect with given interval <br/>\r\n     * If no values stored in the tree, returns array of keys which intersect given interval\r\n     * @param {Interval} interval - search interval, or tuple [low, high]\r\n     * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output\r\n     * @returns {Array}\r\n     */\r\n    search(interval, outputMapperFn = (value, key) => value === key ? key.output() : value) {\r\n        let search_node = new Node(interval);\r\n        let resp_nodes = [];\r\n        this.tree_search_interval(this.root, search_node, resp_nodes);\r\n        return resp_nodes.map(node => outputMapperFn(node.item.value, node.item.key))\r\n    }\r\n\r\n    /**\r\n     * Returns true if intersection between given and any interval stored in the tree found\r\n     * @param {Interval} interval - search interval or tuple [low, high]\r\n     * @returns {boolean}\r\n     */\r\n    intersect_any(interval) {\r\n        let search_node = new Node(interval);\r\n        let found = this.tree_find_any_interval(this.root, search_node);\r\n        return found;\r\n    }\r\n\r\n    /**\r\n     * Tree visitor. For each node implement a callback function. <br/>\r\n     * Method calls a callback function with two parameters (key, value)\r\n     * @param visitor(key,value) - function to be called for each tree item\r\n     */\r\n    forEach(visitor) {\r\n        this.tree_walk(this.root, (node) => visitor(node.item.key, node.item.value));\r\n    }\r\n\r\n    /** Value Mapper. Walk through every node and map node value to another value\r\n    * @param callback(value,key) - function to be called for each tree item\r\n    */\r\n    map(callback) {\r\n        const tree = new IntervalTree();\r\n        this.tree_walk(this.root, (node) => tree.insert(node.item.key, callback(node.item.value, node.item.key)));\r\n        return tree;\r\n    }\r\n\r\n    recalc_max(node) {\r\n        let node_current = node;\r\n        while (node_current.parent != null) {\r\n            node_current.parent.update_max();\r\n            node_current = node_current.parent;\r\n        }\r\n    }\r\n\r\n    tree_insert(insert_node) {\r\n        let current_node = this.root;\r\n        let parent_node = null;\r\n\r\n        if (this.root == null || this.root == this.nil_node) {\r\n            this.root = insert_node;\r\n        }\r\n        else {\r\n            while (current_node != this.nil_node) {\r\n                parent_node = current_node;\r\n                if (insert_node.less_than(current_node)) {\r\n                    current_node = current_node.left;\r\n                }\r\n                else {\r\n                    current_node = current_node.right;\r\n                }\r\n            }\r\n\r\n            insert_node.parent = parent_node;\r\n\r\n            if (insert_node.less_than(parent_node)) {\r\n                parent_node.left = insert_node;\r\n            }\r\n            else {\r\n                parent_node.right = insert_node;\r\n            }\r\n        }\r\n\r\n        this.insert_fixup(insert_node);\r\n    }\r\n\r\n// After insertion insert_node may have red-colored parent, and this is a single possible violation\r\n// Go upwords to the root and re-color until violation will be resolved\r\n    insert_fixup(insert_node) {\r\n        let current_node;\r\n        let uncle_node;\r\n\r\n        current_node = insert_node;\r\n        while (current_node != this.root && current_node.parent.color == RB_TREE_COLOR_RED) {\r\n            if (current_node.parent == current_node.parent.parent.left) {   // parent is left child of grandfather\r\n                uncle_node = current_node.parent.parent.right;              // right brother of parent\r\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 1. Uncle is red\r\n                    // re-color father and uncle into black\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    current_node = current_node.parent.parent;\r\n                }\r\n                else {                                                    // Case 2 & 3. Uncle is black\r\n                    if (current_node == current_node.parent.right) {     // Case 2. Current if right child\r\n                        // This case is transformed into Case 3.\r\n                        current_node = current_node.parent;\r\n                        this.rotate_left(current_node);\r\n                    }\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 3. Current is left child.\r\n                    // Re-color father and grandfather, rotate grandfather right\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    this.rotate_right(current_node.parent.parent);\r\n                }\r\n            }\r\n            else {                                                         // parent is right child of grandfather\r\n                uncle_node = current_node.parent.parent.left;              // left brother of parent\r\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 4. Uncle is red\r\n                    // re-color father and uncle into black\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    current_node = current_node.parent.parent;\r\n                }\r\n                else {\r\n                    if (current_node == current_node.parent.left) {             // Case 5. Current is left child\r\n                        // Transform into case 6\r\n                        current_node = current_node.parent;\r\n                        this.rotate_right(current_node);\r\n                    }\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 6. Current is right child.\r\n                    // Re-color father and grandfather, rotate grandfather left\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    this.rotate_left(current_node.parent.parent);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.root.color = RB_TREE_COLOR_BLACK;\r\n    }\r\n\r\n    tree_delete(delete_node) {\r\n        let cut_node;   // node to be cut - either delete_node or successor_node  (\"y\" from 14.4)\r\n        let fix_node;   // node to fix rb tree property   (\"x\" from 14.4)\r\n\r\n        if (delete_node.left == this.nil_node || delete_node.right == this.nil_node) {  // delete_node has less then 2 children\r\n            cut_node = delete_node;\r\n        }\r\n        else {                                                    // delete_node has 2 children\r\n            cut_node = this.tree_successor(delete_node);\r\n        }\r\n\r\n        // fix_node if single child of cut_node\r\n        if (cut_node.left != this.nil_node) {\r\n            fix_node = cut_node.left;\r\n        }\r\n        else {\r\n            fix_node = cut_node.right;\r\n        }\r\n\r\n        // remove cut_node from parent\r\n        /*if (fix_node != this.nil_node) {*/\r\n            fix_node.parent = cut_node.parent;\r\n        /*}*/\r\n\r\n        if (cut_node == this.root) {\r\n            this.root = fix_node;\r\n        }\r\n        else {\r\n            if (cut_node == cut_node.parent.left) {\r\n                cut_node.parent.left = fix_node;\r\n            }\r\n            else {\r\n                cut_node.parent.right = fix_node;\r\n            }\r\n            cut_node.parent.update_max();        // update max property of the parent\r\n        }\r\n\r\n        this.recalc_max(fix_node);              // update max property upward from fix_node to root\r\n\r\n        // COPY DATA !!!\r\n        // Delete_node becomes cut_node, it means that we cannot hold reference\r\n        // to node in outer structure and we will have to delete by key, additional search need\r\n        if (cut_node != delete_node) {\r\n            delete_node.copy_data(cut_node);\r\n            delete_node.update_max();           // update max property of the cut node at the new place\r\n            this.recalc_max(delete_node);       // update max property upward from delete_node to root\r\n        }\r\n\r\n        if (/*fix_node != this.nil_node && */cut_node.color == RB_TREE_COLOR_BLACK) {\r\n            this.delete_fixup(fix_node);\r\n        }\r\n    }\r\n\r\n    delete_fixup(fix_node) {\r\n        let current_node = fix_node;\r\n        let brother_node;\r\n\r\n        while (current_node != this.root && current_node.parent != null && current_node.color == RB_TREE_COLOR_BLACK) {\r\n            if (current_node == current_node.parent.left) {          // fix node is left child\r\n                brother_node = current_node.parent.right;\r\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\r\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\r\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\r\n                    this.rotate_left(current_node.parent);\r\n                    brother_node = current_node.parent.right;                      // update brother\r\n                }\r\n                // Derive to cases 2..4: brother is black\r\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\r\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {  // case 2: both nephews black\r\n                    brother_node.color = RB_TREE_COLOR_RED;              // re-color brother\r\n                    current_node = current_node.parent;                  // continue iteration\r\n                }\r\n                else {\r\n                    if (brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 3: left nephew red, right nephew black\r\n                        brother_node.color = RB_TREE_COLOR_RED;          // re-color brother\r\n                        brother_node.left.color = RB_TREE_COLOR_BLACK;   // re-color nephew\r\n                        this.rotate_right(brother_node);\r\n                        brother_node = current_node.parent.right;                     // update brother\r\n                        // Derive to case 4: left nephew black, right nephew red\r\n                    }\r\n                    // case 4: left nephew black, right nephew red\r\n                    brother_node.color = current_node.parent.color;\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    brother_node.right.color = RB_TREE_COLOR_BLACK;\r\n                    this.rotate_left(current_node.parent);\r\n                    current_node = this.root;                         // exit from loop\r\n                }\r\n            }\r\n            else {                                             // fix node is right child\r\n                brother_node = current_node.parent.left;\r\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\r\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\r\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\r\n                    this.rotate_right(current_node.parent);\r\n                    brother_node = current_node.parent.left;                        // update brother\r\n                }\r\n                // Go to cases 2..4\r\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\r\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 2\r\n                    brother_node.color = RB_TREE_COLOR_RED;             // re-color brother\r\n                    current_node = current_node.parent;                              // continue iteration\r\n                }\r\n                else {\r\n                    if (brother_node.left.color == RB_TREE_COLOR_BLACK) {  // case 3: right nephew red, left nephew black\r\n                        brother_node.color = RB_TREE_COLOR_RED;            // re-color brother\r\n                        brother_node.right.color = RB_TREE_COLOR_BLACK;    // re-color nephew\r\n                        this.rotate_left(brother_node);\r\n                        brother_node = current_node.parent.left;                        // update brother\r\n                        // Derive to case 4: right nephew black, left nephew red\r\n                    }\r\n                    // case 4: right nephew black, left nephew red\r\n                    brother_node.color = current_node.parent.color;\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    brother_node.left.color = RB_TREE_COLOR_BLACK;\r\n                    this.rotate_right(current_node.parent);\r\n                    current_node = this.root;                               // force exit from loop\r\n                }\r\n            }\r\n        }\r\n\r\n        current_node.color = RB_TREE_COLOR_BLACK;\r\n    }\r\n\r\n    tree_search(node, search_node) {\r\n        if (node == null || node == this.nil_node)\r\n            return undefined;\r\n\r\n        if (search_node.equal_to(node)) {\r\n            return node;\r\n        }\r\n        if (search_node.less_than(node)) {\r\n            return this.tree_search(node.left, search_node);\r\n        }\r\n        else {\r\n            return this.tree_search(node.right, search_node);\r\n        }\r\n    }\r\n\r\n    // Original search_interval method; container res support push() insertion\r\n    // Search all intervals intersecting given one\r\n    tree_search_interval(node, search_node, res) {\r\n        if (node != null && node != this.nil_node) {\r\n            // if (node->left != this.nil_node && node->left->max >= low) {\r\n            if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) {\r\n                this.tree_search_interval(node.left, search_node, res);\r\n            }\r\n            // if (low <= node->high && node->low <= high) {\r\n            if (node.intersect(search_node)) {\r\n                res.push(node);\r\n            }\r\n            // if (node->right != this.nil_node && node->low <= high) {\r\n            if (node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) {\r\n                this.tree_search_interval(node.right, search_node, res);\r\n            }\r\n        }\r\n    }\r\n\r\n    tree_find_any_interval(node, search_node) {\r\n        let found = false;\r\n        if (node != null && node != this.nil_node) {\r\n            // if (node->left != this.nil_node && node->left->max >= low) {\r\n            if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) {\r\n                found = this.tree_find_any_interval(node.left, search_node);\r\n            }\r\n            // if (low <= node->high && node->low <= high) {\r\n            if (!found) {\r\n                found = node.intersect(search_node);\r\n            }\r\n            // if (node->right != this.nil_node && node->low <= high) {\r\n            if (!found && node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) {\r\n                found = this.tree_find_any_interval(node.right, search_node);\r\n            }\r\n        }\r\n        return found;\r\n    }\r\n\r\n    local_minimum(node) {\r\n        let node_min = node;\r\n        while (node_min.left != null && node_min.left != this.nil_node) {\r\n            node_min = node_min.left;\r\n        }\r\n        return node_min;\r\n    }\r\n\r\n    // not in use\r\n    local_maximum(node) {\r\n        let node_max = node;\r\n        while (node_max.right != null && node_max.right != this.nil_node) {\r\n            node_max = node_max.right;\r\n        }\r\n        return node_max;\r\n    }\r\n\r\n    tree_successor(node) {\r\n        let node_successor;\r\n        let current_node;\r\n        let parent_node;\r\n\r\n        if (node.right != this.nil_node) {\r\n            node_successor = this.local_minimum(node.right);\r\n        }\r\n        else {\r\n            current_node = node;\r\n            parent_node = node.parent;\r\n            while (parent_node != null && parent_node.right == current_node) {\r\n                current_node = parent_node;\r\n                parent_node = parent_node.parent;\r\n            }\r\n            node_successor = parent_node;\r\n        }\r\n        return node_successor;\r\n    }\r\n\r\n    //           |            right-rotate(T,y)       |\r\n    //           y            ---------------.       x\r\n    //          / \\                                  / \\\r\n    //         x   c          left-rotate(T,x)      a   y\r\n    //        / \\             <---------------         / \\\r\n    //       a   b                                    b   c\r\n\r\n    rotate_left(x) {\r\n        let y = x.right;\r\n\r\n        x.right = y.left;           // b goes to x.right\r\n\r\n        if (y.left != this.nil_node) {\r\n            y.left.parent = x;     // x becomes parent of b\r\n        }\r\n        y.parent = x.parent;       // move parent\r\n\r\n        if (x == this.root) {\r\n            this.root = y;           // y becomes root\r\n        }\r\n        else {                        // y becomes child of x.parent\r\n            if (x == x.parent.left) {\r\n                x.parent.left = y;\r\n            }\r\n            else {\r\n                x.parent.right = y;\r\n            }\r\n        }\r\n        y.left = x;                 // x becomes left child of y\r\n        x.parent = y;               // and y becomes parent of x\r\n\r\n        if (x != null && x != this.nil_node) {\r\n            x.update_max();\r\n        }\r\n\r\n        y = x.parent;\r\n        if (y != null && y != this.nil_node) {\r\n            y.update_max();\r\n        }\r\n    }\r\n\r\n    rotate_right(y) {\r\n        let x = y.left;\r\n\r\n        y.left = x.right;           // b goes to y.left\r\n\r\n        if (x.right != this.nil_node) {\r\n            x.right.parent = y;        // y becomes parent of b\r\n        }\r\n        x.parent = y.parent;          // move parent\r\n\r\n        if (y == this.root) {        // x becomes root\r\n            this.root = x;\r\n        }\r\n        else {                        // y becomes child of x.parent\r\n            if (y == y.parent.left) {\r\n                y.parent.left = x;\r\n            }\r\n            else {\r\n                y.parent.right = x;\r\n            }\r\n        }\r\n        x.right = y;                 // y becomes right child of x\r\n        y.parent = x;               // and x becomes parent of y\r\n\r\n        if (y != null && y != this.nil_node) {\r\n            y.update_max();\r\n        }\r\n\r\n        x = y.parent;\r\n        if (x != null && x != this.nil_node) {\r\n            x.update_max();\r\n        }\r\n    }\r\n\r\n    tree_walk(node, action) {\r\n        if (node != null && node != this.nil_node) {\r\n            this.tree_walk(node.left, action);\r\n            // arr.push(node.toArray());\r\n            action(node);\r\n            this.tree_walk(node.right, action);\r\n        }\r\n    }\r\n\r\n    /* Return true if all red nodes have exactly two black child nodes */\r\n    testRedBlackProperty() {\r\n        let res = true;\r\n        this.tree_walk(this.root, function (node) {\r\n            if (node.color == RB_TREE_COLOR_RED) {\r\n                if (!(node.left.color == RB_TREE_COLOR_BLACK && node.right.color == RB_TREE_COLOR_BLACK)) {\r\n                    res = false;\r\n                }\r\n            }\r\n        });\r\n        return res;\r\n    }\r\n\r\n    /* Throw error if not every path from root to bottom has same black height */\r\n    testBlackHeightProperty(node) {\r\n        let height = 0;\r\n        let heightLeft = 0;\r\n        let heightRight = 0;\r\n        if (node.color == RB_TREE_COLOR_BLACK) {\r\n            height++;\r\n        }\r\n        if (node.left != this.nil_node) {\r\n            heightLeft = this.testBlackHeightProperty(node.left);\r\n        }\r\n        else {\r\n            heightLeft = 1;\r\n        }\r\n        if (node.right != this.nil_node) {\r\n            heightRight = this.testBlackHeightProperty(node.right);\r\n        }\r\n        else {\r\n            heightRight = 1;\r\n        }\r\n        if (heightLeft != heightRight) {\r\n            throw new Error('Red-black height property violated');\r\n        }\r\n        height += heightLeft;\r\n        return height;\r\n    };\r\n}\r\n\r\n/**\r\n * Created by Alex Bol on 3/12/2017.\r\n */\r\n\r\n\r\n/**\r\n * Class representing a planar set - a generic container with ability to keep and retrieve shapes and\r\n * perform spatial queries. Planar set is an extension of Set container, so it supports\r\n * Set properties and methods\r\n */\r\nclass PlanarSet extends Set {\r\n    /**\r\n     * Create new instance of PlanarSet\r\n     * @param shapes - array or set of geometric objects to store in planar set\r\n     * Each object should have a <b>box</b> property\r\n     */\r\n    constructor(shapes) {\r\n        super(shapes);\r\n        this.index = new IntervalTree();\r\n        this.forEach(shape => this.index.insert(shape));\r\n    }\r\n\r\n    /**\r\n     * Add new shape to planar set and to its spatial index.<br/>\r\n     * If shape already exist, it will not be added again.\r\n     * This happens with no error, it is possible to use <i>size</i> property to check if\r\n     * a shape was actually added.<br/>\r\n     * Method returns planar set object updated and may be chained\r\n     * @param {AnyShape | {Box, AnyShape}} entry - shape to be added, should have valid <i>box</i> property\r\n     * Another option to transfer as an object {key: Box, value: AnyShape}\r\n     * @returns {PlanarSet}\r\n     */\r\n    add(entry) {\r\n        let size = this.size;\r\n        const {key, value} = entry;\r\n        const box = key || entry.box;\r\n        const shape = value || entry;\r\n        super.add(shape);\r\n        // size not changed - item not added, probably trying to add same item twice\r\n        if (this.size > size) {\r\n            this.index.insert(box, shape);\r\n        }\r\n        return this;         // in accordance to Set.add interface\r\n    }\r\n\r\n    /**\r\n     * Delete shape from planar set. Returns true if shape was actually deleted, false otherwise\r\n     * @param {AnyShape | {Box, AnyShape}} entry - shape to be deleted\r\n     * @returns {boolean}\r\n     */\r\n    delete(entry) {\r\n        const {key, value} = entry;\r\n        const box = key || entry.box;\r\n        const shape = value || entry;\r\n        let deleted = super.delete(shape);\r\n        if (deleted) {\r\n            this.index.remove(box, shape);\r\n        }\r\n        return deleted;\r\n    }\r\n\r\n    /**\r\n     * Clear planar set\r\n     */\r\n    clear() {\r\n        super.clear();\r\n        this.index = new IntervalTree();\r\n    }\r\n\r\n    /**\r\n     * 2d range search in planar set.<br/>\r\n     * Returns array of all shapes in planar set which bounding box is intersected with query box\r\n     * @param {Box} box - query box\r\n     * @returns {AnyShape[]}\r\n     */\r\n    search(box) {\r\n        let resp = this.index.search(box);\r\n        return resp;\r\n    }\r\n\r\n    /**\r\n     * Point location test. Returns array of shapes which contains given point\r\n     * @param {Point} point - query point\r\n     * @returns {AnyShape[]}\r\n     */\r\n    hit(point) {\r\n        let box = new Flatten.Box(point.x - 1, point.y - 1, point.x + 1, point.y + 1);\r\n        let resp = this.index.search(box);\r\n        return resp.filter((shape) => point.on(shape));\r\n    }\r\n\r\n    /**\r\n     * Returns svg string to draw all shapes in planar set\r\n     * @returns {String}\r\n     */\r\n    svg() {\r\n        let svgcontent = [...this].reduce((acc, shape) => acc + shape.svg(), \"\");\r\n        return svgcontent;\r\n    }\r\n}\r\n\r\nFlatten.PlanarSet = PlanarSet;\r\n\r\n/**\r\n * Base class representing shape\r\n * Implement common methods of affine transformations\r\n */\r\nclass Shape {\r\n    get name() {\r\n        throw(Errors.CANNOT_INVOKE_ABSTRACT_METHOD);\r\n    }\r\n\r\n    get box() {\r\n        throw(Errors.CANNOT_INVOKE_ABSTRACT_METHOD);\r\n    }\r\n\r\n    clone() {\r\n        throw(Errors.CANNOT_INVOKE_ABSTRACT_METHOD);\r\n    }\r\n\r\n    /**\r\n     * Returns new shape translated by given vector.\r\n     * Translation vector may be also defined by a pair of numbers.\r\n     * @param {Vector | (number, number) } args - Translation vector\r\n     * or tuple of numbers\r\n     * @returns {Shape}\r\n     */\r\n    translate(...args) {\r\n        return this.transform(new Matrix().translate(...args))\r\n    }\r\n\r\n    /**\r\n     * Returns new shape rotated by given angle around given center point.\r\n     * If center point is omitted, rotates around zero point (0,0).\r\n     * Positive value of angle defines rotation in counterclockwise direction,\r\n     * negative angle defines rotation in clockwise direction\r\n     * @param {number} angle - angle in radians\r\n     * @param {Point} [center=(0,0)] center\r\n     * @returns {Shape}\r\n     */\r\n    rotate(angle, center = new Flatten.Point()) {\r\n        return this.transform(new Matrix().rotate(angle, center.x, center.y));\r\n    }\r\n\r\n    /**\r\n     * Return new shape with coordinates multiplied by scaling factor\r\n     * @param {number} sx - x-axis scaling factor\r\n     * @param {number} sy - y-axis scaling factor\r\n     * @returns {Shape}\r\n     */\r\n    scale(sx, sy) {\r\n        return this.transform(new Matrix().scale(sx, sy));\r\n    }\r\n\r\n    transform(...args) {\r\n        throw(Errors.CANNOT_INVOKE_ABSTRACT_METHOD);\r\n    }\r\n\r\n    /**\r\n     * This method returns an object that defines how data will be\r\n     * serialized when called JSON.stringify() method\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n        return Object.assign({}, this, {name: this.name});\r\n    }\r\n\r\n    svg(attrs = {}) {\r\n        throw(Errors.CANNOT_INVOKE_ABSTRACT_METHOD);\r\n    }\r\n}\r\n\r\n/**\r\n * Created by Alex Bol on 2/18/2017.\r\n */\r\n\r\n\r\n/**\r\n *\r\n * Class representing a point\r\n * @type {Point}\r\n */\r\nlet Point$3 = class Point extends Shape {\r\n    /**\r\n     * Point may be constructed by two numbers, or by array of two numbers\r\n     * @param {number} x - x-coordinate (float number)\r\n     * @param {number} y - y-coordinate (float number)\r\n     */\r\n    constructor(...args) {\r\n        super();\r\n        /**\r\n         * x-coordinate (float number)\r\n         * @type {number}\r\n         */\r\n        this.x = 0;\r\n        /**\r\n         * y-coordinate (float number)\r\n         * @type {number}\r\n         */\r\n        this.y = 0;\r\n\r\n        if (args.length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (args.length === 1 && args[0] instanceof Array && args[0].length === 2) {\r\n            let arr = args[0];\r\n            if (typeof (arr[0]) == \"number\" && typeof (arr[1]) == \"number\") {\r\n                this.x = arr[0];\r\n                this.y = arr[1];\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"point\") {\r\n            let {x, y} = args[0];\r\n            this.x = x;\r\n            this.y = y;\r\n            return;\r\n        }\r\n\r\n        if (args.length === 2) {\r\n            if (typeof (args[0]) == \"number\" && typeof (args[1]) == \"number\") {\r\n                this.x = args[0];\r\n                this.y = args[1];\r\n                return;\r\n            }\r\n        }\r\n        throw Errors.ILLEGAL_PARAMETERS;\r\n    }\r\n\r\n    /**\r\n     * Returns bounding box of a point\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        return new Flatten.Box(this.x, this.y, this.x, this.y);\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of point\r\n     * @returns {Point}\r\n     */\r\n    clone() {\r\n        return new Flatten.Point(this.x, this.y);\r\n    }\r\n\r\n    get vertices() {\r\n        return [this.clone()];\r\n    }\r\n\r\n    /**\r\n     * Returns true if points are equal up to [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\r\n     * @param {Point} pt Query point\r\n     * @returns {boolean}\r\n     */\r\n    equalTo(pt) {\r\n        return Flatten.Utils.EQ(this.x, pt.x) && Flatten.Utils.EQ(this.y, pt.y);\r\n    }\r\n\r\n    /**\r\n     * Defines predicate \"less than\" between points. Returns true if the point is less than query points, false otherwise <br/>\r\n     * By definition point1 < point2 if {point1.y < point2.y || point1.y == point2.y && point1.x < point2.x <br/>\r\n     * Numeric values compared with [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\r\n     * @param {Point} pt Query point\r\n     * @returns {boolean}\r\n     */\r\n    lessThan(pt) {\r\n        if (Flatten.Utils.LT(this.y, pt.y))\r\n            return true;\r\n        if (Flatten.Utils.EQ(this.y, pt.y) && Flatten.Utils.LT(this.x, pt.x))\r\n            return true;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Return new point transformed by affine transformation matrix\r\n     * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\r\n     * @returns {Point}\r\n     */\r\n    transform(m) {\r\n        return new Flatten.Point(m.transform([this.x, this.y]))\r\n    }\r\n\r\n    /**\r\n     * Returns projection point on given line\r\n     * @param {Line} line Line this point be projected on\r\n     * @returns {Point}\r\n     */\r\n    projectionOn(line) {\r\n        if (this.equalTo(line.pt))                   // this point equal to line anchor point\r\n            return this.clone();\r\n\r\n        let vec = new Flatten.Vector(this, line.pt);\r\n        if (Flatten.Utils.EQ_0(vec.cross(line.norm)))    // vector to point from anchor point collinear to normal vector\r\n            return line.pt.clone();\r\n\r\n        let dist = vec.dot(line.norm);             // signed distance\r\n        let proj_vec = line.norm.multiply(dist);\r\n        return this.translate(proj_vec);\r\n    }\r\n\r\n    /**\r\n     * Returns true if point belongs to the \"left\" semi-plane, which means, point belongs to the same semi plane where line normal vector points to\r\n     * Return false if point belongs to the \"right\" semi-plane or to the line itself\r\n     * @param {Line} line Query line\r\n     * @returns {boolean}\r\n     */\r\n    leftTo(line) {\r\n        let vec = new Flatten.Vector(line.pt, this);\r\n        let onLeftSemiPlane = Flatten.Utils.GT(vec.dot(line.norm), 0);\r\n        return onLeftSemiPlane;\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment from point to shape and return as array [distance, shortest segment]\r\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n     * @returns {number} distance from point to shape\r\n     * @returns {Segment} shortest segment between point and shape (started at point, ended at shape)\r\n     */\r\n    distanceTo(shape) {\r\n        if (shape instanceof Point) {\r\n            let dx = shape.x - this.x;\r\n            let dy = shape.y - this.y;\r\n            return [Math.sqrt(dx * dx + dy * dy), new Flatten.Segment(this, shape)];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Line) {\r\n            return Flatten.Distance.point2line(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            return Flatten.Distance.point2circle(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            return Flatten.Distance.point2segment(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            return Flatten.Distance.point2arc(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            return Flatten.Distance.point2polygon(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.PlanarSet) {\r\n            return Flatten.Distance.shape2planarSet(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Multiline) {\r\n            return Flatten.Distance.shape2multiline(this, shape);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if point is on a shape, false otherwise\r\n     * @param {Shape} shape\r\n     * @returns {boolean}\r\n     */\r\n    on(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            return this.equalTo(shape);\r\n        }\r\n\r\n        if (shape.contains && shape.contains instanceof Function) {\r\n            return shape.contains(this);\r\n        }\r\n\r\n        throw Flatten.Errors.UNSUPPORTED_SHAPE_TYPE;\r\n    }\r\n\r\n    get name() {\r\n        return \"point\"\r\n    }\r\n\r\n    /**\r\n     * Return string to draw point in svg as circle with radius \"r\" <br/>\r\n     * Accept any valid attributes of svg elements as svg object\r\n     * Defaults attribues are: <br/>\r\n     * {\r\n     *    r:\"3\",\r\n     *    stroke:\"black\",\r\n     *    strokeWidth:\"1\",\r\n     *    fill:\"red\"\r\n     * }\r\n     * @param {Object} attrs - Any valid attributes of svg circle element, like \"r\", \"stroke\", \"strokeWidth\", \"fill\"\r\n     * @returns {String}\r\n     */\r\n    svg(attrs = {}) {\r\n        const r = attrs.r ?? 3;            // default radius - 3\r\n        return `\\n<circle cx=\"${this.x}\" cy=\"${this.y}\" r=\"${r}\"\r\n            ${convertToString({fill: \"red\", ...attrs})} />`;\r\n    }\r\n};\r\n\r\nFlatten.Point = Point$3;\r\n/**\r\n * Function to create point equivalent to \"new\" constructor\r\n * @param args\r\n */\r\nconst point = (...args) => new Flatten.Point(...args);\r\nFlatten.point = point;\r\n\r\n// export {Point};\r\n\r\n/**\r\n * Created by Alex Bol on 2/19/2017.\r\n */\r\n\r\n\r\n/**\r\n * Class representing a vector\r\n * @type {Vector}\r\n */\r\nlet Vector$1 = class Vector extends Shape {\r\n    /**\r\n     * Vector may be constructed by two points, or by two float numbers,\r\n     * or by array of two numbers\r\n     * @param {Point} ps - start point\r\n     * @param {Point} pe - end point\r\n     */\r\n    constructor(...args) {\r\n        super();\r\n        /**\r\n         * x-coordinate of a vector (float number)\r\n         * @type {number}\r\n         */\r\n        this.x = 0;\r\n        /**\r\n         * y-coordinate of a vector (float number)\r\n         * @type {number}\r\n         */\r\n        this.y = 0;\r\n\r\n        /* return zero vector */\r\n        if (args.length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (args.length === 1 && args[0] instanceof Array && args[0].length === 2) {\r\n            let arr = args[0];\r\n            if (typeof (arr[0]) == \"number\" && typeof (arr[1]) == \"number\") {\r\n                this.x = arr[0];\r\n                this.y = arr[1];\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"vector\") {\r\n            let {x, y} = args[0];\r\n            this.x = x;\r\n            this.y = y;\r\n            return;\r\n        }\r\n\r\n        if (args.length === 2) {\r\n            let a1 = args[0];\r\n            let a2 = args[1];\r\n\r\n            if (typeof (a1) == \"number\" && typeof (a2) == \"number\") {\r\n                this.x = a1;\r\n                this.y = a2;\r\n                return;\r\n            }\r\n\r\n            if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\r\n                this.x = a2.x - a1.x;\r\n                this.y = a2.y - a1.y;\r\n                return;\r\n            }\r\n\r\n        }\r\n\r\n        throw Errors.ILLEGAL_PARAMETERS;\r\n    }\r\n\r\n    /**\r\n     * Method clone returns new instance of Vector\r\n     * @returns {Vector}\r\n     */\r\n    clone() {\r\n        return new Flatten.Vector(this.x, this.y);\r\n    }\r\n\r\n    /**\r\n     * Slope of the vector in radians from 0 to 2PI\r\n     * @returns {number}\r\n     */\r\n    get slope() {\r\n        let angle = Math.atan2(this.y, this.x);\r\n        if (angle < 0) angle = 2 * Math.PI + angle;\r\n        return angle;\r\n    }\r\n\r\n    /**\r\n     * Length of vector\r\n     * @returns {number}\r\n     */\r\n    get length() {\r\n        return Math.sqrt(this.dot(this));\r\n    }\r\n\r\n    /**\r\n     * Returns true if vectors are equal up to [DP_TOL]{@link http://localhost:63342/flatten-js/docs/global.html#DP_TOL}\r\n     * tolerance\r\n     * @param {Vector} v\r\n     * @returns {boolean}\r\n     */\r\n    equalTo(v) {\r\n        return Flatten.Utils.EQ(this.x, v.x) && Flatten.Utils.EQ(this.y, v.y);\r\n    }\r\n\r\n    /**\r\n     * Returns new vector multiplied by scalar\r\n     * @param {number} scalar\r\n     * @returns {Vector}\r\n     */\r\n    multiply(scalar) {\r\n        return (new Flatten.Vector(scalar * this.x, scalar * this.y));\r\n    }\r\n\r\n    /**\r\n     * Returns scalar product (dot product) of two vectors <br/>\r\n     * <code>dot_product = (this * v)</code>\r\n     * @param {Vector} v Other vector\r\n     * @returns {number}\r\n     */\r\n    dot(v) {\r\n        return (this.x * v.x + this.y * v.y);\r\n    }\r\n\r\n    /**\r\n     * Returns vector product (cross product) of two vectors <br/>\r\n     * <code>cross_product = (this x v)</code>\r\n     * @param {Vector} v Other vector\r\n     * @returns {number}\r\n     */\r\n    cross(v) {\r\n        return (this.x * v.y - this.y * v.x);\r\n    }\r\n\r\n    /**\r\n     * Returns unit vector.<br/>\r\n     * Throw error if given vector has zero length\r\n     * @returns {Vector}\r\n     */\r\n    normalize() {\r\n        if (!Flatten.Utils.EQ_0(this.length)) {\r\n            return (new Flatten.Vector(this.x / this.length, this.y / this.length));\r\n        }\r\n        throw Errors.ZERO_DIVISION;\r\n    }\r\n\r\n    /**\r\n     * Returns new vector rotated by given angle,\r\n     * positive angle defines rotation in counterclockwise direction,\r\n     * negative - in clockwise direction\r\n     * Vector only can be rotated around (0,0) point!\r\n     * @param {number} angle - Angle in radians\r\n     * @returns {Vector}\r\n     */\r\n    rotate(angle, center = new Flatten.Point()) {\r\n        if (center.x === 0 && center.y === 0) {\r\n            return this.transform(new Matrix().rotate(angle));\r\n        }\r\n        throw(Errors.OPERATION_IS_NOT_SUPPORTED);\r\n    }\r\n\r\n    /**\r\n     * Return new vector transformed by affine transformation matrix m\r\n     * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\r\n     * @returns {Vector}\r\n     */\r\n    transform(m) {\r\n        return new Flatten.Vector(m.transform([this.x, this.y]))\r\n    }\r\n\r\n    /**\r\n     * Returns vector rotated 90 degrees counterclockwise\r\n     * @returns {Vector}\r\n     */\r\n    rotate90CCW() {\r\n        return new Flatten.Vector(-this.y, this.x);\r\n    };\r\n\r\n    /**\r\n     * Returns vector rotated 90 degrees clockwise\r\n     * @returns {Vector}\r\n     */\r\n    rotate90CW() {\r\n        return new Flatten.Vector(this.y, -this.x);\r\n    };\r\n\r\n    /**\r\n     * Return inverted vector\r\n     * @returns {Vector}\r\n     */\r\n    invert() {\r\n        return new Flatten.Vector(-this.x, -this.y);\r\n    }\r\n\r\n    /**\r\n     * Return result of addition of other vector to this vector as a new vector\r\n     * @param {Vector} v Other vector\r\n     * @returns {Vector}\r\n     */\r\n    add(v) {\r\n        return new Flatten.Vector(this.x + v.x, this.y + v.y);\r\n    }\r\n\r\n    /**\r\n     * Return result of subtraction of other vector from current vector as a new vector\r\n     * @param {Vector} v Another vector\r\n     * @returns {Vector}\r\n     */\r\n    subtract(v) {\r\n        return new Flatten.Vector(this.x - v.x, this.y - v.y);\r\n    }\r\n\r\n    /**\r\n     * Return angle between this vector and other vector. <br/>\r\n     * Angle is measured from 0 to 2*PI in the counterclockwise direction\r\n     * from current vector to  another.\r\n     * @param {Vector} v Another vector\r\n     * @returns {number}\r\n     */\r\n    angleTo(v) {\r\n        let norm1 = this.normalize();\r\n        let norm2 = v.normalize();\r\n        let angle = Math.atan2(norm1.cross(norm2), norm1.dot(norm2));\r\n        if (angle < 0) angle += 2 * Math.PI;\r\n        return angle;\r\n    }\r\n\r\n    /**\r\n     * Return vector projection of the current vector on another vector\r\n     * @param {Vector} v Another vector\r\n     * @returns {Vector}\r\n     */\r\n    projectionOn(v) {\r\n        let n = v.normalize();\r\n        let d = this.dot(n);\r\n        return n.multiply(d);\r\n    }\r\n\r\n    get name() {\r\n        return \"vector\"\r\n    }\r\n};\r\n\r\nFlatten.Vector = Vector$1;\r\n\r\n/**\r\n * Function to create vector equivalent to \"new\" constructor\r\n * @param args\r\n */\r\nconst vector$1 = (...args) => new Flatten.Vector(...args);\r\nFlatten.vector = vector$1;\r\n\r\n/**\r\n * Created by Alex Bol on 3/10/2017.\r\n */\r\n\r\n\r\n/**\r\n * Class representing a segment\r\n * @type {Segment}\r\n */\r\nlet Segment$1 = class Segment extends Shape {\r\n    /**\r\n     *\r\n     * @param {Point} ps - start point\r\n     * @param {Point} pe - end point\r\n     */\r\n    constructor(...args) {\r\n        super();\r\n        /**\r\n         * Start point\r\n         * @type {Point}\r\n         */\r\n        this.ps = new Flatten.Point();\r\n        /**\r\n         * End Point\r\n         * @type {Point}\r\n         */\r\n        this.pe = new Flatten.Point();\r\n\r\n        if (args.length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (args.length === 1 && args[0] instanceof Array && args[0].length === 4) {\r\n            let coords = args[0];\r\n            this.ps = new Flatten.Point(coords[0], coords[1]);\r\n            this.pe = new Flatten.Point(coords[2], coords[3]);\r\n            return;\r\n        }\r\n\r\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"segment\") {\r\n            let {ps, pe} = args[0];\r\n            this.ps = new Flatten.Point(ps.x, ps.y);\r\n            this.pe = new Flatten.Point(pe.x, pe.y);\r\n            return;\r\n        }\r\n\r\n        // second point omitted issue #84\r\n        if (args.length === 1 && args[0] instanceof Flatten.Point) {\r\n            this.ps = args[0].clone();\r\n            return;\r\n        }\r\n\r\n        if (args.length === 2 && args[0] instanceof Flatten.Point && args[1] instanceof Flatten.Point) {\r\n            this.ps = args[0].clone();\r\n            this.pe = args[1].clone();\r\n            return;\r\n        }\r\n\r\n        if (args.length === 4) {\r\n            this.ps = new Flatten.Point(args[0], args[1]);\r\n            this.pe = new Flatten.Point(args[2], args[3]);\r\n            return;\r\n        }\r\n\r\n        throw Errors.ILLEGAL_PARAMETERS;\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of segment\r\n     * @returns {Segment}\r\n     */\r\n    clone() {\r\n        return new Flatten.Segment(this.start, this.end);\r\n    }\r\n\r\n    /**\r\n     * Start point\r\n     * @returns {Point}\r\n     */\r\n    get start() {\r\n        return this.ps;\r\n    }\r\n\r\n    /**\r\n     * End point\r\n     * @returns {Point}\r\n     */\r\n    get end() {\r\n        return this.pe;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns array of start and end point\r\n     * @returns [Point,Point]\r\n     */\r\n    get vertices() {\r\n        return [this.ps.clone(), this.pe.clone()];\r\n    }\r\n\r\n    /**\r\n     * Length of a segment\r\n     * @returns {number}\r\n     */\r\n    get length() {\r\n        return this.start.distanceTo(this.end)[0];\r\n    }\r\n\r\n    /**\r\n     * Slope of the line - angle to axe x in radians from 0 to 2PI\r\n     * @returns {number}\r\n     */\r\n    get slope() {\r\n        let vec = new Flatten.Vector(this.start, this.end);\r\n        return vec.slope;\r\n    }\r\n\r\n    /**\r\n     * Bounding box\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        return new Flatten.Box(\r\n            Math.min(this.start.x, this.end.x),\r\n            Math.min(this.start.y, this.end.y),\r\n            Math.max(this.start.x, this.end.x),\r\n            Math.max(this.start.y, this.end.y)\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Returns true if equals to query segment, false otherwise\r\n     * @param {Segment} seg - query segment\r\n     * @returns {boolean}\r\n     */\r\n    equalTo(seg) {\r\n        return this.ps.equalTo(seg.ps) && this.pe.equalTo(seg.pe);\r\n    }\r\n\r\n    /**\r\n     * Returns true if segment contains point\r\n     * @param {Point} pt Query point\r\n     * @returns {boolean}\r\n     */\r\n    contains(pt) {\r\n        return Flatten.Utils.EQ_0(this.distanceToPoint(pt));\r\n    }\r\n\r\n    /**\r\n     * Returns array of intersection points between segment and other shape\r\n     * @param {Shape} shape - Shape of the one of supported types <br/>\r\n     * @returns {Point[]}\r\n     */\r\n    intersect(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            return this.contains(shape) ? [shape] : [];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Line) {\r\n            return intersectSegment2Line(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Ray) {\r\n            return intersectRay2Segment(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            return  intersectSegment2Segment(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            return intersectSegment2Circle(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Box) {\r\n            return intersectSegment2Box(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            return intersectSegment2Arc(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            return  intersectSegment2Polygon(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Multiline) {\r\n            return intersectShape2Multiline(this, shape);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment from segment to shape and return as array [distance, shortest segment]\r\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n     * @returns {[number, Segment]} shortest segment between segment and shape (started at segment, ended at shape)\r\n     */\r\n    distanceTo(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            let [dist, shortest_segment] = Flatten.Distance.point2segment(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            let [dist, shortest_segment] = Flatten.Distance.segment2circle(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Line) {\r\n            let [dist, shortest_segment] = Flatten.Distance.segment2line(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            let [dist, shortest_segment] = Flatten.Distance.segment2segment(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            let [dist, shortest_segment] = Flatten.Distance.segment2arc(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            let [dist, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.PlanarSet) {\r\n            let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Multiline) {\r\n            return Flatten.Distance.shape2multiline(this, shape);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns unit vector in the direction from start to end\r\n     * @returns {Vector}\r\n     */\r\n    tangentInStart() {\r\n        let vec = new Flatten.Vector(this.start, this.end);\r\n        return vec.normalize();\r\n    }\r\n\r\n    /**\r\n     * Return unit vector in the direction from end to start\r\n     * @returns {Vector}\r\n     */\r\n    tangentInEnd() {\r\n        let vec = new Flatten.Vector(this.end, this.start);\r\n        return vec.normalize();\r\n    }\r\n\r\n    /**\r\n     * Returns new segment with swapped start and end points\r\n     * @returns {Segment}\r\n     */\r\n    reverse() {\r\n        return new Segment(this.end, this.start);\r\n    }\r\n\r\n    /**\r\n     * When point belongs to segment, return array of two segments split by given point,\r\n     * if point is inside segment. Returns clone of this segment if query point is incident\r\n     * to start or end point of the segment. Returns empty array if point does not belong to segment\r\n     * @param {Point} pt Query point\r\n     * @returns {Segment[]}\r\n     */\r\n    split(pt) {\r\n        if (this.start.equalTo(pt))\r\n            return [null, this.clone()];\r\n\r\n        if (this.end.equalTo(pt))\r\n            return [this.clone(), null];\r\n\r\n        return [\r\n            new Flatten.Segment(this.start, pt),\r\n            new Flatten.Segment(pt, this.end)\r\n        ]\r\n    }\r\n\r\n    /**\r\n     * Return middle point of the segment\r\n     * @returns {Point}\r\n     */\r\n    middle() {\r\n        return new Flatten.Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);\r\n    }\r\n\r\n    /**\r\n     * Get point at given length\r\n     * @param {number} length - The length along the segment\r\n     * @returns {Point}\r\n     */\r\n    pointAtLength(length) {\r\n        if (length > this.length || length < 0) return null;\r\n        if (length == 0) return this.start;\r\n        if (length == this.length) return this.end;\r\n        let factor = length / this.length;\r\n        return new Flatten.Point(\r\n            (this.end.x - this.start.x) * factor + this.start.x,\r\n            (this.end.y - this.start.y) * factor + this.start.y\r\n        );\r\n    }\r\n\r\n    distanceToPoint(pt) {\r\n        let [dist, ...rest] = Flatten.Distance.point2segment(pt, this);\r\n        return dist;\r\n    };\r\n\r\n    definiteIntegral(ymin = 0.0) {\r\n        let dx = this.end.x - this.start.x;\r\n        let dy1 = this.start.y - ymin;\r\n        let dy2 = this.end.y - ymin;\r\n        return (dx * (dy1 + dy2) / 2);\r\n    }\r\n\r\n    /**\r\n     * Return new segment transformed using affine transformation matrix\r\n     * @param {Matrix} matrix - affine transformation matrix\r\n     * @returns {Segment} - transformed segment\r\n     */\r\n    transform(matrix = new Flatten.Matrix()) {\r\n        return new Segment(this.ps.transform(matrix), this.pe.transform(matrix))\r\n    }\r\n\r\n    /**\r\n     * Returns true if segment start is equal to segment end up to DP_TOL\r\n     * @returns {boolean}\r\n     */\r\n    isZeroLength() {\r\n        return this.ps.equalTo(this.pe)\r\n    }\r\n\r\n    /**\r\n     * Sort given array of points from segment start to end, assuming all points lay on the segment\r\n     * @param {Point[]} - array of points\r\n     * @returns {Point[]} new array sorted\r\n     */\r\n    sortPoints(pts) {\r\n        let line = new Flatten.Line(this.start, this.end);\r\n        return line.sortPoints(pts);\r\n    }\r\n\r\n    get name() {\r\n        return \"segment\"\r\n    }\r\n\r\n    /**\r\n     * Return string to draw segment in svg\r\n     * @param {Object} attrs - an object with attributes for svg path element,\r\n     * like \"stroke\", \"strokeWidth\" <br/>\r\n     * Defaults are stroke:\"black\", strokeWidth:\"1\"\r\n     * @returns {string}\r\n     */\r\n    svg(attrs = {}) {\r\n        return `\\n<line x1=\"${this.start.x}\" y1=\"${this.start.y}\" x2=\"${this.end.x}\" y2=\"${this.end.y}\" ${convertToString(attrs)} />`;\r\n    }\r\n};\r\n\r\nFlatten.Segment = Segment$1;\r\n/**\r\n * Shortcut method to create new segment\r\n */\r\nconst segment = (...args) => new Flatten.Segment(...args);\r\nFlatten.segment = segment;\r\n\r\n/**\r\n * Created by Alex Bol on 2/20/2017.\r\n */\r\n\r\nlet {vector} = Flatten;\r\n\r\n/**\r\n * Class representing a line\r\n * @type {Line}\r\n */\r\nlet Line$1 = class Line extends Shape {\r\n    /**\r\n     * Line may be constructed by point and normal vector or by two points that a line passes through\r\n     * @param {Point} pt - point that a line passes through\r\n     * @param {Vector|Point} norm - normal vector to a line or second point a line passes through\r\n     */\r\n    constructor(...args) {\r\n        super();\r\n        /**\r\n         * Point a line passes through\r\n         * @type {Point}\r\n         */\r\n        this.pt = new Flatten.Point();\r\n        /**\r\n         * Normal vector to a line <br/>\r\n         * Vector is normalized (length == 1)<br/>\r\n         * Direction of the vector is chosen to satisfy inequality norm * p >= 0\r\n         * @type {Vector}\r\n         */\r\n        this.norm = new Flatten.Vector(0, 1);\r\n\r\n        if (args.length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"line\") {\r\n            let {pt, norm} = args[0];\r\n            this.pt = new Flatten.Point(pt);\r\n            this.norm = new Flatten.Vector(norm);\r\n            return;\r\n        }\r\n\r\n        if (args.length === 2) {\r\n            let a1 = args[0];\r\n            let a2 = args[1];\r\n\r\n            if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\r\n                this.pt = a1;\r\n                this.norm = Line.points2norm(a1, a2);\r\n                if (this.norm.dot(vector(this.pt.x,this.pt.y)) >= 0) {\r\n                    this.norm.invert();\r\n                }\r\n                return;\r\n            }\r\n\r\n            if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Vector) {\r\n                if (Flatten.Utils.EQ_0(a2.x) && Flatten.Utils.EQ_0(a2.y)) {\r\n                    throw Errors.ILLEGAL_PARAMETERS;\r\n                }\r\n                this.pt = a1.clone();\r\n                this.norm = a2.clone();\r\n                this.norm = this.norm.normalize();\r\n                if (this.norm.dot(vector(this.pt.x,this.pt.y)) >= 0) {\r\n                    this.norm.invert();\r\n                }\r\n                return;\r\n            }\r\n\r\n            if (a1 instanceof Flatten.Vector && a2 instanceof Flatten.Point) {\r\n                if (Flatten.Utils.EQ_0(a1.x) && Flatten.Utils.EQ_0(a1.y)) {\r\n                    throw Errors.ILLEGAL_PARAMETERS;\r\n                }\r\n                this.pt = a2.clone();\r\n                this.norm = a1.clone();\r\n                this.norm = this.norm.normalize();\r\n                if (this.norm.dot(vector(this.pt.x,this.pt.y)) >= 0) {\r\n                    this.norm.invert();\r\n                }\r\n                return;\r\n            }\r\n        }\r\n\r\n        throw Errors.ILLEGAL_PARAMETERS;\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of line\r\n     * @returns {Line}\r\n     */\r\n    clone() {\r\n        return new Flatten.Line(this.pt, this.norm);\r\n    }\r\n\r\n    /* The following methods need for implementation of Edge interface\r\n    /**\r\n     * Line has no start point\r\n     * @returns {undefined}\r\n     */\r\n    get start() {return undefined;}\r\n\r\n    /**\r\n     * Line has no end point\r\n     */\r\n    get end() {return undefined;}\r\n\r\n    /**\r\n     * Return positive infinity number as length\r\n     * @returns {number}\r\n     */\r\n    get length() {return Number.POSITIVE_INFINITY;}\r\n\r\n    /**\r\n     * Returns infinite box\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        return new Flatten.Box(\r\n            Number.NEGATIVE_INFINITY,\r\n            Number.NEGATIVE_INFINITY,\r\n            Number.POSITIVE_INFINITY,\r\n            Number.POSITIVE_INFINITY\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Middle point is undefined\r\n     * @returns {undefined}\r\n     */\r\n    get middle() {return undefined}\r\n\r\n    /**\r\n     * Slope of the line - angle in radians between line and axe x from 0 to 2PI\r\n     * @returns {number} - slope of the line\r\n     */\r\n    get slope() {\r\n        let vec = new Flatten.Vector(this.norm.y, -this.norm.x);\r\n        return vec.slope;\r\n    }\r\n\r\n    /**\r\n     * Get coefficients [A,B,C] of a standard line equation in the form Ax + By = C\r\n     * @code [A, B, C] = line.standard\r\n     * @returns {number[]} - array of coefficients\r\n     */\r\n    get standard() {\r\n        let A = this.norm.x;\r\n        let B = this.norm.y;\r\n        let C = this.norm.dot(vector(this.pt.x, this.pt.y));\r\n\r\n        return [A, B, C];\r\n    }\r\n\r\n    /**\r\n     * Return true if parallel or incident to other line\r\n     * @param {Line} other_line - line to check\r\n     * @returns {boolean}\r\n     */\r\n    parallelTo(other_line) {\r\n        return Flatten.Utils.EQ_0(this.norm.cross(other_line.norm));\r\n    }\r\n\r\n    /**\r\n     * Returns true if incident to other line\r\n     * @param {Line} other_line - line to check\r\n     * @returns {boolean}\r\n     */\r\n    incidentTo(other_line) {\r\n        return this.parallelTo(other_line) && this.pt.on(other_line);\r\n    }\r\n\r\n    /**\r\n     * Returns true if point belongs to line\r\n     * @param {Point} pt Query point\r\n     * @returns {boolean}\r\n     */\r\n    contains(pt) {\r\n        if (this.pt.equalTo(pt)) {\r\n            return true;\r\n        }\r\n        /* Line contains point if vector to point is orthogonal to the line normal vector */\r\n        let vec = new Flatten.Vector(this.pt, pt);\r\n        return Flatten.Utils.EQ_0(this.norm.dot(vec));\r\n    }\r\n\r\n    /**\r\n     * Return coordinate of the point that lies on the line in the transformed\r\n     * coordinate system where center is the projection of the point(0,0) to\r\n     * the line and axe y is collinear to the normal vector. <br/>\r\n     * This method assumes that point lies on the line and does not check it\r\n     * @param {Point} pt - point on a line\r\n     * @returns {number}\r\n     */\r\n    coord(pt) {\r\n        return vector(pt.x, pt.y).cross(this.norm);\r\n    }\r\n\r\n    /**\r\n     * Returns array of intersection points\r\n     * @param {Shape} shape - shape to intersect with\r\n     * @returns {Point[]}\r\n     */\r\n    intersect(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            return this.contains(shape) ? [shape] : [];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Line) {\r\n            return intersectLine2Line(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Ray) {\r\n            return intersectRay2Line(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            return intersectLine2Circle(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Box) {\r\n            return intersectLine2Box(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            return intersectSegment2Line(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            return intersectLine2Arc(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            return  intersectLine2Polygon(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Multiline) {\r\n            return intersectShape2Multiline(this, shape);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment from line to shape and returns array [distance, shortest_segment]\r\n     * @param {Shape} shape Shape of the one of the types Point, Circle, Segment, Arc, Polygon\r\n     * @returns {[number, Segment]}\r\n     */\r\n    distanceTo(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            let [distance, shortest_segment] = Flatten.Distance.point2line(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [distance, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            let [distance, shortest_segment] = Flatten.Distance.circle2line(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [distance, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            let [distance, shortest_segment] = Flatten.Distance.segment2line(shape, this);\r\n            return [distance, shortest_segment.reverse()];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            let [distance, shortest_segment] = Flatten.Distance.arc2line(shape, this);\r\n            return [distance, shortest_segment.reverse()];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            let [distance, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\r\n            return [distance, shortest_segment];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Split line with a point or array of points and return array of shapes\r\n     * Assumed (but not checked) that all points lay on the line\r\n     * @param {Point | Point[]} pt\r\n     * @returns {MultilineShapes}\r\n     */\r\n    split(pt) {\r\n        if (pt instanceof Flatten.Point) {\r\n            return [new Flatten.Ray(pt, this.norm), new Flatten.Ray(pt, this.norm)]\r\n        }\r\n        else {\r\n            let multiline = new Flatten.Multiline([this]);\r\n            let sorted_points = this.sortPoints(pt);\r\n            multiline.split(sorted_points);\r\n            return multiline.toShapes();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return new line rotated by angle\r\n     * @param {number} angle - angle in radians\r\n     * @param {Point} center - center of rotation\r\n     */\r\n    rotate(angle, center = new Flatten.Point()) {\r\n        return new Flatten.Line(\r\n            this.pt.rotate(angle, center),\r\n            this.norm.rotate(angle)\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Return new line transformed by affine transformation matrix\r\n     * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\r\n     * @returns {Line}\r\n     */\r\n    transform(m) {\r\n        return new Flatten.Line(\r\n            this.pt.transform(m),\r\n            this.norm.clone()\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Sort given array of points that lay on a line with respect to coordinate on a line\r\n     * The method assumes that points lay on the line and does not check this\r\n     * @param {Point[]} pts - array of points\r\n     * @returns {Point[]} new array sorted\r\n     */\r\n    sortPoints(pts) {\r\n        return pts.slice().sort( (pt1, pt2) => {\r\n            if (this.coord(pt1) < this.coord(pt2)) {\r\n                return -1;\r\n            }\r\n            if (this.coord(pt1) > this.coord(pt2)) {\r\n                return 1;\r\n            }\r\n            return 0;\r\n        })\r\n    }\r\n\r\n    get name() {\r\n        return \"line\"\r\n    }\r\n\r\n    /**\r\n     * Return string to draw svg segment representing line inside given box\r\n     * @param {Box} box Box representing drawing area\r\n     * @param {Object} attrs - an object with attributes of svg circle element\r\n     */\r\n    svg(box, attrs = {}) {\r\n        let ip = intersectLine2Box(this, box);\r\n        if (ip.length === 0)\r\n            return \"\";\r\n        let ps = ip[0];\r\n        let pe = ip.length === 2 ? ip[1] : ip.find(pt => !pt.equalTo(ps));\r\n        if (pe === undefined) pe = ps;\r\n        let segment = new Flatten.Segment(ps, pe);\r\n        return segment.svg(attrs);\r\n    }\r\n\r\n    static points2norm(pt1, pt2) {\r\n        if (pt1.equalTo(pt2)) {\r\n            throw Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n        let vec = new Flatten.Vector(pt1, pt2);\r\n        let unit = vec.normalize();\r\n        return unit.rotate90CCW();\r\n    }\r\n};\r\n\r\nFlatten.Line = Line$1;\r\n/**\r\n * Function to create line equivalent to \"new\" constructor\r\n * @param args\r\n */\r\nconst line = (...args) => new Flatten.Line(...args);\r\nFlatten.line = line;\r\n\r\n/**\r\n * Created by Alex Bol on 3/6/2017.\r\n */\r\n\r\n\r\n/**\r\n * Class representing a circle\r\n * @type {Circle}\r\n */\r\nlet Circle$1 = class Circle extends Shape {\r\n    /**\r\n     * Class private property\r\n     * @type {string}\r\n     */\r\n\r\n    /**\r\n     *\r\n     * @param {Point} pc - circle center point\r\n     * @param {number} r - circle radius\r\n     */\r\n    constructor(...args) {\r\n        super();\r\n        /**\r\n         * Circle center\r\n         * @type {Point}\r\n         */\r\n        this.pc = new Flatten.Point();\r\n        /**\r\n         * Circle radius\r\n         * @type {number}\r\n         */\r\n        this.r = 1;\r\n\r\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"circle\") {\r\n            let {pc, r} = args[0];\r\n            this.pc = new Flatten.Point(pc);\r\n            this.r = r;\r\n        } else {\r\n            let [pc, r] = [...args];\r\n            if (pc && pc instanceof Flatten.Point) this.pc = pc.clone();\r\n            if (r !== undefined) this.r = r;\r\n        }\r\n        // throw Errors.ILLEGAL_PARAMETERS;    unreachable code\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of circle\r\n     * @returns {Circle}\r\n     */\r\n    clone() {\r\n        return new Flatten.Circle(this.pc.clone(), this.r);\r\n    }\r\n\r\n    /**\r\n     * Circle center\r\n     * @returns {Point}\r\n     */\r\n    get center() {\r\n        return this.pc;\r\n    }\r\n\r\n    /**\r\n     * Circle bounding box\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        return new Flatten.Box(\r\n            this.pc.x - this.r,\r\n            this.pc.y - this.r,\r\n            this.pc.x + this.r,\r\n            this.pc.y + this.r\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Return true if circle contains shape: no point of shape lies outside of the circle\r\n     * @param {Shape} shape - test shape\r\n     * @returns {boolean}\r\n     */\r\n    contains(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            return Flatten.Utils.LE(shape.distanceTo(this.center)[0], this.r);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            return Flatten.Utils.LE(shape.start.distanceTo(this.center)[0], this.r) &&\r\n                Flatten.Utils.LE(shape.end.distanceTo(this.center)[0], this.r);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            return this.intersect(shape).length === 0 &&\r\n                Flatten.Utils.LE(shape.start.distanceTo(this.center)[0], this.r) &&\r\n                Flatten.Utils.LE(shape.end.distanceTo(this.center)[0], this.r);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            return this.intersect(shape).length === 0 &&\r\n                Flatten.Utils.LE(shape.r, this.r) &&\r\n                Flatten.Utils.LE(shape.center.distanceTo(this.center)[0], this.r);\r\n        }\r\n\r\n        /* TODO: box, polygon */\r\n    }\r\n\r\n    /**\r\n     * Transform circle to closed arc\r\n     * @param {boolean} counterclockwise\r\n     * @returns {Arc}\r\n     */\r\n    toArc(counterclockwise = true) {\r\n        return new Flatten.Arc(this.center, this.r, Math.PI, -Math.PI, counterclockwise);\r\n    }\r\n\r\n    /**\r\n     * Method scale is supported only for uniform scaling of the circle with (0,0) center\r\n     * @param {number} sx\r\n     * @param {number} sy\r\n     * @returns {Circle}\r\n     */\r\n    scale(sx, sy) {\r\n        if (sx !== sy)\r\n            throw Errors.OPERATION_IS_NOT_SUPPORTED\r\n        if (!(this.pc.x === 0.0 && this.pc.y === 0.0))\r\n            throw Errors.OPERATION_IS_NOT_SUPPORTED\r\n        return new Flatten.Circle(this.pc, this.r*sx)\r\n    }\r\n\r\n    /**\r\n     * Return new circle transformed using affine transformation matrix\r\n     * @param {Matrix} matrix - affine transformation matrix\r\n     * @returns {Circle}\r\n     */\r\n    transform(matrix = new Flatten.Matrix()) {\r\n        return new Flatten.Circle(this.pc.transform(matrix), this.r)\r\n    }\r\n\r\n    /**\r\n     * Returns array of intersection points between circle and other shape\r\n     * @param {Shape} shape Shape of the one of supported types\r\n     * @returns {Point[]}\r\n     */\r\n    intersect(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            return this.contains(shape) ? [shape] : [];\r\n        }\r\n        if (shape instanceof Flatten.Line) {\r\n            return intersectLine2Circle(shape, this);\r\n        }\r\n        if (shape instanceof Flatten.Ray) {\r\n            return intersectRay2Circle(shape, this);\r\n        }\r\n        if (shape instanceof Flatten.Segment) {\r\n            return intersectSegment2Circle(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            return intersectCircle2Circle(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Box) {\r\n            return intersectCircle2Box(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            return intersectArc2Circle(shape, this);\r\n        }\r\n        if (shape instanceof Flatten.Polygon) {\r\n            return intersectCircle2Polygon(this, shape);\r\n        }\r\n        if (shape instanceof Flatten.Multiline) {\r\n            return intersectShape2Multiline(this, shape);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment from circle to shape and return array [distance, shortest segment]\r\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n     * @returns {number} distance from circle to shape\r\n     * @returns {Segment} shortest segment between circle and shape (started at circle, ended at shape)\r\n\r\n     */\r\n    distanceTo(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            let [distance, shortest_segment] = Flatten.Distance.point2circle(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [distance, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            let [distance, shortest_segment] = Flatten.Distance.circle2circle(this, shape);\r\n            return [distance, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Line) {\r\n            let [distance, shortest_segment] = Flatten.Distance.circle2line(this, shape);\r\n            return [distance, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            let [distance, shortest_segment] = Flatten.Distance.segment2circle(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [distance, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            let [distance, shortest_segment] = Flatten.Distance.arc2circle(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [distance, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            let [distance, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\r\n            return [distance, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.PlanarSet) {\r\n            let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Multiline) {\r\n            let [dist, shortest_segment] = Flatten.Distance.shape2multiline(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n    }\r\n\r\n    get name() {\r\n        return \"circle\"\r\n    }\r\n\r\n    /**\r\n     * Return string to draw circle in svg\r\n     * @param {Object} attrs - an object with attributes of svg circle element\r\n     * @returns {string}\r\n     */\r\n    svg(attrs = {}) {\r\n        return `\\n<circle cx=\"${this.pc.x}\" cy=\"${this.pc.y}\" r=\"${this.r}\"\r\n                ${convertToString({fill: \"none\", ...attrs})} />`;\r\n    }\r\n\r\n};\r\n\r\nFlatten.Circle = Circle$1;\r\n/**\r\n * Shortcut to create new circle\r\n * @param args\r\n */\r\nconst circle = (...args) => new Flatten.Circle(...args);\r\nFlatten.circle = circle;\r\n\r\n/**\r\n * Created by Alex Bol on 3/10/2017.\r\n */\r\n\r\n\r\n/**\r\n * Class representing a circular arc\r\n * @type {Arc}\r\n */\r\nclass Arc extends Shape {\r\n    /**\r\n     *\r\n     * @param {Point} pc - arc center\r\n     * @param {number} r - arc radius\r\n     * @param {number} startAngle - start angle in radians from 0 to 2*PI\r\n     * @param {number} endAngle - end angle in radians from 0 to 2*PI\r\n     * @param {boolean} counterClockwise - arc direction, true - clockwise, false - counterclockwise\r\n     */\r\n    constructor(...args) {\r\n        super();\r\n        /**\r\n         * Arc center\r\n         * @type {Point}\r\n         */\r\n        this.pc = new Flatten.Point();\r\n        /**\r\n         * Arc radius\r\n         * @type {number}\r\n         */\r\n        this.r = 1;\r\n        /**\r\n         * Arc start angle in radians\r\n         * @type {number}\r\n         */\r\n        this.startAngle = 0;\r\n        /**\r\n         * Arc end angle in radians\r\n         * @type {number}\r\n         */\r\n        this.endAngle = 2 * Math.PI;\r\n        /**\r\n         * Arc orientation\r\n         * @type {boolean}\r\n         */\r\n        this.counterClockwise = Flatten.CCW;\r\n\r\n        if (args.length === 0)\r\n            return;\r\n\r\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"arc\") {\r\n            let {pc, r, startAngle, endAngle, counterClockwise} = args[0];\r\n            this.pc = new Flatten.Point(pc.x, pc.y);\r\n            this.r = r;\r\n            this.startAngle = startAngle;\r\n            this.endAngle = endAngle;\r\n            this.counterClockwise = counterClockwise;\r\n        } else {\r\n            let [pc, r, startAngle, endAngle, counterClockwise] = [...args];\r\n            if (pc && pc instanceof Flatten.Point) this.pc = pc.clone();\r\n            if (r !== undefined) this.r = r;\r\n            if (startAngle !== undefined) this.startAngle = startAngle;\r\n            if (endAngle !== undefined) this.endAngle = endAngle;\r\n            if (counterClockwise !== undefined) this.counterClockwise = counterClockwise;\r\n        }\r\n\r\n        // throw Flatten.Errors.ILLEGAL_PARAMETERS; unreachable code\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of arc\r\n     * @returns {Arc}\r\n     */\r\n    clone() {\r\n        return new Flatten.Arc(this.pc.clone(), this.r, this.startAngle, this.endAngle, this.counterClockwise);\r\n    }\r\n\r\n    /**\r\n     * Get sweep angle in radians. Sweep angle is non-negative number from 0 to 2*PI\r\n     * @returns {number}\r\n     */\r\n    get sweep() {\r\n        if (Flatten.Utils.EQ(this.startAngle, this.endAngle))\r\n            return 0.0;\r\n        if (Flatten.Utils.EQ(Math.abs(this.startAngle - this.endAngle), Flatten.PIx2)) {\r\n            return Flatten.PIx2;\r\n        }\r\n        let sweep;\r\n        if (this.counterClockwise) {\r\n            sweep = Flatten.Utils.GT(this.endAngle, this.startAngle) ?\r\n                this.endAngle - this.startAngle : this.endAngle - this.startAngle + Flatten.PIx2;\r\n        } else {\r\n            sweep = Flatten.Utils.GT(this.startAngle, this.endAngle) ?\r\n                this.startAngle - this.endAngle : this.startAngle - this.endAngle + Flatten.PIx2;\r\n        }\r\n\r\n        if (Flatten.Utils.GT(sweep, Flatten.PIx2)) {\r\n            sweep -= Flatten.PIx2;\r\n        }\r\n        if (Flatten.Utils.LT(sweep, 0)) {\r\n            sweep += Flatten.PIx2;\r\n        }\r\n        return sweep;\r\n    }\r\n\r\n    /**\r\n     * Get start point of arc\r\n     * @returns {Point}\r\n     */\r\n    get start() {\r\n        let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);\r\n        return p0.rotate(this.startAngle, this.pc);\r\n    }\r\n\r\n    /**\r\n     * Get end point of arc\r\n     * @returns {Point}\r\n     */\r\n    get end() {\r\n        let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);\r\n        return p0.rotate(this.endAngle, this.pc);\r\n    }\r\n\r\n    /**\r\n     * Get center of arc\r\n     * @returns {Point}\r\n     */\r\n    get center() {\r\n        return this.pc.clone();\r\n    }\r\n\r\n    get vertices() {\r\n        return [this.start.clone(), this.end.clone()];\r\n    }\r\n\r\n    /**\r\n     * Get arc length\r\n     * @returns {number}\r\n     */\r\n    get length() {\r\n        return Math.abs(this.sweep * this.r);\r\n    }\r\n\r\n    /**\r\n     * Get bounding box of the arc\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        let func_arcs = this.breakToFunctional();\r\n        let box = func_arcs.reduce((acc, arc) => acc.merge(arc.start.box), new Flatten.Box());\r\n        box = box.merge(this.end.box);\r\n        return box;\r\n    }\r\n\r\n    /**\r\n     * Returns true if arc contains point, false otherwise\r\n     * @param {Point} pt - point to test\r\n     * @returns {boolean}\r\n     */\r\n    contains(pt) {\r\n        // first check if  point on circle (pc,r)\r\n        if (!Flatten.Utils.EQ(this.pc.distanceTo(pt)[0], this.r))\r\n            return false;\r\n\r\n        // point on circle\r\n\r\n        if (pt.equalTo(this.start))\r\n            return true;\r\n\r\n        let angle = new Flatten.Vector(this.pc, pt).slope;\r\n        let test_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise);\r\n        return Flatten.Utils.LE(test_arc.length, this.length);\r\n    }\r\n\r\n    /**\r\n     * When given point belongs to arc, return array of two arcs split by this point. If points is incident\r\n     * to start or end point of the arc, return clone of the arc. If point does not belong to the arcs, return\r\n     * empty array.\r\n     * @param {Point} pt Query point\r\n     * @returns {Arc[]}\r\n     */\r\n    split(pt) {\r\n        if (this.start.equalTo(pt))\r\n            return [null, this.clone()];\r\n\r\n        if (this.end.equalTo(pt))\r\n            return [this.clone(), null];\r\n\r\n        let angle = new Flatten.Vector(this.pc, pt).slope;\r\n\r\n        return [\r\n            new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise),\r\n            new Flatten.Arc(this.pc, this.r, angle, this.endAngle, this.counterClockwise)\r\n        ]\r\n    }\r\n\r\n    /**\r\n     * Return middle point of the arc\r\n     * @returns {Point}\r\n     */\r\n    middle() {\r\n        let endAngle = this.counterClockwise ? this.startAngle + this.sweep / 2 : this.startAngle - this.sweep / 2;\r\n        let arc = new Flatten.Arc(this.pc, this.r, this.startAngle, endAngle, this.counterClockwise);\r\n        return arc.end;\r\n    }\r\n\r\n    /**\r\n     * Get point at given length\r\n     * @param {number} length - The length along the arc\r\n     * @returns {Point}\r\n     */\r\n    pointAtLength(length) {\r\n        if (length > this.length || length < 0) return null;\r\n        if (length === 0) return this.start;\r\n        if (length === this.length) return this.end;\r\n        let factor = length / this.length;\r\n        let endAngle = this.counterClockwise ? this.startAngle + this.sweep * factor : this.startAngle - this.sweep * factor;\r\n        let arc = new Flatten.Arc(this.pc, this.r, this.startAngle, endAngle, this.counterClockwise);\r\n        return arc.end;\r\n    }\r\n\r\n    /**\r\n     * Returns chord height (\"sagitta\") of the arc\r\n     * @returns {number}\r\n     */\r\n    chordHeight() {\r\n        return (1.0 - Math.cos(Math.abs(this.sweep / 2.0))) * this.r;\r\n    }\r\n\r\n    /**\r\n     * Returns array of intersection points between arc and other shape\r\n     * @param {Shape} shape Shape of the one of supported types <br/>\r\n     * @returns {Point[]}\r\n     */\r\n    intersect(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            return this.contains(shape) ? [shape] : [];\r\n        }\r\n        if (shape instanceof Flatten.Line) {\r\n            return intersectLine2Arc(shape, this);\r\n        }\r\n        if (shape instanceof Flatten.Ray) {\r\n            return intersectRay2Arc(shape, this);\r\n        }\r\n        if (shape instanceof Flatten.Circle) {\r\n            return intersectArc2Circle(this, shape);\r\n        }\r\n        if (shape instanceof Flatten.Segment) {\r\n            return intersectSegment2Arc(shape, this);\r\n        }\r\n        if (shape instanceof Flatten.Box) {\r\n            return intersectArc2Box(this, shape);\r\n        }\r\n        if (shape instanceof Flatten.Arc) {\r\n            return intersectArc2Arc(this, shape);\r\n        }\r\n        if (shape instanceof Flatten.Polygon) {\r\n            return intersectArc2Polygon(this, shape);\r\n        }\r\n        if (shape instanceof Flatten.Multiline) {\r\n            return intersectShape2Multiline(this, shape);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment from arc to shape and return array [distance, shortest segment]\r\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n     * @returns {number} distance from arc to shape\r\n     * @returns {Segment} shortest segment between arc and shape (started at arc, ended at shape)\r\n\r\n     */\r\n    distanceTo(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            let [dist, shortest_segment] = Flatten.Distance.point2arc(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            let [dist, shortest_segment] = Flatten.Distance.arc2circle(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Line) {\r\n            let [dist, shortest_segment] = Flatten.Distance.arc2line(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            let [dist, shortest_segment] = Flatten.Distance.segment2arc(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            let [dist, shortest_segment] = Flatten.Distance.arc2arc(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            let [dist, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.PlanarSet) {\r\n            let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Multiline) {\r\n           return Flatten.Distance.shape2multiline(this, shape);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Breaks arc in extreme point 0, pi/2, pi, 3*pi/2 and returns array of sub-arcs\r\n     * @returns {Arc[]}\r\n     */\r\n    breakToFunctional() {\r\n        let func_arcs_array = [];\r\n        let angles = [0, Math.PI / 2, 2 * Math.PI / 2, 3 * Math.PI / 2];\r\n        let pts = [\r\n            this.pc.translate(this.r, 0),\r\n            this.pc.translate(0, this.r),\r\n            this.pc.translate(-this.r, 0),\r\n            this.pc.translate(0, -this.r)\r\n        ];\r\n\r\n        // If arc contains extreme point,\r\n        // create test arc started at start point and ended at this extreme point\r\n        let test_arcs = [];\r\n        for (let i = 0; i < 4; i++) {\r\n            if (pts[i].on(this)) {\r\n                test_arcs.push(new Flatten.Arc(this.pc, this.r, this.startAngle, angles[i], this.counterClockwise));\r\n            }\r\n        }\r\n\r\n        if (test_arcs.length === 0) {                  // arc does contain any extreme point\r\n            func_arcs_array.push(this.clone());\r\n        } else {                                        // arc passes extreme point\r\n            // sort these arcs by length\r\n            test_arcs.sort((arc1, arc2) => arc1.length - arc2.length);\r\n\r\n            for (let i = 0; i < test_arcs.length; i++) {\r\n                let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\r\n                let new_arc;\r\n                if (prev_arc) {\r\n                    new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, test_arcs[i].endAngle, this.counterClockwise);\r\n                } else {\r\n                    new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, test_arcs[i].endAngle, this.counterClockwise);\r\n                }\r\n                if (!Flatten.Utils.EQ_0(new_arc.length)) {\r\n                    func_arcs_array.push(new_arc.clone());\r\n                }\r\n            }\r\n\r\n            // add last sub arc\r\n            let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\r\n            let new_arc;\r\n            if (prev_arc) {\r\n                new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, this.endAngle, this.counterClockwise);\r\n            } else {\r\n                new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, this.endAngle, this.counterClockwise);\r\n            }\r\n            // It could be 2*PI when occasionally start = 0 and end = 2*PI but this is not valid for breakToFunctional\r\n            if (!Flatten.Utils.EQ_0(new_arc.length) && !Flatten.Utils.EQ(new_arc.sweep, 2*Math.PI)) {\r\n                func_arcs_array.push(new_arc.clone());\r\n            }\r\n        }\r\n        return func_arcs_array;\r\n    }\r\n\r\n    /**\r\n     * Return tangent unit vector in the start point in the direction from start to end\r\n     * @returns {Vector}\r\n     */\r\n    tangentInStart() {\r\n        let vec = new Flatten.Vector(this.pc, this.start);\r\n        let angle = this.counterClockwise ? Math.PI / 2. : -Math.PI / 2.;\r\n        return vec.rotate(angle).normalize();\r\n    }\r\n\r\n    /**\r\n     * Return tangent unit vector in the end point in the direction from end to start\r\n     * @returns {Vector}\r\n     */\r\n    tangentInEnd() {\r\n        let vec = new Flatten.Vector(this.pc, this.end);\r\n        let angle = this.counterClockwise ? -Math.PI / 2. : Math.PI / 2.;\r\n        return vec.rotate(angle).normalize();\r\n    }\r\n\r\n    /**\r\n     * Returns new arc with swapped start and end angles and reversed direction\r\n     * @returns {Arc}\r\n     */\r\n    reverse() {\r\n        return new Flatten.Arc(this.pc, this.r, this.endAngle, this.startAngle, !this.counterClockwise);\r\n    }\r\n\r\n    /**\r\n     * Return new arc transformed using affine transformation matrix <br/>\r\n     * @param {Matrix} matrix - affine transformation matrix\r\n     * @returns {Arc}\r\n     */\r\n    transform(matrix = new Flatten.Matrix()) {\r\n        let newStart = this.start.transform(matrix);\r\n        let newEnd = this.end.transform(matrix);\r\n        let newCenter = this.pc.transform(matrix);\r\n        let newDirection = this.counterClockwise;\r\n        if (matrix.a * matrix.d < 0) {\r\n          newDirection = !newDirection;\r\n        }\r\n        return Flatten.Arc.arcSE(newCenter, newStart, newEnd, newDirection);\r\n    }\r\n\r\n    static arcSE(center, start, end, counterClockwise) {\r\n        let {vector} = Flatten;\r\n        let startAngle = vector(center, start).slope;\r\n        let endAngle = vector(center, end).slope;\r\n        if (Flatten.Utils.EQ(startAngle, endAngle)) {\r\n            endAngle += 2 * Math.PI;\r\n            counterClockwise = true;\r\n        }\r\n        let r = vector(center, start).length;\r\n\r\n        return new Flatten.Arc(center, r, startAngle, endAngle, counterClockwise);\r\n    }\r\n\r\n    definiteIntegral(ymin = 0) {\r\n        let f_arcs = this.breakToFunctional();\r\n        let area = f_arcs.reduce((acc, arc) => acc + arc.circularSegmentDefiniteIntegral(ymin), 0.0);\r\n        return area;\r\n    }\r\n\r\n    circularSegmentDefiniteIntegral(ymin) {\r\n        let line = new Flatten.Line(this.start, this.end);\r\n        let onLeftSide = this.pc.leftTo(line);\r\n        let segment = new Flatten.Segment(this.start, this.end);\r\n        let areaTrapez = segment.definiteIntegral(ymin);\r\n        let areaCircularSegment = this.circularSegmentArea();\r\n        let area = onLeftSide ? areaTrapez - areaCircularSegment : areaTrapez + areaCircularSegment;\r\n        return area;\r\n    }\r\n\r\n    circularSegmentArea() {\r\n        return (0.5 * this.r * this.r * (this.sweep - Math.sin(this.sweep)))\r\n    }\r\n\r\n    /**\r\n     * Sort given array of points from arc start to end, assuming all points lay on the arc\r\n     * @param {Point[]} pts array of points\r\n     * @returns {Point[]} new array sorted\r\n     */\r\n    sortPoints(pts) {\r\n        let {vector} = Flatten;\r\n        return pts.slice().sort( (pt1, pt2) => {\r\n            let slope1 = vector(this.pc, pt1).slope;\r\n            let slope2 = vector(this.pc, pt2).slope;\r\n            if (slope1 < slope2) {\r\n                return -1;\r\n            }\r\n            if (slope1 > slope2) {\r\n                return 1;\r\n            }\r\n            return 0;\r\n        })\r\n    }\r\n\r\n    get name() {\r\n        return \"arc\"\r\n    }\r\n\r\n    /**\r\n     * Return string to draw arc in svg\r\n     * @param {Object} attrs - an object with attributes of svg path element\r\n     * @returns {string}\r\n     */\r\n    svg(attrs = {}) {\r\n        let largeArcFlag = this.sweep <= Math.PI ? \"0\" : \"1\";\r\n        let sweepFlag = this.counterClockwise ? \"1\" : \"0\";\r\n\r\n        if (Flatten.Utils.EQ(this.sweep, 2 * Math.PI)) {\r\n            let circle = new Flatten.Circle(this.pc, this.r);\r\n            return circle.svg(attrs);\r\n        } else {\r\n            return `\\n<path d=\"M${this.start.x},${this.start.y}\r\n                             A${this.r},${this.r} 0 ${largeArcFlag},${sweepFlag} ${this.end.x},${this.end.y}\"\r\n                    ${convertToString({fill: \"none\", ...attrs})} />`\r\n        }\r\n    }\r\n\r\n}\r\n\r\nFlatten.Arc = Arc;\r\n/**\r\n * Function to create arc equivalent to \"new\" constructor\r\n * @param args\r\n */\r\nconst arc = (...args) => new Flatten.Arc(...args);\r\nFlatten.arc = arc;\r\n\r\n/**\r\n * Created by Alex Bol on 3/7/2017.\r\n */\r\n\r\n/**\r\n * Class Box represents bounding box of the shape.\r\n * It may also represent axis-aligned rectangle\r\n * @type {Box}\r\n */\r\nclass Box extends Shape {\r\n    /**\r\n     *\r\n     * @param {number} xmin - minimal x coordinate\r\n     * @param {number} ymin - minimal y coordinate\r\n     * @param {number} xmax - maximal x coordinate\r\n     * @param {number} ymax - maximal y coordinate\r\n     */\r\n    constructor(xmin = undefined, ymin = undefined, xmax = undefined, ymax = undefined) {\r\n        super();\r\n        /**\r\n         * Minimal x coordinate\r\n         * @type {number}\r\n         */\r\n        this.xmin = xmin;\r\n        /**\r\n         * Minimal y coordinate\r\n         * @type {number}\r\n         */\r\n        this.ymin = ymin;\r\n        /**\r\n         * Maximal x coordinate\r\n         * @type {number}\r\n         */\r\n        this.xmax = xmax;\r\n        /**\r\n         * Maximal y coordinate\r\n         * @type {number}\r\n         */\r\n        this.ymax = ymax;\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of box\r\n     * @returns {Box}\r\n     */\r\n    clone() {\r\n        return new Box(this.xmin, this.ymin, this.xmax, this.ymax);\r\n    }\r\n\r\n    /**\r\n     * Property low need for interval tree interface\r\n     * @returns {Point}\r\n     */\r\n    get low() {\r\n        return new Flatten.Point(this.xmin, this.ymin);\r\n    }\r\n\r\n    /**\r\n     * Property high need for interval tree interface\r\n     * @returns {Point}\r\n     */\r\n    get high() {\r\n        return new Flatten.Point(this.xmax, this.ymax);\r\n    }\r\n\r\n    /**\r\n     * Property max returns the box itself !\r\n     * @returns {Box}\r\n     */\r\n    get max() {\r\n        return this.clone();\r\n    }\r\n    \r\n    /**\r\n     * Return center of the box\r\n     * @returns {Point}\r\n     */\r\n    get center() {\r\n        return new Flatten.Point((this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2);\r\n    }\r\n\r\n    /**\r\n     * Return the width of the box\r\n     * @returns {number}\r\n     */\r\n    get width() {\r\n        return Math.abs(this.xmax - this.xmin);\r\n    }\r\n\r\n    /**\r\n     * Return the height of the box\r\n     * @returns {number}\r\n     */\r\n    get height() {\r\n        return Math.abs(this.ymax - this.ymin);\r\n    }\r\n    \r\n    /**\r\n     * Return property box like all other shapes\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        return this.clone();\r\n    }\r\n\r\n    /**\r\n     * Returns true if not intersected with other box\r\n     * @param {Box} other_box - other box to test\r\n     * @returns {boolean}\r\n     */\r\n    not_intersect(other_box) {\r\n        return (\r\n            this.xmax < other_box.xmin ||\r\n            this.xmin > other_box.xmax ||\r\n            this.ymax < other_box.ymin ||\r\n            this.ymin > other_box.ymax\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns true if intersected with other box\r\n     * @param {Box} other_box - Query box\r\n     * @returns {boolean}\r\n     */\r\n    intersect(other_box) {\r\n        return !this.not_intersect(other_box);\r\n    }\r\n\r\n    /**\r\n     * Returns new box merged with other box\r\n     * @param {Box} other_box - Other box to merge with\r\n     * @returns {Box}\r\n     */\r\n    merge(other_box) {\r\n        return new Box(\r\n            this.xmin === undefined ? other_box.xmin : Math.min(this.xmin, other_box.xmin),\r\n            this.ymin === undefined ? other_box.ymin : Math.min(this.ymin, other_box.ymin),\r\n            this.xmax === undefined ? other_box.xmax : Math.max(this.xmax, other_box.xmax),\r\n            this.ymax === undefined ? other_box.ymax : Math.max(this.ymax, other_box.ymax)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Defines predicate \"less than\" between two boxes. Need for interval index\r\n     * @param {Box} other_box - other box\r\n     * @returns {boolean} - true if this box less than other box, false otherwise\r\n     */\r\n    less_than(other_box) {\r\n        if (this.low.lessThan(other_box.low))\r\n            return true;\r\n        if (this.low.equalTo(other_box.low) && this.high.lessThan(other_box.high))\r\n            return true;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if this box is equal to other box, false otherwise\r\n     * @param {Box} other_box - query box\r\n     * @returns {boolean}\r\n     */\r\n    equal_to(other_box) {\r\n        return (this.low.equalTo(other_box.low) && this.high.equalTo(other_box.high));\r\n    }\r\n\r\n    output() {\r\n        return this.clone();\r\n    }\r\n\r\n    static comparable_max(box1, box2) {\r\n        // return pt1.lessThan(pt2) ? pt2.clone() : pt1.clone();\r\n        return box1.merge(box2);\r\n    }\r\n\r\n    static comparable_less_than(pt1, pt2) {\r\n        return pt1.lessThan(pt2);\r\n    }\r\n\r\n    /**\r\n     * Set new values to the box object\r\n     * @param {number} xmin - mininal x coordinate\r\n     * @param {number} ymin - minimal y coordinate\r\n     * @param {number} xmax - maximal x coordinate\r\n     * @param {number} ymax - maximal y coordinate\r\n     */\r\n    set(xmin, ymin, xmax, ymax) {\r\n        this.xmin = xmin;\r\n        this.ymin = ymin;\r\n        this.xmax = xmax;\r\n        this.ymax = ymax;\r\n    }\r\n\r\n    /**\r\n     * Transform box into array of points from low left corner in counterclockwise\r\n     * @returns {Point[]}\r\n     */\r\n    toPoints() {\r\n        return [\r\n            new Flatten.Point(this.xmin, this.ymin),\r\n            new Flatten.Point(this.xmax, this.ymin),\r\n            new Flatten.Point(this.xmax, this.ymax),\r\n            new Flatten.Point(this.xmin, this.ymax)\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * Transform box into array of segments from low left corner in counterclockwise\r\n     * @returns {Segment[]}\r\n     */\r\n    toSegments() {\r\n        let pts = this.toPoints();\r\n        return [\r\n            new Flatten.Segment(pts[0], pts[1]),\r\n            new Flatten.Segment(pts[1], pts[2]),\r\n            new Flatten.Segment(pts[2], pts[3]),\r\n            new Flatten.Segment(pts[3], pts[0])\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * Box rotation is not supported\r\n     * Attempt to rotate box throws error\r\n     * @param {number} angle - angle in radians\r\n     * @param {Point} [center=(0,0)] center\r\n     */\r\n    rotate(angle, center = new Flatten.Point()) {\r\n            throw Errors.OPERATION_IS_NOT_SUPPORTED\r\n    }\r\n\r\n    /**\r\n     * Return new box transformed using affine transformation matrix\r\n     * New box is a bounding box of transformed corner points\r\n     * @param {Matrix} m - affine transformation matrix\r\n     * @returns {Box}\r\n     */\r\n    transform(m = new Flatten.Matrix()) {\r\n        const transformed_points = this.toPoints().map(pt => pt.transform(m));\r\n        return transformed_points.reduce(\r\n            (new_box, pt) => new_box.merge(pt.box), new Box())\r\n    }\r\n\r\n    /**\r\n     * Return true if box contains shape: no point of shape lies outside the box\r\n     * @param {AnyShape} shape - test shape\r\n     * @returns {boolean}\r\n     */\r\n    contains(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            return (shape.x >= this.xmin) && (shape.x <= this.xmax) && (shape.y >= this.ymin) && (shape.y <= this.ymax);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            return shape.vertices.every(vertex => this.contains(vertex))\r\n        }\r\n\r\n        if (shape instanceof Flatten.Box) {\r\n            return shape.toSegments().every(segment => this.contains(segment))\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            return this.contains(shape.box)\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            return shape.vertices.every(vertex => this.contains(vertex)) &&\r\n                shape.toSegments().every(segment => intersectSegment2Arc(segment, shape).length === 0)\r\n        }\r\n\r\n        if (shape instanceof Flatten.Line || shape instanceof Flatten.Ray) {\r\n            return false\r\n        }\r\n\r\n        if (shape instanceof Flatten.Multiline) {\r\n            return shape.toShapes().every(shape => this.contains(shape))\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            return this.contains(shape.box)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment from box to shape and return as array [distance, shortest segment]\r\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n     * @returns {number} distance from box to shape\r\n     * @returns {Segment} shortest segment between box and shape (started at box, ended at shape)\r\n     */\r\n    distanceTo(shape) {\r\n        const distanceInfos = this.toSegments()\r\n          .map(segment => segment.distanceTo(shape));\r\n        let shortestDistanceInfo = [\r\n          Number.MAX_SAFE_INTEGER,\r\n          null,\r\n        ];\r\n        distanceInfos.forEach(distanceInfo => {\r\n          if (distanceInfo[0] < shortestDistanceInfo[0]) {\r\n            shortestDistanceInfo = distanceInfo;\r\n          }\r\n        });\r\n        return shortestDistanceInfo;\r\n    }\r\n\r\n    get name() {\r\n        return \"box\"\r\n    }\r\n\r\n    /**\r\n     * Return string to draw box in svg\r\n     * @param {Object} attrs - an object with attributes of svg rectangle element\r\n     * @returns {string}\r\n     */\r\n    svg(attrs = {}) {\r\n        const width = this.xmax - this.xmin;\r\n        const height = this.ymax - this.ymin;\r\n        return `\\n<rect x=\"${this.xmin}\" y=\"${this.ymin}\" width=\"${width}\" height=\"${height}\"\r\n                ${convertToString({fill: \"none\", ...attrs})} />`;\r\n    };\r\n}\r\n\r\nFlatten.Box = Box;\r\n/**\r\n * Shortcut to create new box\r\n * @param args\r\n * @returns {Box}\r\n */\r\nconst box = (...args) => new Flatten.Box(...args);\r\nFlatten.box = box;\r\n\r\n/**\r\n * Created by Alex Bol on 3/17/2017.\r\n */\r\n\r\n\r\n/**\r\n * Class representing an edge of polygon. Edge shape may be Segment or Arc.\r\n * Each edge contains references to the next and previous edges in the face of the polygon.\r\n *\r\n * @type {Edge}\r\n */\r\nclass Edge {\r\n    /**\r\n     * Construct new instance of edge\r\n     * @param {Shape} shape Shape of type Segment or Arc\r\n     */\r\n    constructor(shape) {\r\n        /**\r\n         * Shape of the edge: Segment or Arc\r\n         * @type {Segment|Arc}\r\n         */\r\n        this.shape = shape;\r\n        /**\r\n         * Pointer to the next edge in the face\r\n         * @type {Edge}\r\n         */\r\n        this.next = undefined;\r\n        /**\r\n         * Pointer to the previous edge in the face\r\n         * @type {Edge}\r\n         */\r\n        this.prev = undefined;\r\n        /**\r\n         * Pointer to the face containing this edge\r\n         * @type {Face}\r\n         */\r\n        this.face = undefined;\r\n        /**\r\n         * \"Arc distance\" from the face start\r\n         * @type {number}\r\n         */\r\n        this.arc_length = 0;\r\n        /**\r\n         * Start inclusion flag (inside/outside/boundary)\r\n         * @type {*}\r\n         */\r\n        this.bvStart = undefined;\r\n        /**\r\n         * End inclusion flag (inside/outside/boundary)\r\n         * @type {*}\r\n         */\r\n        this.bvEnd = undefined;\r\n        /**\r\n         * Edge inclusion flag (Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY)\r\n         * @type {*}\r\n         */\r\n        this.bv = undefined;\r\n        /**\r\n         * Overlap flag for boundary edge (Flatten.OVERLAP_SAME/Flatten.OVERLAP_OPPOSITE)\r\n         * @type {*}\r\n         */\r\n        this.overlap = undefined;\r\n    }\r\n\r\n    /**\r\n     * Get edge start point\r\n     */\r\n    get start() {\r\n        return this.shape.start;\r\n    }\r\n\r\n    /**\r\n     * Get edge end point\r\n     */\r\n    get end() {\r\n        return this.shape.end;\r\n    }\r\n\r\n    /**\r\n     * Get edge length\r\n     */\r\n    get length() {\r\n        return this.shape.length;\r\n    }\r\n\r\n    /**\r\n     * Get bounding box of the edge\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        return this.shape.box;\r\n    }\r\n\r\n    get isSegment() {\r\n        return this.shape instanceof Flatten.Segment;\r\n    }\r\n\r\n    get isArc() {\r\n        return this.shape instanceof Flatten.Arc;\r\n    }\r\n\r\n    get isLine() {\r\n        return this.shape instanceof Flatten.Line;\r\n    }\r\n\r\n    get isRay() {\r\n        return this.shape instanceof Flatten.Ray\r\n    }\r\n\r\n    /**\r\n     * Get middle point of the edge\r\n     * @returns {Point}\r\n     */\r\n    middle() {\r\n        return this.shape.middle();\r\n    }\r\n\r\n    /**\r\n     * Get point at given length\r\n     * @param {number} length - The length along the edge\r\n     * @returns {Point}\r\n     */\r\n    pointAtLength(length) {\r\n        return this.shape.pointAtLength(length);\r\n    }\r\n\r\n    /**\r\n     * Returns true if point belongs to the edge, false otherwise\r\n     * @param {Point} pt - test point\r\n     */\r\n    contains(pt) {\r\n        return this.shape.contains(pt);\r\n    }\r\n\r\n    /**\r\n     * Set inclusion flag of the edge with respect to another polygon\r\n     * Inclusion flag is one of Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY\r\n     * @param polygon\r\n     */\r\n    setInclusion(polygon) {\r\n        if (this.bv !== undefined) return this.bv;\r\n\r\n        if (this.shape instanceof Flatten.Line || this.shape instanceof Flatten.Ray) {\r\n            this.bv = Flatten.OUTSIDE;\r\n            return this.bv;\r\n        }\r\n\r\n        if (this.bvStart === undefined) {\r\n            this.bvStart = ray_shoot(polygon, this.start);\r\n        }\r\n        if (this.bvEnd === undefined) {\r\n            this.bvEnd = ray_shoot(polygon, this.end);\r\n        }\r\n        /* At least one end outside - the whole edge outside */\r\n        if (this.bvStart === Flatten.OUTSIDE || this.bvEnd == Flatten.OUTSIDE) {\r\n            this.bv = Flatten.OUTSIDE;\r\n        }\r\n        /* At least one end inside - the whole edge inside */\r\n        else if (this.bvStart === Flatten.INSIDE || this.bvEnd == Flatten.INSIDE) {\r\n            this.bv = Flatten.INSIDE;\r\n        }\r\n        /* Both are boundary - check the middle point */\r\n        else {\r\n            let bvMiddle = ray_shoot(polygon, this.middle());\r\n            // let boundary = this.middle().distanceTo(polygon)[0] < 10*Flatten.DP_TOL;\r\n            // let bvMiddle = boundary ? Flatten.BOUNDARY : ray_shoot(polygon, this.middle());\r\n            this.bv = bvMiddle;\r\n        }\r\n        return this.bv;\r\n    }\r\n\r\n    /**\r\n     * Set overlapping between two coincident boundary edges\r\n     * Overlapping flag is one of Flatten.OVERLAP_SAME or Flatten.OVERLAP_OPPOSITE\r\n     * @param edge\r\n     */\r\n    setOverlap(edge) {\r\n        let flag = undefined;\r\n        let shape1 = this.shape;\r\n        let shape2 = edge.shape;\r\n\r\n        if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Segment) {\r\n            if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end)) {\r\n                flag = Flatten.OVERLAP_SAME;\r\n            } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start)) {\r\n                flag = Flatten.OVERLAP_OPPOSITE;\r\n            }\r\n        } else if (shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Arc) {\r\n            if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && /*shape1.counterClockwise === shape2.counterClockwise &&*/\r\n                shape1.middle().equalTo(shape2.middle())) {\r\n                flag = Flatten.OVERLAP_SAME;\r\n            } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && /*shape1.counterClockwise !== shape2.counterClockwise &&*/\r\n                shape1.middle().equalTo(shape2.middle())) {\r\n                flag = Flatten.OVERLAP_OPPOSITE;\r\n            }\r\n        } else if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Arc ||\r\n            shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Segment) {\r\n            if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && shape1.middle().equalTo(shape2.middle())) {\r\n                flag = Flatten.OVERLAP_SAME;\r\n            } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && shape1.middle().equalTo(shape2.middle())) {\r\n                flag = Flatten.OVERLAP_OPPOSITE;\r\n            }\r\n        }\r\n\r\n        /* Do not update overlap flag if already set on previous chain */\r\n        if (this.overlap === undefined) this.overlap = flag;\r\n        if (edge.overlap === undefined) edge.overlap = flag;\r\n    }\r\n\r\n    svg() {\r\n        if (this.shape instanceof Flatten.Segment) {\r\n            return ` L${this.shape.end.x},${this.shape.end.y}`;\r\n        } else if (this.shape instanceof Flatten.Arc) {\r\n            let arc = this.shape;\r\n            let largeArcFlag;\r\n            let sweepFlag = arc.counterClockwise ? \"1\" : \"0\";\r\n\r\n            // Draw full circe arc as special case: split it into two half-circles\r\n            if (Flatten.Utils.EQ(arc.sweep, 2 * Math.PI)) {\r\n                let sign = arc.counterClockwise ? 1 : -1;\r\n                let halfArc1 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle, arc.startAngle + sign * Math.PI, arc.counterClockwise);\r\n                let halfArc2 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle + sign * Math.PI, arc.endAngle, arc.counterClockwise);\r\n\r\n                largeArcFlag = \"0\";\r\n\r\n                return ` A${halfArc1.r},${halfArc1.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc1.end.x},${halfArc1.end.y}\r\n                    A${halfArc2.r},${halfArc2.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc2.end.x},${halfArc2.end.y}`\r\n            } else {\r\n                largeArcFlag = arc.sweep <= Math.PI ? \"0\" : \"1\";\r\n\r\n                return ` A${arc.r},${arc.r} 0 ${largeArcFlag},${sweepFlag} ${arc.end.x},${arc.end.y}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    toJSON() {\r\n        return this.shape.toJSON();\r\n    }\r\n}\r\nFlatten.Edge = Edge;\r\n\r\n/**\r\n * Class implements circular bidirectional linked list <br/>\r\n * LinkedListElement - object of any type that has properties next and prev.\r\n */\r\nclass CircularLinkedList extends LinkedList {\r\n    constructor(first, last) {\r\n        super(first, last);\r\n        this.setCircularLinks();\r\n    }\r\n\r\n    setCircularLinks() {\r\n        if (this.isEmpty()) return;\r\n        this.last.next = this.first;\r\n        this.first.prev = this.last;\r\n    }\r\n\r\n    [Symbol.iterator]() {\r\n        let element = undefined;\r\n        return {\r\n            next: () => {\r\n                let value = element ? element : this.first;\r\n                let done = this.first ? (element ? element === this.first : false) : true;\r\n                element = value ? value.next : undefined;\r\n                return {value: value, done: done};\r\n            }\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Append new element to the end of the list\r\n     * @param {LinkedListElement} element - new element to be appended\r\n     * @returns {CircularLinkedList}\r\n     */\r\n    append(element) {\r\n        super.append(element);\r\n        this.setCircularLinks();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Insert new element to the list after elementBefore\r\n     * @param {LinkedListElement} newElement - new element to be inserted\r\n     * @param {LinkedListElement} elementBefore - element in the list to insert after it\r\n     * @returns {CircularLinkedList}\r\n     */\r\n    insert(newElement, elementBefore) {\r\n        super.insert(newElement, elementBefore);\r\n        this.setCircularLinks();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove element from the list\r\n     * @param {LinkedListElement} element - element to be removed from the list\r\n     * @returns {CircularLinkedList}\r\n     */\r\n    remove(element) {\r\n        super.remove(element);\r\n        // this.setCircularLinks();\r\n        return this;\r\n    }\r\n}\r\n\r\n/**\r\n * Created by Alex Bol on 3/17/2017.\r\n */\r\n\r\n\r\n/**\r\n * Class representing a face (closed loop) in a [polygon]{@link Flatten.Polygon} object.\r\n * Face is a circular bidirectionally linked list of [edges]{@link Flatten.Edge}.\r\n * Face object cannot be instantiated with a constructor.\r\n * Instead, use [polygon.addFace()]{@link Flatten.Polygon#addFace} method.\r\n * <br/>\r\n * Note, that face only set entry point to the linked list of edges but does not contain edges by itself.\r\n * Container of edges is a property of the polygon object. <br/>\r\n *\r\n * @example\r\n * // Face implements \"next\" iterator which enables to iterate edges in for loop:\r\n * for (let edge of face) {\r\n *      console.log(edge.shape.length)     // do something\r\n * }\r\n *\r\n * // Instead, it is possible to iterate edges as linked list, starting from face.first:\r\n * let edge = face.first;\r\n * do {\r\n *   console.log(edge.shape.length);   // do something\r\n *   edge = edge.next;\r\n * } while (edge != face.first)\r\n */\r\nclass Face extends CircularLinkedList {\r\n    constructor(polygon, ...args) {\r\n        super();            // construct empty list of edges\r\n        /**\r\n         * Reference to the first edge in face\r\n         */\r\n        // this.first;\r\n        /**\r\n         * Reference to the last edge in face\r\n         */\r\n        // this.last;\r\n\r\n        this._box = undefined;  // new Box();\r\n        this._orientation = undefined;\r\n\r\n        if (args.length === 0) {\r\n            return;\r\n        }\r\n\r\n        /* If passed an array it supposed to be:\r\n         1) array of shapes that performs close loop or\r\n         2) array of points that performs set of vertices\r\n         */\r\n        if (args.length === 1) {\r\n            if (args[0] instanceof Array) {\r\n                // let argsArray = args[0];\r\n                let shapes = args[0];  // argsArray[0];\r\n                if (shapes.length === 0)\r\n                    return;\r\n\r\n                /* array of Flatten.Points */\r\n                if (shapes.every((shape) => {return shape instanceof Flatten.Point})) {\r\n                    let segments = Face.points2segments(shapes);\r\n                    this.shapes2face(polygon.edges, segments);\r\n                }\r\n                /* array of points as pairs of numbers */\r\n                else if (shapes.every((shape) => {return shape instanceof Array && shape.length === 2})) {\r\n                    let points = shapes.map((shape) => new Flatten.Point(shape[0],shape[1]));\r\n                    let segments = Face.points2segments(points);\r\n                    this.shapes2face(polygon.edges, segments);\r\n                }\r\n                /* array of segments ot arcs */\r\n                else if (shapes.every((shape) => {\r\n                    return (shape instanceof Flatten.Segment || shape instanceof Flatten.Arc)\r\n                })) {\r\n                    this.shapes2face(polygon.edges, shapes);\r\n                }\r\n                // this is from JSON.parse object\r\n                else if (shapes.every((shape) => {\r\n                    return (shape.name === \"segment\" || shape.name === \"arc\")\r\n                })) {\r\n                    let flattenShapes = [];\r\n                    for (let shape of shapes) {\r\n                        let flattenShape;\r\n                        if (shape.name === \"segment\") {\r\n                            flattenShape = new Flatten.Segment(shape);\r\n                        } else {\r\n                            flattenShape = new Flatten.Arc(shape);\r\n                        }\r\n                        flattenShapes.push(flattenShape);\r\n                    }\r\n                    this.shapes2face(polygon.edges, flattenShapes);\r\n                }\r\n            }\r\n            /* Create new face and copy edges into polygon.edges set */\r\n            else if (args[0] instanceof Face) {\r\n                let face = args[0];\r\n                this.first = face.first;\r\n                this.last = face.last;\r\n                for (let edge of face) {\r\n                    polygon.edges.add(edge);\r\n                }\r\n            }\r\n            /* Instantiate face from a circle in CCW orientation */\r\n            else if (args[0] instanceof Flatten.Circle) {\r\n                this.shapes2face(polygon.edges, [args[0].toArc(CCW)]);\r\n            }\r\n            /* Instantiate face from a box in CCW orientation */\r\n            else if (args[0] instanceof Flatten.Box) {\r\n                let box = args[0];\r\n                this.shapes2face(polygon.edges, [\r\n                    new Flatten.Segment(new Flatten.Point(box.xmin, box.ymin), new Flatten.Point(box.xmax, box.ymin)),\r\n                    new Flatten.Segment(new Flatten.Point(box.xmax, box.ymin), new Flatten.Point(box.xmax, box.ymax)),\r\n                    new Flatten.Segment(new Flatten.Point(box.xmax, box.ymax), new Flatten.Point(box.xmin, box.ymax)),\r\n                    new Flatten.Segment(new Flatten.Point(box.xmin, box.ymax), new Flatten.Point(box.xmin, box.ymin))\r\n                ]);\r\n            }\r\n        }\r\n        /* If passed two edges, consider them as start and end of the face loop */\r\n        /* THIS METHOD WILL BE USED BY BOOLEAN OPERATIONS */\r\n        /* Assume that edges already copied to polygon.edges set in the clip algorithm !!! */\r\n        if (args.length === 2 && args[0] instanceof Flatten.Edge && args[1] instanceof Flatten.Edge) {\r\n            this.first = args[0];                          // first edge in face or undefined\r\n            this.last = args[1];                           // last edge in face or undefined\r\n            this.last.next = this.first;\r\n            this.first.prev = this.last;\r\n\r\n            // set arc length\r\n            this.setArcLength();\r\n\r\n            // this.box = this.getBox();\r\n            // this.orientation = this.getOrientation();      // face direction cw or ccw\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return array of edges from first to last\r\n     * @returns {Array}\r\n     */\r\n    get edges() {\r\n        return this.toArray();\r\n    }\r\n\r\n    /**\r\n     * Return array of shapes which comprise face\r\n     * @returns {Array}\r\n     */\r\n    get shapes() {\r\n        return this.edges.map(edge => edge.shape.clone());\r\n    }\r\n\r\n    /**\r\n     * Return bounding box of the face\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        if (this._box === undefined) {\r\n            let box = new Flatten.Box();\r\n            for (let edge of this) {\r\n                box = box.merge(edge.box);\r\n            }\r\n            this._box = box;\r\n        }\r\n        return this._box;\r\n    }\r\n\r\n    /**\r\n     * Get all edges length\r\n     * @returns {number}\r\n     */\r\n    get perimeter() {\r\n        return this.last.arc_length + this.last.length\r\n    }\r\n\r\n    /**\r\n     * Get point on face boundary at given length\r\n     * @param {number} length - The length along the face boundary\r\n     * @returns {Point}\r\n     */\r\n    pointAtLength(length) {\r\n        if (length > this.perimeter || length < 0) return null;\r\n        let point = null;\r\n        for (let edge of this) {\r\n            if (length >= edge.arc_length &&\r\n                (edge === this.last || length < edge.next.arc_length)) {\r\n                point = edge.pointAtLength(length - edge.arc_length);\r\n                break;\r\n            }\r\n        }\r\n        return point;\r\n    }\r\n\r\n    static points2segments(points) {\r\n        let segments = [];\r\n        for (let i = 0; i < points.length; i++) {\r\n            // skip zero length segment\r\n            if (points[i].equalTo(points[(i + 1) % points.length]))\r\n                continue;\r\n            segments.push(new Flatten.Segment(points[i], points[(i + 1) % points.length]));\r\n        }\r\n        return segments;\r\n    }\r\n\r\n    shapes2face(edges, shapes) {\r\n        for (let shape of shapes) {\r\n            let edge = new Flatten.Edge(shape);\r\n            this.append(edge);\r\n            // this.box = this.box.merge(shape.box);\r\n            edges.add(edge);\r\n        }\r\n        // this.orientation = this.getOrientation();              // face direction cw or ccw\r\n    }\r\n\r\n    /**\r\n     * Append edge after the last edge of the face (and before the first edge). <br/>\r\n     * @param {Edge} edge - Edge to be appended to the linked list\r\n     * @returns {Face}\r\n     */\r\n    append(edge) {\r\n        super.append(edge);\r\n        // set arc length\r\n        this.setOneEdgeArcLength(edge);\r\n        edge.face = this;\r\n        // edges.add(edge);      // Add new edges into edges container\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Insert edge newEdge into the linked list after the edge edgeBefore <br/>\r\n     * @param {Edge} newEdge - Edge to be inserted into linked list\r\n     * @param {Edge} edgeBefore - Edge to insert newEdge after it\r\n     * @returns {Face}\r\n     */\r\n    insert(newEdge, edgeBefore) {\r\n        super.insert(newEdge, edgeBefore);\r\n        // set arc length\r\n        this.setOneEdgeArcLength(newEdge);\r\n        newEdge.face = this;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove the given edge from the linked list of the face <br/>\r\n     * @param {Edge} edge - Edge to be removed\r\n     * @returns {Face}\r\n     */\r\n    remove(edge) {\r\n        super.remove(edge);\r\n        // Recalculate arc length\r\n        this.setArcLength();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Merge current edge with the next edge. Given edge will be extended,\r\n     * next edge after it will be removed. The distortion of the polygon\r\n     * is on the responsibility of the user of this method\r\n     * @param {Edge} edge - edge to be extended\r\n     * @returns {Face}\r\n     */\r\n    merge_with_next_edge(edge) {\r\n        edge.shape.end.x = edge.next.shape.end.x;\r\n        edge.shape.end.y = edge.next.shape.end.y;\r\n        this.remove(edge.next);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reverse orientation of the face: first edge become last and vice a verse,\r\n     * all edges starts and ends swapped, direction of arcs inverted. If face was oriented\r\n     * clockwise, it becomes counterclockwise and vice versa\r\n     */\r\n    reverse() {\r\n        // collect edges in revert order with reverted shapes\r\n        let edges = [];\r\n        let edge_tmp = this.last;\r\n        do {\r\n            // reverse shape\r\n            edge_tmp.shape = edge_tmp.shape.reverse();\r\n            edges.push(edge_tmp);\r\n            edge_tmp = edge_tmp.prev;\r\n        } while (edge_tmp !== this.last);\r\n\r\n        // restore linked list\r\n        this.first = undefined;\r\n        this.last = undefined;\r\n        for (let edge of edges) {\r\n            if (this.first === undefined) {\r\n                edge.prev = edge;\r\n                edge.next = edge;\r\n                this.first = edge;\r\n                this.last = edge;\r\n            } else {\r\n                // append to end\r\n                edge.prev = this.last;\r\n                this.last.next = edge;\r\n\r\n                // update edge to be last\r\n                this.last = edge;\r\n\r\n                // restore circular links\r\n                this.last.next = this.first;\r\n                this.first.prev = this.last;\r\n\r\n            }\r\n            // set arc length\r\n            this.setOneEdgeArcLength(edge);\r\n        }\r\n\r\n        // Recalculate orientation, if set\r\n        if (this._orientation !== undefined) {\r\n            this._orientation = undefined;\r\n            this._orientation = this.orientation();\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Set arc_length property for each of the edges in the face.\r\n     * Arc_length of the edge it the arc length from the first edge of the face\r\n     */\r\n    setArcLength() {\r\n        for (let edge of this) {\r\n            this.setOneEdgeArcLength(edge);\r\n            edge.face = this;\r\n        }\r\n    }\r\n\r\n    setOneEdgeArcLength(edge) {\r\n        if (edge === this.first) {\r\n            edge.arc_length = 0.0;\r\n        } else {\r\n            edge.arc_length = edge.prev.arc_length + edge.prev.length;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the absolute value of the area of the face\r\n     * @returns {number}\r\n     */\r\n    area() {\r\n        return Math.abs(this.signedArea());\r\n    }\r\n\r\n    /**\r\n     * Returns signed area of the simple face.\r\n     * Face is simple if it has no self intersections that change its orientation.\r\n     * Then the area will be positive if the orientation of the face is clockwise,\r\n     * and negative if orientation is counterclockwise.\r\n     * It may be zero if polygon is degenerated.\r\n     * @returns {number}\r\n     */\r\n    signedArea() {\r\n        let sArea = 0;\r\n        let ymin = this.box.ymin;\r\n        for (let edge of this) {\r\n            sArea += edge.shape.definiteIntegral(ymin);\r\n        }\r\n        return sArea;\r\n    }\r\n\r\n    /**\r\n     * Return face orientation: one of Flatten.ORIENTATION.CCW, Flatten.ORIENTATION.CW, Flatten.ORIENTATION.NOT_ORIENTABLE <br/>\r\n     * According to Green theorem the area of a closed curve may be calculated as double integral,\r\n     * and the sign of the integral will be defined by the direction of the curve.\r\n     * When the integral (\"signed area\") will be negative, direction is counterclockwise,\r\n     * when positive - clockwise and when it is zero, polygon is not orientable.\r\n     * See {@link https://mathinsight.org/greens_theorem_find_area}\r\n     * @returns {number}\r\n     */\r\n    orientation() {\r\n        if (this._orientation === undefined) {\r\n            let area = this.signedArea();\r\n            if (Flatten.Utils.EQ_0(area)) {\r\n                this._orientation = ORIENTATION.NOT_ORIENTABLE;\r\n            } else if (Flatten.Utils.LT(area, 0)) {\r\n                this._orientation = ORIENTATION.CCW;\r\n            } else {\r\n                this._orientation = ORIENTATION.CW;\r\n            }\r\n        }\r\n        return this._orientation;\r\n    }\r\n\r\n    /**\r\n     * Returns true if face of the polygon is simple (no self-intersection points found)\r\n     * NOTE: this method is incomplete because it does not exclude touching points.\r\n     * Self intersection test should check if polygon change orientation in the test point.\r\n     * @param {PlanarSet} edges - reference to polygon edges to provide search index\r\n     * @returns {boolean}\r\n     */\r\n    isSimple(edges) {\r\n        let ip = Face.getSelfIntersections(this, edges, true);\r\n        return ip.length === 0;\r\n    }\r\n\r\n    static getSelfIntersections(face, edges, exitOnFirst = false) {\r\n        let int_points = [];\r\n\r\n        // calculate intersections\r\n        for (let edge1 of face) {\r\n\r\n            // request edges of polygon in the box of edge1\r\n            let resp = edges.search(edge1.box);\r\n\r\n            // for each edge2 in response\r\n            for (let edge2 of resp) {\r\n\r\n                // Skip itself\r\n                if (edge1 === edge2)\r\n                    continue;\r\n\r\n                // Skip is edge2 belongs to another face\r\n                if (edge2.face !== face)\r\n                    continue;\r\n\r\n                // Skip next and previous edge if both are segment (if one of them arc - calc intersection)\r\n                if (edge1.shape instanceof Flatten.Segment && edge2.shape instanceof Flatten.Segment &&\r\n                    (edge1.next === edge2 || edge1.prev === edge2))\r\n                    continue;\r\n\r\n                // calculate intersections between edge1 and edge2\r\n                let ip = edge1.shape.intersect(edge2.shape);\r\n\r\n                // for each intersection point\r\n                for (let pt of ip) {\r\n\r\n                    // skip start-end connections\r\n                    if (pt.equalTo(edge1.start) && pt.equalTo(edge2.end) && edge2 === edge1.prev)\r\n                        continue;\r\n                    if (pt.equalTo(edge1.end) && pt.equalTo(edge2.start) && edge2 === edge1.next)\r\n                        continue;\r\n\r\n                    int_points.push(pt);\r\n\r\n                    if (exitOnFirst)\r\n                        break;\r\n                }\r\n\r\n                if (int_points.length > 0 && exitOnFirst)\r\n                    break;\r\n            }\r\n\r\n            if (int_points.length > 0 && exitOnFirst)\r\n                break;\r\n\r\n        }\r\n        return int_points;\r\n    }\r\n\r\n    /**\r\n     * Returns edge which contains given point\r\n     * @param {Point} pt - test point\r\n     * @returns {Edge}\r\n     */\r\n    findEdgeByPoint(pt) {\r\n        let edgeFound;\r\n        for (let edge of this) {\r\n            if (pt.equalTo(edge.shape.start)) continue\r\n            if (pt.equalTo(edge.shape.end) || edge.shape.contains(pt)) {\r\n                edgeFound = edge;\r\n                break;\r\n            }\r\n        }\r\n        return edgeFound;\r\n    }\r\n\r\n    /**\r\n     * Returns new polygon created from one face\r\n     * @returns {Polygon}\r\n     */\r\n    toPolygon() {\r\n        return new Flatten.Polygon(this.shapes);\r\n    }\r\n\r\n    toJSON() {\r\n        return this.edges.map(edge => edge.toJSON());\r\n    }\r\n\r\n    /**\r\n     * Returns string to be assigned to \"d\" attribute inside defined \"path\"\r\n     * @returns {string}\r\n     */\r\n    svg() {\r\n        let svgStr = `M${this.first.start.x},${this.first.start.y}`;\r\n        for (let edge of this) {\r\n            svgStr += edge.svg();\r\n        }\r\n        svgStr += ` z`;\r\n        return svgStr;\r\n    }\r\n\r\n}\r\n\r\nFlatten.Face = Face;\r\n\r\n/**\r\n * Class representing a ray (a half-infinite line).\r\n * @type {Ray}\r\n */\r\nclass Ray extends Shape {\r\n    /**\r\n     * Ray may be constructed by setting an <b>origin</b> point and a <b>normal</b> vector, so that any point <b>x</b>\r\n     * on a ray fit an equation: <br />\r\n     *  (<b>x</b> - <b>origin</b>) * <b>vector</b> = 0 <br />\r\n     * Ray defined by constructor is a right semi-infinite line with respect to the normal vector <br/>\r\n     * If normal vector is omitted ray is considered horizontal (normal vector is (0,1)). <br/>\r\n     * Don't be confused: direction of the normal vector is orthogonal to the ray <br/>\r\n     * @param {Point} pt - start point\r\n     * @param {Vector} norm - normal vector\r\n     */\r\n    constructor(...args) {\r\n        super();\r\n        this.pt = new Flatten.Point();\r\n        this.norm = new Flatten.Vector(0,1);\r\n\r\n        if (args.length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (args.length >= 1 && args[0] instanceof Flatten.Point) {\r\n            this.pt = args[0].clone();\r\n        }\r\n\r\n        if (args.length === 1) {\r\n            return;\r\n        }\r\n\r\n        if (args.length === 2 && args[1] instanceof Flatten.Vector) {\r\n            this.norm = args[1].clone();\r\n            return;\r\n        }\r\n\r\n        throw Errors.ILLEGAL_PARAMETERS;\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of ray\r\n     * @returns {Ray}\r\n     */\r\n    clone() {\r\n        return new Ray(this.pt, this.norm);\r\n    }\r\n\r\n    /**\r\n     * Slope of the ray - angle in radians between ray and axe x from 0 to 2PI\r\n     * @returns {number} - slope of the line\r\n     */\r\n    get slope() {\r\n        let vec = new Flatten.Vector(this.norm.y, -this.norm.x);\r\n        return vec.slope;\r\n    }\r\n\r\n    /**\r\n     * Returns half-infinite bounding box of the ray\r\n     * @returns {Box} - bounding box\r\n     */\r\n    get box() {\r\n        let slope = this.slope;\r\n        return new Flatten.Box(\r\n            slope > Math.PI/2 && slope < 3*Math.PI/2 ? Number.NEGATIVE_INFINITY : this.pt.x,\r\n            slope >= 0 && slope <= Math.PI ? this.pt.y : Number.NEGATIVE_INFINITY,\r\n            slope >= Math.PI/2 && slope <= 3*Math.PI/2 ? this.pt.x : Number.POSITIVE_INFINITY,\r\n            slope >= Math.PI && slope <= 2*Math.PI || slope === 0 ? this.pt.y : Number.POSITIVE_INFINITY\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Return ray start point\r\n     * @returns {Point} - ray start point\r\n     */\r\n    get start() {\r\n        return this.pt;\r\n    }\r\n\r\n    /**\r\n     * Ray has no end point?\r\n     * @returns {undefined}\r\n     */\r\n    get end() {return undefined;}\r\n\r\n    /**\r\n     * Return positive infinity number as length\r\n     * @returns {number}\r\n     */\r\n    get length() {return Number.POSITIVE_INFINITY;}\r\n\r\n    /**\r\n     * Returns true if point belongs to ray\r\n     * @param {Point} pt Query point\r\n     * @returns {boolean}\r\n     */\r\n    contains(pt) {\r\n        if (this.pt.equalTo(pt)) {\r\n            return true;\r\n        }\r\n        /* Ray contains point if vector to point is orthogonal to the ray normal vector\r\n            and cross product from vector to point is positive */\r\n        let vec = new Flatten.Vector(this.pt, pt);\r\n        return Flatten.Utils.EQ_0(this.norm.dot(vec)) && Flatten.Utils.GE(vec.cross(this.norm),0);\r\n    }\r\n\r\n    /**\r\n     * Return coordinate of the point that lies on the ray in the transformed\r\n     * coordinate system where center is the projection of the point(0,0) to\r\n     * the line containing this ray and axe y is collinear to the normal vector. <br/>\r\n     * This method assumes that point lies on the ray\r\n     * @param {Point} pt - point on a ray\r\n     * @returns {number}\r\n     */\r\n    coord(pt) {\r\n        return vector$1(pt.x, pt.y).cross(this.norm);\r\n    }\r\n\r\n    /**\r\n     * Split ray with point and return array of segment and new ray\r\n     * @param {Point} pt\r\n     * @returns [Segment,Ray]\r\n     */\r\n    split(pt) {\r\n        if (!this.contains(pt))\r\n            return [];\r\n\r\n        if (this.pt.equalTo(pt)) {\r\n            return [this]\r\n        }\r\n\r\n        return [\r\n            new Flatten.Segment(this.pt, pt),\r\n            new Flatten.Ray(pt, this.norm)\r\n        ]\r\n    }\r\n\r\n    /**\r\n     * Returns array of intersection points between ray and another shape\r\n     * @param {Shape} shape - Shape to intersect with ray\r\n     * @returns {Point[]} array of intersection points\r\n     */\r\n    intersect(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            return this.contains(shape) ? [shape] : [];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            return intersectRay2Segment(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            return intersectRay2Arc(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Line) {\r\n            return intersectRay2Line(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Ray) {\r\n            return intersectRay2Ray(this, shape)\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            return intersectRay2Circle(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Box) {\r\n            return intersectRay2Box(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            return  intersectRay2Polygon(this, shape);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return new line rotated by angle\r\n     * @param {number} angle - angle in radians\r\n     * @param {Point} center - center of rotation\r\n     */\r\n    rotate(angle, center = new Flatten.Point()) {\r\n        return new Flatten.Ray(\r\n            this.pt.rotate(angle, center),\r\n            this.norm.rotate(angle)\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Return new ray transformed by affine transformation matrix\r\n     * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\r\n     * @returns {Ray}\r\n     */\r\n    transform(m) {\r\n        return new Flatten.Ray(\r\n            this.pt.transform(m),\r\n            this.norm.clone()\r\n        )\r\n    }\r\n\r\n    get name() {\r\n        return \"ray\"\r\n    }\r\n\r\n    /**\r\n     * Return string to draw svg segment representing ray inside given box\r\n     * @param {Box} box Box representing drawing area\r\n     * @param {Object} attrs - an object with attributes of svg segment element\r\n     */\r\n    svg(box, attrs = {}) {\r\n        let line = new Flatten.Line(this.pt, this.norm);\r\n        let ip = intersectLine2Box(line, box);\r\n        ip = ip.filter( pt => this.contains(pt) );\r\n        if (ip.length === 0 || ip.length === 2)\r\n            return \"\";\r\n        let segment = new Flatten.Segment(this.pt, ip[0]);\r\n        return segment.svg(attrs);\r\n    }\r\n\r\n}\r\n\r\nFlatten.Ray = Ray;\r\n\r\nconst ray = (...args) => new Flatten.Ray(...args);\r\nFlatten.ray = ray;\r\n\r\n/**\r\n * Created by Alex Bol on 3/15/2017.\r\n */\r\n\r\n\r\n/**\r\n * Class representing a polygon.<br/>\r\n * Polygon in FlattenJS is a multipolygon comprised from a set of [faces]{@link Flatten.Face}. <br/>\r\n * Face, in turn, is a closed loop of [edges]{@link Flatten.Edge}, where edge may be segment or circular arc<br/>\r\n * @type {Polygon}\r\n */\r\nlet Polygon$1 = class Polygon {\r\n    /**\r\n     * Constructor creates new instance of polygon. With no arguments new polygon is empty.<br/>\r\n     * Constructor accepts as argument array that define loop of shapes\r\n     * or array of arrays in case of multi polygon <br/>\r\n     * Loop may be defined in different ways: <br/>\r\n     * - array of shapes of type Segment or Arc <br/>\r\n     * - array of points (Flatten.Point) <br/>\r\n     * - array of numeric pairs which represent points <br/>\r\n     * - box or circle object <br/>\r\n     * Alternatively, it is possible to use polygon.addFace method\r\n     * @param {args} - array of shapes or array of arrays\r\n     */\r\n    constructor() {\r\n        /**\r\n         * Container of faces (closed loops), may be empty\r\n         * @type {PlanarSet}\r\n         */\r\n        this.faces = new Flatten.PlanarSet();\r\n        /**\r\n         * Container of edges\r\n         * @type {PlanarSet}\r\n         */\r\n        this.edges = new Flatten.PlanarSet();\r\n\r\n        /* It may be array of something that may represent one loop (face) or\r\n         array of arrays that represent multiple loops\r\n         */\r\n        let args = [...arguments];\r\n        if (args.length === 1 &&\r\n            ((args[0] instanceof Array && args[0].length > 0) ||\r\n                args[0] instanceof Flatten.Circle || args[0] instanceof Flatten.Box)) {\r\n            let argsArray = args[0];\r\n            if (args[0] instanceof Array && args[0].every((loop) => {\r\n                return loop instanceof Array\r\n            })) {\r\n                if (argsArray.every(el => {\r\n                    return el instanceof Array && el.length === 2 && typeof (el[0]) === \"number\" && typeof (el[1]) === \"number\"\r\n                })) {\r\n                    this.faces.add(new Flatten.Face(this, argsArray));    // one-loop polygon as array of pairs of numbers\r\n                } else {\r\n                    for (let loop of argsArray) {   // multi-loop polygon\r\n                        /* Check extra level of nesting for GeoJSON-style multi polygons */\r\n                        if (loop instanceof Array && loop[0] instanceof Array &&\r\n                            loop[0].every(el => {\r\n                                return el instanceof Array && el.length === 2 && typeof (el[0]) === \"number\" && typeof (el[1]) === \"number\"\r\n                            })) {\r\n                            for (let loop1 of loop) {\r\n                                this.faces.add(new Flatten.Face(this, loop1));\r\n                            }\r\n                        } else {\r\n                            this.faces.add(new Flatten.Face(this, loop));\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                this.faces.add(new Flatten.Face(this, argsArray));    // one-loop polygon\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * (Getter) Returns bounding box of the polygon\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        return [...this.faces].reduce((acc, face) => acc.merge(face.box), new Flatten.Box());\r\n    }\r\n\r\n    /**\r\n     * (Getter) Returns array of vertices\r\n     * @returns {Array}\r\n     */\r\n    get vertices() {\r\n        return [...this.edges].map(edge => edge.start);\r\n    }\r\n\r\n    /**\r\n     * Create new cloned instance of the polygon\r\n     * @returns {Polygon}\r\n     */\r\n    clone() {\r\n        let polygon = new Polygon();\r\n        for (let face of this.faces) {\r\n            polygon.addFace(face.shapes);\r\n        }\r\n        return polygon;\r\n    }\r\n\r\n    /**\r\n     * Return true is polygon has no edges\r\n     * @returns {boolean}\r\n     */\r\n    isEmpty() {\r\n        return this.edges.size === 0;\r\n    }\r\n\r\n    /**\r\n     * Return true if polygon is valid for boolean operations\r\n     * Polygon is valid if <br/>\r\n     * 1. All faces are simple polygons (there are no self-intersected polygons) <br/>\r\n     * 2. All faces are orientable and there is no island inside island or hole inside hole - TODO <br/>\r\n     * 3. There is no intersections between faces (excluding touching) - TODO <br/>\r\n     * @returns {boolean}\r\n     */\r\n    isValid() {\r\n        let valid = true;\r\n        // 1. Polygon is invalid if at least one face is not simple\r\n        for (let face of this.faces) {\r\n            if (!face.isSimple(this.edges)) {\r\n                valid = false;\r\n                break;\r\n            }\r\n        }\r\n        // 2. TODO: check if no island inside island and no hole inside hole\r\n        // 3. TODO: check the there is no intersection between faces\r\n        return valid;\r\n    }\r\n\r\n    /**\r\n     * Returns area of the polygon. Area of an island will be added, area of a hole will be subtracted\r\n     * @returns {number}\r\n     */\r\n    area() {\r\n        let signedArea = [...this.faces].reduce((acc, face) => acc + face.signedArea(), 0);\r\n        return Math.abs(signedArea);\r\n    }\r\n\r\n    /**\r\n     * Add new face to polygon. Returns added face\r\n     * @param {Point[]|Segment[]|Arc[]|Circle|Box} args -  new face may be create with one of the following ways: <br/>\r\n     * 1) array of points that describe closed path (edges are segments) <br/>\r\n     * 2) array of shapes (segments and arcs) which describe closed path <br/>\r\n     * 3) circle - will be added as counterclockwise arc <br/>\r\n     * 4) box - will be added as counterclockwise rectangle <br/>\r\n     * You can chain method face.reverse() is you need to change direction of the creates face\r\n     * @returns {Face}\r\n     */\r\n    addFace(...args) {\r\n        let face = new Flatten.Face(this, ...args);\r\n        this.faces.add(face);\r\n        return face;\r\n    }\r\n\r\n    /**\r\n     * Delete existing face from polygon\r\n     * @param {Face} face Face to be deleted\r\n     * @returns {boolean}\r\n     */\r\n    deleteFace(face) {\r\n        for (let edge of face) {\r\n            this.edges.delete(edge);\r\n        }\r\n        return this.faces.delete(face);\r\n    }\r\n\r\n    /**\r\n     * Clear all faces and create new faces from edges\r\n     */\r\n    recreateFaces() {\r\n        // Remove all faces\r\n        this.faces.clear();\r\n        for (let edge of this.edges) {\r\n            edge.face = null;\r\n        }\r\n\r\n        // Restore faces\r\n        let first;\r\n        let unassignedEdgeFound = true;\r\n        while (unassignedEdgeFound) {\r\n            unassignedEdgeFound = false;\r\n            for (let edge of this.edges) {\r\n                if (edge.face === null) {\r\n                    first = edge;\r\n                    unassignedEdgeFound = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (unassignedEdgeFound) {\r\n                let last = first;\r\n                do {\r\n                    last = last.next;\r\n                } while (last.next !== first)\r\n\r\n                this.addFace(first, last);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete chain of edges from the face.\r\n     * @param {Face} face Face to remove chain\r\n     * @param {Edge} edgeFrom Start of the chain of edges to be removed\r\n     * @param {Edge} edgeTo End of the chain of edges to be removed\r\n     */\r\n    removeChain(face, edgeFrom, edgeTo) {\r\n        // Special case: all edges removed\r\n        if (edgeTo.next === edgeFrom) {\r\n            this.deleteFace(face);\r\n            return;\r\n        }\r\n        for (let edge = edgeFrom; edge !== edgeTo.next; edge = edge.next) {\r\n            face.remove(edge);\r\n            this.edges.delete(edge);      // delete from PlanarSet of edges and update index\r\n            if (face.isEmpty()) {\r\n                this.deleteFace(face);    // delete from PlanarSet of faces and update index\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add point as a new vertex and split edge. Point supposed to belong to an edge.\r\n     * When edge is split, new edge created from the start of the edge to the new vertex\r\n     * and inserted before current edge.\r\n     * Current edge is trimmed and updated.\r\n     * Method returns new edge added. If no edge added, it returns edge before vertex\r\n     * @param {Point} pt Point to be added as a new vertex\r\n     * @param {Edge} edge Edge to be split with new vertex and then trimmed from start\r\n     * @returns {Edge}\r\n     */\r\n    addVertex(pt, edge) {\r\n        let shapes = edge.shape.split(pt);\r\n        // if (shapes.length < 2) return;\r\n\r\n        if (shapes[0] === null)   // point incident to edge start vertex, return previous edge\r\n            return edge.prev;\r\n\r\n        if (shapes[1] === null)   // point incident to edge end vertex, return edge itself\r\n            return edge;\r\n\r\n        let newEdge = new Flatten.Edge(shapes[0]);\r\n        let edgeBefore = edge.prev;\r\n\r\n        /* Insert first split edge into linked list after edgeBefore */\r\n        edge.face.insert(newEdge, edgeBefore);\r\n\r\n        // Remove old edge from edges container and 2d index\r\n        this.edges.delete(edge);\r\n\r\n        // Insert new edge to the edges container and 2d index\r\n        this.edges.add(newEdge);\r\n\r\n        // Update edge shape with second split edge keeping links\r\n        edge.shape = shapes[1];\r\n\r\n        // Add updated edge to the edges container and 2d index\r\n        this.edges.add(edge);\r\n\r\n        return newEdge;\r\n    }\r\n\r\n    /**\r\n     * Merge given edge with next edge and remove vertex between them\r\n     * @param {Edge} edge\r\n     */\r\n    removeEndVertex(edge) {\r\n        const edge_next = edge.next;\r\n        if (edge_next === edge) return\r\n        edge.face.merge_with_next_edge(edge);\r\n        this.edges.delete(edge_next);\r\n    }\r\n\r\n    /**\r\n     * Cut polygon with multiline and return a new polygon\r\n     * @param {Multiline} multiline\r\n     * @returns {Polygon}\r\n     */\r\n    cut(multiline) {\r\n        let newPoly = this.clone();\r\n\r\n        // smart intersections\r\n        let intersections = {\r\n            int_points1: [],\r\n            int_points2: [],\r\n            int_points1_sorted: [],\r\n            int_points2_sorted: []\r\n        };\r\n\r\n        // intersect each edge of multiline with each edge of the polygon\r\n        // and create smart intersections\r\n        for (let edge1 of multiline.edges) {\r\n            for (let edge2 of newPoly.edges) {\r\n                let ip = intersectEdge2Edge(edge1, edge2);\r\n                // for each intersection point\r\n                for (let pt of ip) {\r\n                    addToIntPoints(edge1, pt, intersections.int_points1);\r\n                    addToIntPoints(edge2, pt, intersections.int_points2);\r\n                }\r\n            }\r\n        }\r\n\r\n        // No intersections - return a copy of the original polygon\r\n        if (intersections.int_points1.length === 0)\r\n            return newPoly;\r\n\r\n        // sort smart intersections\r\n        intersections.int_points1_sorted = getSortedArray(intersections.int_points1);\r\n        intersections.int_points2_sorted = getSortedArray(intersections.int_points2);\r\n\r\n        // split by intersection points\r\n        splitByIntersections(multiline, intersections.int_points1_sorted);\r\n        splitByIntersections(newPoly, intersections.int_points2_sorted);\r\n\r\n        // filter duplicated intersection points\r\n        filterDuplicatedIntersections(intersections);\r\n\r\n        // sort intersection points again after filtering\r\n        intersections.int_points1_sorted = getSortedArray(intersections.int_points1);\r\n        intersections.int_points2_sorted = getSortedArray(intersections.int_points2);\r\n\r\n        // initialize inclusion flags for edges of multiline incident to intersections\r\n        initializeInclusionFlags(intersections.int_points1);\r\n\r\n        // calculate inclusion flag for edges of multiline incident to intersections\r\n        calculateInclusionFlags(intersections.int_points1, newPoly);\r\n\r\n        // filter intersections between two edges that got same inclusion flag\r\n        for (let int_point1 of intersections.int_points1_sorted) {\r\n            if (int_point1.edge_before && int_point1.edge_after &&\r\n                int_point1.edge_before.bv === int_point1.edge_after.bv) {\r\n                intersections.int_points2[int_point1.id] = -1;   // to be filtered out\r\n                int_point1.id = -1;                              // to be filtered out\r\n            }\r\n        }\r\n        intersections.int_points1 = intersections.int_points1.filter( int_point => int_point.id >= 0);\r\n        intersections.int_points2 = intersections.int_points2.filter( int_point => int_point.id >= 0);\r\n        intersections.int_points1.forEach((int_point, index) => { int_point.id = index; });\r\n        intersections.int_points2.forEach((int_point, index) => { int_point.id = index; });\r\n\r\n\r\n        // No intersections left after filtering - return a copy of the original polygon\r\n        if (intersections.int_points1.length === 0)\r\n            return newPoly;\r\n\r\n        // sort intersection points 3d time after filtering\r\n        intersections.int_points1_sorted = getSortedArray(intersections.int_points1);\r\n        intersections.int_points2_sorted = getSortedArray(intersections.int_points2);\r\n\r\n        // Add new inner edges between intersection points\r\n        let int_point1_prev;\r\n        let int_point1_curr;\r\n        for (let i = 1; i <  intersections.int_points1_sorted.length; i++) {\r\n            int_point1_curr = intersections.int_points1_sorted[i];\r\n            int_point1_prev = intersections.int_points1_sorted[i-1];\r\n            if (int_point1_curr.edge_before && int_point1_curr.edge_before.bv === INSIDE$2) {\r\n                let edgeFrom = int_point1_prev.edge_after;\r\n                let edgeTo = int_point1_curr.edge_before;\r\n                let newEdges = multiline.getChain(edgeFrom, edgeTo);\r\n                insertBetweenIntPoints(intersections.int_points2[int_point1_prev.id], intersections.int_points2[int_point1_curr.id], newEdges);\r\n                newEdges.forEach(edge => newPoly.edges.add(edge));\r\n\r\n                newEdges = newEdges.reverse().map(edge => new Flatten.Edge(edge.shape.reverse()));\r\n                for (let k=0; k < newEdges.length-1; k++) {\r\n                    newEdges[k].next = newEdges[k+1];\r\n                    newEdges[k+1].prev = newEdges[k];\r\n                }\r\n                insertBetweenIntPoints(intersections.int_points2[int_point1_curr.id], intersections.int_points2[int_point1_prev.id], newEdges);\r\n                newEdges.forEach(edge => newPoly.edges.add(edge));\r\n            }\r\n\r\n        }\r\n\r\n        // Recreate faces\r\n        newPoly.recreateFaces();\r\n\r\n        return newPoly\r\n    }\r\n\r\n    /**\r\n     * A special case of cut() function\r\n     * The return is a polygon cut with line\r\n     * @param {Line} line - cutting line\r\n     * @returns {Polygon} newPoly - resulted polygon\r\n     */\r\n    cutWithLine(line) {\r\n        let multiline = new Multiline$1([line]);\r\n        return this.cut(multiline);\r\n    }\r\n\r\n    /**\r\n     * Returns the first found edge of polygon that contains given point\r\n     * If point is a vertex, return the edge where the point is an end vertex, not a start one\r\n     * @param {Point} pt\r\n     * @returns {Edge}\r\n     */\r\n    findEdgeByPoint(pt) {\r\n        let edge;\r\n        for (let face of this.faces) {\r\n            edge = face.findEdgeByPoint(pt);\r\n            if (edge !== undefined)\r\n                break;\r\n        }\r\n        return edge;\r\n    }\r\n\r\n    /**\r\n     * Split polygon into array of polygons, where each polygon is an outer face with all\r\n     * containing inner faces\r\n     * @returns {Flatten.Polygon[]}\r\n     */\r\n    splitToIslands() {\r\n        if (this.isEmpty()) return [];      // return empty array if polygon is empty\r\n        let polygons = this.toArray();      // split into array of one-loop polygons\r\n        /* Sort polygons by area in descending order */\r\n        polygons.sort((polygon1, polygon2) => polygon2.area() - polygon1.area());\r\n        /* define orientation of the island by orientation of the first polygon in array */\r\n        let orientation = [...polygons[0].faces][0].orientation();\r\n        /* Create output array from polygons with same orientation as a first polygon (array of islands) */\r\n        let newPolygons = polygons.filter(polygon => [...polygon.faces][0].orientation() === orientation);\r\n        for (let polygon of polygons) {\r\n            let face = [...polygon.faces][0];\r\n            if (face.orientation() === orientation) continue;  // skip same orientation\r\n            /* Proceed with opposite orientation */\r\n            /* Look if any of island polygons contains tested polygon as a hole */\r\n            for (let islandPolygon of newPolygons) {\r\n                if (face.shapes.every(shape => islandPolygon.contains(shape))) {\r\n                    islandPolygon.addFace(face.shapes);      // add polygon as a hole in islandPolygon\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // TODO: assert if not all polygons added into output\r\n        return newPolygons;\r\n    }\r\n\r\n    /**\r\n     * Reverse orientation of all faces to opposite\r\n     * @returns {Polygon}\r\n     */\r\n    reverse() {\r\n        for (let face of this.faces) {\r\n            face.reverse();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns true if polygon contains shape: no point of shape lay outside of the polygon,\r\n     * false otherwise\r\n     * @param {Shape} shape - test shape\r\n     * @returns {boolean}\r\n     */\r\n    contains(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            let rel = ray_shoot(this, shape);\r\n            return rel === INSIDE$2 || rel === BOUNDARY$1;\r\n        } else {\r\n            return cover(this, shape);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return distance and shortest segment between polygon and other shape as array [distance, shortest_segment]\r\n     * @param {Shape} shape Shape of one of the types Point, Circle, Line, Segment, Arc or Polygon\r\n     * @returns {Number | Segment}\r\n     */\r\n    distanceTo(shape) {\r\n        // let {Distance} = Flatten;\r\n\r\n        if (shape instanceof Flatten.Point) {\r\n            let [dist, shortest_segment] = Flatten.Distance.point2polygon(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle ||\r\n            shape instanceof Flatten.Line ||\r\n            shape instanceof Flatten.Segment ||\r\n            shape instanceof Flatten.Arc) {\r\n            let [dist, shortest_segment] = Flatten.Distance.shape2polygon(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        /* this method is bit faster */\r\n        if (shape instanceof Flatten.Polygon) {\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\r\n            let dist, shortest_segment;\r\n\r\n            for (let edge of this.edges) {\r\n                // let [dist, shortest_segment] = Distance.shape2polygon(edge.shape, shape);\r\n                let min_stop = min_dist_and_segment[0];\r\n                [dist, shortest_segment] = Flatten.Distance.shape2planarSet(edge.shape, shape.edges, min_stop);\r\n                if (Flatten.Utils.LT(dist, min_stop)) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return array of intersection points between polygon and other shape\r\n     * @param shape Shape of the one of supported types <br/>\r\n     * @returns {Point[]}\r\n     */\r\n    intersect(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            return this.contains(shape) ? [shape] : [];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Line) {\r\n            return intersectLine2Polygon(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Ray) {\r\n            return intersectRay2Polygon(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            return intersectCircle2Polygon(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            return intersectSegment2Polygon(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            return intersectArc2Polygon(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            return intersectPolygon2Polygon(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Multiline) {\r\n            return intersectMultiline2Polygon(shape, this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns new polygon translated by vector vec\r\n     * @param {Vector} vec\r\n     * @returns {Polygon}\r\n     */\r\n    translate(vec) {\r\n        let newPolygon = new Polygon();\r\n        for (let face of this.faces) {\r\n            newPolygon.addFace(face.shapes.map(shape => shape.translate(vec)));\r\n        }\r\n        return newPolygon;\r\n    }\r\n\r\n    /**\r\n     * Return new polygon rotated by given angle around given point\r\n     * If point omitted, rotate around origin (0,0)\r\n     * Positive value of angle defines rotation counterclockwise, negative - clockwise\r\n     * @param {number} angle - rotation angle in radians\r\n     * @param {Point} center - rotation center, default is (0,0)\r\n     * @returns {Polygon} - new rotated polygon\r\n     */\r\n    rotate(angle = 0, center = new Flatten.Point()) {\r\n        let newPolygon = new Polygon();\r\n        for (let face of this.faces) {\r\n            newPolygon.addFace(face.shapes.map(shape => shape.rotate(angle, center)));\r\n        }\r\n        return newPolygon;\r\n    }\r\n\r\n    /**\r\n     * Return new polygon with coordinates multiplied by scaling factor\r\n     * @param {number} sx - x-axis scaling factor\r\n     * @param {number} sy - y-axis scaling factor\r\n     * @returns {Polygon}\r\n     */\r\n    scale(sx, sy) {\r\n        let newPolygon = new Polygon();\r\n        for (let face of this.faces) {\r\n            newPolygon.addFace(face.shapes.map(shape => shape.scale(sx, sy)));\r\n        }\r\n        return newPolygon;\r\n    }\r\n\r\n    /**\r\n     * Return new polygon transformed using affine transformation matrix\r\n     * @param {Matrix} matrix - affine transformation matrix\r\n     * @returns {Polygon} - new polygon\r\n     */\r\n    transform(matrix = new Flatten.Matrix()) {\r\n        let newPolygon = new Polygon();\r\n        for (let face of this.faces) {\r\n            newPolygon.addFace(face.shapes.map(shape => shape.transform(matrix)));\r\n        }\r\n        return newPolygon;\r\n    }\r\n\r\n    /**\r\n     * This method returns an object that defines how data will be\r\n     * serialized when called JSON.stringify() method\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n        return [...this.faces].map(face => face.toJSON());\r\n    }\r\n\r\n    /**\r\n     * Transform all faces into array of polygons\r\n     * @returns {Flatten.Polygon[]}\r\n     */\r\n    toArray() {\r\n        return [...this.faces].map(face => face.toPolygon());\r\n    }\r\n\r\n    /**\r\n     * Return string to be assigned to 'd' attribute of <path> element\r\n     * @returns {*}\r\n     */\r\n    dpath() {\r\n        return [...this.faces].reduce((acc, face) => acc + face.svg(), \"\")\r\n    }\r\n\r\n    /**\r\n     * Return string to draw polygon in svg\r\n     * @param attrs  - an object with attributes for svg path element\r\n     * @returns {string}\r\n     */\r\n    svg(attrs = {}) {\r\n        let svgStr = `\\n<path ${convertToString({fillRule: \"evenodd\", fill: \"lightcyan\", ...attrs})} d=\"`;\r\n        for (let face of this.faces) {\r\n            svgStr += `\\n${face.svg()}` ;\r\n        }\r\n        svgStr += `\" >\\n</path>`;\r\n        return svgStr;\r\n    }\r\n};\r\n\r\nFlatten.Polygon = Polygon$1;\r\n\r\n/**\r\n * Shortcut method to create new polygon\r\n */\r\nconst polygon = (...args) => new Flatten.Polygon(...args);\r\nFlatten.polygon = polygon;\r\n\r\nconst {Circle, Line, Point: Point$2, Vector, Utils} = Flatten;\r\n/**\r\n * Class Inversion represent operator of inversion in circle\r\n * Inversion is a transformation of the Euclidean plane that maps generalized circles\r\n * (where line is considered as a circle with infinite radius) into generalized circles\r\n * See also https://en.wikipedia.org/wiki/Inversive_geometry and\r\n * http://mathworld.wolfram.com/Inversion.html <br/>\r\n * @type {Inversion}\r\n */\r\nclass Inversion {\r\n    /**\r\n     * Inversion constructor\r\n     * @param {Circle} inversion_circle inversion circle\r\n     */\r\n    constructor(inversion_circle) {\r\n        this.circle = inversion_circle;\r\n    }\r\n\r\n\r\n    get inversion_circle() {\r\n        return this.circle;\r\n    }\r\n\r\n    static inversePoint(inversion_circle, point) {\r\n        const v = new Vector(inversion_circle.pc, point);\r\n        const k2 = inversion_circle.r * inversion_circle.r;\r\n        const len2 = v.dot(v);\r\n        const reflected_point = Utils.EQ_0(len2) ?\r\n            new Point$2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY) :\r\n            inversion_circle.pc.translate(v.multiply(k2 / len2));\r\n        return reflected_point;\r\n    }\r\n\r\n    static inverseCircle(inversion_circle, circle) {\r\n        const dist = inversion_circle.pc.distanceTo(circle.pc)[0];\r\n        if (Utils.EQ(dist, circle.r)) {     // Circle passing through inversion center mapped into line\r\n            let d = (inversion_circle.r * inversion_circle.r) / (2 * circle.r);\r\n            let v = new Vector(inversion_circle.pc, circle.pc);\r\n            v = v.normalize();\r\n            let pt = inversion_circle.pc.translate(v.multiply(d));\r\n\r\n            return new Line(pt, v);\r\n        } else {                           // Circle not passing through inversion center - map into another circle */\r\n            /* Taken from http://mathworld.wolfram.com */\r\n            let v = new Vector(inversion_circle.pc, circle.pc);\r\n            let s = inversion_circle.r * inversion_circle.r / (v.dot(v) - circle.r * circle.r);\r\n            let pc = inversion_circle.pc.translate(v.multiply(s));\r\n            let r = Math.abs(s) * circle.r;\r\n\r\n            return new Circle(pc, r);\r\n        }\r\n    }\r\n\r\n    static inverseLine(inversion_circle, line) {\r\n        const [dist, shortest_segment] = inversion_circle.pc.distanceTo(line);\r\n        if (Utils.EQ_0(dist)) {            // Line passing through inversion center, is mapping to itself\r\n            return line.clone();\r\n        } else {                           // Line not passing through inversion center is mapping into circle\r\n            let r = inversion_circle.r * inversion_circle.r / (2 * dist);\r\n            let v = new Vector(inversion_circle.pc, shortest_segment.end);\r\n            v = v.multiply(r / dist);\r\n            return new Circle(inversion_circle.pc.translate(v), r);\r\n        }\r\n    }\r\n\r\n    inverse(shape) {\r\n        if (shape instanceof Point$2) {\r\n            return Inversion.inversePoint(this.circle, shape);\r\n        }\r\n        else if (shape instanceof Circle) {\r\n            return Inversion.inverseCircle(this.circle, shape);\r\n        }\r\n        else if (shape instanceof Line) {\r\n            return Inversion.inverseLine(this.circle, shape);\r\n        }\r\n    }\r\n}\r\nFlatten.Inversion = Inversion;\r\n\r\n/**\r\n * Shortcut to create inversion operator\r\n * @param circle\r\n * @returns {Inversion}\r\n */\r\nconst inversion = (circle) => new Flatten.Inversion(circle);\r\nFlatten.inversion = inversion;\r\n\r\nclass Distance {\r\n    /**\r\n     * Calculate distance and shortest segment between points\r\n     * @param pt1\r\n     * @param pt2\r\n     * @returns {[number, Flatten.Segment]} - distance and shortest segment\r\n     */\r\n    static point2point(pt1, pt2) {\r\n        return pt1.distanceTo(pt2);\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between point and line\r\n     * @param pt\r\n     * @param line\r\n     * @returns {[number, Flatten.Segment]} - distance and shortest segment\r\n     */\r\n    static point2line(pt, line) {\r\n        let closest_point = pt.projectionOn(line);\r\n        let vec = new Flatten.Vector(pt, closest_point);\r\n        return [vec.length, new Flatten.Segment(pt, closest_point)];\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between point and circle\r\n     * @param pt\r\n     * @param circle\r\n     * @returns {[number, Flatten.Segment]} - distance and shortest segment\r\n     */\r\n    static point2circle(pt, circle) {\r\n        let [dist2center, shortest_dist] = pt.distanceTo(circle.center);\r\n        if (Flatten.Utils.EQ_0(dist2center)) {\r\n            return [circle.r, new Flatten.Segment(pt, circle.toArc().start)];\r\n        } else {\r\n            let dist = Math.abs(dist2center - circle.r);\r\n            let v = new Flatten.Vector(circle.pc, pt).normalize().multiply(circle.r);\r\n            let closest_point = circle.pc.translate(v);\r\n            return [dist, new Flatten.Segment(pt, closest_point)];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between point and segment\r\n     * @param pt\r\n     * @param segment\r\n     * @returns {[number, Flatten.Segment]} - distance and shortest segment\r\n     */\r\n    static point2segment(pt, segment) {\r\n        /* Degenerated case of zero-length segment */\r\n        if (segment.start.equalTo(segment.end)) {\r\n            return Distance.point2point(pt, segment.start);\r\n        }\r\n\r\n        let v_seg = new Flatten.Vector(segment.start, segment.end);\r\n        let v_ps2pt = new Flatten.Vector(segment.start, pt);\r\n        let v_pe2pt = new Flatten.Vector(segment.end, pt);\r\n        let start_sp = v_seg.dot(v_ps2pt);\r\n        /* dot product v_seg * v_ps2pt */\r\n        let end_sp = -v_seg.dot(v_pe2pt);\r\n        /* minus dot product v_seg * v_pe2pt */\r\n\r\n        let dist;\r\n        let closest_point;\r\n        if (Flatten.Utils.GE(start_sp, 0) && Flatten.Utils.GE(end_sp, 0)) {    /* point inside segment scope */\r\n            let v_unit = segment.tangentInStart(); // new Flatten.Vector(v_seg.x / this.length, v_seg.y / this.length);\r\n            /* unit vector ||v_unit|| = 1 */\r\n            dist = Math.abs(v_unit.cross(v_ps2pt));\r\n            /* dist = abs(v_unit x v_ps2pt) */\r\n            closest_point = segment.start.translate(v_unit.multiply(v_unit.dot(v_ps2pt)));\r\n            return [dist, new Flatten.Segment(pt, closest_point)];\r\n        } else if (start_sp < 0) {                             /* point is out of scope closer to ps */\r\n            return pt.distanceTo(segment.start);\r\n        } else {                                               /* point is out of scope closer to pe */\r\n            return pt.distanceTo(segment.end);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between point and arc\r\n     * @param pt\r\n     * @param arc\r\n     * @returns {[number, Flatten.Segment]} - distance and shortest segment\r\n     */\r\n    static point2arc(pt, arc) {\r\n        let circle = new Flatten.Circle(arc.pc, arc.r);\r\n        let dist_and_segment = [];\r\n        let dist, shortest_segment;\r\n        [dist, shortest_segment] = Distance.point2circle(pt, circle);\r\n        if (shortest_segment.end.on(arc)) {\r\n            dist_and_segment.push(Distance.point2circle(pt, circle));\r\n        }\r\n        dist_and_segment.push(Distance.point2point(pt, arc.start));\r\n        dist_and_segment.push(Distance.point2point(pt, arc.end));\r\n\r\n        Distance.sort(dist_and_segment);\r\n\r\n        return dist_and_segment[0];\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between point and edge\r\n     * @param pt\r\n     * @param edge\r\n     * @returns {[number, Flatten.Segment]}\r\n     */\r\n    static point2edge(pt, edge) {\r\n        return edge.shape instanceof Flatten.Segment ?\r\n            Distance.point2segment(pt, edge.shape) :\r\n            Distance.point2arc(pt, edge.shape);\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between segment and line\r\n     * @param seg\r\n     * @param line\r\n     * @returns {[number, Flatten.Segment]}\r\n     */\r\n    static segment2line(seg, line) {\r\n        let ip = seg.intersect(line);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];   // distance = 0, closest point is the first point\r\n        }\r\n        let dist_and_segment = [];\r\n        dist_and_segment.push(Distance.point2line(seg.start, line));\r\n        dist_and_segment.push(Distance.point2line(seg.end, line));\r\n\r\n        Distance.sort(dist_and_segment);\r\n        return dist_and_segment[0];\r\n\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between two segments\r\n     * @param seg1\r\n     * @param seg2\r\n     * @returns {[number, Flatten.Segment]} - distance and shortest segment\r\n     */\r\n    static segment2segment(seg1, seg2) {\r\n        let ip = intersectSegment2Segment(seg1, seg2);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];   // distance = 0, closest point is the first point\r\n        }\r\n\r\n        // Seg1 and seg2 not intersected\r\n        let dist_and_segment = [];\r\n        let dist_tmp, shortest_segment_tmp;\r\n        [dist_tmp, shortest_segment_tmp] = Distance.point2segment(seg2.start, seg1);\r\n        dist_and_segment.push([dist_tmp, shortest_segment_tmp.reverse()]);\r\n        [dist_tmp, shortest_segment_tmp] = Distance.point2segment(seg2.end, seg1);\r\n        dist_and_segment.push([dist_tmp, shortest_segment_tmp.reverse()]);\r\n        dist_and_segment.push(Distance.point2segment(seg1.start, seg2));\r\n        dist_and_segment.push(Distance.point2segment(seg1.end, seg2));\r\n\r\n        Distance.sort(dist_and_segment);\r\n        return dist_and_segment[0];\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between segment and circle\r\n     * @param seg\r\n     * @param circle\r\n     * @returns {[number, Flatten.Segment]} - distance and shortest segment\r\n     */\r\n    static segment2circle(seg, circle) {\r\n        /* Case 1 Segment and circle intersected. Return the first point and zero distance */\r\n        let ip = seg.intersect(circle);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];\r\n        }\r\n\r\n        // No intersection between segment and circle\r\n\r\n        /* Case 2. Distance to projection of center point to line bigger than radius\r\n         * And projection point belong to segment\r\n          * Then measure again distance from projection to circle and return it */\r\n        let line = new Flatten.Line(seg.ps, seg.pe);\r\n        let [dist, shortest_segment] = Distance.point2line(circle.center, line);\r\n        if (Flatten.Utils.GE(dist, circle.r) && shortest_segment.end.on(seg)) {\r\n            return Distance.point2circle(shortest_segment.end, circle);\r\n        }\r\n        /* Case 3. Otherwise closest point is one of the end points of the segment */\r\n        else {\r\n            let [dist_from_start, shortest_segment_from_start] = Distance.point2circle(seg.start, circle);\r\n            let [dist_from_end, shortest_segment_from_end] = Distance.point2circle(seg.end, circle);\r\n            return Flatten.Utils.LT(dist_from_start, dist_from_end) ?\r\n                [dist_from_start, shortest_segment_from_start] :\r\n                [dist_from_end, shortest_segment_from_end];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between segment and arc\r\n     * @param seg\r\n     * @param arc\r\n     * @returns {[number, Flatten.Segment]} - distance and shortest segment\r\n     */\r\n    static segment2arc(seg, arc) {\r\n        /* Case 1 Segment and arc intersected. Return the first point and zero distance */\r\n        let ip = seg.intersect(arc);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];\r\n        }\r\n\r\n        // No intersection between segment and arc\r\n        let line = new Flatten.Line(seg.ps, seg.pe);\r\n        let circle = new Flatten.Circle(arc.pc, arc.r);\r\n\r\n        /* Case 2. Distance to projection of center point to line bigger than radius AND\r\n         * projection point belongs to segment AND\r\n           * distance from projection point to circle belongs to arc  =>\r\n           * return this distance from projection to circle */\r\n        let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\r\n        if (Flatten.Utils.GE(dist_from_center, circle.r) && shortest_segment_from_center.end.on(seg)) {\r\n            let [dist_from_projection, shortest_segment_from_projection] =\r\n                Distance.point2circle(shortest_segment_from_center.end, circle);\r\n            if (shortest_segment_from_projection.end.on(arc)) {\r\n                return [dist_from_projection, shortest_segment_from_projection];\r\n            }\r\n        }\r\n        /* Case 3. Otherwise closest point is one of the end points of the segment */\r\n        let dist_and_segment = [];\r\n        dist_and_segment.push(Distance.point2arc(seg.start, arc));\r\n        dist_and_segment.push(Distance.point2arc(seg.end, arc));\r\n\r\n        let dist_tmp, segment_tmp;\r\n        [dist_tmp, segment_tmp] = Distance.point2segment(arc.start, seg);\r\n        dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n\r\n        [dist_tmp, segment_tmp] = Distance.point2segment(arc.end, seg);\r\n        dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n\r\n        Distance.sort(dist_and_segment);\r\n        return dist_and_segment[0];\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between two circles\r\n     * @param circle1\r\n     * @param circle2\r\n     * @returns {[number, Flatten.Segment]} - distance and shortest segment\r\n     */\r\n    static circle2circle(circle1, circle2) {\r\n        let ip = circle1.intersect(circle2);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];\r\n        }\r\n\r\n        // Case 1. Concentric circles. Convert to arcs and take distance between two arc starts\r\n        if (circle1.center.equalTo(circle2.center)) {\r\n            let arc1 = circle1.toArc();\r\n            let arc2 = circle2.toArc();\r\n            return Distance.point2point(arc1.start, arc2.start);\r\n        } else {\r\n            // Case 2. Not concentric circles\r\n            let line = new Flatten.Line(circle1.center, circle2.center);\r\n            let ip1 = line.intersect(circle1);\r\n            let ip2 = line.intersect(circle2);\r\n\r\n            let dist_and_segment = [];\r\n\r\n            dist_and_segment.push(Distance.point2point(ip1[0], ip2[0]));\r\n            dist_and_segment.push(Distance.point2point(ip1[0], ip2[1]));\r\n            dist_and_segment.push(Distance.point2point(ip1[1], ip2[0]));\r\n            dist_and_segment.push(Distance.point2point(ip1[1], ip2[1]));\r\n\r\n            Distance.sort(dist_and_segment);\r\n            return dist_and_segment[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between two circles\r\n     * @param circle\r\n     * @param line\r\n     * @returns {[number, Flatten.Segment]} - distance and shortest segment\r\n     */\r\n    static circle2line(circle, line) {\r\n        let ip = circle.intersect(line);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];\r\n        }\r\n\r\n        let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\r\n        let [dist, shortest_segment] = Distance.point2circle(shortest_segment_from_center.end, circle);\r\n        shortest_segment = shortest_segment.reverse();\r\n        return [dist, shortest_segment];\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between arc and line\r\n     * @param arc\r\n     * @param line\r\n     * @returns {[number, Flatten.Segment]} - distance and shortest segment\r\n     */\r\n    static arc2line(arc, line) {\r\n        /* Case 1 Line and arc intersected. Return the first point and zero distance */\r\n        let ip = line.intersect(arc);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];\r\n        }\r\n\r\n        let circle = new Flatten.Circle(arc.center, arc.r);\r\n\r\n        /* Case 2. Distance to projection of center point to line bigger than radius AND\r\n         * projection point belongs to segment AND\r\n           * distance from projection point to circle belongs to arc  =>\r\n           * return this distance from projection to circle */\r\n        let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\r\n        if (Flatten.Utils.GE(dist_from_center, circle.r)) {\r\n            let [dist_from_projection, shortest_segment_from_projection] =\r\n                Distance.point2circle(shortest_segment_from_center.end, circle);\r\n            if (shortest_segment_from_projection.end.on(arc)) {\r\n                return [dist_from_projection, shortest_segment_from_projection];\r\n            }\r\n        } else {\r\n            let dist_and_segment = [];\r\n            dist_and_segment.push(Distance.point2line(arc.start, line));\r\n            dist_and_segment.push(Distance.point2line(arc.end, line));\r\n\r\n            Distance.sort(dist_and_segment);\r\n            return dist_and_segment[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between arc and circle\r\n     * @param arc\r\n     * @param circle2\r\n     * @returns {[number, Flatten.Segment]} - distance and shortest segment\r\n     */\r\n    static arc2circle(arc, circle2) {\r\n        let ip = arc.intersect(circle2);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];\r\n        }\r\n\r\n        let circle1 = new Flatten.Circle(arc.center, arc.r);\r\n\r\n        let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);\r\n        if (shortest_segment.start.on(arc)) {\r\n            return [dist, shortest_segment];\r\n        } else {\r\n            let dist_and_segment = [];\r\n\r\n            dist_and_segment.push(Distance.point2circle(arc.start, circle2));\r\n            dist_and_segment.push(Distance.point2circle(arc.end, circle2));\r\n\r\n            Distance.sort(dist_and_segment);\r\n\r\n            return dist_and_segment[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between two arcs\r\n     * @param arc1\r\n     * @param arc2\r\n     * @returns {[number, Flatten.Segment]} - distance and shortest segment\r\n     */\r\n    static arc2arc(arc1, arc2) {\r\n        let ip = arc1.intersect(arc2);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];\r\n        }\r\n\r\n        let circle1 = new Flatten.Circle(arc1.center, arc1.r);\r\n        let circle2 = new Flatten.Circle(arc2.center, arc2.r);\r\n\r\n        let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);\r\n        if (shortest_segment.start.on(arc1) && shortest_segment.end.on(arc2)) {\r\n            return [dist, shortest_segment];\r\n        } else {\r\n            let dist_and_segment = [];\r\n\r\n            let dist_tmp, segment_tmp;\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc1.start, arc2);\r\n            if (segment_tmp.end.on(arc2)) {\r\n                dist_and_segment.push([dist_tmp, segment_tmp]);\r\n            }\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc1.end, arc2);\r\n            if (segment_tmp.end.on(arc2)) {\r\n                dist_and_segment.push([dist_tmp, segment_tmp]);\r\n            }\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc2.start, arc1);\r\n            if (segment_tmp.end.on(arc1)) {\r\n                dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n            }\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc2.end, arc1);\r\n            if (segment_tmp.end.on(arc1)) {\r\n                dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n            }\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.start);\r\n            dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.end);\r\n            dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.start);\r\n            dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.end);\r\n            dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n            Distance.sort(dist_and_segment);\r\n\r\n            return dist_and_segment[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between point and polygon\r\n     * @param point\r\n     * @param polygon\r\n     * @returns {[number, Flatten.Segment]} - distance and shortest segment\r\n     */\r\n    static point2polygon(point, polygon) {\r\n        let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\r\n        for (let edge of polygon.edges) {\r\n            let [dist, shortest_segment] = Distance.point2edge(point, edge);\r\n            if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                min_dist_and_segment = [dist, shortest_segment];\r\n            }\r\n        }\r\n        return min_dist_and_segment;\r\n    }\r\n\r\n    static shape2polygon(shape, polygon) {\r\n        let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\r\n        for (let edge of polygon.edges) {\r\n            let [dist, shortest_segment] = shape.distanceTo(edge.shape);\r\n            if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                min_dist_and_segment = [dist, shortest_segment];\r\n            }\r\n        }\r\n        return min_dist_and_segment;\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between two polygons\r\n     * @param polygon1\r\n     * @param polygon2\r\n     * @returns {[number, Flatten.Segment]} - distance and shortest segment\r\n     */\r\n    static polygon2polygon(polygon1, polygon2) {\r\n        let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\r\n        for (let edge1 of polygon1.edges) {\r\n            for (let edge2 of polygon2.edges) {\r\n                let [dist, shortest_segment] = edge1.shape.distanceTo(edge2.shape);\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n        }\r\n        return min_dist_and_segment;\r\n    }\r\n\r\n    /**\r\n     * Returns [mindist, maxdist] array of squared minimal and maximal distance between boxes\r\n     * Minimal distance by x is\r\n     *    (box2.xmin - box1.xmax), if box1 is left to box2\r\n     *    (box1.xmin - box2.xmax), if box2 is left to box1\r\n     *    0,                       if box1 and box2 are intersected by x\r\n     * Minimal distance by y is defined in the same way\r\n     *\r\n     * Maximal distance is estimated as a sum of squared dimensions of the merged box\r\n     *\r\n     * @param box1\r\n     * @param box2\r\n     * @returns {Number | Number} - minimal and maximal distance\r\n     */\r\n    static box2box_minmax(box1, box2) {\r\n        let mindist_x = Math.max(Math.max(box1.xmin - box2.xmax, 0), Math.max(box2.xmin - box1.xmax, 0));\r\n        let mindist_y = Math.max(Math.max(box1.ymin - box2.ymax, 0), Math.max(box2.ymin - box1.ymax, 0));\r\n        let mindist = mindist_x * mindist_x + mindist_y * mindist_y;\r\n\r\n        let box = box1.merge(box2);\r\n        let dx = box.xmax - box.xmin;\r\n        let dy = box.ymax - box.ymin;\r\n        let maxdist = dx * dx + dy * dy;\r\n\r\n        return [mindist, maxdist];\r\n    }\r\n\r\n    static minmax_tree_process_level(shape, level, min_stop, tree) {\r\n        // Calculate minmax distance to each shape in current level\r\n        // Insert result into the interval tree for further processing\r\n        // update min_stop with maxdist, it will be the new stop distance\r\n        let mindist, maxdist;\r\n        for (let node of level) {\r\n\r\n            // [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\r\n            // if (Flatten.Utils.GT(mindist, min_stop))\r\n            //     continue;\r\n\r\n            // Estimate min-max dist to the shape stored in the node.item, using node.item.key which is shape's box\r\n            [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.item.key);\r\n            if (node.item.value instanceof Flatten.Edge) {\r\n                tree.insert([mindist, maxdist], node.item.value.shape);\r\n            } else {\r\n                tree.insert([mindist, maxdist], node.item.value);\r\n            }\r\n            if (Flatten.Utils.LT(maxdist, min_stop)) {\r\n                min_stop = maxdist;                       // this will be the new distance estimation\r\n            }\r\n        }\r\n\r\n        if (level.length === 0)\r\n            return min_stop;\r\n\r\n        // Calculate new level from left and right children of the current\r\n        let new_level_left = level.map(node => node.left.isNil() ? undefined : node.left).filter(node => node !== undefined);\r\n        let new_level_right = level.map(node => node.right.isNil() ? undefined : node.right).filter(node => node !== undefined);\r\n        // Merge left and right subtrees and leave only relevant subtrees\r\n        let new_level = [...new_level_left, ...new_level_right].filter(node => {\r\n            // Node subtree quick reject, node.max is a subtree box\r\n            let [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\r\n            return (Flatten.Utils.LE(mindist, min_stop));\r\n        });\r\n\r\n        min_stop = Distance.minmax_tree_process_level(shape, new_level, min_stop, tree);\r\n        return min_stop;\r\n    }\r\n\r\n    /**\r\n     * Calculates sorted tree of [mindist, maxdist] intervals between query shape\r\n     * and shapes of the planar set.\r\n     * @param shape\r\n     * @param set\r\n     */\r\n    static minmax_tree(shape, set, min_stop) {\r\n        let tree = new IntervalTree();\r\n        let level = [set.index.root];\r\n        let squared_min_stop = min_stop < Number.POSITIVE_INFINITY ? min_stop * min_stop : Number.POSITIVE_INFINITY;\r\n        squared_min_stop = Distance.minmax_tree_process_level(shape, level, squared_min_stop, tree);\r\n        return tree;\r\n    }\r\n\r\n    static minmax_tree_calc_distance(shape, node, min_dist_and_segment) {\r\n        let min_dist_and_segment_new, stop;\r\n        if (node != null && !node.isNil()) {\r\n            [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.left, min_dist_and_segment);\r\n\r\n            if (stop) {\r\n                return [min_dist_and_segment_new, stop];\r\n            }\r\n\r\n            if (Flatten.Utils.LT(min_dist_and_segment_new[0], Math.sqrt(node.item.key.low))) {\r\n                return [min_dist_and_segment_new, true];   // stop condition\r\n            }\r\n\r\n            let [dist, shortest_segment] = Distance.distance(shape, node.item.value);\r\n            // console.log(dist)\r\n            if (Flatten.Utils.LT(dist, min_dist_and_segment_new[0])) {\r\n                min_dist_and_segment_new = [dist, shortest_segment];\r\n            }\r\n\r\n            [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.right, min_dist_and_segment_new);\r\n\r\n            return [min_dist_and_segment_new, stop];\r\n        }\r\n\r\n        return [min_dist_and_segment, false];\r\n    }\r\n\r\n    /**\r\n     * Calculates distance between shape and Planar Set of shapes\r\n     * @param shape\r\n     * @param {PlanarSet} set\r\n     * @param {Number} min_stop\r\n     * @returns {*}\r\n     */\r\n    static shape2planarSet(shape, set, min_stop = Number.POSITIVE_INFINITY) {\r\n        let min_dist_and_segment = [min_stop, new Flatten.Segment()];\r\n        let stop = false;\r\n        if (set instanceof Flatten.PlanarSet) {\r\n            let tree = Distance.minmax_tree(shape, set, min_stop);\r\n            [min_dist_and_segment, stop] = Distance.minmax_tree_calc_distance(shape, tree.root, min_dist_and_segment);\r\n        }\r\n        return min_dist_and_segment;\r\n    }\r\n\r\n    static sort(dist_and_segment) {\r\n        dist_and_segment.sort((d1, d2) => {\r\n            if (Flatten.Utils.LT(d1[0], d2[0])) {\r\n                return -1;\r\n            }\r\n            if (Flatten.Utils.GT(d1[0], d2[0])) {\r\n                return 1;\r\n            }\r\n            return 0;\r\n        });\r\n    }\r\n\r\n    static distance(shape1, shape2) {\r\n        return shape1.distanceTo(shape2);\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment any shape and multiline\r\n     * @param shape\r\n     * @param multiline\r\n     * @returns {[number, Flatten.Segment]}\r\n     */\r\n    static shape2multiline(shape, multiline) {\r\n        let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\r\n        for (let edge of multiline) {\r\n            let [dist, shortest_segment] = Distance.distance(shape, edge.shape);\r\n            if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                min_dist_and_segment = [dist, shortest_segment];\r\n            }\r\n        }\r\n        return min_dist_and_segment;\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between two multilines\r\n     * @param multiline1\r\n     * @param multiline2\r\n     * @returns {[number, Flatten.Segment]}\r\n     */\r\n    static multiline2multiline(multiline1, multiline2) {\r\n        let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\r\n        for (let edge1 of multiline1) {\r\n            for (let edge2 of multiline2) {\r\n                let [dist, shortest_segment] = Distance.distance(edge1.shape, edge2.shape);\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n        }\r\n        return min_dist_and_segment;\r\n    }\r\n}\r\n\r\nFlatten.Distance = Distance;\r\n\r\nconst {Multiline, Point: Point$1, Segment, Polygon} = Flatten;\r\n\r\n// POINT (30 10)\r\n// MULTIPOINT (10 40, 40 30, 20 20, 30 10)\r\n// LINESTRING (30 10, 10 30, 40 40)\r\n// MULTILINESTRING ((10 10, 20 20, 10 40), (40 40, 30 30, 40 20, 30 10))\r\n// MULTILINESTRING ((8503.732 4424.547, 8963.747 3964.532), (8963.747 3964.532, 8707.468 3708.253), (8707.468 3708.253, 8247.454 4168.268), (8247.454 4168.268, 8503.732 4424.547))\r\n// POLYGON ((35 10, 45 45, 15 40, 10 20, 35 10), (20 30, 35 35, 30 20, 20 30))\r\n// MULTIPOLYGON (((40 40, 20 45, 45 30, 40 40)), ((20 35, 10 30, 10 10, 30 5, 45 20, 20 35), (30 20, 20 15, 20 25, 30 20)))\r\n// GEOMETRYCOLLECTION (POINT (0 0), LINESTRING (0 0, 1440 900), POLYGON ((0 0, 0 1024, 1024 1024, 1024 0, 0 0)))\r\n// GEOMETRYCOLLECTION (POINT (40 10), LINESTRING (10 10, 20 20, 10 40), POLYGON ((40 40, 20 45, 45 30, 40 40)))\r\n\r\nfunction parseSinglePoint(pointStr) {\r\n    return new Point$1(pointStr.split(' ').map(Number))\r\n}\r\n\r\nfunction parseMultiPoint(multipointStr) {\r\n    return multipointStr.split(', ').map(parseSinglePoint)\r\n}\r\n\r\nfunction parseLineString(lineStr) {\r\n    const points = parseMultiPoint(lineStr);\r\n    let segments = [];\r\n    for (let i = 0; i < points.length-1;  i++) {\r\n        segments.push(new Segment(points[i], points[i+1]));\r\n    }\r\n    return new Multiline(segments)\r\n}\r\n\r\nfunction parseMultiLineString(multilineStr) {\r\n    const lineStrings = multilineStr.replace(/\\(\\(/, '').replace(/\\)\\)$/, '').split('), (');\r\n    return lineStrings.map(parseLineString)\r\n}\r\n\r\nfunction parseSinglePolygon(polygonStr) {\r\n    const facesStr = polygonStr.replace(/\\(\\(/, '').replace(/\\)\\)$/, '').split('), (');\r\n    const polygon = new Polygon();\r\n    let orientation;\r\n    facesStr.forEach((facesStr, idx) => {\r\n        let points = facesStr.split(', ').map(coordStr => {\r\n            return new Point$1(coordStr.split(' ').map(Number))\r\n        });\r\n        const face = polygon.addFace(points);\r\n        if (idx === 0) {\r\n            orientation = face.orientation();\r\n        }\r\n        else {\r\n            if (face.orientation() === orientation) {\r\n                face.reverse();\r\n            }\r\n        }\r\n    });\r\n    return polygon\r\n}\r\n\r\nfunction parseMutliPolygon(multiPolygonString) {\r\n    // const polygonStrings = multiPolygonString.split('?')\r\n    // Split the string by the delimiter \")), ((\" which separates the polygons\r\n    const polygonStrings = multiPolygonString.split(/\\)\\), \\(\\(/).map(polygon => '((' + polygon + '))');\r\n\r\n    const polygons = polygonStrings.map(parseSinglePolygon);\r\n    const polygon = new Polygon();\r\n    const faces = polygons.reduce((acc, polygon) => [...acc, ...polygon?.faces], []);\r\n    faces.forEach(face => polygon.addFace([...face?.shapes]));\r\n    return polygon;\r\n}\r\n\r\nfunction parsePolygon(wkt) {\r\n    if (wkt.startsWith(\"POLYGON\")) {\r\n        const polygonStr = wkt.replace(/^POLYGON /, '');\r\n        return parseSinglePolygon(polygonStr)\r\n    }\r\n    else {\r\n        // const multiPolygonString = wkt.replace(/^MULTIPOLYGON \\(/, '').replace(/\\)$/, '').replace(/\\)\\), \\(\\(/,'))?((')\r\n        const multiPolygonString = wkt.replace(/^MULTIPOLYGON \\(\\(\\((.*)\\)\\)\\)$/, '$1');\r\n        return parseMutliPolygon(multiPolygonString)\r\n    }\r\n}\r\n\r\nfunction parseArrayOfPoints(str) {\r\n    const arr = str.split('\\n').map(x => x.match(/\\(([^)]+)\\)/)[1]);\r\n    return arr.map(parseSinglePoint)\r\n}\r\n\r\nfunction parseArrayOfLineStrings(str) {\r\n    const arr = str.split('\\n').map(x => x.match(/\\(([^)]+)\\)/)[1]);\r\n    return arr.map(parseLineString).reduce((acc, x) => [...acc, ...x], [])\r\n}\r\n\r\n/**\r\n * Convert WKT string to array of Flatten shapes.\r\n * @param str\r\n * @returns {Point | Point[] | Multiline | Multiline[] | Polygon | Shape[] | null}\r\n */\r\nfunction parseWKT(str) {\r\n    if (str.startsWith(\"POINT\")) {\r\n        const pointStr = str.replace(/^POINT \\(/, '').replace(/\\)$/, '');\r\n        return parseSinglePoint(pointStr)\r\n    }\r\n    else if (str.startsWith(\"MULTIPOINT\")) {\r\n        const multiPointStr = str.replace(/^MULTIPOINT \\(/, '').replace(/\\)$/, '');\r\n        return parseMultiPoint(multiPointStr)\r\n    }\r\n    else if (str.startsWith(\"LINESTRING\")) {\r\n        const lineStr = str.replace(/^LINESTRING \\(/, '').replace(/\\)$/, '');\r\n        return parseLineString(lineStr)\r\n    }\r\n    else if (str.startsWith(\"MULTILINESTRING\")) {\r\n        const multilineStr = str.replace(/^MULTILINESTRING /, '');\r\n        return parseMultiLineString(multilineStr)\r\n    }\r\n    else if (str.startsWith(\"POLYGON\") || str.startsWith(\"MULTIPOLYGON\")) {\r\n        return parsePolygon(str)\r\n    }\r\n    else if (str.startsWith(\"GEOMETRYCOLLECTION\")) {\r\n        // const regex = /(POINT|LINESTRING|POLYGON|MULTIPOINT|MULTILINESTRING|MULTIPOLYGON|GEOMETRYCOLLECTION) \\([^\\)]+\\)/g\r\n        /* Explanation:\r\n(?<type>POINT|LINESTRING|POLYGON|MULTIPOINT|MULTILINESTRING|MULTIPOLYGON):\r\nThis named group will capture the geometry type. The type label helps with understanding the structure but\r\n is not necessary unless you process the matches programmatically and want easy access to the geometry type.\r\n\\( and \\): Match the opening and closing parentheses.\r\n(?:[^\\(\\)]|\\([^\\)]*\\))*: A non-capturing group that allows for:\r\n[^\\(\\)]: Matching any character except parentheses, handling simple geometries.\r\n|\\([^\\)]*\\): Handling nested parentheses for geometries like POLYGON and MULTILINESTRING.\r\n* after the non-capturing group: Allows for repeating the pattern zero or more times to match all contents between the outermost parentheses. */\r\n        const regex = /(?<type>POINT|LINESTRING|POLYGON|MULTIPOINT|MULTILINESTRING|MULTIPOLYGON) \\((?:[^\\(\\)]|\\([^\\)]*\\))*\\)/g;\r\n        const wktArray = str.match(regex);\r\n        if (wktArray[0].startsWith('GEOMETRYCOLLECTION')) {\r\n            wktArray[0] = wktArray[0].replace('GEOMETRYCOLLECTION (','');\r\n        }\r\n        const flArray = wktArray.map(parseWKT).map(x => x instanceof Array ? x : [x]);\r\n        return flArray.reduce((acc, x) => [...acc, ...x], [])\r\n    }\r\n    else if (isArrayOfPoints(str)) {\r\n        return parseArrayOfPoints(str)\r\n    }\r\n    else if (isArrayOfLines(str)) {\r\n        return parseArrayOfLineStrings(str)\r\n    }\r\n    return []\r\n}\r\n\r\nfunction isArrayOfPoints(str) {\r\n    return str.split('\\n')?.every(str => str.includes('POINT'))\r\n}\r\n\r\nfunction isArrayOfLines(str) {\r\n    return str.split('\\n')?.every(str => str.includes('LINESTRING'))\r\n}\r\n\r\n/**\r\n * Return true if given string starts with one of WKT tags and possibly contains WKT string,\r\n * @param str\r\n * @returns {boolean}\r\n */\r\nfunction isWktString(str) {\r\n    return (\r\n        str.startsWith(\"POINT\") || isArrayOfPoints(str) ||\r\n        str.startsWith(\"LINESTRING\") || isArrayOfLines(str) ||\r\n        str.startsWith(\"MULTILINESTRING\") ||\r\n        str.startsWith(\"POLYGON\") ||\r\n        str.startsWith(\"MULTIPOINT\") ||\r\n        str.startsWith(\"MULTIPOLYGON\") ||\r\n        str.startsWith(\"GEOMETRYCOLLECTION\")\r\n    )\r\n}\r\n\r\nFlatten.isWktString = isWktString;\r\nFlatten.parseWKT = parseWKT;\r\n\r\n/**\r\n * Created by Alex Bol on 2/18/2017.\r\n */\r\n\r\n\r\nFlatten.BooleanOperations = BooleanOperations;\r\nFlatten.Relations = Relations;\r\n\r\nexport { Arc, BOUNDARY$1 as BOUNDARY, BooleanOperations, Box, CCW, CW, Circle$1 as Circle, Distance, Edge, Errors, Face, INSIDE$2 as INSIDE, Inversion, Line$1 as Line, Matrix, Multiline$1 as Multiline, ORIENTATION, OUTSIDE$1 as OUTSIDE, OVERLAP_OPPOSITE$1 as OVERLAP_OPPOSITE, OVERLAP_SAME$1 as OVERLAP_SAME, PlanarSet, Point$3 as Point, Polygon$1 as Polygon, Ray, Relations, Segment$1 as Segment, smart_intersections as SmartIntersections, Utils$1 as Utils, Vector$1 as Vector, arc, box, circle, Flatten as default, inversion, isWktString, line, matrix, multiline, parseWKT, point, polygon, ray, ray_shoot, segment, vector$1 as vector };\r\n","import type {LatLngExpression} from 'leaflet';\nimport L, {Bounds, LatLng, LatLngBounds, Path, Point, Util} from 'leaflet';\nimport Flatten from '@flatten-js/core';\nimport Matrix = Flatten.Matrix;\nimport type {Points, Shape, ShapeSet, Units} from './types';\nimport type {ShapeOptions, TrackSymbolOptions} from './options';\n\nconst DEFAULT_SIZE = 24;\nconst DEFAULT_LEADER_TIME = 60;\n\n/**\n * Track symbol.\n */\nexport class TrackSymbol\n    extends Path {\n\n    /** Default 'withHeading' shape points. */\n    public static DEFAULT_HEADING_SHAPE_POINTS: Points = [[0.75, 0], [-0.25, 0.3], [-0.25, -0.3]];\n\n    /** Default 'withoutHeading' shape points. */\n    public static DEFAULT_NOHEADING_SHAPE_POINTS: Points = [[0.3, 0], [0, 0.3], [-0.3, 0], [0, -0.3]];\n\n    /** Default shape set. */\n    private static DEFAULT_SHAPE_SET: ShapeSet = {\n        withHeading: {\n            points: TrackSymbol.DEFAULT_HEADING_SHAPE_POINTS,\n            length: DEFAULT_SIZE,\n            breadth: DEFAULT_SIZE,\n            units: \"pixels\",\n        },\n        withoutHeading: {\n            points: TrackSymbol.DEFAULT_NOHEADING_SHAPE_POINTS,\n            length: DEFAULT_SIZE,\n            breadth: DEFAULT_SIZE,\n            units: \"pixels\",\n        },\n    };\n\n    /** Location. */\n    private _latLng: LatLng;\n    /** Heading (radians, from north, clockwise. */\n    private _heading?: number;\n    /** Course (radians, from north, clockwise. */\n    private _course?: number;\n    /** Speed (m/s). */\n    private _speed?: number;\n    /** Shape options. */\n    private _shapeOptions: ShapeOptions;\n\n    /** Current shape points. */\n    private _currentShapePoints: Point[] | undefined;\n    /** Current leader points. */\n    private _currentLeaderPoints: Point[] | undefined;\n    /** Current bounds. */\n    private _currentBounds: Bounds | undefined;\n    /** Current lat/lng bounds. */\n    private _currentLatLngBounds: LatLngBounds | undefined;\n\n    /**\n     * TrackSymbol constructor.\n     *\n     * @param latLng - Initial location.\n     * @param options - Options.\n     */\n    constructor(latLng: LatLngExpression, options?: TrackSymbolOptions) {\n        super();\n\n        Util.setOptions(this, options);\n        if (latLng == undefined) {\n            throw Error(\"latLng required\");\n        }\n        options = options || {};\n        this._latLng = L.latLng(latLng);\n        this._heading = options.heading;\n        this._course = options.course;\n        this._speed = options.speed;\n        this._shapeOptions = options.shapeOptions || {\n            leaderTime: DEFAULT_LEADER_TIME,\n            defaultShapeSet: TrackSymbol.DEFAULT_SHAPE_SET,\n        };\n        this._setShapeOptions(options.shapeOptions);\n    }\n\n    // ---- Leaflet\n\n    /**\n     * Project to layer.\n     *\n     * [Leaflet internal]\n     */\n    protected _project() {\n        this._currentShapePoints = this._getProjectedShapePoints();\n        this._currentLeaderPoints = this._getLeaderShapePoints();\n\n        const bounds = new Bounds();\n        for (let i = 0; i < this._currentShapePoints.length; i++) {\n            const point = this._currentShapePoints[i];\n            bounds.extend(point);\n        }\n        if (this._currentLeaderPoints !== undefined) {\n            for (let i = 0; i < this._currentLeaderPoints.length; i++) {\n                const point = this._currentShapePoints[i];\n                bounds.extend(point);\n            }\n        }\n        this._currentBounds = bounds;\n        this._currentLatLngBounds = new LatLngBounds(\n            this._map.layerPointToLatLng(bounds.getBottomLeft()),\n            this._map.layerPointToLatLng(bounds.getTopRight())\n        );\n    }\n\n    /**\n     * Update element.\n     *\n     * [Leaflet internal]\n     */\n    protected _update() {\n        if (!this._map) {\n            return;\n        }\n        const el = this.getElement();\n        if (el === undefined) {\n            return;\n        }\n        const paths: string[] = [];\n        if (this._currentShapePoints !== undefined) {\n            paths.push(TrackSymbol._toSVGPath(this._currentShapePoints, true));\n        }\n        if (this._currentLeaderPoints !== undefined) {\n            paths.push(TrackSymbol._toSVGPath(this._currentLeaderPoints, false));\n        }\n        const viewPath = paths.join(' ');\n        el.setAttribute('d', viewPath);\n    }\n\n    // ----\n\n    /**\n     * Set shape options.\n     *\n     * @param shapeOptions - Shape options.\n     */\n    private _setShapeOptions(shapeOptions: ShapeOptions | undefined) {\n        this._shapeOptions = shapeOptions || {\n            leaderTime: DEFAULT_LEADER_TIME,\n            defaultShapeSet: TrackSymbol.DEFAULT_SHAPE_SET,\n        };\n        if (this._shapeOptions.leaderTime === undefined) {\n            this._shapeOptions.leaderTime = DEFAULT_LEADER_TIME;\n        }\n        if (this._shapeOptions.defaultShapeSet === undefined) {\n            this._shapeOptions.defaultShapeSet = TrackSymbol.DEFAULT_SHAPE_SET;\n        }\n        if (this._shapeOptions.shapeSetEntries !== undefined) {\n            this._shapeOptions.shapeSetEntries\n                .sort((a, b) => b.minZoomLevel - a.minZoomLevel);\n        }\n    }\n\n    // ---\n\n    /**\n     * Sets the location.\n     *\n     * @param latLng - Location.\n     * @returns this\n     */\n    public setLatLng(latLng: LatLngExpression): this {\n        const oldLatLng = this._latLng;\n        this._latLng = L.latLng(latLng);\n        this.fire('move', {\n            oldLatLng: oldLatLng,\n            latlng: this._latLng,\n        });\n        return this.redraw();\n    }\n\n    /**\n     * Sets the heading.\n     *\n     * @param heading - Heading (unit: radians, from north, clockwise).\n     * @returns this\n     */\n    public setHeading(heading: number | undefined): this {\n        this._heading = heading;\n        return this.redraw();\n    }\n\n    /**\n     * Sets the course over ground.\n     *\n     * @param course - Course over ground (unit: radians, from north, clockwise).\n     * @returns this\n     */\n    public setCourse(course: number | undefined): this {\n        this._course = course;\n        return this.redraw();\n    }\n\n    /**\n     * Sets the speed.\n     *\n     * @param speed - Speed (unit: m/s).\n     * @returns this\n     */\n    public setSpeed(speed: number | undefined): this {\n        this._speed = speed;\n        return this.redraw();\n    }\n\n    /**\n     * Sets the shape options.\n     *\n     * @param shapeOptions - Shape options.\n     * @returns this\n     */\n    public setShapeOptions(shapeOptions: ShapeOptions): this {\n        this._setShapeOptions(shapeOptions);\n        return this.redraw();\n    }\n\n    /**\n     * Returns the bounding box.\n     *\n     * @returns The bounding box.\n     */\n    public getBounds(): LatLngBounds | undefined {\n        return this._currentLatLngBounds;\n    }\n\n    /**\n     * Returns the location.\n     *\n     * @returns The location.\n     */\n    public getLatLng(): LatLng {\n        return this._latLng;\n    }\n\n    /**\n     * Returns the speed.\n     *\n     * @returns The speed (m/s).\n     */\n    public getSpeed(): number | undefined {\n        return this._speed;\n    }\n\n    /**\n     * Returns the heading.\n     *\n     * @returns The heading (radians, from north, clockwise).\n     */\n    public getHeading(): number | undefined {\n        return this._heading;\n    }\n\n    /**\n     * Returns the course.\n     *\n     * @returns The course (radians, from north, clockwise).\n     */\n    public getCourse(): number | undefined {\n        return this._course;\n    }\n\n    /**\n     * Creates a shape.\n     *\n     * @param points - Points.\n     * @param size - Size (units: pixels).\n     * @returns The new shape.\n     */\n    public static createShape(points: Points, size: number): Shape {\n        return {\n            points: points,\n            length: size,\n            breadth: size,\n            units: \"pixels\",\n        };\n    }\n\n    /**\n     * Creates a shape set.\n     *\n     * @param size - Size (units: pixels).\n     * @returns The new shape set.\n     */\n    public static createShapeSet(size: number): ShapeSet {\n        return {\n            withHeading: TrackSymbol.createShape(TrackSymbol.DEFAULT_HEADING_SHAPE_POINTS, size),\n            withoutHeading: TrackSymbol.createShape(TrackSymbol.DEFAULT_NOHEADING_SHAPE_POINTS, size),\n        };\n    }\n\n    /**\n     * Get latitude size of y-distance.\n     *\n     * @param value - Y distance (m).\n     * @returns dLat\n     */\n    private _getLatSizeOf(value: number): number {\n        return (value / 40075017) * 360;\n    }\n\n    /**\n     * Get longitude size of x-distance.\n     *\n     * @param value - X distance (m).\n     * @returns dLng\n     */\n    private _getLngSizeOf(value: number): number {\n        return ((value / 40075017) * 360) / Math.cos((Math.PI / 180) * this._latLng.lat);\n    }\n\n    /**\n     * Get view angle from model.\n     *\n     * @param modelAngle - Model angle (radians).\n     * @returns View angle from model (radians).\n     */\n    private _getViewAngleFromModel(modelAngle: number): number {\n        return modelAngle - Math.PI / 2.0;\n    }\n\n    /**\n     * Get leader shape points.\n     *\n     * @returns Points.\n     */\n    private _getLeaderShapePoints(): Point[] | undefined {\n        if ((this._course === undefined) || (this._speed === undefined)\n            || (this._shapeOptions === undefined) || (this._shapeOptions.leaderTime === undefined)) {\n            return undefined;\n        }\n        const angle = this._getViewAngleFromModel(this._course);\n        const leaderLength = this._speed * this._shapeOptions.leaderTime;\n        const leaderEndLatLng = this._calcRelativeLatLng(this._latLng, leaderLength, angle);\n        return this._latLngsToLayerPoints(this._latLng, leaderEndLatLng);\n    }\n\n    /**\n     * Calculate relative lat/lng.\n     *\n     * @param latLng - LatLng.\n     * @param distance - Distance (meters).\n     * @param angle - Angle (radians).\n     * @returns Calculated LatLng.\n     */\n    private _calcRelativeLatLng(latLng: LatLng, distance: number, angle: number): LatLng {\n        return new LatLng(\n            latLng.lat - this._getLatSizeOf(distance * Math.sin(angle)),\n            latLng.lng + this._getLngSizeOf(distance * Math.cos(angle))\n        );\n    }\n\n    /**\n     * Convert LatLngs to map layer points.\n     *\n     * @param latLngs - LatLngs.\n     * @returns Points.\n     */\n    private _latLngsToLayerPoints(...latLngs: LatLng[]): Point[] {\n        return latLngs.map(latLng => this._map.latLngToLayerPoint(latLng));\n    }\n\n    /**\n     * Gets the shape set.\n     *\n     * @returns The shape set.\n     */\n    private _getShapeSet(): ShapeSet {\n        if ((this._shapeOptions.shapeSetEntries === undefined)\n            || (this._shapeOptions.shapeSetEntries.length == 0)) {\n            return this._shapeOptions.defaultShapeSet ? this._shapeOptions.defaultShapeSet : TrackSymbol.DEFAULT_SHAPE_SET;\n        }\n        const zoomLevel = this._map.getZoom();\n        const shapeSetEntriesFiltered = this._shapeOptions.shapeSetEntries\n            .sort((a, b) => b.minZoomLevel - a.minZoomLevel)\n            .filter(shapeSetEntry => zoomLevel >= shapeSetEntry.minZoomLevel);\n        if (shapeSetEntriesFiltered.length > 0) {\n            return shapeSetEntriesFiltered[0].shapeSet;\n        } else {\n            return this._shapeOptions.defaultShapeSet ? this._shapeOptions.defaultShapeSet : TrackSymbol.DEFAULT_SHAPE_SET;\n        }\n    }\n\n    /**\n     * Gets the shape.\n     *\n     * @returns The shape.\n     */\n    private _getShape(): Shape {\n        const shapeSet = this._getShapeSet();\n        return (this._heading !== undefined) ? shapeSet.withHeading : shapeSet.withoutHeading;\n    }\n\n    /**\n     * Get transformed shape points.\n     *\n     * @returns Transformed points and units.\n     */\n    private _getTransformedShapePoints(): [Points, Units] {\n        const shape = this._getShape();\n        let m = new Matrix();\n        if (this._heading !== undefined) {\n            const headingAngle = this._getViewAngleFromModel(this._heading);\n            m = m.rotate(headingAngle);\n        }\n        if (shape.center !== undefined) {\n            m = m.translate(-shape.center[0], -shape.center[1]);\n        }\n        m = m.scale(shape.length, shape.breadth);\n        const points = shape.points.map(point => m.transform(point));\n        return [points, shape.units];\n    }\n\n    /**\n     * Get projected shape points.\n     *\n     * @returns Points projected to map layer.\n     */\n    private _getProjectedShapePoints(): Point[] {\n        const [points, units] = this._getTransformedShapePoints();\n        switch (units) {\n            case \"pixels\": {\n                const p = this._map.latLngToLayerPoint(this._latLng);\n                const m = new Matrix().translate(p.x, p.y);\n                return points.map(point => {\n                    const p1 = m.transform(point);\n                    return new Point(p1[0], p1[1]);\n                });\n            }\n            case \"meters\": {\n                return points.map(point => this._map.latLngToLayerPoint(\n                    new LatLng(\n                        this._latLng.lat - this._getLatSizeOf(point[1]),\n                        this._latLng.lng + this._getLngSizeOf(point[0])\n                    )\n                ));\n            }\n            default:\n                throw `unsupported units: ${units}`;\n        }\n    }\n\n    /**\n     * Converts points to an SVG path string.\n     *\n     * @param points - Points.\n     * @param close - Close path.\n     * @returns SVG path string.\n     */\n    private static _toSVGPath(points: Point[], close: boolean): string {\n        let result = '';\n        for (let i = 0; i < points.length; i++) {\n            const point = points[i];\n            if (result === '') {\n                result = `M ${point.x} ${point.y} `;\n            } else {\n                result += `L ${point.x} ${point.y} `;\n            }\n        }\n        if (close) {\n            result += 'Z';\n        }\n        return result;\n    }\n}\n","import {TrackSymbol} from '../trackSymbol';\nimport type {ShapeOptions} from '../options';\nimport type {Points, ShapeSet} from '../types';\nimport type {AISTrackSymbolOptions} from './options';\nimport type {Dimension, ETA, PositionReport, ShipStaticData} from './types';\nimport {DomUtil, Util} from 'leaflet';\n\nconst DEFAULT_SIZE = 24;\nconst DEFAULT_MIN_ZOOM_LEVEL = 14;\nconst DEFAULT_LEADER_TIME = 60;\nconst KNOTS_PER_METER_PER_SECOND = 1.944;\nconst MAX_SOG_EXCLUSIVE = 102.3;\nconst MAX_COG_EXCLUSIVE = 360;\nconst MAX_HEADING_EXCLUSIVE = 360;\n\ninterface ShipType {\n    name: string;\n    color: string;\n    fillColor: string;\n}\n\nconst RESERVED_COLOR = \"#000000\";\nconst RESERVED_FILL_COLOR = \"#d3d3d3\";\nconst WIG_COLOR = \"#000000\";\nconst WIG_FILL_COLOR = \"#d3d3d3\";\nconst TYPE_3X_COLOR = \"#8b008b\";\nconst TYPE_3X_FILL_COLOR = \"#ff00ff\";\nconst HSC_COLOR = \"#00008b\";\nconst HSC_FILL_COLOR = \"#ffff00\";\nconst TYPE_5X_COLOR = \"#008b8b\";\nconst TYPE_5X_FILL_COLOR = \"#00ffff\";\nconst PASSENGER_COLOR = \"#00008b\";\nconst PASSENGER_FILL_COLOR = \"#0000ff\";\nconst CARGO_COLOR = \"#006400\";\nconst CARGO_FILL_COLOR = \"#90ee90\";\nconst TANKER_COLOR = \"#8b0000\";\nconst TANKER_FILL_COLOR = \"#ff0000\";\nconst OTHER_COLOR = \"#008b8b\";\nconst OTHER_FILL_COLOR = \"#00ffff\";\n\nconst TYPES: { [key: number]: ShipType } = {\n    0: newShipType('Not available', WIG_COLOR, WIG_FILL_COLOR),\n    20: newShipType('Wing in ground (WIG), all ships of this type', WIG_COLOR, WIG_FILL_COLOR),\n    21: newShipType('Wing in ground (WIG), Hazardous category A', WIG_COLOR, WIG_FILL_COLOR),\n    22: newShipType('Wing in ground (WIG), Hazardous category B', WIG_COLOR, WIG_FILL_COLOR),\n    23: newShipType('Wing in ground (WIG), Hazardous category C', WIG_COLOR, WIG_FILL_COLOR),\n    24: newShipType('Wing in ground (WIG), Hazardous category D', WIG_COLOR, WIG_FILL_COLOR),\n    25: newShipType('Wing in ground (WIG), Reserved for future use', WIG_COLOR, WIG_FILL_COLOR),\n    26: newShipType('Wing in ground (WIG), Reserved for future use', WIG_COLOR, WIG_FILL_COLOR),\n    27: newShipType('Wing in ground (WIG), Reserved for future use', WIG_COLOR, WIG_FILL_COLOR),\n    28: newShipType('Wing in ground (WIG), Reserved for future use', WIG_COLOR, WIG_FILL_COLOR),\n    29: newShipType('Wing in ground (WIG), Reserved for future use', WIG_COLOR, WIG_FILL_COLOR),\n    30: newShipType('Fishing', TYPE_3X_COLOR, TYPE_3X_FILL_COLOR),\n    31: newShipType('Towing', TYPE_3X_COLOR, TYPE_3X_FILL_COLOR),\n    32: newShipType('Towing: length exceeds 200m or breadth exceeds 25m', TYPE_3X_COLOR, TYPE_3X_FILL_COLOR),\n    33: newShipType('Dredging or underwater ops', TYPE_3X_COLOR, TYPE_3X_FILL_COLOR),\n    34: newShipType('Diving ops', TYPE_3X_COLOR, TYPE_3X_FILL_COLOR),\n    35: newShipType('Military ops', TYPE_3X_COLOR, TYPE_3X_FILL_COLOR),\n    36: newShipType('Sailing', TYPE_3X_COLOR, TYPE_3X_FILL_COLOR),\n    37: newShipType('Pleasure Craft', TYPE_3X_COLOR, TYPE_3X_FILL_COLOR),\n    40: newShipType('High speed craft (HSC), all ships of this type', HSC_COLOR, HSC_FILL_COLOR),\n    41: newShipType('High speed craft (HSC), Hazardous category A', HSC_COLOR, HSC_FILL_COLOR),\n    42: newShipType('High speed craft (HSC), Hazardous category B', HSC_COLOR, HSC_FILL_COLOR),\n    43: newShipType('High speed craft (HSC), Hazardous category C', HSC_COLOR, HSC_FILL_COLOR),\n    44: newShipType('High speed craft (HSC), Hazardous category D', HSC_COLOR, HSC_FILL_COLOR),\n    45: newShipType('High speed craft (HSC), Reserved for future use', HSC_COLOR, HSC_FILL_COLOR),\n    46: newShipType('High speed craft (HSC), Reserved for future use', HSC_COLOR, HSC_FILL_COLOR),\n    47: newShipType('High speed craft (HSC), Reserved for future use', HSC_COLOR, HSC_FILL_COLOR),\n    48: newShipType('High speed craft (HSC), Reserved for future use', HSC_COLOR, HSC_FILL_COLOR),\n    49: newShipType('High speed craft (HSC), No additional information', HSC_COLOR, HSC_FILL_COLOR),\n    50: newShipType('Pilot Vessel', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    51: newShipType('Search and Rescue vessel', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    52: newShipType('Tug', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    53: newShipType('Port Tender', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    54: newShipType('Anti-pollution equipment', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    55: newShipType('Law Enforcement', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    56: newShipType('Spare - Local Vessel', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    57: newShipType('Spare - Local Vessel', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    58: newShipType('Medical Transport', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    59: newShipType('Noncombatant ship according to RR Resolution No. 18', '', ''),\n    60: newShipType('Passenger, all ships of this type', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    61: newShipType('Passenger, Hazardous category A', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    62: newShipType('Passenger, Hazardous category B', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    63: newShipType('Passenger, Hazardous category C', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    64: newShipType('Passenger, Hazardous category D', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    65: newShipType('Passenger, Reserved for future use', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    66: newShipType('Passenger, Reserved for future use', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    67: newShipType('Passenger, Reserved for future use', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    68: newShipType('Passenger, Reserved for future use', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    69: newShipType('Passenger, No additional information', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    70: newShipType('Cargo, all ships of this type', CARGO_COLOR, CARGO_FILL_COLOR),\n    71: newShipType('Cargo, Hazardous category A', CARGO_COLOR, CARGO_FILL_COLOR),\n    72: newShipType('Cargo, Hazardous category B', CARGO_COLOR, CARGO_FILL_COLOR),\n    73: newShipType('Cargo, Hazardous category C', CARGO_COLOR, CARGO_FILL_COLOR),\n    74: newShipType('Cargo, Hazardous category D', CARGO_COLOR, CARGO_FILL_COLOR),\n    75: newShipType('Cargo, Reserved for future use', CARGO_COLOR, CARGO_FILL_COLOR),\n    76: newShipType('Cargo, Reserved for future use', CARGO_COLOR, CARGO_FILL_COLOR),\n    77: newShipType('Cargo, Reserved for future use', CARGO_COLOR, CARGO_FILL_COLOR),\n    78: newShipType('Cargo, Reserved for future use', CARGO_COLOR, CARGO_FILL_COLOR),\n    79: newShipType('Cargo, No additional information', CARGO_COLOR, CARGO_FILL_COLOR),\n    80: newShipType('Tanker, all ships of this type', TANKER_COLOR, TANKER_FILL_COLOR),\n    81: newShipType('Tanker, Hazardous category A', TANKER_COLOR, TANKER_FILL_COLOR),\n    82: newShipType('Tanker, Hazardous category B', TANKER_COLOR, TANKER_FILL_COLOR),\n    83: newShipType('Tanker, Hazardous category C', TANKER_COLOR, TANKER_FILL_COLOR),\n    84: newShipType('Tanker, Hazardous category D', TANKER_COLOR, TANKER_FILL_COLOR),\n    85: newShipType('Tanker, Reserved for future use', TANKER_COLOR, TANKER_FILL_COLOR),\n    86: newShipType('Tanker, Reserved for future use', TANKER_COLOR, TANKER_FILL_COLOR),\n    87: newShipType('Tanker, Reserved for future use', TANKER_COLOR, TANKER_FILL_COLOR),\n    88: newShipType('Tanker, Reserved for future use', TANKER_COLOR, TANKER_FILL_COLOR),\n    89: newShipType('Tanker, No additional information', TANKER_COLOR, TANKER_FILL_COLOR),\n    90: newShipType('Other Type, all ships of this type', OTHER_COLOR, OTHER_FILL_COLOR),\n    91: newShipType('Other Type, Hazardous category A', OTHER_COLOR, OTHER_FILL_COLOR),\n    92: newShipType('Other Type, Hazardous category B', OTHER_COLOR, OTHER_FILL_COLOR),\n    93: newShipType('Other Type, Hazardous category C', OTHER_COLOR, OTHER_FILL_COLOR),\n    94: newShipType('Other Type, Hazardous category D', OTHER_COLOR, OTHER_FILL_COLOR),\n    95: newShipType('Other Type, Reserved for future use', OTHER_COLOR, OTHER_FILL_COLOR),\n    96: newShipType('Other Type, Reserved for future use', OTHER_COLOR, OTHER_FILL_COLOR),\n    97: newShipType('Other Type, Reserved for future use', OTHER_COLOR, OTHER_FILL_COLOR),\n    98: newShipType('Other Type, Reserved for future use', OTHER_COLOR, OTHER_FILL_COLOR),\n    99: newShipType('Other Type, no additional information', OTHER_COLOR, OTHER_FILL_COLOR),\n};\nconst RESERVED_TYPE = newShipType('Reserved', RESERVED_COLOR, RESERVED_FILL_COLOR);\nconst UNKNOWN_TYPE = newShipType('Unknown', RESERVED_COLOR, RESERVED_FILL_COLOR);\n\nexport class AISTrackSymbol\n    extends TrackSymbol {\n\n    /** Default silhouette shape points. */\n    public static DEFAULT_SILHOUETTE_SHAPE_POINTS: Points = [[1, 0.5], [0.75, 1], [0, 1], [0, 0], [0.75, 0]];\n\n    private readonly _leaderTime: number;\n    private readonly _minZoomLevel: number;\n    private readonly _size: number;\n    private _positionReport: PositionReport;\n    private _shipStaticData?: ShipStaticData;\n\n    /**\n     * AISTrackSymbol constructor.\n     *\n     * @param positionReport - Position report.\n     * @param options - Options.\n     */\n    constructor(positionReport: PositionReport, options?: AISTrackSymbolOptions) {\n        super([positionReport.latitude, positionReport.longitude], options);\n\n        Util.setOptions(this, options);\n        options = options || {};\n        this._leaderTime = options.leaderTime || DEFAULT_LEADER_TIME;\n        this._minZoomLevel = options.minZoomLevel || DEFAULT_MIN_ZOOM_LEVEL;\n        this._size = options.size || DEFAULT_SIZE;\n        this._positionReport = positionReport;\n        this.setPositionReport(positionReport);\n        this.setShipStaticData(options.shipStaticData);\n    }\n\n    /**\n     * Get ETA from Date.\n     *\n     * @param date - Date.\n     * @returns ETA\n     */\n    public static etaFromDate(date: Date | null | undefined): ETA | undefined {\n        if ((date === null) || (date === undefined)) {\n            return undefined;\n        }\n        return {\n            month: date.getMonth() + 1,\n            day: date.getDate(),\n            hour: date.getHours(),\n            minute: date.getMinutes(),\n        }\n    }\n\n    /**\n     * Sets the position report.\n     *\n     * @param positionReport - Position report.\n     * @returns this\n     */\n    public setPositionReport(positionReport: PositionReport): this {\n        this._positionReport = positionReport;\n        this.setLatLng([positionReport.latitude, positionReport.longitude]);\n        if ((positionReport.trueHeading !== null) && (positionReport.trueHeading !== undefined) && (positionReport.trueHeading < MAX_HEADING_EXCLUSIVE)) {\n            this.setHeading(toRadians(positionReport.trueHeading));\n        } else {\n            this.setHeading(undefined);\n        }\n        if ((positionReport.cog !== null) && (positionReport.cog !== undefined) && (positionReport.cog < MAX_COG_EXCLUSIVE)) {\n            this.setCourse(toRadians(positionReport.cog));\n        } else {\n            this.setCourse(undefined);\n        }\n        if ((positionReport.sog !== null) && (positionReport.sog !== undefined) && (positionReport.sog < MAX_SOG_EXCLUSIVE)) {\n            this.setSpeed(positionReport.sog / KNOTS_PER_METER_PER_SECOND);\n        } else {\n            this.setSpeed(undefined);\n        }\n        this.bindPopup(this._getPopupContent(this._positionReport, this._shipStaticData));\n        return this.redraw();\n    }\n\n    /**\n     * Sets the ship static data.\n     *\n     * @param shipStaticData - Ship static data.\n     * @returns this\n     */\n    public setShipStaticData(shipStaticData?: ShipStaticData): this {\n        this._shipStaticData = shipStaticData;\n        const shipType = getShipType((shipStaticData !== null) && (shipStaticData !== undefined) ? shipStaticData.type : undefined);\n        this.setStyle({\n            color: shipType.color,\n            fill: true,\n            fillOpacity: 1.0,\n            fillColor: shipType.fillColor,\n        });\n        this.bindPopup(this._getPopupContent(this._positionReport, this._shipStaticData));\n        return this.setShapeOptions(AISTrackSymbol._getShapeOptions(this._leaderTime, this._minZoomLevel, this._size,\n            shipStaticData));\n    }\n\n    private static _getShapeOptions(leaderTime: number, minZoomLevel: number, size: number,\n                                    shipStaticData?: ShipStaticData): ShapeOptions {\n        const shapeOptions: ShapeOptions = {\n            leaderTime: leaderTime,\n            defaultShapeSet: TrackSymbol.createShapeSet(size),\n        };\n        const shapeSet = AISTrackSymbol._getShapeSet(size, shipStaticData);\n        if (shapeSet !== null) {\n            shapeOptions.shapeSetEntries = [{\n                shapeSet: shapeSet,\n                minZoomLevel: minZoomLevel,\n            }];\n        }\n        return shapeOptions;\n    }\n\n    private static _getShapeSet(size: number, shipStaticData?: ShipStaticData): ShapeSet | null {\n        if ((shipStaticData === null) || (shipStaticData === undefined)\n            || (shipStaticData.dimension === null) || (shipStaticData.dimension === undefined)\n            || !isDimensionValid(shipStaticData.dimension)) {\n            return null;\n        }\n        return {\n            withHeading: {\n                points: AISTrackSymbol.DEFAULT_SILHOUETTE_SHAPE_POINTS,\n                center: [shipStaticData.dimension.B, shipStaticData.dimension.D],\n                length: shipStaticData.dimension.A + shipStaticData.dimension.B,\n                breadth: shipStaticData.dimension.C + shipStaticData.dimension.D,\n                units: \"meters\",\n            },\n            withoutHeading: TrackSymbol.createShape(TrackSymbol.DEFAULT_NOHEADING_SHAPE_POINTS, size),\n        };\n    }\n\n    private _getPopupContent(positionReport?: PositionReport, shipStaticData?: ShipStaticData): HTMLElement {\n        let content = \"<table>\";\n        if ((shipStaticData !== null) && (shipStaticData !== undefined)) {\n            content += createTableRow(\"User ID\", shipStaticData.userId);\n            content += createTableRow(\"IMO Number\", shipStaticData.imoNumber);\n            content += createTableRow(\"Call sign\", shipStaticData.callSign);\n            content += createTableRow(\"Name\", shipStaticData.name);\n        }\n        if ((positionReport !== null) && (positionReport !== undefined)) {\n            content += createTableRow(\"Location\", `${toFixed(positionReport.latitude, 5)}, ${toFixed(positionReport.longitude, 5)}`);\n            content += createTableRow(\"SOG\",\n                toFixed(positionReport.sog, 2, v => v < MAX_SOG_EXCLUSIVE), \"knots\");\n            content += createTableRow(\"COG\",\n                toFixed(positionReport.cog, 1), \"°\");\n            content += createTableRow(\"Heading\",\n                toFixed(positionReport.trueHeading, 1), \"°\");\n            content += createTableRow(\"Navigation status\",\n                toNavigationStatusString(positionReport.navigationalStatus));\n        }\n        if ((shipStaticData !== null) && (shipStaticData !== undefined)) {\n            content += createTableRow(\"Type\", toTypeString(shipStaticData.type));\n            if ((shipStaticData.dimension !== null) && (shipStaticData.dimension !== undefined)\n                && isDimensionValid(shipStaticData.dimension)) {\n                content += createTableRow(\"Ship length\",\n                    shipStaticData.dimension.A + shipStaticData.dimension.B, \"m\");\n                content += createTableRow(\"Ship width\",\n                    shipStaticData.dimension.C + shipStaticData.dimension.D, \"m\");\n            }\n            content += createTableRow(\"Fix type\", toFixTypeString(shipStaticData.fixType));\n            content += createTableRow(\"ETA\", toETAString(shipStaticData.eta));\n            content += createTableRow(\"Maximum static draught\",\n                toFixed(shipStaticData.maximumStaticDraught, 1), \"m\");\n            content += createTableRow(\"Destination\", shipStaticData.destination);\n            content += createTableRow(\"DTE\", shipStaticData.dte);\n        }\n        content += \"</table>\";\n        const popupContent = DomUtil.create(\"div\");\n        popupContent.innerHTML = content;\n        return popupContent;\n    }\n}\n\nfunction toFixed(v: number | null | undefined, fractionDigits?: number, isValid?: (v: number) => boolean): string | undefined {\n    if ((v === null) || (v === undefined)) {\n        return undefined;\n    }\n    if (isValid && !isValid(v)) {\n        return undefined;\n    }\n    return v.toFixed(fractionDigits);\n}\n\nfunction toTypeString(type: number | null | undefined): string | undefined {\n    if ((type === null) || (type === undefined)) {\n        return undefined;\n    }\n    const shipType = getShipType(type);\n    return shipType.name;\n}\n\nfunction toFixTypeString(fixType: number | null | undefined): string | undefined {\n    if ((fixType === null) || (fixType === undefined)) {\n        return undefined;\n    }\n    switch (fixType) {\n        case 0:\n            return undefined;\n        case 1:\n            return 'GPS';\n        case 2:\n            return 'GLONASS';\n        case 3:\n            return 'combined GPS/GLONASS';\n        case 4:\n            return 'Loran-C';\n        case 5:\n            return 'Chayka';\n        case 6:\n            return 'integrated navigation system';\n        case 7:\n            return 'surveyed';\n        case 8:\n            return 'Galileo';\n        case 9:\n        case 10:\n        case 11:\n        case 12:\n        case 13:\n        case 14:\n            return `not used (${fixType})`;\n        case 15:\n            return \"internal GNSS\";\n        default:\n            return `unknown (${fixType})`;\n    }\n}\n\nfunction toNavigationStatusString(navigationStatus: number | null | undefined): string | undefined {\n    if ((navigationStatus === null) || (navigationStatus === undefined)) {\n        return undefined;\n    }\n    switch (navigationStatus) {\n        case 0:\n            return 'Under way using engine';\n        case 1:\n            return 'At anchor';\n        case 2:\n            return 'Not under command';\n        case 3:\n            return 'Restricted manoeuverability';\n        case 4:\n            return 'Constrained by her draught';\n        case 5:\n            return 'Moored';\n        case 6:\n            return 'Aground';\n        case 7:\n            return 'Engaged in Fishing';\n        case 8:\n            return 'Under way sailing';\n        case 9:\n            return 'Reserved for future amendment of Navigational Status for HSC';\n        case 10:\n            return 'Reserved for future amendment of Navigational Status for WIG';\n        case 11:\n            return 'Reserved for future use';\n        case 12:\n            return 'Reserved for future use';\n        case 13:\n            return 'Reserved for future use';\n        case 14:\n            return 'AIS-SART is active';\n        case 15:\n            return 'Not defined (default)';\n        default:\n            return `unknown (${navigationStatus})`;\n    }\n}\n\nfunction toETAString(eta: ETA | null | undefined): string | undefined {\n    if ((eta === null) || (eta === undefined)) {\n        return undefined;\n    }\n    const parts: string[] = [];\n    if (!isNullOrUndefined(eta.month) && !isNullOrUndefined(eta.day)) {\n        parts.push(`${eta.month.toString().padStart(2, '0')}/${eta.day.toString().padStart(2, '0')}`);\n    }\n    if (!isNullOrUndefined(eta.hour) && !isNullOrUndefined(eta.minute)) {\n        parts.push(`${eta.hour.toString().padStart(2, '0')}:${eta.minute.toString().padStart(2, '0')}`);\n    }\n    if (parts.length === 0) {\n        return undefined;\n    }\n    return `${parts.join(' ')} UTC`;\n}\n\nfunction toRadians(degs: number | null | undefined): number | undefined {\n    if ((degs === null) || (degs === undefined)) {\n        return undefined;\n    }\n    return degs * Math.PI / 180;\n}\n\nfunction isNullOrUndefined(v: any): boolean {\n    return (v === null) || (v === undefined);\n}\n\nfunction isDimensionValid(dimension: Dimension | null | undefined): boolean {\n    return (dimension !== null) && (dimension !== undefined)\n        && (dimension.A > 0) && (dimension.B > 0) && (dimension.C > 0) && (dimension.D > 0);\n}\n\nfunction createTableRow(name: string, value: any, unit?: string): string {\n    if ((value === null) || (value === undefined)) {\n        return '';\n    }\n    const sValue = String(value);\n    return `<tr><td>${name}</td><td>${sValue} ${isNullOrUndefined(unit) ? \"\" : unit}</td></tr>`;\n}\n\nfunction newShipType(name: string, color: string, fillColor: string): ShipType {\n    return {\n        name: name,\n        color: color,\n        fillColor: fillColor,\n    };\n}\n\nfunction getShipType(type: number | null | undefined): ShipType {\n    if ((type === null) || (type === undefined)) {\n        return TYPES[0];\n    }\n    if ((type < 0) || (type > 99)) {\n        return UNKNOWN_TYPE;\n    }\n    const shipType = TYPES[type];\n    if (!isNullOrUndefined(shipType)) {\n        return shipType;\n    }\n    return RESERVED_TYPE;\n}\n","//@ts-strict-ignore\nimport L from 'leaflet';\nimport type {LatLngExpression} from 'leaflet';\nimport {TrackSymbol} from './trackSymbol';\nimport type {ShapeSetEntry, ShapeOptions, TrackSymbolOptions} from './options';\nimport type {Points, Shape, ShapeSet, Units} from './types';\nimport {AISTrackSymbol} from './ais/aisTrackSymbol';\nimport type {AISTrackSymbolOptions} from './ais/options';\nimport type {AISMessage, Dimension, ETA, PositionReport, ShipStaticData} from './ais/types';\n\nexport {\n    Points,\n    Shape,\n    ShapeOptions,\n    ShapeSet,\n    ShapeSetEntry,\n    TrackSymbol,\n    TrackSymbolOptions,\n    Units,\n};\n\nexport {\n    AISMessage,\n    AISTrackSymbol,\n    AISTrackSymbolOptions,\n    Dimension,\n    ETA,\n    PositionReport,\n    ShipStaticData,\n};\n\nL['trackSymbol'] = function(latLng: LatLngExpression, options?: TrackSymbolOptions): TrackSymbol {\n    return new TrackSymbol(latLng, options);\n}\nL['TrackSymbol'] = TrackSymbol;\n\nL['aisTrackSymbol'] = function(positionReport: PositionReport, options?: AISTrackSymbolOptions): AISTrackSymbol {\n    return new AISTrackSymbol(positionReport, options);\n}\nL['AISTrackSymbol'] = AISTrackSymbol;\n\nexport default TrackSymbol;\n"],"names":["ORIENTATION","PIx2","INSIDE$2","OUTSIDE$1","BOUNDARY$1","CONTAINS","INTERLACE","OVERLAP_SAME$1","OVERLAP_OPPOSITE$1","NOT_VERTEX$1","START_VERTEX$1","END_VERTEX$1","Constants","DP_TOL","setTolerance","tolerance","getTolerance","DECIMALS","EQ_0","x","EQ","y","GT","GE","LT","LE","Utils$1","Flatten","c","value","Errors","LinkedList","first","last","counter","edge","start","end","elements","from","to","element","newElement","elementBefore","elementAfter","controlEdge","defaultAttributes","SVGAttributes","args","property","acc","key","SVGKey","str","convertToString","attrs","intersectLine2Line","line1","line2","ip","A1","B1","C1","A2","B2","C2","det","detX","detY","intersectLine2Circle","line","circle","prj","dist","delta","v_trans","pt","intersectLine2Box","box","ips","seg","ips_tmp","intersectSegment2Line","ptInIntPoints","intersectLine2Arc","arc","ip_tmp","intersectSegment2Segment","seg1","seg2","new_ip","isPointInSegmentBox","point","segment","intersectSegment2Circle","_","intersectSegment2Arc","intersectSegment2Box","intersectCircle2Circle","circle1","circle2","vec","r1","r2","a","mid_pt","h","intersectCircle2Box","intersectArc2Arc","arc1","arc2","intersectArc2Circle","intersectArc2Box","intersectEdge2Segment","intersectEdge2Arc","intersectEdge2Line","intersectEdge2Ray","ray","intersectRay2Segment","intersectRay2Arc","intersectEdge2Circle","intersectSegment2Polygon","polygon","intersectArc2Polygon","intersectLine2Polygon","intersectCircle2Polygon","intersectEdge2Edge","edge1","edge2","intersectEdge2Polygon","resp_edges","resp_edge","intersectMultiline2Polygon","multiline","intersectPolygon2Polygon","polygon1","polygon2","intersectShape2Polygon","shape","new_pt","createLineFromRay","intersectRay2Circle","intersectRay2Box","intersectRay2Line","intersectRay2Ray","ray1","ray2","intersectRay2Polygon","intersectShape2Shape","shape1","shape2","intersectShape2Multiline","intersectMultiline2Multiline","multiline1","multiline2","Multiline$1","Multiline","validShapes","shapes","L","anyShape","s","anyShapeExceptLine","shapeSegmentOrArc","v","len","length","newEdge","edgeBefore","edgeFrom","edgeTo","edges","edgeFound","shortest_segment","angle","center","matrix","p","dPathStr","svgStr","addToIntPoints","int_points","id","is_vertex","arc_length","sortIntersections","intersections","getSortedArray","faceMap","compareFn","ip1","ip2","filterDuplicatedIntersections","do_squeeze","int_point_ref1","int_point_ref2","int_point_cur1","int_point_cur2","i","j","int_point","index","initializeInclusionFlags","calculateInclusionFlags","setOverlappingFlags","cur_face","first_int_point_in_face_id","next_int_point1","num_int_points","cur_int_point1","int_points_cur_pool_start","int_points_cur_pool_num","intPointsPoolCount","next_int_point_id","int_points_next_pool_num","next_int_point1_tmp","edge_from1","edge_to1","cur_int_point2","next_int_point2","edge_from2","edge_to2","cur_int_point_num","int_point_current","int_point_next","int_points_pool_num","splitByIntersections","insertBetweenIntPoints","int_point1","int_point2","new_edges","edge_before","edge_after","INSIDE$1","OUTSIDE","BOUNDARY","OVERLAP_SAME","OVERLAP_OPPOSITE","NOT_VERTEX","START_VERTEX","END_VERTEX","BOOLEAN_UNION","BOOLEAN_INTERSECT","BOOLEAN_SUBTRACT","unify","res_poly","wrk_poly","booleanOpBinary","subtract","polygon2_reversed","intersect$1","innerClip","clip_shapes1","face","clip_shapes2","outerClip","calculateIntersections","getIntersections","ip_sorted1","ip_sorted2","filterNotRelevantEdges","op","notIntersectedFacesRes","getNotIntersectedFaces","notIntersectedFacesWrk","calcInclusionForNotIntersectedFaces","fixBoundaryConflicts","removeNotRelevantChains","removeNotRelevantNotIntersectedFaces","swapLinksAndRestore","copyWrkToRes","swapLinks","removeOldFaces","restoreFaces","restore","resp","poly","notIntersected","notIntersectedFaces","poly2","poly1","int_points1","int_points1_sorted","int_points2","iterate_more","edge_tmp","new_bv","newEdge1","int_point2_edge_after","newEdge2","is_res_polygon","first_int_point_in_face_num","int_points_from_pull_start","int_points_from_pull_num","next_int_point_num","int_points_to_pull_start","int_points_to_pull_num","edge_from","edge_to","k","res_polygon","wrk_polygon","other_int_points","int_point_tmp","rel","BooleanOperations","EQUAL","INTERSECT","TOUCH","INSIDE","COVERED","DE9IM","geom","e","ray_shoot","contains","searchBox","faces","i1","i2","intersection","prev_edge","prev_tangent","prev_point","cur_tangent","cur_point","prev_on_the_left","cur_on_the_left","next_edge","next_tangent","next_point","next_on_the_left","equal","relate","intersect","touch","disjoint","inside","covered","contain","cover","relateLine2Line","relateLine2Circle","relateLine2Box","relateLine2Polygon","relateShape2Polygon","relatePolygon2Polygon","denim","ip_sorted","splitShapes","boolean_intersection","boolean_difference1","boolean_difference2","inner_clip_shapes1","inner_clip_shapes2","outer_clip_shapes1","outer_clip_shapes2","Relations","Matrix$1","Matrix","b","d","tx","ty","vector","other_matrix","centerX","centerY","cos","sin","sx","sy","Interval","low","high","other_interval","interval1","interval2","val1","val2","RB_TREE_COLOR_RED","RB_TREE_COLOR_BLACK","Node","left","right","parent","color","other_node","comparable_max","search_node","comparable_less_than","IntervalTree","count","res","node","insert_node","delete_node","interval","outputMapperFn","resp_nodes","visitor","callback","tree","node_current","current_node","parent_node","uncle_node","cut_node","fix_node","brother_node","found","node_min","node_max","node_successor","action","height","heightLeft","heightRight","PlanarSet","entry","size","deleted","Shape","Point$3","Point","arr","m","proj_vec","dx","dy","r","Vector$1","a1","a2","scalar","norm1","norm2","n","vector$1","Segment$1","Segment","coords","ps","pe","factor","rest","ymin","dy1","dy2","pts","Line$1","Line","norm","A","B","C","other_line","distance","sorted_points","pt1","pt2","Circle$1","pc","counterclockwise","Arc","startAngle","endAngle","counterClockwise","sweep","test_arc","func_arcs_array","angles","test_arcs","prev_arc","new_arc","newStart","newEnd","newCenter","newDirection","onLeftSide","areaTrapez","areaCircularSegment","slope1","slope2","largeArcFlag","sweepFlag","Box","xmin","xmax","ymax","other_box","box1","box2","new_box","vertex","distanceInfos","shortestDistanceInfo","distanceInfo","width","Edge","bvMiddle","flag","sign","halfArc1","halfArc2","CircularLinkedList","done","Face","segments","points","flattenShapes","flattenShape","sArea","area","exitOnFirst","Ray","slope","Polygon$1","Polygon","argsArray","loop","el","loop1","valid","signedArea","unassignedEdgeFound","edge_next","newPoly","int_point1_prev","int_point1_curr","newEdges","polygons","orientation","newPolygons","islandPolygon","min_dist_and_segment","min_stop","newPolygon","Circle","Point$2","Vector","Utils","Inversion","inversion_circle","k2","len2","inversion","Distance","closest_point","dist2center","shortest_dist","v_seg","v_ps2pt","v_pe2pt","start_sp","end_sp","v_unit","dist_and_segment","dist_tmp","shortest_segment_tmp","dist_from_start","shortest_segment_from_start","dist_from_end","shortest_segment_from_end","dist_from_center","shortest_segment_from_center","dist_from_projection","shortest_segment_from_projection","segment_tmp","mindist_x","mindist_y","mindist","maxdist","level","new_level_left","new_level_right","new_level","set","squared_min_stop","min_dist_and_segment_new","stop","d1","d2","Point$1","parseSinglePoint","pointStr","parseMultiPoint","multipointStr","parseLineString","lineStr","parseMultiLineString","multilineStr","parseSinglePolygon","polygonStr","facesStr","idx","coordStr","parseMutliPolygon","multiPolygonString","parsePolygon","wkt","parseArrayOfPoints","parseArrayOfLineStrings","parseWKT","multiPointStr","regex","wktArray","isArrayOfPoints","isArrayOfLines","_a","isWktString","DEFAULT_SIZE","DEFAULT_LEADER_TIME","_TrackSymbol","Path","latLng","options","Util","bounds","Bounds","LatLngBounds","paths","viewPath","shapeOptions","oldLatLng","heading","course","speed","modelAngle","leaderLength","leaderEndLatLng","LatLng","latLngs","zoomLevel","shapeSetEntriesFiltered","shapeSetEntry","shapeSet","headingAngle","units","p1","close","result","TrackSymbol","DEFAULT_MIN_ZOOM_LEVEL","KNOTS_PER_METER_PER_SECOND","MAX_SOG_EXCLUSIVE","MAX_COG_EXCLUSIVE","MAX_HEADING_EXCLUSIVE","RESERVED_COLOR","RESERVED_FILL_COLOR","WIG_COLOR","WIG_FILL_COLOR","TYPE_3X_COLOR","TYPE_3X_FILL_COLOR","HSC_COLOR","HSC_FILL_COLOR","TYPE_5X_COLOR","TYPE_5X_FILL_COLOR","PASSENGER_COLOR","PASSENGER_FILL_COLOR","CARGO_COLOR","CARGO_FILL_COLOR","TANKER_COLOR","TANKER_FILL_COLOR","OTHER_COLOR","OTHER_FILL_COLOR","TYPES","newShipType","RESERVED_TYPE","UNKNOWN_TYPE","_AISTrackSymbol","positionReport","date","toRadians","shipStaticData","shipType","getShipType","leaderTime","minZoomLevel","isDimensionValid","content","createTableRow","toFixed","toNavigationStatusString","toTypeString","toFixTypeString","toETAString","popupContent","DomUtil","AISTrackSymbol","fractionDigits","isValid","type","fixType","navigationStatus","eta","parts","isNullOrUndefined","degs","dimension","name","unit","sValue","fillColor"],"mappings":"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","x_google_ignoreList":[0]}