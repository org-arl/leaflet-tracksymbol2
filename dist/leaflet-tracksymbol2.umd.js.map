{"version":3,"file":"leaflet-tracksymbol2.umd.js","sources":["../node_modules/.pnpm/@flatten-js+core@1.5.1/node_modules/@flatten-js/core/dist/main.mjs","../src/trackSymbol.ts","../src/ais/aisTrackSymbol.ts","../src/index.ts"],"sourcesContent":["/**\n * Global constant CCW defines counterclockwise direction of arc\n * @type {boolean}\n */\nconst CCW = true;\n\n/**\n * Global constant CW defines clockwise direction of arc\n * @type {boolean}\n */\nconst CW = false;\n\n/**\n * Defines orientation for face of the polygon: clockwise, counterclockwise\n * or not orientable in the case of self-intersection\n * @type {{CW: number, CCW: number, NOT_ORIENTABLE: number}}\n */\nconst ORIENTATION = {CCW:-1, CW:1, NOT_ORIENTABLE: 0};\n\nconst PIx2 = 2 * Math.PI;\n\nconst INSIDE$2 = 1;\nconst OUTSIDE$1 = 0;\nconst BOUNDARY$1 = 2;\nconst CONTAINS = 3;\nconst INTERLACE = 4;\n\nconst OVERLAP_SAME$1 = 1;\nconst OVERLAP_OPPOSITE$1 = 2;\n\nconst NOT_VERTEX$1 = 0;\nconst START_VERTEX$1 = 1;\nconst END_VERTEX$1 = 2;\n\nvar Constants = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    BOUNDARY: BOUNDARY$1,\n    CCW: CCW,\n    CONTAINS: CONTAINS,\n    CW: CW,\n    END_VERTEX: END_VERTEX$1,\n    INSIDE: INSIDE$2,\n    INTERLACE: INTERLACE,\n    NOT_VERTEX: NOT_VERTEX$1,\n    ORIENTATION: ORIENTATION,\n    OUTSIDE: OUTSIDE$1,\n    OVERLAP_OPPOSITE: OVERLAP_OPPOSITE$1,\n    OVERLAP_SAME: OVERLAP_SAME$1,\n    PIx2: PIx2,\n    START_VERTEX: START_VERTEX$1\n});\n\n/**\n * Created by Alex Bol on 2/18/2017.\n */\n\n/**\n * Floating point comparison tolerance.\n * Default value is 0.000001 (10e-6)\n * @type {number}\n */\nlet DP_TOL = 0.000001;\n\n/**\n * Set new floating point comparison tolerance\n * @param {number} tolerance\n */\nfunction setTolerance(tolerance) {DP_TOL = tolerance;}\n\n/**\n * Get floating point comparison tolerance\n * @returns {number}\n */\nfunction getTolerance() {return DP_TOL;}\n\nconst DECIMALS = 3;\n\n/**\n * Returns *true* if value comparable to zero\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nfunction EQ_0(x) {\n    return (x < DP_TOL && x > -DP_TOL);\n}\n\n/**\n * Returns *true* if two values are equal up to DP_TOL\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nfunction EQ(x, y) {\n    return (x - y < DP_TOL && x - y > -DP_TOL);\n}\n\n/**\n * Returns *true* if first argument greater than second argument up to DP_TOL\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nfunction GT(x, y) {\n    return (x - y > DP_TOL);\n}\n\n/**\n * Returns *true* if first argument greater than or equal to second argument up to DP_TOL\n * @param {number} x\n * @param {number} y\n * @returns {boolean}\n */\nfunction GE(x, y) {\n    return (x - y > -DP_TOL);\n}\n\n/**\n * Returns *true* if first argument less than second argument up to DP_TOL\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nfunction LT(x, y) {\n    return (x - y < -DP_TOL)\n}\n\n/**\n * Returns *true* if first argument less than or equal to second argument up to DP_TOL\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nfunction LE(x, y) {\n    return (x - y < DP_TOL);\n}\n\nvar Utils$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    DECIMALS: DECIMALS,\n    EQ: EQ,\n    EQ_0: EQ_0,\n    GE: GE,\n    GT: GT,\n    LE: LE,\n    LT: LT,\n    getTolerance: getTolerance,\n    setTolerance: setTolerance\n});\n\nlet Flatten = {\n    Utils: Utils$1,\n    Errors: undefined,\n    Matrix: undefined,\n    Planar_set: undefined,\n    Point: undefined,\n    Vector: undefined,\n    Line: undefined,\n    Circle: undefined,\n    Segment: undefined,\n    Arc: undefined,\n    Box: undefined,\n    Edge: undefined,\n    Face: undefined,\n    Ray: undefined,\n    Ray_shooting: undefined,\n    Multiline: undefined,\n    Polygon: undefined,\n    Distance: undefined,\n    Inversion: undefined\n};\n\nfor (let c in Constants) {Flatten[c] = Constants[c];}\n\nObject.defineProperty(Flatten, 'DP_TOL', {\n    get:function(){return getTolerance()}, \n    set:function(value){setTolerance(value);}\n});\n\n/**\n * Created by Alex Bol on 2/19/2017.\n */\n\n\n/**\n * Class of system errors\n */\nclass Errors {\n    /**\n     * Throw error ILLEGAL_PARAMETERS when cannot instantiate from given parameter\n     * @returns {ReferenceError}\n     */\n    static get ILLEGAL_PARAMETERS() {\n        return new ReferenceError('Illegal Parameters');\n    }\n\n    /**\n     * Throw error ZERO_DIVISION to catch situation of zero division\n     * @returns {Error}\n     */\n    static get ZERO_DIVISION() {\n        return new Error('Zero division');\n    }\n\n    /**\n     * Error to throw from BooleanOperations module in case when fixBoundaryConflicts not capable to fix it\n     * @returns {Error}\n     */\n    static get UNRESOLVED_BOUNDARY_CONFLICT() {\n        return new Error('Unresolved boundary conflict in boolean operation');\n    }\n\n    /**\n     * Error to throw from LinkedList:testInfiniteLoop static method\n     * in case when circular loop detected in linked list\n     * @returns {Error}\n     */\n    static get INFINITE_LOOP() {\n        return new Error('Infinite loop');\n    }\n\n    static get CANNOT_COMPLETE_BOOLEAN_OPERATION() {\n        return new Error('Cannot complete boolean operation')\n    }\n\n    static get CANNOT_INVOKE_ABSTRACT_METHOD() {\n        return new Error('Abstract method cannot be invoked');\n    }\n\n    static get OPERATION_IS_NOT_SUPPORTED() {\n        return new Error('Operation is not supported')\n    }\n}\n\nFlatten.Errors = Errors;\n\n/**\n * Class implements bidirectional non-circular linked list. <br/>\n * LinkedListElement - object of any type that has properties next and prev.\n */\nclass LinkedList {\n    constructor(first, last) {\n        this.first = first;\n        this.last = last || this.first;\n    }\n\n    [Symbol.iterator]() {\n        let value = undefined;\n        return {\n            next: () => {\n                value = value ? value.next : this.first;\n                return {value: value, done: value === undefined};\n            }\n        };\n    };\n\n    /**\n     * Return number of elements in the list\n     * @returns {number}\n     */\n    get size() {\n        let counter = 0;\n        for (let edge of this) {\n            counter++;\n        }\n        return counter;\n    }\n\n    /**\n     * Return array of elements from start to end,\n     * If start or end not defined, take first as start, last as end\n     * @returns {Array}\n     */\n    toArray(start=undefined, end=undefined) {\n        let elements = [];\n        let from = start || this.first;\n        let to = end || this.last;\n        let element = from;\n        if (element === undefined) return elements;\n        do {\n            elements.push(element);\n            element = element.next;\n        } while (element !== to.next);\n        return elements;\n    }\n\n\n    /**\n     * Append new element to the end of the list\n     * @param {LinkedListElement} element\n     * @returns {LinkedList}\n     */\n    append(element) {\n        if (this.isEmpty()) {\n            this.first = element;\n        } else {\n            element.prev = this.last;\n            this.last.next = element;\n        }\n\n        // update edge to be last\n        this.last = element;\n\n        // nullify non-circular links\n        this.last.next = undefined;\n        this.first.prev = undefined;\n        return this;\n    }\n\n    /**\n     * Insert new element to the list after elementBefore\n     * @param {LinkedListElement} newElement\n     * @param {LinkedListElement} elementBefore\n     * @returns {LinkedList}\n     */\n    insert(newElement, elementBefore) {\n        if (this.isEmpty()) {\n            this.first = newElement;\n            this.last = newElement;\n        }\n        else if (elementBefore === null || elementBefore === undefined) {\n            newElement.next = this.first;\n            this.first.prev = newElement;\n            this.first = newElement;\n        }\n        else {\n            /* set links to new element */\n            let elementAfter = elementBefore.next;\n            elementBefore.next = newElement;\n            if (elementAfter) elementAfter.prev = newElement;\n\n            /* set links from new element */\n            newElement.prev = elementBefore;\n            newElement.next = elementAfter;\n\n            /* extend list if new element added after the last element */\n            if (this.last === elementBefore)\n                this.last = newElement;\n        }\n        // nullify non-circular links\n        this.last.next = undefined;\n        this.first.prev = undefined;\n        return this;\n    }\n\n    /**\n     * Remove element from the list\n     * @param {LinkedListElement} element\n     * @returns {LinkedList}\n     */\n    remove(element) {\n        // special case if last edge removed\n        if (element === this.first && element === this.last) {\n            this.first = undefined;\n            this.last = undefined;\n        } else {\n            // update linked list\n            if (element.prev) element.prev.next = element.next;\n            if (element.next) element.next.prev = element.prev;\n            // update first if need\n            if (element === this.first) {\n                this.first = element.next;\n            }\n            // update last if need\n            if (element === this.last) {\n                this.last = element.prev;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Return true if list is empty\n     * @returns {boolean}\n     */\n    isEmpty() {\n        return this.first === undefined;\n    }\n\n    /**\n     * Throw an error if circular loop detected in the linked list\n     * @param {LinkedListElement} first element to start iteration\n     * @throws {Errors.INFINITE_LOOP}\n     */\n    static testInfiniteLoop(first) {\n        let edge = first;\n        let controlEdge = first;\n        do {\n            if (edge != first && edge === controlEdge) {\n                throw Errors.INFINITE_LOOP;  // new Error(\"Infinite loop\")\n            }\n            edge = edge.next;\n            controlEdge = controlEdge.next.next;\n        } while (edge != first)\n    }\n}\n\n/*\n    Smart intersections describe intersection points that refers to the edges they intersect\n    This function are supposed for internal usage by morphing and relation methods between\n */\n\nfunction addToIntPoints(edge, pt, int_points)\n{\n    let id = int_points.length;\n    let shapes = edge.shape.split(pt);\n\n    // if (shapes.length < 2) return;\n    if (shapes.length === 0) return;     // Point does not belong to edge ?\n\n    let len = 0;\n    if (shapes[0] === null) {   // point incident to edge start vertex\n        len = 0;\n    }\n    else if (shapes[1] === null) {   // point incident to edge end vertex\n        len = edge.shape.length;\n    }\n    else {                             // Edge was split into to edges\n        len = shapes[0].length;\n    }\n\n    let is_vertex = NOT_VERTEX$1;\n    if (EQ(len, 0)) {\n        is_vertex |= START_VERTEX$1;\n    }\n    if (EQ(len, edge.shape.length)) {\n        is_vertex |= END_VERTEX$1;\n    }\n    // Fix intersection point which is end point of the last edge\n    let arc_length;\n    if (len === Infinity) {\n        arc_length = shapes[0].coord(pt);\n    }\n    else {\n        arc_length = (is_vertex & END_VERTEX$1) && edge.next && edge.next.arc_length === 0 ?\n            0 :\n            edge.arc_length + len;\n    }\n\n    int_points.push({\n        id: id,\n        pt: pt,\n        arc_length: arc_length,\n        edge_before: edge,\n        edge_after: undefined,\n        face: edge.face,\n        is_vertex: is_vertex\n    });\n}\n\nfunction sortIntersections(intersections)\n{\n    // if (intersections.int_points1.length === 0) return;\n\n    // augment intersections with new sorted arrays\n    // intersections.int_points1_sorted = intersections.int_points1.slice().sort(compareFn);\n    // intersections.int_points2_sorted = intersections.int_points2.slice().sort(compareFn);\n    intersections.int_points1_sorted = getSortedArray(intersections.int_points1);\n    intersections.int_points2_sorted = getSortedArray(intersections.int_points2);\n}\n\nfunction getSortedArray(int_points)\n{\n    let faceMap = new Map;\n    let id = 0;\n    // Create integer id's for faces\n    for (let ip of int_points) {\n        if (!faceMap.has(ip.face)) {\n            faceMap.set(ip.face, id);\n            id++;\n        }\n    }\n    // Augment intersection points with face id's\n    for (let ip of int_points) {\n        ip.faceId = faceMap.get(ip.face);\n    }\n    // Clone and sort\n    let int_points_sorted = int_points.slice().sort(compareFn);\n    return int_points_sorted;\n}\n\nfunction compareFn(ip1, ip2)\n{\n    // compare face id's\n    if (ip1.faceId < ip2.faceId) {\n        return -1;\n    }\n    if (ip1.faceId > ip2.faceId) {\n        return 1;\n    }\n    // same face - compare arc_length\n    if (ip1.arc_length < ip2.arc_length) {\n        return -1;\n    }\n    if (ip1.arc_length > ip2.arc_length) {\n        return 1;\n    }\n    return 0;\n}\n\n// export function getSortedArrayOnLine(line, int_points) {\n//     return int_points.slice().sort( (int_point1, int_point2) => {\n//         if (line.coord(int_point1.pt) < line.coord(int_point2.pt)) {\n//             return -1;\n//         }\n//         if (line.coord(int_point1.pt) > line.coord(int_point2.pt)) {\n//             return 1;\n//         }\n//         return 0;\n//     })\n// }\n\nfunction filterDuplicatedIntersections(intersections)\n{\n    if (intersections.int_points1.length < 2) return;\n\n    let do_squeeze = false;\n\n    let int_point_ref1;\n    let int_point_ref2;\n    let int_point_cur1;\n    let int_point_cur2;\n    for (let i = 0; i < intersections.int_points1_sorted.length; i++) {\n\n        if (intersections.int_points1_sorted[i].id === -1)\n            continue;\n\n        int_point_ref1 = intersections.int_points1_sorted[i];\n        int_point_ref2 = intersections.int_points2[int_point_ref1.id];\n\n        for (let j=i+1; j < intersections.int_points1_sorted.length; j++) {\n            int_point_cur1 = intersections.int_points1_sorted[j];\n            if (!EQ(int_point_cur1.arc_length, int_point_ref1.arc_length)) {\n                break;\n            }\n            if (int_point_cur1.id === -1)\n                continue;\n            int_point_cur2 = intersections.int_points2[int_point_cur1.id];\n            if (int_point_cur2.id === -1)\n                continue;\n            if (int_point_cur1.edge_before === int_point_ref1.edge_before &&\n                int_point_cur1.edge_after === int_point_ref1.edge_after &&\n                int_point_cur2.edge_before === int_point_ref2.edge_before &&\n                int_point_cur2.edge_after === int_point_ref2.edge_after) {\n                int_point_cur1.id = -1;\n                /* to be deleted */\n                int_point_cur2.id = -1;\n                /* to be deleted */\n                do_squeeze = true;\n            }\n        }\n    }\n\n    int_point_ref2 = intersections.int_points2_sorted[0];\n    int_point_ref1 = intersections.int_points1[int_point_ref2.id];\n    for (let i = 1; i < intersections.int_points2_sorted.length; i++) {\n        let int_point_cur2 = intersections.int_points2_sorted[i];\n\n        if (int_point_cur2.id === -1) continue;\n        /* already deleted */\n\n        if (int_point_ref2.id === -1 || /* can't be reference if already deleted */\n            !(EQ(int_point_cur2.arc_length, int_point_ref2.arc_length))) {\n            int_point_ref2 = int_point_cur2;\n            int_point_ref1 = intersections.int_points1[int_point_ref2.id];\n            continue;\n        }\n\n        let int_point_cur1 = intersections.int_points1[int_point_cur2.id];\n        if (int_point_cur1.edge_before === int_point_ref1.edge_before &&\n            int_point_cur1.edge_after === int_point_ref1.edge_after &&\n            int_point_cur2.edge_before === int_point_ref2.edge_before &&\n            int_point_cur2.edge_after === int_point_ref2.edge_after) {\n            int_point_cur1.id = -1;\n            /* to be deleted */\n            int_point_cur2.id = -1;\n            /* to be deleted */\n            do_squeeze = true;\n        }\n    }\n\n    if (do_squeeze) {\n        intersections.int_points1 = intersections.int_points1.filter((int_point) => int_point.id >= 0);\n        intersections.int_points2 = intersections.int_points2.filter((int_point) => int_point.id >= 0);\n\n        // update id's\n        intersections.int_points1.forEach((int_point, index) => int_point.id = index);\n        intersections.int_points2.forEach((int_point, index) => int_point.id = index);\n    }\n}\n\nfunction initializeInclusionFlags(int_points)\n{\n    for (let int_point of int_points) {\n        if (int_point.edge_before) {\n            int_point.edge_before.bvStart = undefined;\n            int_point.edge_before.bvEnd = undefined;\n            int_point.edge_before.bv = undefined;\n            int_point.edge_before.overlap = undefined;\n        }\n\n        if (int_point.edge_after) {\n            int_point.edge_after.bvStart = undefined;\n            int_point.edge_after.bvEnd = undefined;\n            int_point.edge_after.bv = undefined;\n            int_point.edge_after.overlap = undefined;\n        }\n    }\n\n    for (let int_point of int_points) {\n        if (int_point.edge_before) int_point.edge_before.bvEnd = BOUNDARY$1;\n        if (int_point.edge_after) int_point.edge_after.bvStart = BOUNDARY$1;\n    }\n}\n\nfunction calculateInclusionFlags(int_points, polygon)\n{\n    for (let int_point of int_points) {\n        if (int_point.edge_before) int_point.edge_before.setInclusion(polygon);\n        if (int_point.edge_after) int_point.edge_after.setInclusion(polygon);\n    }\n}\n\nfunction setOverlappingFlags(intersections)\n{\n    let cur_face = undefined;\n    let first_int_point_in_face_id = undefined;\n    let next_int_point1 = undefined;\n    let num_int_points = intersections.int_points1.length;\n\n    for (let i = 0; i < num_int_points; i++) {\n        let cur_int_point1 = intersections.int_points1_sorted[i];\n\n        // Find boundary chain in the polygon1\n        if (cur_int_point1.face !== cur_face) {                               // next chain started\n            first_int_point_in_face_id = i; // cur_int_point1;\n            cur_face = cur_int_point1.face;\n        }\n\n        // Skip duplicated points with same <x,y> in \"cur_int_point1\" pool\n        let int_points_cur_pool_start = i;\n        let int_points_cur_pool_num = intPointsPoolCount(intersections.int_points1_sorted, i, cur_face);\n        let next_int_point_id;\n        if (int_points_cur_pool_start + int_points_cur_pool_num < num_int_points &&\n            intersections.int_points1_sorted[int_points_cur_pool_start + int_points_cur_pool_num].face === cur_face) {\n            next_int_point_id = int_points_cur_pool_start + int_points_cur_pool_num;\n        } else {                                         // get first point from the same face\n            next_int_point_id = first_int_point_in_face_id;\n        }\n\n        // From all points with same ,x,y. in 'next_int_point1' pool choose one that\n        // has same face both in res_poly and in wrk_poly\n        let int_points_next_pool_num = intPointsPoolCount(intersections.int_points1_sorted, next_int_point_id, cur_face);\n        next_int_point1 = null;\n        for (let j=next_int_point_id; j < next_int_point_id + int_points_next_pool_num; j++) {\n            let next_int_point1_tmp = intersections.int_points1_sorted[j];\n            if (next_int_point1_tmp.face === cur_face &&\n                intersections.int_points2[next_int_point1_tmp.id].face === intersections.int_points2[cur_int_point1.id].face) {\n                next_int_point1 = next_int_point1_tmp;\n                break;\n            }\n        }\n        if (next_int_point1 === null)\n            continue;\n\n        let edge_from1 = cur_int_point1.edge_after;\n        let edge_to1 = next_int_point1.edge_before;\n\n        if (!(edge_from1.bv === BOUNDARY$1 && edge_to1.bv === BOUNDARY$1))      // not a boundary chain - skip\n            continue;\n\n        if (edge_from1 !== edge_to1)                    //  one edge chain    TODO: support complex case\n            continue;\n\n        /* Find boundary chain in polygon2 between same intersection points */\n        let cur_int_point2 = intersections.int_points2[cur_int_point1.id];\n        let next_int_point2 = intersections.int_points2[next_int_point1.id];\n\n        let edge_from2 = cur_int_point2.edge_after;\n        let edge_to2 = next_int_point2.edge_before;\n\n        /* if [edge_from2..edge_to2] is not a boundary chain, invert it */\n        /* check also that chain consist of one or two edges */\n        if (!(edge_from2.bv === BOUNDARY$1 && edge_to2.bv === BOUNDARY$1 && edge_from2 === edge_to2)) {\n            cur_int_point2 = intersections.int_points2[next_int_point1.id];\n            next_int_point2 = intersections.int_points2[cur_int_point1.id];\n\n            edge_from2 = cur_int_point2.edge_after;\n            edge_to2 = next_int_point2.edge_before;\n        }\n\n        if (!(edge_from2.bv === BOUNDARY$1 && edge_to2.bv === BOUNDARY$1 && edge_from2 === edge_to2))\n            continue;                           // not an overlapping chain - skip   TODO: fix boundary conflict\n\n        // Set overlapping flag - one-to-one case\n        edge_from1.setOverlap(edge_from2);\n    }\n}\n\nfunction intPointsPoolCount(int_points, cur_int_point_num, cur_face)\n{\n    let int_point_current;\n    let int_point_next;\n\n    let int_points_pool_num = 1;\n\n    if (int_points.length === 1) return 1;\n\n    int_point_current = int_points[cur_int_point_num];\n\n    for (let i = cur_int_point_num + 1; i < int_points.length; i++) {\n        if (int_point_current.face !== cur_face) {      /* next face started */\n            break;\n        }\n\n        int_point_next = int_points[i];\n\n        if (!(int_point_next.pt.equalTo(int_point_current.pt) &&\n            int_point_next.edge_before === int_point_current.edge_before &&\n            int_point_next.edge_after === int_point_current.edge_after)) {\n            break;         /* next point is different - break and exit */\n        }\n\n        int_points_pool_num++;     /* duplicated intersection point - increase counter */\n    }\n    return int_points_pool_num;\n}\n\nfunction splitByIntersections(polygon, int_points)\n{\n    if (!int_points) return;\n    for (let int_point of int_points) {\n        let edge = int_point.edge_before;\n\n        // recalculate vertex flag: it may be changed after previous split\n        int_point.is_vertex = NOT_VERTEX$1;\n        if (edge.shape.start && edge.shape.start.equalTo(int_point.pt)) {\n            int_point.is_vertex |= START_VERTEX$1;\n        }\n        if (edge.shape.end && edge.shape.end.equalTo(int_point.pt)) {\n            int_point.is_vertex |= END_VERTEX$1;\n        }\n\n        if (int_point.is_vertex & START_VERTEX$1) {  // nothing to split\n            if (edge.prev) {\n                int_point.edge_before = edge.prev;           // polygon\n                int_point.is_vertex = END_VERTEX$1;\n            }\n            else {                                           // multiline start vertex\n                int_point.edge_after = int_point.edge_before;\n                int_point.edge_before = edge.prev;\n            }\n            continue;\n        }\n        if (int_point.is_vertex & END_VERTEX$1) {    // nothing to split\n            continue;\n        }\n\n        let newEdge = polygon.addVertex(int_point.pt, edge);\n        int_point.edge_before = newEdge;\n    }\n\n    for (let int_point of int_points) {\n        if (int_point.edge_before) {\n            int_point.edge_after = int_point.edge_before.next;\n        }\n    }\n}\n\nfunction insertBetweenIntPoints(int_point1, int_point2, new_edges) {\n    const edge_before = int_point1.edge_before;\n    const edge_after = int_point2.edge_after;\n    const len = new_edges.length;\n    edge_before.next = new_edges[0];\n    new_edges[0].prev = edge_before;\n\n    new_edges[len-1].next = edge_after;\n    edge_after.prev = new_edges[len-1];\n}\n\nvar smart_intersections = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    addToIntPoints: addToIntPoints,\n    calculateInclusionFlags: calculateInclusionFlags,\n    filterDuplicatedIntersections: filterDuplicatedIntersections,\n    getSortedArray: getSortedArray,\n    initializeInclusionFlags: initializeInclusionFlags,\n    insertBetweenIntPoints: insertBetweenIntPoints,\n    intPointsPoolCount: intPointsPoolCount,\n    setOverlappingFlags: setOverlappingFlags,\n    sortIntersections: sortIntersections,\n    splitByIntersections: splitByIntersections\n});\n\n/**\n * Created by Alex Bol on 12/02/2018.\n */\n/**\n * @module BooleanOperations\n */\n\nconst {INSIDE: INSIDE$1, OUTSIDE, BOUNDARY, OVERLAP_SAME, OVERLAP_OPPOSITE} = Constants;\nconst {NOT_VERTEX, START_VERTEX, END_VERTEX} = Constants;\n\nconst BOOLEAN_UNION = 1;\nconst BOOLEAN_INTERSECT = 2;\nconst BOOLEAN_SUBTRACT = 3;\n\n\n/**\n * Unify two polygons polygons and returns new polygon. <br/>\n * Point belongs to the resulted polygon if it belongs to the first OR to the second polygon\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Polygon}\n */\nfunction unify(polygon1, polygon2) {\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_UNION, true);\n    return res_poly;\n}\n\n/**\n * Subtract second polygon from the first and returns new polygon\n * Point belongs to the resulted polygon if it belongs to the first polygon AND NOT to the second polygon\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Polygon}\n */\nfunction subtract(polygon1, polygon2) {\n    let polygon2_tmp = polygon2.clone();\n    let polygon2_reversed = polygon2_tmp.reverse();\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2_reversed, BOOLEAN_SUBTRACT, true);\n    return res_poly;\n}\n\n/**\n * Intersect two polygons and returns new polygon\n * Point belongs to the resulted polygon is it belongs to the first AND to the second polygon\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Polygon}\n */\nfunction intersect$1(polygon1, polygon2) {\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_INTERSECT, true);\n    return res_poly;\n}\n\n/**\n * Returns boundary of intersection between two polygons as two arrays of shapes (Segments/Arcs) <br/>\n * The first array are shapes from the first polygon, the second array are shapes from the second\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Shape[][]}\n */\nfunction innerClip(polygon1, polygon2) {\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_INTERSECT, false);\n\n    let clip_shapes1 = [];\n    for (let face of res_poly.faces) {\n        clip_shapes1 = [...clip_shapes1, ...[...face.edges].map(edge => edge.shape)];\n    }\n    let clip_shapes2 = [];\n    for (let face of wrk_poly.faces) {\n        clip_shapes2 = [...clip_shapes2, ...[...face.edges].map(edge => edge.shape)];\n    }\n    return [clip_shapes1, clip_shapes2];\n}\n\n/**\n * Returns boundary of subtraction of the second polygon from first polygon as array of shapes\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Shape[]}\n */\nfunction outerClip(polygon1, polygon2) {\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_SUBTRACT, false);\n\n    let clip_shapes1 = [];\n    for (let face of res_poly.faces) {\n        clip_shapes1 = [...clip_shapes1, ...[...face.edges].map(edge => edge.shape)];\n    }\n\n    return clip_shapes1;\n}\n\n/**\n * Returns intersection points between boundaries of two polygons as two array of points <br/>\n * Points in the first array belong to first polygon, points from the second - to the second.\n * Points in each array are ordered according to the direction of the correspondent polygon\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Point[][]}\n */\nfunction calculateIntersections(polygon1, polygon2) {\n    let res_poly = polygon1.clone();\n    let wrk_poly = polygon2.clone();\n\n    // get intersection points\n    let intersections = getIntersections(res_poly, wrk_poly);\n\n    // sort intersection points\n    sortIntersections(intersections);\n\n    // split by intersection points\n    splitByIntersections(res_poly, intersections.int_points1_sorted);\n    splitByIntersections(wrk_poly, intersections.int_points2_sorted);\n\n    // filter duplicated intersection points\n    filterDuplicatedIntersections(intersections);\n\n    // sort intersection points again after filtering\n    sortIntersections(intersections);\n\n    let ip_sorted1 = intersections.int_points1_sorted.map( int_point => int_point.pt);\n    let ip_sorted2 = intersections.int_points2_sorted.map( int_point => int_point.pt);\n    return [ip_sorted1, ip_sorted2];\n}\n\nfunction filterNotRelevantEdges(res_poly, wrk_poly, intersections, op) {\n    // keep not intersected faces for further remove and merge\n    let notIntersectedFacesRes = getNotIntersectedFaces(res_poly, intersections.int_points1);\n    let notIntersectedFacesWrk = getNotIntersectedFaces(wrk_poly, intersections.int_points2);\n\n    // calculate inclusion flag for not intersected faces\n    calcInclusionForNotIntersectedFaces(notIntersectedFacesRes, wrk_poly);\n    calcInclusionForNotIntersectedFaces(notIntersectedFacesWrk, res_poly);\n\n    // initialize inclusion flags for edges incident to intersections\n    initializeInclusionFlags(intersections.int_points1);\n    initializeInclusionFlags(intersections.int_points2);\n\n    // calculate inclusion flags only for edges incident to intersections\n    calculateInclusionFlags(intersections.int_points1, wrk_poly);\n    calculateInclusionFlags(intersections.int_points2, res_poly);\n\n    // fix boundary conflicts\n    while (fixBoundaryConflicts(res_poly, wrk_poly, intersections.int_points1, intersections.int_points1_sorted, intersections.int_points2, intersections));\n    // while (fixBoundaryConflicts(wrk_poly, res_poly, intersections.int_points2, intersections.int_points2_sorted, intersections.int_points1, intersections));\n\n    // Set overlapping flags for boundary chains: SAME or OPPOSITE\n    setOverlappingFlags(intersections);\n\n    // remove not relevant chains between intersection points\n    removeNotRelevantChains(res_poly, op, intersections.int_points1_sorted, true);\n    removeNotRelevantChains(wrk_poly, op, intersections.int_points2_sorted, false);\n\n    // remove not relevant not intersected faces from res_polygon and wrk_polygon\n    // if op == UNION, remove faces that are included in wrk_polygon without intersection\n    // if op == INTERSECT, remove faces that are not included into wrk_polygon\n    removeNotRelevantNotIntersectedFaces(res_poly, notIntersectedFacesRes, op, true);\n    removeNotRelevantNotIntersectedFaces(wrk_poly, notIntersectedFacesWrk, op, false);\n}\n\nfunction swapLinksAndRestore(res_poly, wrk_poly, intersections, op) {\n\n    // add edges of wrk_poly into the edge container of res_poly\n    copyWrkToRes(res_poly, wrk_poly, op, intersections.int_points2);\n\n    // swap links from res_poly to wrk_poly and vice versa\n    swapLinks(res_poly, wrk_poly, intersections);\n\n    // remove old faces\n    removeOldFaces(res_poly, intersections.int_points1);\n    removeOldFaces(wrk_poly, intersections.int_points2);\n\n    // restore faces\n    restoreFaces(res_poly, intersections.int_points1, intersections.int_points2);\n    restoreFaces(res_poly, intersections.int_points2, intersections.int_points1);\n\n    // merge relevant not intersected faces from wrk_polygon to res_polygon\n    // mergeRelevantNotIntersectedFaces(res_poly, wrk_poly);\n}\n\n\nfunction booleanOpBinary(polygon1, polygon2, op, restore)\n{\n    let res_poly = polygon1.clone();\n    let wrk_poly = polygon2.clone();\n\n    // get intersection points\n    let intersections = getIntersections(res_poly, wrk_poly);\n\n    // sort intersection points\n    sortIntersections(intersections);\n\n    // split by intersection points\n    splitByIntersections(res_poly, intersections.int_points1_sorted);\n    splitByIntersections(wrk_poly, intersections.int_points2_sorted);\n\n    // filter duplicated intersection points\n    filterDuplicatedIntersections(intersections);\n\n    // sort intersection points again after filtering\n    sortIntersections(intersections);\n\n    // calculate inclusion and remove not relevant edges\n    filterNotRelevantEdges(res_poly, wrk_poly, intersections, op);\n\n    if (restore) {\n        swapLinksAndRestore(res_poly, wrk_poly, intersections, op);\n    }\n\n    return [res_poly, wrk_poly];\n}\n\nfunction getIntersections(polygon1, polygon2)\n{\n    let intersections = {\n        int_points1: [],\n        int_points2: []\n    };\n\n    // calculate intersections\n    for (let edge1 of polygon1.edges) {\n\n        // request edges of polygon2 in the box of edge1\n        let resp = polygon2.edges.search(edge1.box);\n\n        // for each edge2 in response\n        for (let edge2 of resp) {\n\n            // calculate intersections between edge1 and edge2\n            let ip = edge1.shape.intersect(edge2.shape);\n\n            // for each intersection point\n            for (let pt of ip) {\n                addToIntPoints(edge1, pt, intersections.int_points1);\n                addToIntPoints(edge2, pt, intersections.int_points2);\n            }\n        }\n    }\n    return intersections;\n}\n\nfunction getNotIntersectedFaces(poly, int_points)\n{\n    let notIntersected = [];\n    for (let face of poly.faces) {\n        if (!int_points.find((ip) => ip.face === face)) {\n            notIntersected.push(face);\n        }\n    }\n    return notIntersected;\n}\n\nfunction calcInclusionForNotIntersectedFaces(notIntersectedFaces, poly2)\n{\n    for (let face of notIntersectedFaces) {\n        face.first.bv = face.first.bvStart = face.first.bvEnd = undefined;\n        face.first.setInclusion(poly2);\n    }\n}\n\nfunction fixBoundaryConflicts(poly1, poly2, int_points1, int_points1_sorted, int_points2, intersections )\n{\n    let cur_face;\n    let first_int_point_in_face_id;\n    let next_int_point1;\n    let num_int_points = int_points1_sorted.length;\n    let iterate_more = false;\n\n    for (let i = 0; i < num_int_points; i++) {\n        let cur_int_point1 = int_points1_sorted[i];\n\n        // Find boundary chain in the polygon1\n        if (cur_int_point1.face !== cur_face) {                               // next chain started\n            first_int_point_in_face_id = i; // cur_int_point1;\n            cur_face = cur_int_point1.face;\n        }\n\n        // Skip duplicated points with same <x,y> in \"cur_int_point1\" pool\n        let int_points_cur_pool_start = i;\n        let int_points_cur_pool_num = intPointsPoolCount(int_points1_sorted, i, cur_face);\n        let next_int_point_id;\n        if (int_points_cur_pool_start + int_points_cur_pool_num < num_int_points &&\n            int_points1_sorted[int_points_cur_pool_start + int_points_cur_pool_num].face === cur_face) {\n            next_int_point_id = int_points_cur_pool_start + int_points_cur_pool_num;\n        } else {                                         // get first point from the same face\n            next_int_point_id = first_int_point_in_face_id;\n        }\n\n        // From all points with same ,x,y. in 'next_int_point1' pool choose one that\n        // has same face both in res_poly and in wrk_poly\n        let int_points_next_pool_num = intPointsPoolCount(int_points1_sorted, next_int_point_id, cur_face);\n        next_int_point1 = null;\n        for (let j=next_int_point_id; j < next_int_point_id + int_points_next_pool_num; j++) {\n            let next_int_point1_tmp = int_points1_sorted[j];\n            if (next_int_point1_tmp.face === cur_face &&\n                int_points2[next_int_point1_tmp.id].face === int_points2[cur_int_point1.id].face) {\n                next_int_point1 = next_int_point1_tmp;\n                break;\n            }\n        }\n        if (next_int_point1 === null)\n            continue;\n\n        let edge_from1 = cur_int_point1.edge_after;\n        let edge_to1 = next_int_point1.edge_before;\n\n        // Case #1. One of the ends is not boundary - probably tiny edge wrongly marked as boundary\n        if (edge_from1.bv === BOUNDARY && edge_to1.bv != BOUNDARY) {\n            edge_from1.bv = edge_to1.bv;\n            continue;\n        }\n\n        if (edge_from1.bv != BOUNDARY && edge_to1.bv === BOUNDARY) {\n            edge_to1.bv = edge_from1.bv;\n            continue;\n        }\n\n        // Set up all boundary values for middle edges. Need for cases 2 and 3\n        if ( (edge_from1.bv === BOUNDARY && edge_to1.bv === BOUNDARY && edge_from1 != edge_to1) ||\n        (edge_from1.bv === INSIDE$1 && edge_to1.bv === OUTSIDE  || edge_from1.bv === OUTSIDE && edge_to1.bv === INSIDE$1 ) ) {\n            let edge_tmp = edge_from1.next;\n            while (edge_tmp != edge_to1) {\n                edge_tmp.bvStart = undefined;\n                edge_tmp.bvEnd = undefined;\n                edge_tmp.bv = undefined;\n                edge_tmp.setInclusion(poly2);\n                edge_tmp = edge_tmp.next;\n            }\n        }\n\n        // Case #2. Both of the ends boundary. Check all the edges in the middle\n        // If some edges in the middle are not boundary then update bv of 'from' and 'to' edges\n        if (edge_from1.bv === BOUNDARY && edge_to1.bv === BOUNDARY && edge_from1 != edge_to1) {\n            let edge_tmp = edge_from1.next;\n            let new_bv;\n            while (edge_tmp != edge_to1) {\n                if (edge_tmp.bv != BOUNDARY) {\n                    if (new_bv === undefined) {        // first not boundary edge between from and to\n                        new_bv = edge_tmp.bv;\n                    }\n                    else {                            // another not boundary edge between from and to\n                        if (edge_tmp.bv != new_bv) {  // and it has different bv - can't resolve conflict\n                            throw Errors.UNRESOLVED_BOUNDARY_CONFLICT;\n                        }\n                    }\n                }\n                edge_tmp = edge_tmp.next;\n            }\n\n            if (new_bv != undefined) {\n                edge_from1.bv = new_bv;\n                edge_to1.bv = new_bv;\n            }\n            continue;         // all middle edges are boundary, proceed with this\n        }\n\n        // Case 3. One of the ends is inner, another is outer\n        if (edge_from1.bv === INSIDE$1 && edge_to1.bv === OUTSIDE  || edge_from1.bv === OUTSIDE && edge_to1.bv === INSIDE$1 ) {\n            let edge_tmp = edge_from1;\n            // Find missing intersection point\n            while (edge_tmp != edge_to1) {\n                if (edge_tmp.bvStart === edge_from1.bv && edge_tmp.bvEnd === edge_to1.bv) {\n                    let [dist, segment] = edge_tmp.shape.distanceTo(poly2);\n                    if (dist < 10*Flatten.DP_TOL) {  // it should be very close\n                        // let pt = edge_tmp.end;\n                        // add to the list of intersections of poly1\n                        addToIntPoints(edge_tmp, segment.ps, int_points1);\n\n                        // split edge_tmp in poly1 if need\n                        let int_point1 = int_points1[int_points1.length-1];\n                        if (int_point1.is_vertex & START_VERTEX) {        // nothing to split\n                            int_point1.edge_after = edge_tmp;\n                            int_point1.edge_before = edge_tmp.prev;\n                            edge_tmp.bvStart = BOUNDARY;\n                            edge_tmp.bv = undefined;\n                            edge_tmp.setInclusion(poly2);\n                        }\n                        else if (int_point1.is_vertex & END_VERTEX) {    // nothing to split\n                            int_point1.edge_after = edge_tmp.next;\n                            edge_tmp.bvEnd = BOUNDARY;\n                            edge_tmp.bv = undefined;\n                            edge_tmp.setInclusion(poly2);\n                        }\n                        else {        // split edge here\n                            let newEdge1 = poly2.addVertex(int_point1.pt, edge_tmp);\n                            int_point1.edge_before = newEdge1;\n                            int_point1.edge_after = newEdge1.next;\n\n                            newEdge1.setInclusion(poly2);\n\n                            newEdge1.next.bvStart = BOUNDARY;\n                            newEdge1.next.bvEnd = undefined;\n                            newEdge1.next.bv = undefined;\n                            newEdge1.next.setInclusion(poly2);\n                        }\n\n                        // add to the list of intersections of poly2\n                        let edge2 = poly2.findEdgeByPoint(segment.pe);\n                        addToIntPoints(edge2, segment.pe, int_points2);\n                        // split edge2 in poly2 if need\n                        let int_point2 = int_points2[int_points2.length-1];\n                        if (int_point2.is_vertex & START_VERTEX) {        // nothing to split\n                            int_point2.edge_after = edge2;\n                            int_point2.edge_before = edge2.prev;\n                        }\n                        else if (int_point2.is_vertex & END_VERTEX) {    // nothing to split\n                            int_point2.edge_after = edge2.next;\n                        }\n                        else {        // split edge here\n                            // first locate int_points that may refer to edge2 as edge.after\n                            // let int_point2_edge_before = int_points2.find( int_point => int_point.edge_before === edge2)\n                            let int_point2_edge_after = int_points2.find( int_point => int_point.edge_after === edge2 );\n\n                            let newEdge2 = poly2.addVertex(int_point2.pt, edge2);\n                            int_point2.edge_before = newEdge2;\n                            int_point2.edge_after = newEdge2.next;\n\n                            if (int_point2_edge_after)\n                                int_point2_edge_after.edge_after = newEdge2;\n\n                            newEdge2.bvStart = undefined;\n                            newEdge2.bvEnd = BOUNDARY;\n                            newEdge2.bv = undefined;\n                            newEdge2.setInclusion(poly1);\n\n                            newEdge2.next.bvStart = BOUNDARY;\n                            newEdge2.next.bvEnd = undefined;\n                            newEdge2.next.bv = undefined;\n                            newEdge2.next.setInclusion(poly1);\n                        }\n\n                        sortIntersections(intersections);\n\n                        iterate_more = true;\n                        break;\n                    }\n                }\n                edge_tmp = edge_tmp.next;\n            }\n\n            // we changed intersections inside loop, have to exit and repair again\n            if (iterate_more)\n                break;\n\n            throw Errors.UNRESOLVED_BOUNDARY_CONFLICT;\n        }\n    }\n\n    return iterate_more;\n}\n\nfunction removeNotRelevantChains(polygon, op, int_points, is_res_polygon)\n{\n    if (!int_points) return;\n    let cur_face = undefined;\n    let first_int_point_in_face_num = undefined;\n    let int_point_current;\n    let int_point_next;\n\n    for (let i = 0; i < int_points.length; i++) {\n        int_point_current = int_points[i];\n\n        if (int_point_current.face !== cur_face) {   // next face started\n            first_int_point_in_face_num = i;\n            cur_face = int_point_current.face;\n        }\n\n        if (cur_face.isEmpty())                // ??\n            continue;\n\n        // Get next int point from the same face that current\n\n        // Count how many duplicated points with same <x,y> in \"points from\" pool ?\n        let int_points_from_pull_start = i;\n        let int_points_from_pull_num = intPointsPoolCount(int_points, i, cur_face);\n        let next_int_point_num;\n        if (int_points_from_pull_start + int_points_from_pull_num < int_points.length &&\n            int_points[int_points_from_pull_start + int_points_from_pull_num].face === int_point_current.face) {\n            next_int_point_num = int_points_from_pull_start + int_points_from_pull_num;\n        } else {                                         // get first point from the same face\n            next_int_point_num = first_int_point_in_face_num;\n        }\n        int_point_next = int_points[next_int_point_num];\n\n        /* Count how many duplicated points with same <x,y> in \"points to\" pull ? */\n        let int_points_to_pull_start = next_int_point_num;\n        let int_points_to_pull_num = intPointsPoolCount(int_points, int_points_to_pull_start, cur_face);\n\n\n        let edge_from = int_point_current.edge_after;\n        let edge_to = int_point_next.edge_before;\n\n        if ((edge_from.bv === INSIDE$1 && edge_to.bv === INSIDE$1 && op === BOOLEAN_UNION) ||\n            (edge_from.bv === OUTSIDE && edge_to.bv === OUTSIDE && op === BOOLEAN_INTERSECT) ||\n            ((edge_from.bv === OUTSIDE || edge_to.bv === OUTSIDE) && op === BOOLEAN_SUBTRACT && !is_res_polygon) ||\n            ((edge_from.bv === INSIDE$1 || edge_to.bv === INSIDE$1) && op === BOOLEAN_SUBTRACT && is_res_polygon) ||\n            (edge_from.bv === BOUNDARY && edge_to.bv === BOUNDARY && (edge_from.overlap & OVERLAP_SAME) && is_res_polygon) ||\n            (edge_from.bv === BOUNDARY && edge_to.bv === BOUNDARY && (edge_from.overlap & OVERLAP_OPPOSITE))) {\n\n            polygon.removeChain(cur_face, edge_from, edge_to);\n\n            /* update all points in \"points from\" pull */\n            for (let k = int_points_from_pull_start; k < int_points_from_pull_start + int_points_from_pull_num; k++) {\n                int_points[k].edge_after = undefined;\n            }\n\n            /* update all points in \"points to\" pull */\n            for (let k = int_points_to_pull_start; k < int_points_to_pull_start + int_points_to_pull_num; k++) {\n                int_points[k].edge_before = undefined;\n            }\n        }\n\n        /* skip to the last point in \"points from\" group */\n        i += int_points_from_pull_num - 1;\n    }\n}\nfunction copyWrkToRes(res_polygon, wrk_polygon, op, int_points)\n{\n    for (let face of wrk_polygon.faces) {\n        for (let edge of face) {\n            res_polygon.edges.add(edge);\n        }\n        // If union - add face from wrk_polygon that is not intersected with res_polygon\n        if ( /*(op === BOOLEAN_UNION || op == BOOLEAN_SUBTRACT) &&*/\n            int_points.find((ip) => (ip.face === face)) === undefined) {\n            res_polygon.addFace(face.first, face.last);\n        }\n    }\n}\n\nfunction swapLinks(res_polygon, wrk_polygon, intersections)\n{\n    if (intersections.int_points1.length === 0) return;\n\n    for (let i = 0; i < intersections.int_points1.length; i++) {\n        let int_point1 = intersections.int_points1[i];\n        let int_point2 = intersections.int_points2[i];\n\n        // Simple case - find continuation on the other polygon\n\n        // Process edge from res_polygon\n        if (int_point1.edge_before !== undefined && int_point1.edge_after === undefined) {    // swap need\n            if (int_point2.edge_before === undefined && int_point2.edge_after !== undefined) {  // simple case\n                // Connect edges\n                int_point1.edge_before.next = int_point2.edge_after;\n                int_point2.edge_after.prev = int_point1.edge_before;\n\n                // Fill in missed links in intersection points\n                int_point1.edge_after = int_point2.edge_after;\n                int_point2.edge_before = int_point1.edge_before;\n            }\n        }\n        // Process edge from wrk_polygon\n        if (int_point2.edge_before !== undefined && int_point2.edge_after === undefined) {    // swap need\n            if (int_point1.edge_before === undefined && int_point1.edge_after !== undefined) {  // simple case\n                // Connect edges\n                int_point2.edge_before.next = int_point1.edge_after;\n                int_point1.edge_after.prev = int_point2.edge_before;\n\n                // Complete missed links\n                int_point2.edge_after = int_point1.edge_after;\n                int_point1.edge_before = int_point2.edge_before;\n            }\n        }\n\n        // Continuation not found - complex case\n        // Continuation will be found on the same polygon.\n        // It happens when intersection point is actually touching point\n        // Polygon1\n        if (int_point1.edge_before !== undefined && int_point1.edge_after === undefined) {    // still swap need\n            for (let int_point of intersections.int_points1_sorted) {\n                if (int_point === int_point1) continue;     // skip same\n                if (int_point.edge_before === undefined && int_point.edge_after !== undefined) {\n                    if (int_point.pt.equalTo(int_point1.pt)) {\n                        // Connect edges\n                        int_point1.edge_before.next = int_point.edge_after;\n                        int_point.edge_after.prev = int_point1.edge_before;\n\n                        // Complete missed links\n                        int_point1.edge_after = int_point.edge_after;\n                        int_point.edge_before = int_point1.edge_before;\n                    }\n                }\n            }\n        }\n        // Polygon2\n        if (int_point2.edge_before !== undefined && int_point2.edge_after === undefined) {    // still swap need\n            for (let int_point of intersections.int_points2_sorted) {\n                if (int_point === int_point2) continue;     // skip same\n                if (int_point.edge_before === undefined && int_point.edge_after !== undefined) {\n                    if (int_point.pt.equalTo(int_point2.pt)) {\n                        // Connect edges\n                        int_point2.edge_before.next = int_point.edge_after;\n                        int_point.edge_after.prev = int_point2.edge_before;\n\n                        // Complete missed links\n                        int_point2.edge_after = int_point.edge_after;\n                        int_point.edge_before = int_point2.edge_before;\n                    }\n                }\n            }\n        }\n    }\n    // Sanity check that no dead ends left\n}\n\nfunction removeOldFaces(polygon, int_points)\n{\n    for (let int_point of int_points) {\n        polygon.faces.delete(int_point.face);\n        int_point.face = undefined;\n        if (int_point.edge_before)\n            int_point.edge_before.face = undefined;\n        if (int_point.edge_after)\n            int_point.edge_after.face = undefined;\n    }\n}\n\nfunction restoreFaces(polygon, int_points, other_int_points)\n{\n    // For each intersection point - create new face\n    for (let int_point of int_points) {\n        if (int_point.edge_before === undefined || int_point.edge_after === undefined)  // completely deleted\n            continue;\n        if (int_point.face)            // already restored\n            continue;\n\n        if (int_point.edge_after.face || int_point.edge_before.face)        // Face already created. Possible case in duplicated intersection points\n            continue;\n\n        let first = int_point.edge_after;      // face start\n        let last = int_point.edge_before;      // face end;\n\n        try {\n            LinkedList.testInfiniteLoop(first);    // check and throw error if infinite loop found\n        }\n        catch (error) {\n            throw Errors.CANNOT_COMPLETE_BOOLEAN_OPERATION\n        }\n\n        let face = polygon.addFace(first, last);\n\n        // Mark intersection points from the newly create face\n        // to avoid multiple creation of the same face.\n        // Face was assigned to each edge of new face in addFace function\n        for (let int_point_tmp of int_points) {\n            if (int_point_tmp.edge_before && int_point_tmp.edge_after &&\n                int_point_tmp.edge_before.face === face && int_point_tmp.edge_after.face === face) {\n                int_point_tmp.face = face;\n            }\n        }\n        // Mark other intersection points as well\n        for (let int_point_tmp of other_int_points) {\n            if (int_point_tmp.edge_before && int_point_tmp.edge_after &&\n                int_point_tmp.edge_before.face === face && int_point_tmp.edge_after.face === face) {\n                int_point_tmp.face = face;\n            }\n        }\n    }\n}\n\nfunction removeNotRelevantNotIntersectedFaces(polygon, notIntersectedFaces, op, is_res_polygon)\n{\n    for (let face of notIntersectedFaces) {\n        let rel = face.first.bv;\n        if (op === BOOLEAN_UNION && rel === INSIDE$1 ||\n            op === BOOLEAN_SUBTRACT && rel === INSIDE$1 && is_res_polygon ||\n            op === BOOLEAN_SUBTRACT && rel === OUTSIDE && !is_res_polygon ||\n            op === BOOLEAN_INTERSECT && rel === OUTSIDE) {\n\n            polygon.deleteFace(face);\n        }\n    }\n}\n\nvar BooleanOperations = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    BOOLEAN_INTERSECT: BOOLEAN_INTERSECT,\n    BOOLEAN_SUBTRACT: BOOLEAN_SUBTRACT,\n    BOOLEAN_UNION: BOOLEAN_UNION,\n    calculateIntersections: calculateIntersections,\n    innerClip: innerClip,\n    intersect: intersect$1,\n    outerClip: outerClip,\n    removeNotRelevantChains: removeNotRelevantChains,\n    removeOldFaces: removeOldFaces,\n    restoreFaces: restoreFaces,\n    subtract: subtract,\n    unify: unify\n});\n\n/*\n    Dimensionally extended 9-intersected model\n    See https://en.wikipedia.org/wiki/DE-9IM for more details\n */\n// const DISJOINT = RegExp('FF.FF....');\nconst EQUAL = RegExp('T.F..FFF.|T.F...F..');\nconst INTERSECT = RegExp('T........|.T.......|...T.....|....T....');\nconst TOUCH = RegExp('FT.......|F..T.....|F...T....');\nconst INSIDE = RegExp('T.F..F...');\nconst COVERED = RegExp('T.F..F...|.TF..F...|..FT.F...|..F.TF...');\n\nclass DE9IM {\n    /**\n     * Create new instance of DE9IM matrix\n     */\n    constructor() {\n        /**\n         * Array representing 3x3 intersection matrix\n         * @type {Shape[]}\n         */\n        this.m = new Array(9).fill(undefined);\n    }\n\n    /**\n     * Get Interior To Interior intersection\n     * @returns {Shape[] | undefined}\n     */\n    get I2I() {\n        return this.m[0];\n    }\n\n    /**\n     * Set Interior To Interior intersection\n     * @param geom\n     */\n    set I2I(geom) {\n        this.m[0] = geom;\n    }\n\n    /**\n     * Get Interior To Boundary intersection\n     * @returns {Shape[] | undefined}\n     */\n    get I2B() {\n        return this.m[1];\n    }\n\n    /**\n     * Set Interior to Boundary intersection\n     * @param geomc\n     */\n    set I2B(geom) {\n        this.m[1] = geom;\n    }\n\n    /**\n     * Get Interior To Exterior intersection\n     * @returns {Shape[] | undefined}\n     */\n    get I2E() {\n        return this.m[2];\n    }\n\n    /**\n     * Set Interior to Exterior intersection\n     * @param geom\n     */\n    set I2E(geom) {\n        this.m[2] = geom;\n    }\n\n    /**\n     * Get Boundary To Interior intersection\n     * @returns {Shape[] | undefined}\n     */\n    get B2I() {\n        return this.m[3];\n    }\n\n    /**\n     * Set Boundary to Interior intersection\n     * @param geom\n     */\n    set B2I(geom) {\n        this.m[3] = geom;\n    }\n\n    /**\n     * Get Boundary To Boundary intersection\n     * @returns {Shape[] | undefined}\n     */\n    get B2B() {\n        return this.m[4];\n    }\n\n    /**\n     * Set Boundary to Boundary intersection\n     * @param geom\n     */\n    set B2B(geom) {\n        this.m[4] = geom;\n    }\n\n    /**\n     * Get Boundary To Exterior intersection\n     * @returns {Shape[] | undefined}\n     */\n    get B2E() {\n        return this.m[5];\n    }\n\n    /**\n     * Set Boundary to Exterior intersection\n     * @param geom\n     */\n    set B2E(geom) {\n        this.m[5] = geom;\n    }\n\n    /**\n     * Get Exterior To Interior intersection\n     * @returns {Shape[] | undefined}\n     */\n    get E2I() {\n        return this.m[6];\n    }\n\n    /**\n     * Set Exterior to Interior intersection\n     * @param geom\n     */\n    set E2I(geom) {\n        this.m[6] = geom;\n    }\n\n    /**\n     * Get Exterior To Boundary intersection\n     * @returns {Shape[] | undefined}\n     */\n    get E2B() {\n        return this.m[7];\n    }\n\n    /**\n     * Set Exterior to Boundary intersection\n     * @param geom\n     */\n    set E2B(geom) {\n        this.m[7] = geom;\n    }\n\n    /**\n     * Get Exterior to Exterior intersection\n     * @returns {Shape[] | undefined}\n     */\n    get E2E() {\n        return this.m[8];\n    }\n\n    /**\n     * Set Exterior to Exterior intersection\n     * @param geom\n     */\n    set E2E(geom) {\n        this.m[8] = geom;\n    }\n\n    /**\n     * Return de9im matrix as string where<br/>\n     * - intersection is 'T'<br/>\n     * - not intersected is 'F'<br/>\n     * - not relevant is '*'<br/>\n     * For example, string 'FF**FF****' means 'DISJOINT'\n     * @returns {string}\n     */\n    toString() {\n        return this.m.map( e => {\n            if (e instanceof Array && e.length > 0) {\n                return 'T'\n            }\n            else if (e instanceof Array && e.length === 0) {\n                return 'F'\n            }\n            else {\n                return '*'\n            }\n        }).join(\"\")\n    }\n\n    equal() {\n        return EQUAL.test(this.toString());\n    }\n\n    intersect() {\n        return INTERSECT.test(this.toString());\n    }\n\n    touch() {\n        return TOUCH.test(this.toString());\n    }\n\n    inside() {\n        return INSIDE.test(this.toString());\n    }\n\n    covered() {\n        return COVERED.test(this.toString());\n    }\n}\n\n/**\n * Intersection\n *\n * */\n\n\nfunction intersectLine2Line(line1, line2) {\n    let ip = [];\n\n    let [A1, B1, C1] = line1.standard;\n    let [A2, B2, C2] = line2.standard;\n\n    /* Cramer's rule */\n    let det = A1 * B2 - B1 * A2;\n    let detX = C1 * B2 - B1 * C2;\n    let detY = A1 * C2 - C1 * A2;\n\n    if (!Flatten.Utils.EQ_0(det)) {\n        let x, y;\n\n        if (B1 === 0) {        // vertical line x  = C1/A1, where A1 == +1 or -1\n            x = C1/A1;\n            y = detY / det;\n        }\n        else if (B2 === 0) {   // vertical line x = C2/A2, where A2 = +1 or -1\n            x = C2/A2;\n            y = detY / det;\n        }\n        else if (A1 === 0) {   // horizontal line y = C1/B1, where B1 = +1 or -1\n            x = detX / det;\n            y = C1/B1;\n        }\n        else if (A2 === 0) {   // horizontal line y = C2/B2, where B2 = +1 or -1\n            x = detX / det;\n            y = C2/B2;\n        }\n        else {\n            x = detX / det;\n            y = detY / det;\n        }\n\n        ip.push(new Flatten.Point(x, y));\n    }\n\n    return ip;\n}\n\nfunction intersectLine2Circle(line, circle) {\n    let ip = [];\n    let prj = circle.pc.projectionOn(line);            // projection of circle center on a line\n    let dist = circle.pc.distanceTo(prj)[0];           // distance from circle center to projection\n\n    if (Flatten.Utils.EQ(dist, circle.r)) {            // line tangent to circle - return single intersection point\n        ip.push(prj);\n    } else if (Flatten.Utils.LT(dist, circle.r)) {       // return two intersection points\n        let delta = Math.sqrt(circle.r * circle.r - dist * dist);\n        let v_trans, pt;\n\n        v_trans = line.norm.rotate90CCW().multiply(delta);\n        pt = prj.translate(v_trans);\n        ip.push(pt);\n\n        v_trans = line.norm.rotate90CW().multiply(delta);\n        pt = prj.translate(v_trans);\n        ip.push(pt);\n    }\n    return ip;\n}\n\nfunction intersectLine2Box(line, box) {\n    let ips = [];\n    for (let seg of box.toSegments()) {\n        let ips_tmp = intersectSegment2Line(seg, line);\n        for (let pt of ips_tmp) {\n            if (!ptInIntPoints(pt, ips)) {\n                ips.push(pt);\n            }\n        }\n    }\n    return ips;\n}\n\nfunction intersectLine2Arc(line, arc) {\n    let ip = [];\n\n    if (intersectLine2Box(line, arc.box).length === 0) {\n        return ip;\n    }\n\n    let circle = new Flatten.Circle(arc.pc, arc.r);\n    let ip_tmp = intersectLine2Circle(line, circle);\n    for (let pt of ip_tmp) {\n        if (pt.on(arc)) {\n            ip.push(pt);\n        }\n    }\n\n    return ip;\n}\n\nfunction intersectSegment2Line(seg, line) {\n    let ip = [];\n\n    // Boundary cases\n    if (seg.ps.on(line)) {\n        ip.push(seg.ps);\n    }\n    // If both ends lay on line, return two intersection points\n    if (seg.pe.on(line) && !seg.isZeroLength()) {\n        ip.push(seg.pe);\n    }\n\n    if (ip.length > 0) {\n        return ip;          // done, intersection found\n    }\n\n    // If zero-length segment and nothing found, return no intersections\n    if (seg.isZeroLength()) {\n        return ip;\n    }\n\n    // Not a boundary case, check if both points are on the same side and\n    // hence there is no intersection\n    if (seg.ps.leftTo(line) && seg.pe.leftTo(line) ||\n        !seg.ps.leftTo(line) && !seg.pe.leftTo(line)) {\n        return ip;\n    }\n\n    // Calculate intersection between lines\n    let line1 = new Flatten.Line(seg.ps, seg.pe);\n    return intersectLine2Line(line1, line);\n}\n\nfunction intersectSegment2Segment(seg1, seg2) {\n    let ip = [];\n\n    // quick reject\n    if (seg1.box.not_intersect(seg2.box)) {\n        return ip;\n    }\n\n    // Special case of seg1 zero length\n    if (seg1.isZeroLength()) {\n        if (seg1.ps.on(seg2)) {\n            ip.push(seg1.ps);\n        }\n        return ip;\n    }\n\n    // Special case of seg2 zero length\n    if (seg2.isZeroLength()) {\n        if (seg2.ps.on(seg1)) {\n            ip.push(seg2.ps);\n        }\n        return ip;\n    }\n\n    // Neither seg1 nor seg2 is zero length\n    let line1 = new Flatten.Line(seg1.ps, seg1.pe);\n    let line2 = new Flatten.Line(seg2.ps, seg2.pe);\n\n    // Check overlapping between segments in case of incidence\n    // If segments touching, add one point. If overlapping, add two points\n    if (line1.incidentTo(line2)) {\n        if (seg1.ps.on(seg2)) {\n            ip.push(seg1.ps);\n        }\n        if (seg1.pe.on(seg2)) {\n            ip.push(seg1.pe);\n        }\n        if (seg2.ps.on(seg1) && !seg2.ps.equalTo(seg1.ps) && !seg2.ps.equalTo(seg1.pe)) {\n            ip.push(seg2.ps);\n        }\n        if (seg2.pe.on(seg1) && !seg2.pe.equalTo(seg1.ps) && !seg2.pe.equalTo(seg1.pe)) {\n            ip.push(seg2.pe);\n        }\n    } else {                /* not incident - parallel or intersect */\n        // Calculate intersection between lines\n        let new_ip = intersectLine2Line(line1, line2);\n        if (new_ip.length > 0) {\n            if (isPointInSegmentBox(new_ip[0], seg1) && isPointInSegmentBox(new_ip[0], seg2)) {\n                ip.push(new_ip[0]);\n            }\n        }\n    }\n    return ip;\n}\n\nfunction isPointInSegmentBox(point, segment) {\n    const box = segment.box;\n    return Flatten.Utils.LE(point.x, box.xmax) && Flatten.Utils.GE(point.x, box.xmin) &&\n        Flatten.Utils.LE(point.y, box.ymax) && Flatten.Utils.GE(point.y, box.ymin)\n}\n\nfunction intersectSegment2Circle(segment, circle) {\n    let ips = [];\n\n    if (segment.box.not_intersect(circle.box)) {\n        return ips;\n    }\n\n    // Special case of zero length segment\n    if (segment.isZeroLength()) {\n        let [dist, _] = segment.ps.distanceTo(circle.pc);\n        if (Flatten.Utils.EQ(dist, circle.r)) {\n            ips.push(segment.ps);\n        }\n        return ips;\n    }\n\n    // Non zero-length segment\n    let line = new Flatten.Line(segment.ps, segment.pe);\n\n    let ips_tmp = intersectLine2Circle(line, circle);\n\n    for (let ip of ips_tmp) {\n        if (ip.on(segment)) {\n            ips.push(ip);\n        }\n    }\n\n    return ips;\n}\n\nfunction intersectSegment2Arc(segment, arc) {\n    let ip = [];\n\n    if (segment.box.not_intersect(arc.box)) {\n        return ip;\n    }\n\n    // Special case of zero-length segment\n    if (segment.isZeroLength()) {\n        if (segment.ps.on(arc)) {\n            ip.push(segment.ps);\n        }\n        return ip;\n    }\n\n    // Non-zero length segment\n    let line = new Flatten.Line(segment.ps, segment.pe);\n    let circle = new Flatten.Circle(arc.pc, arc.r);\n\n    let ip_tmp = intersectLine2Circle(line, circle);\n\n    for (let pt of ip_tmp) {\n        if (pt.on(segment) && pt.on(arc)) {\n            ip.push(pt);\n        }\n    }\n    return ip;\n\n}\n\nfunction intersectSegment2Box(segment, box) {\n    let ips = [];\n    for (let seg of box.toSegments()) {\n        let ips_tmp = intersectSegment2Segment(seg, segment);\n        for (let ip of ips_tmp) {\n            ips.push(ip);\n        }\n    }\n    return ips;\n}\n\nfunction intersectCircle2Circle(circle1, circle2) {\n    let ip = [];\n\n    if (circle1.box.not_intersect(circle2.box)) {\n        return ip;\n    }\n\n    let vec = new Flatten.Vector(circle1.pc, circle2.pc);\n\n    let r1 = circle1.r;\n    let r2 = circle2.r;\n\n    // Degenerated circle\n    if (Flatten.Utils.EQ_0(r1) || Flatten.Utils.EQ_0(r2))\n        return ip;\n\n    // In case of equal circles return one leftmost point\n    if (Flatten.Utils.EQ_0(vec.x) && Flatten.Utils.EQ_0(vec.y) && Flatten.Utils.EQ(r1, r2)) {\n        ip.push(circle1.pc.translate(-r1, 0));\n        return ip;\n    }\n\n    let dist = circle1.pc.distanceTo(circle2.pc)[0];\n\n    if (Flatten.Utils.GT(dist, r1 + r2))               // circles too far, no intersections\n        return ip;\n\n    if (Flatten.Utils.LT(dist, Math.abs(r1 - r2)))     // one circle is contained within another, no intersections\n        return ip;\n\n    // Normalize vector.\n    vec.x /= dist;\n    vec.y /= dist;\n\n    let pt;\n\n    // Case of touching from outside or from inside - single intersection point\n    // TODO: check this specifically not sure if correct\n    if (Flatten.Utils.EQ(dist, r1 + r2) || Flatten.Utils.EQ(dist, Math.abs(r1 - r2))) {\n        pt = circle1.pc.translate(r1 * vec.x, r1 * vec.y);\n        ip.push(pt);\n        return ip;\n    }\n\n    // Case of two intersection points\n\n    // Distance from first center to center of common chord:\n    //   a = (r1^2 - r2^2 + d^2) / 2d\n    // Separate for better accuracy\n    let a = (r1 * r1) / (2 * dist) - (r2 * r2) / (2 * dist) + dist / 2;\n\n    let mid_pt = circle1.pc.translate(a * vec.x, a * vec.y);\n    let h = Math.sqrt(r1 * r1 - a * a);\n    // let norm;\n\n    // norm = vec.rotate90CCW().multiply(h);\n    pt = mid_pt.translate(vec.rotate90CCW().multiply(h));\n    ip.push(pt);\n\n    // norm = vec.rotate90CW();\n    pt = mid_pt.translate(vec.rotate90CW().multiply(h));\n    ip.push(pt);\n\n    return ip;\n}\n\nfunction intersectCircle2Box(circle, box) {\n    let ips = [];\n    for (let seg of box.toSegments()) {\n        let ips_tmp = intersectSegment2Circle(seg, circle);\n        for (let ip of ips_tmp) {\n            ips.push(ip);\n        }\n    }\n    return ips;\n}\n\nfunction intersectArc2Arc(arc1, arc2) {\n    let ip = [];\n\n    if (arc1.box.not_intersect(arc2.box)) {\n        return ip;\n    }\n\n    // Special case: overlapping arcs\n    // May return up to 4 intersection points\n    if (arc1.pc.equalTo(arc2.pc) && Flatten.Utils.EQ(arc1.r, arc2.r)) {\n        let pt;\n\n        pt = arc1.start;\n        if (pt.on(arc2))\n            ip.push(pt);\n\n        pt = arc1.end;\n        if (pt.on(arc2))\n            ip.push(pt);\n\n        pt = arc2.start;\n        if (pt.on(arc1)) ip.push(pt);\n\n        pt = arc2.end;\n        if (pt.on(arc1)) ip.push(pt);\n\n        return ip;\n    }\n\n    // Common case\n    let circle1 = new Flatten.Circle(arc1.pc, arc1.r);\n    let circle2 = new Flatten.Circle(arc2.pc, arc2.r);\n    let ip_tmp = circle1.intersect(circle2);\n    for (let pt of ip_tmp) {\n        if (pt.on(arc1) && pt.on(arc2)) {\n            ip.push(pt);\n        }\n    }\n    return ip;\n}\n\nfunction intersectArc2Circle(arc, circle) {\n    let ip = [];\n\n    if (arc.box.not_intersect(circle.box)) {\n        return ip;\n    }\n\n    // Case when arc center incident to circle center\n    // Return arc's end points as 2 intersection points\n    if (circle.pc.equalTo(arc.pc) && Flatten.Utils.EQ(circle.r, arc.r)) {\n        ip.push(arc.start);\n        ip.push(arc.end);\n        return ip;\n    }\n\n    // Common case\n    let circle1 = circle;\n    let circle2 = new Flatten.Circle(arc.pc, arc.r);\n    let ip_tmp = intersectCircle2Circle(circle1, circle2);\n    for (let pt of ip_tmp) {\n        if (pt.on(arc)) {\n            ip.push(pt);\n        }\n    }\n    return ip;\n}\n\nfunction intersectArc2Box(arc, box) {\n    let ips = [];\n    for (let seg of box.toSegments()) {\n        let ips_tmp = intersectSegment2Arc(seg, arc);\n        for (let ip of ips_tmp) {\n            ips.push(ip);\n        }\n    }\n    return ips;\n}\n\nfunction intersectEdge2Segment(edge, segment) {\n    return edge.isSegment ? intersectSegment2Segment(edge.shape, segment) : intersectSegment2Arc(segment, edge.shape);\n}\n\nfunction intersectEdge2Arc(edge, arc) {\n    return edge.isSegment ? intersectSegment2Arc(edge.shape, arc) : intersectArc2Arc(edge.shape, arc);\n}\n\nfunction intersectEdge2Line(edge, line) {\n    return edge.isSegment ? intersectSegment2Line(edge.shape, line) : intersectLine2Arc(line, edge.shape);\n}\n\nfunction intersectEdge2Ray(edge, ray) {\n    return edge.isSegment ? intersectRay2Segment(ray, edge.shape) : intersectRay2Arc(ray, edge.shape);\n}\n\nfunction intersectEdge2Circle(edge, circle) {\n    return edge.isSegment ? intersectSegment2Circle(edge.shape, circle) : intersectArc2Circle(edge.shape, circle);\n}\n\nfunction intersectSegment2Polygon(segment, polygon) {\n    let ip = [];\n\n    for (let edge of polygon.edges) {\n        for (let pt of intersectEdge2Segment(edge, segment)) {\n            ip.push(pt);\n        }\n    }\n\n    return ip;\n}\n\nfunction intersectArc2Polygon(arc, polygon) {\n    let ip = [];\n\n    for (let edge of polygon.edges) {\n        for (let pt of intersectEdge2Arc(edge, arc)) {\n            ip.push(pt);\n        }\n    }\n\n    return ip;\n}\n\nfunction intersectLine2Polygon(line, polygon) {\n    let ip = [];\n\n    if (polygon.isEmpty()) {\n        return ip;\n    }\n\n    for (let edge of polygon.edges) {\n        for (let pt of intersectEdge2Line(edge, line)) {\n            if (!ptInIntPoints(pt, ip)) {\n                ip.push(pt);\n            }\n        }\n    }\n\n    return line.sortPoints(ip);\n}\n\nfunction intersectCircle2Polygon(circle, polygon) {\n    let ip = [];\n\n    if (polygon.isEmpty()) {\n        return ip;\n    }\n\n    for (let edge of polygon.edges) {\n        for (let pt of intersectEdge2Circle(edge, circle)) {\n            ip.push(pt);\n        }\n    }\n\n    return ip;\n}\n\nfunction intersectEdge2Edge(edge1, edge2) {\n    if (edge1.isSegment) {\n        return intersectEdge2Segment(edge2, edge1.shape)\n    }\n    else if (edge1.isArc) {\n        return intersectEdge2Arc(edge2, edge1.shape)\n    }\n    else if (edge1.isLine) {\n        return intersectEdge2Line(edge2, edge1.shape)\n    }\n    else if (edge1.isRay) {\n        return intersectEdge2Ray(edge2, edge1.shape)\n    }\n    return []\n}\n\nfunction intersectEdge2Polygon(edge, polygon) {\n    let ip = [];\n\n    if (polygon.isEmpty() || edge.shape.box.not_intersect(polygon.box)) {\n        return ip;\n    }\n\n    let resp_edges = polygon.edges.search(edge.shape.box);\n\n    for (let resp_edge of resp_edges) {\n        ip = [...ip, ...intersectEdge2Edge(edge, resp_edge)];\n    }\n\n    return ip;\n}\n\nfunction intersectPolygon2Polygon(polygon1, polygon2) {\n    let ip = [];\n\n    if (polygon1.isEmpty() || polygon2.isEmpty()) {\n        return ip;\n    }\n\n    if (polygon1.box.not_intersect(polygon2.box)) {\n        return ip;\n    }\n\n    for (let edge1 of polygon1.edges) {\n        ip = [...ip, ...intersectEdge2Polygon(edge1, polygon2)];\n    }\n\n    return ip;\n}\n\nfunction intersectShape2Polygon(shape, polygon) {\n    if (shape instanceof Flatten.Line) {\n        return intersectLine2Polygon(shape, polygon);\n    }\n    else if (shape instanceof Flatten.Segment) {\n        return intersectSegment2Polygon(shape, polygon);\n    }\n    else if (shape instanceof Flatten.Arc) {\n        return intersectArc2Polygon(shape, polygon);\n    }\n    else {\n        return [];\n    }\n}\n\nfunction ptInIntPoints(new_pt, ip) {\n    return ip.some( pt => pt.equalTo(new_pt) )\n}\n\nfunction createLineFromRay(ray) {\n    return new Flatten.Line(ray.start, ray.norm)\n}\nfunction intersectRay2Segment(ray, segment) {\n    return intersectSegment2Line(segment, createLineFromRay(ray))\n        .filter(pt => ray.contains(pt));\n}\n\nfunction intersectRay2Arc(ray, arc) {\n    return intersectLine2Arc(createLineFromRay(ray), arc)\n        .filter(pt => ray.contains(pt))\n}\n\nfunction intersectRay2Circle(ray, circle) {\n    return intersectLine2Circle(createLineFromRay(ray), circle)\n        .filter(pt => ray.contains(pt))\n}\n\nfunction intersectRay2Box(ray, box) {\n    return intersectLine2Box(createLineFromRay(ray), box)\n        .filter(pt => ray.contains(pt))\n}\n\nfunction intersectRay2Line(ray, line) {\n    return intersectLine2Line(createLineFromRay(ray), line)\n        .filter(pt => ray.contains(pt))\n}\n\nfunction intersectRay2Ray(ray1, ray2) {\n    return intersectLine2Line(createLineFromRay(ray1), createLineFromRay(ray2))\n        .filter(pt => ray1.contains(pt))\n        .filter(pt => ray2.contains(pt))\n}\n\nfunction intersectRay2Polygon(ray, polygon) {\n    return intersectLine2Polygon(createLineFromRay(ray), polygon)\n        .filter(pt => ray.contains(pt))\n}\n\nconst defaultAttributes = {\n    stroke: \"black\"\n};\n\nclass SVGAttributes {\n    constructor(args = defaultAttributes) {\n        for(const property in args) {\n            this[property] = args[property];\n        }\n        this.stroke = args.stroke ?? defaultAttributes.stroke;\n    }\n\n    toAttributesString() {\n        return Object.keys(this)\n            .reduce( (acc, key) =>\n                    acc + (this[key] !== undefined ? this.toAttrString(key, this[key]) : \"\")\n            , ``)\n    }\n\n    toAttrString(key, value) {\n        const SVGKey = key === \"className\" ? \"class\" : this.convertCamelToKebabCase(key);\n        return value === null ? `${SVGKey} ` : `${SVGKey}=\"${value.toString()}\" `\n    }\n\n    convertCamelToKebabCase(str) {\n        return str\n            .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)\n            .join('-')\n            .toLowerCase();\n    }\n}\n\nfunction convertToString(attrs) {\n    return new SVGAttributes(attrs).toAttributesString()\n}\n\n/**\n * Class Multiline represent connected path of [edges]{@link Flatten.Edge}, where each edge may be\n * [segment]{@link Flatten.Segment}, [arc]{@link Flatten.Arc}, [line]{@link Flatten.Line} or [ray]{@link Flatten.Ray}\n */\nclass Multiline extends LinkedList {\n    constructor(...args) {\n        super();\n\n        if (args.length === 0) {\n            return;\n        }\n\n        if (args.length === 1) {\n            if (args[0] instanceof Array) {\n                let shapes = args[0];\n                if (shapes.length === 0)\n                    return;\n\n                // TODO: more strict validation:\n                // there may be only one line\n                // only first and last may be rays\n                shapes.every((shape) => {\n                    return shape instanceof Flatten.Segment ||\n                        shape instanceof Flatten.Arc ||\n                        shape instanceof Flatten.Ray ||\n                        shape instanceof Flatten.Line\n                });\n\n                for (let shape of shapes) {\n                    let edge = new Flatten.Edge(shape);\n                    this.append(edge);\n                }\n\n                this.setArcLength();\n            }\n        }\n    }\n\n    /**\n     * (Getter) Return array of edges\n     * @returns {Edge[]}\n     */\n    get edges() {\n        return [...this];\n    }\n\n    /**\n     * (Getter) Return bounding box of the multiline\n     * @returns {Box}\n     */\n    get box() {\n        return this.edges.reduce( (acc,edge) => acc.merge(edge.box), new Flatten.Box() );\n    }\n\n    /**\n     * (Getter) Returns array of vertices\n     * @returns {Point[]}\n     */\n    get vertices() {\n        let v = this.edges.map(edge => edge.start);\n        v.push(this.last.end);\n        return v;\n    }\n\n    /**\n     * Return new cloned instance of Multiline\n     * @returns {Multiline}\n     */\n    clone() {\n        return new Multiline(this.toShapes());\n    }\n\n    /**\n     * Set arc_length property for each of the edges in the face.\n     * Arc_length of the edge it the arc length from the first edge of the face\n     */\n    setArcLength() {\n        for (let edge of this) {\n            this.setOneEdgeArcLength(edge);\n        }\n    }\n\n    setOneEdgeArcLength(edge) {\n        if (edge === this.first) {\n            edge.arc_length = 0.0;\n        } else {\n            edge.arc_length = edge.prev.arc_length + edge.prev.length;\n        }\n    }\n\n    /**\n     * Split edge and add new vertex, return new edge inserted\n     * @param {Point} pt - point on edge that will be added as new vertex\n     * @param {Edge} edge - edge to split\n     * @returns {Edge}\n     */\n    addVertex(pt, edge) {\n        let shapes = edge.shape.split(pt);\n        // if (shapes.length < 2) return;\n\n        if (shapes[0] === null)   // point incident to edge start vertex, return previous edge\n           return edge.prev;\n\n        if (shapes[1] === null)   // point incident to edge end vertex, return edge itself\n           return edge;\n\n        let newEdge = new Flatten.Edge(shapes[0]);\n        let edgeBefore = edge.prev;\n\n        /* Insert first split edge into linked list after edgeBefore */\n        this.insert(newEdge, edgeBefore);     // edge.face ?\n\n        // Update edge shape with second split edge keeping links\n        edge.shape = shapes[1];\n\n        return newEdge;\n    }\n\n    getChain(edgeFrom, edgeTo) {\n        let edges = [];\n        for (let edge = edgeFrom; edge !== edgeTo.next; edge = edge.next) {\n            edges.push(edge);\n        }\n        return edges\n    }\n\n    /**\n     * Split edges of multiline with intersection points and return mutated multiline\n     * @param {Point[]} ip - array of points to be added as new vertices\n     * @returns {Multiline}\n     */\n    split(ip) {\n        for (let pt of ip) {\n            let edge = this.findEdgeByPoint(pt);\n            this.addVertex(pt, edge);\n        }\n        return this;\n    }\n\n    /**\n     * Returns edge which contains given point\n     * @param {Point} pt\n     * @returns {Edge}\n     */\n    findEdgeByPoint(pt) {\n        let edgeFound;\n        for (let edge of this) {\n            if (edge.shape.contains(pt)) {\n                edgeFound = edge;\n                break;\n            }\n        }\n        return edgeFound;\n    }\n\n    /**\n     * Returns new multiline translated by vector vec\n     * @param {Vector} vec\n     * @returns {Multiline}\n     */\n    translate(vec) {\n        return new Multiline(this.edges.map( edge => edge.shape.translate(vec)));\n    }\n\n    /**\n     * Return new multiline rotated by given angle around given point\n     * If point omitted, rotate around origin (0,0)\n     * Positive value of angle defines rotation counterclockwise, negative - clockwise\n     * @param {number} angle - rotation angle in radians\n     * @param {Point} center - rotation center, default is (0,0)\n     * @returns {Multiline} - new rotated polygon\n     */\n    rotate(angle = 0, center = new Flatten.Point()) {\n        return new Multiline(this.edges.map( edge => edge.shape.rotate(angle, center) ));\n    }\n\n    /**\n     * Return new multiline transformed using affine transformation matrix\n     * Method does not support unbounded shapes\n     * @param {Matrix} matrix - affine transformation matrix\n     * @returns {Multiline} - new multiline\n     */\n    transform(matrix = new Flatten.Matrix()) {\n        return new Multiline(this.edges.map( edge => edge.shape.transform(matrix)));\n    }\n\n    /**\n     * Transform multiline into array of shapes\n     * @returns {Shape[]}\n     */\n    toShapes() {\n        return this.edges.map(edge => edge.shape.clone())\n    }\n\n    /**\n     * This method returns an object that defines how data will be\n     * serialized when called JSON.stringify() method\n     * @returns {Object}\n     */\n    toJSON() {\n        return this.edges.map(edge => edge.toJSON());\n    }\n\n    /**\n     * Return string to draw multiline in svg\n     * @param attrs  - an object with attributes for svg path element\n     * TODO: support semi-infinite Ray and infinite Line\n     * @returns {string}\n     */\n    svg(attrs = {}) {\n        let svgStr = `\\n<path ${convertToString({fill: \"none\", ...attrs})} d=\"`;\n        svgStr += `\\nM${this.first.start.x},${this.first.start.y}`;\n        for (let edge of this) {\n            svgStr += edge.svg();\n        }\n        svgStr += `\" >\\n</path>`;\n        return svgStr;\n    }\n}\n\nFlatten.Multiline = Multiline;\n\n/**\n * Shortcut function to create multiline\n * @param args\n */\nconst multiline = (...args) => new Flatten.Multiline(...args);\nFlatten.multiline = multiline;\n\n/**\n * @module RayShoot\n */\n/**\n * Implements ray shooting algorithm. Returns relation between point and polygon: inside, outside or boundary\n * @param {Polygon} polygon - polygon to test\n * @param {Point} point - point to test\n * @returns {INSIDE|OUTSIDE|BOUNDARY}\n */\nfunction ray_shoot(polygon, point) {\n    let contains = undefined;\n\n    // 1. Quick reject\n    // if (polygon.box.not_intersect(point.box)) {\n    //     return Flatten.OUTSIDE;\n    // }\n\n    let ray = new Flatten.Ray(point);\n    let line = new Flatten.Line(ray.pt, ray.norm);\n\n    // 2. Locate relevant edges of the polygon\n    const searchBox = new Flatten.Box(\n        ray.box.xmin-Flatten.DP_TOL, ray.box.ymin-Flatten.DP_TOL,\n        ray.box.xmax, ray.box.ymax+Flatten.DP_TOL\n    );\n\n    if (polygon.box.not_intersect(searchBox)) {\n        return Flatten.OUTSIDE;\n    }\n\n    let resp_edges = polygon.edges.search(searchBox);\n\n    if (resp_edges.length == 0) {\n        return Flatten.OUTSIDE;\n    }\n\n    // 2.5 Check if boundary\n    for (let edge of resp_edges) {\n        if (edge.shape.contains(point)) {\n            return Flatten.BOUNDARY;\n        }\n    }\n\n    // 3. Calculate intersections\n    let intersections = [];\n    for (let edge of resp_edges) {\n        for (let ip of ray.intersect(edge.shape)) {\n\n            // If intersection is equal to query point then point lays on boundary\n            if (ip.equalTo(point)) {\n                return Flatten.BOUNDARY;\n            }\n\n            intersections.push({\n                pt: ip,\n                edge: edge\n            });\n        }\n    }\n\n    // 4. Sort intersection in x-ascending order\n    intersections.sort((i1, i2) => {\n        if (LT(i1.pt.x, i2.pt.x)) {\n            return -1;\n        }\n        if (GT(i1.pt.x, i2.pt.x)) {\n            return 1;\n        }\n        return 0;\n    });\n\n    // 5. Count real intersections, exclude touching\n    let counter = 0;\n\n    for (let i = 0; i < intersections.length; i++) {\n        let intersection = intersections[i];\n        if (intersection.pt.equalTo(intersection.edge.shape.start)) {\n            /* skip same point between same edges if already counted */\n            if (i > 0 && intersection.pt.equalTo(intersections[i - 1].pt) &&\n                intersection.edge.prev === intersections[i - 1].edge) {\n                continue;\n            }\n            let prev_edge = intersection.edge.prev;\n            while (EQ_0(prev_edge.length)) {\n                prev_edge = prev_edge.prev;\n            }\n            let prev_tangent = prev_edge.shape.tangentInEnd();\n            let prev_point = intersection.pt.translate(prev_tangent);\n\n            let cur_tangent = intersection.edge.shape.tangentInStart();\n            let cur_point = intersection.pt.translate(cur_tangent);\n\n            let prev_on_the_left = prev_point.leftTo(line);\n            let cur_on_the_left = cur_point.leftTo(line);\n\n            if ((prev_on_the_left && !cur_on_the_left) || (!prev_on_the_left && cur_on_the_left)) {\n                counter++;\n            }\n        } else if (intersection.pt.equalTo(intersection.edge.shape.end)) {\n            /* skip same point between same edges if already counted */\n            if (i > 0 && intersection.pt.equalTo(intersections[i - 1].pt) &&\n                intersection.edge.next === intersections[i - 1].edge) {\n                continue;\n            }\n            let next_edge = intersection.edge.next;\n            while (EQ_0(next_edge.length)) {\n                next_edge = next_edge.next;\n            }\n            let next_tangent = next_edge.shape.tangentInStart();\n            let next_point = intersection.pt.translate(next_tangent);\n\n            let cur_tangent = intersection.edge.shape.tangentInEnd();\n            let cur_point = intersection.pt.translate(cur_tangent);\n\n            let next_on_the_left = next_point.leftTo(line);\n            let cur_on_the_left = cur_point.leftTo(line);\n\n            if ((next_on_the_left && !cur_on_the_left) || (!next_on_the_left && cur_on_the_left)) {\n                counter++;\n            }\n        } else {        /* intersection point is not a coincident with a vertex */\n            if (intersection.edge.shape instanceof Flatten.Segment) {\n                counter++;\n            } else {\n                /* Check if ray does not touch the curve in the extremal (top or bottom) point */\n                let box = intersection.edge.shape.box;\n                if (!(EQ(intersection.pt.y, box.ymin) ||\n                    EQ(intersection.pt.y, box.ymax))) {\n                    counter++;\n                }\n            }\n        }\n    }\n\n    // 6. Odd or even?\n    contains = counter % 2 == 1 ? INSIDE$2 : OUTSIDE$1;\n\n    return contains;\n}\n\n/*\n    Calculate relationship between two shapes and return result in the form of\n    Dimensionally Extended nine-Intersection Matrix (https://en.wikipedia.org/wiki/DE-9IM)\n */\n\n\n/**\n * Returns true if shapes are topologically equal:  their interiors intersect and\n * no part of the interior or boundary of one geometry intersects the exterior of the other\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction equal(shape1, shape2) {\n    return relate(shape1, shape2).equal();\n}\n\n/**\n * Returns true if shapes have at least one point in common, same as \"not disjoint\"\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction intersect(shape1, shape2) {\n    return relate(shape1, shape2).intersect();\n}\n\n/**\n * Returns true if shapes have at least one point in common, but their interiors do not intersect\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction touch(shape1, shape2) {\n    return relate(shape1, shape2).touch();\n}\n\n/**\n * Returns true if shapes have no points in common neither in interior nor in boundary\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction disjoint(shape1, shape2) {\n    return !intersect(shape1, shape2);\n}\n\n/**\n * Returns true shape1 lies in the interior of shape2\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction inside(shape1, shape2) {\n    return relate(shape1, shape2).inside();\n}\n\n/**\n * Returns true if every point in shape1 lies in the interior or on the boundary of shape2\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction covered(shape1, shape2) {\n    return  relate(shape1, shape2).covered();\n}\n\n/**\n * Returns true shape1's interior contains shape2 <br/>\n * Same as inside(shape2, shape1)\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction contain(shape1, shape2) {\n    return inside(shape2, shape1);\n}\n\n/**\n * Returns true shape1's cover shape2, same as shape2 covered by shape1\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction cover(shape1, shape2) {\n    return covered(shape2, shape1);\n}\n\n/**\n * Returns relation between two shapes as intersection 3x3 matrix, where each\n * element contains relevant intersection as array of shapes.\n * If there is no intersection, element contains empty array\n * If intersection is irrelevant it left undefined. (For example, intersection\n * between two exteriors is usually irrelevant)\n * @param shape1\n * @param shape2\n * @returns {DE9IM}\n */\nfunction relate(shape1, shape2) {\n    if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Line) {\n        return relateLine2Line(shape1,  shape2);\n    }\n    else if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Circle) {\n        return relateLine2Circle(shape1, shape2);\n    }\n    else if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Box) {\n        return relateLine2Box(shape1, shape2);\n    }\n    else if ( shape1 instanceof Flatten.Line  && shape2 instanceof Flatten.Polygon) {\n        return relateLine2Polygon(shape1, shape2);\n    }\n    else if ( (shape1 instanceof Flatten.Segment || shape1 instanceof Flatten.Arc)  && shape2 instanceof Flatten.Polygon) {\n        return relateShape2Polygon(shape1, shape2);\n    }\n    else if ( (shape1 instanceof Flatten.Segment || shape1 instanceof Flatten.Arc)  &&\n        (shape2 instanceof Flatten.Circle || shape2 instanceof Flatten.Box) ) {\n        return relateShape2Polygon(shape1, new Flatten.Polygon(shape2));\n    }\n    else if (shape1 instanceof Flatten.Polygon && shape2 instanceof Flatten.Polygon) {\n        return relatePolygon2Polygon(shape1, shape2);\n    }\n    else if ((shape1 instanceof Flatten.Circle || shape1 instanceof Flatten.Box) &&\n        (shape2 instanceof  Flatten.Circle || shape2 instanceof Flatten.Box)) {\n        return relatePolygon2Polygon(new Flatten.Polygon(shape1), new Flatten.Polygon(shape2));\n    }\n    else if ((shape1 instanceof Flatten.Circle || shape1 instanceof Flatten.Box) && shape2 instanceof Flatten.Polygon) {\n        return relatePolygon2Polygon(new Flatten.Polygon(shape1), shape2);\n    }\n    else if (shape1 instanceof Flatten.Polygon && (shape2 instanceof Flatten.Circle || shape2 instanceof Flatten.Box)) {\n        return relatePolygon2Polygon(shape1, new Flatten.Polygon(shape2));\n    }\n}\n\nfunction relateLine2Line(line1, line2) {\n    let denim = new DE9IM();\n    let ip = intersectLine2Line(line1, line2);\n    if (ip.length === 0) {       // parallel or equal ?\n        if (line1.contains(line2.pt) && line2.contains(line1.pt)) {\n            denim.I2I = [line1];   // equal  'T.F...F..'  - no boundary\n            denim.I2E = [];\n            denim.E2I = [];\n        }\n        else {                     // parallel - disjoint 'FFTFF*T**'\n            denim.I2I = [];\n            denim.I2E = [line1];\n            denim.E2I = [line2];\n        }\n    }\n    else {                       // intersect   'T********'\n        denim.I2I = ip;\n        denim.I2E = line1.split(ip);\n        denim.E2I = line2.split(ip);\n    }\n    return denim;\n}\n\nfunction relateLine2Circle(line,circle) {\n    let denim = new DE9IM();\n    let ip = intersectLine2Circle(line, circle);\n    if (ip.length === 0) {\n        denim.I2I = [];\n        denim.I2B = [];\n        denim.I2E = [line];\n        denim.E2I = [circle];\n    }\n    else if (ip.length === 1) {\n        denim.I2I = [];\n        denim.I2B = ip;\n        denim.I2E = line.split(ip);\n\n        denim.E2I = [circle];\n    }\n    else {       // ip.length == 2\n        let multiline = new Multiline([line]);\n        let ip_sorted = line.sortPoints(ip);\n        multiline.split(ip_sorted);\n        let splitShapes = multiline.toShapes();\n\n        denim.I2I = [splitShapes[1]];\n        denim.I2B = ip_sorted;\n        denim.I2E = [splitShapes[0], splitShapes[2]];\n\n        denim.E2I = new Flatten.Polygon([circle.toArc()]).cutWithLine(line);\n    }\n\n    return denim;\n}\n\nfunction relateLine2Box(line, box) {\n    let denim = new DE9IM();\n    let ip = intersectLine2Box(line, box);\n    if (ip.length === 0) {\n        denim.I2I = [];\n        denim.I2B = [];\n        denim.I2E = [line];\n\n        denim.E2I = [box];\n    }\n    else if (ip.length === 1) {\n        denim.I2I = [];\n        denim.I2B = ip;\n        denim.I2E = line.split(ip);\n\n        denim.E2I = [box];\n    }\n    else {                     // ip.length == 2\n        let multiline = new Multiline([line]);\n        let ip_sorted = line.sortPoints(ip);\n        multiline.split(ip_sorted);\n        let splitShapes = multiline.toShapes();\n\n        /* Are two intersection points on the same segment of the box boundary ? */\n        if (box.toSegments().some( segment => segment.contains(ip[0]) && segment.contains(ip[1]) )) {\n            denim.I2I = [];                         // case of touching\n            denim.I2B = [splitShapes[1]];\n            denim.I2E = [splitShapes[0], splitShapes[2]];\n\n            denim.E2I = [box];\n        }\n        else {                                       // case of intersection\n            denim.I2I = [splitShapes[1]];            // [segment(ip[0], ip[1])];\n            denim.I2B = ip_sorted;\n            denim.I2E = [splitShapes[0], splitShapes[2]];\n\n            denim.E2I = new Flatten.Polygon(box.toSegments()).cutWithLine(line);\n        }\n    }\n    return denim;\n}\n\nfunction relateLine2Polygon(line, polygon) {\n    let denim = new DE9IM();\n    let ip = intersectLine2Polygon(line, polygon);\n    let multiline = new Multiline([line]);\n    let ip_sorted = ip.length > 0 ? ip.slice() : line.sortPoints(ip);\n\n    multiline.split(ip_sorted);\n\n    [...multiline].forEach(edge => edge.setInclusion(polygon));\n\n    denim.I2I = [...multiline].filter(edge => edge.bv === Flatten.INSIDE).map(edge => edge.shape);\n    denim.I2B = [...multiline].slice(1).map( (edge) => edge.bv === Flatten.BOUNDARY ? edge.shape : edge.shape.start );\n    denim.I2E = [...multiline].filter(edge => edge.bv === Flatten.OUTSIDE).map(edge => edge.shape);\n\n    denim.E2I = polygon.cutWithLine(line);\n\n    return denim;\n}\n\nfunction relateShape2Polygon(shape, polygon) {\n    let denim = new DE9IM();\n    let ip = intersectShape2Polygon(shape, polygon);\n    let ip_sorted = ip.length > 0 ? ip.slice() : shape.sortPoints(ip);\n\n    let multiline = new Multiline([shape]);\n    multiline.split(ip_sorted);\n\n    [...multiline].forEach(edge => edge.setInclusion(polygon));\n\n    denim.I2I = [...multiline].filter(edge => edge.bv === Flatten.INSIDE).map(edge => edge.shape);\n    denim.I2B = [...multiline].slice(1).map( (edge) => edge.bv === Flatten.BOUNDARY ? edge.shape : edge.shape.start );\n    denim.I2E = [...multiline].filter(edge => edge.bv === Flatten.OUTSIDE).map(edge => edge.shape);\n\n\n    denim.B2I = [];\n    denim.B2B = [];\n    denim.B2E = [];\n    for (let pt of [shape.start, shape.end]) {\n        switch (ray_shoot(polygon, pt)) {\n            case Flatten.INSIDE:\n                denim.B2I.push(pt);\n                break;\n            case Flatten.BOUNDARY:\n                denim.B2B.push(pt);\n                break;\n            case Flatten.OUTSIDE:\n                denim.B2E.push(pt);\n                break;\n        }\n    }\n\n    // denim.E2I  TODO: calculate, not clear what is expected result\n\n    return denim;\n}\n\nfunction relatePolygon2Polygon(polygon1, polygon2) {\n    let denim = new DE9IM();\n\n    let [ip_sorted1, ip_sorted2] = calculateIntersections(polygon1, polygon2);\n    let boolean_intersection = intersect$1(polygon1, polygon2);\n    let boolean_difference1 = subtract(polygon1, polygon2);\n    let boolean_difference2 = subtract(polygon2, polygon1);\n    let [inner_clip_shapes1, inner_clip_shapes2] = innerClip(polygon1, polygon2);\n    let outer_clip_shapes1 = outerClip(polygon1, polygon2);\n    let outer_clip_shapes2 = outerClip(polygon2, polygon1);\n\n    denim.I2I = boolean_intersection.isEmpty() ? [] : [boolean_intersection];\n    denim.I2B = inner_clip_shapes2;\n    denim.I2E = boolean_difference1.isEmpty() ? [] : [boolean_difference1];\n\n    denim.B2I = inner_clip_shapes1;\n    denim.B2B = ip_sorted1;\n    denim.B2E = outer_clip_shapes1;\n\n    denim.E2I = boolean_difference2.isEmpty() ? [] : [boolean_difference2];\n    denim.E2B = outer_clip_shapes2;\n    // denim.E2E    not relevant meanwhile\n\n    return denim;\n}\n\nvar Relations = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    contain: contain,\n    cover: cover,\n    covered: covered,\n    disjoint: disjoint,\n    equal: equal,\n    inside: inside,\n    intersect: intersect,\n    relate: relate,\n    touch: touch\n});\n\n/**\n * Class representing an affine transformation 3x3 matrix:\n * <pre>\n *      [ a  c  tx\n * A =    b  d  ty\n *        0  0  1  ]\n * </pre\n * @type {Matrix}\n */\nclass Matrix {\n    /**\n     * Construct new instance of affine transformation matrix <br/>\n     * If parameters omitted, construct identity matrix a = 1, d = 1\n     * @param {number} a - position(0,0)   sx*cos(alpha)\n     * @param {number} b - position (0,1)  sx*sin(alpha)\n     * @param {number} c - position (1,0)  -sy*sin(alpha)\n     * @param {number} d - position (1,1)  sy*cos(alpha)\n     * @param {number} tx - position (2,0) translation by x\n     * @param {number} ty - position (2,1) translation by y\n     */\n    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n    }\n\n    /**\n     * Return new cloned instance of matrix\n     * @return {Matrix}\n     **/\n    clone() {\n        return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);\n    };\n\n    /**\n     * Transform vector [x,y] using transformation matrix. <br/>\n     * Vector [x,y] is an abstract array[2] of numbers and not a FlattenJS object <br/>\n     * The result is also an abstract vector [x',y'] = A * [x,y]:\n     * <code>\n     * [x'       [ ax + by + tx\n     *  y'   =     cx + dy + ty\n     *  1]                    1 ]\n     * </code>\n     * @param {number[]} vector - array[2] of numbers\n     * @returns {number[]} transformation result - array[2] of numbers\n     */\n    transform(vector) {\n        return [\n            vector[0] * this.a + vector[1] * this.c + this.tx,\n            vector[0] * this.b + vector[1] * this.d + this.ty\n        ]\n    };\n\n    /**\n     * Returns result of multiplication of this matrix by other matrix\n     * @param {Matrix} other_matrix - matrix to multiply by\n     * @returns {Matrix}\n     */\n    multiply(other_matrix) {\n        return new Matrix(\n            this.a * other_matrix.a + this.c * other_matrix.b,\n            this.b * other_matrix.a + this.d * other_matrix.b,\n            this.a * other_matrix.c + this.c * other_matrix.d,\n            this.b * other_matrix.c + this.d * other_matrix.d,\n            this.a * other_matrix.tx + this.c * other_matrix.ty + this.tx,\n            this.b * other_matrix.tx + this.d * other_matrix.ty + this.ty\n        )\n    };\n\n    /**\n     * Return new matrix as a result of multiplication of the current matrix\n     * by the matrix(1,0,0,1,tx,ty)\n     * @param {Vector} vector - Translation by vector or\n     * @param {number} tx - translation by x-axis\n     * @param {number} ty - translation by y-axis\n     * @returns {Matrix}\n     */\n    translate(...args) {\n        let tx, ty;\n        if (args.length == 1 &&  !isNaN(args[0].x) && !isNaN(args[0].y)) {\n            tx = args[0].x;\n            ty = args[0].y;\n        } else if (args.length === 2 && typeof (args[0]) == \"number\" && typeof (args[1]) == \"number\") {\n            tx = args[0];\n            ty = args[1];\n        } else {\n            throw Errors.ILLEGAL_PARAMETERS;\n        }\n        return this.multiply(new Matrix(1, 0, 0, 1, tx, ty))\n    };\n\n    /**\n     * Return new matrix as a result of multiplication of the current matrix\n     * by the matrix that defines rotation by given angle (in radians) around\n     * center of rotation (centerX,centerY) in counterclockwise direction\n     * @param {number} angle - angle in radians\n     * @param {number} centerX - center of rotation\n     * @param {number} centerY - center of rotation\n     * @returns {Matrix}\n     */\n    rotate(angle, centerX = 0.0, centerY = 0.0) {\n        let cos = Math.cos(angle);\n        let sin = Math.sin(angle);\n        return this\n            .translate(centerX, centerY)\n            .multiply(new Matrix(cos, sin, -sin, cos, 0, 0))\n            .translate(-centerX, -centerY);\n    };\n\n    /**\n     * Return new matrix as a result of multiplication of the current matrix\n     * by the matrix (sx,0,0,sy,0,0) that defines scaling\n     * @param {number} sx\n     * @param {number} sy\n     * @returns {Matrix}\n     */\n    scale(sx, sy) {\n        return this.multiply(new Matrix(sx, 0, 0, sy, 0, 0));\n    };\n\n    /**\n     * Returns true if two matrix are equal parameter by parameter\n     * @param {Matrix} matrix - other matrix\n     * @returns {boolean} true if equal, false otherwise\n     */\n    equalTo(matrix) {\n        if (!Flatten.Utils.EQ(this.tx, matrix.tx)) return false;\n        if (!Flatten.Utils.EQ(this.ty, matrix.ty)) return false;\n        if (!Flatten.Utils.EQ(this.a, matrix.a)) return false;\n        if (!Flatten.Utils.EQ(this.b, matrix.b)) return false;\n        if (!Flatten.Utils.EQ(this.c, matrix.c)) return false;\n        if (!Flatten.Utils.EQ(this.d, matrix.d)) return false;\n        return true;\n    };\n}\nFlatten.Matrix = Matrix;\n/**\n * Function to create matrix equivalent to \"new\" constructor\n * @param args\n */\nconst matrix = (...args) => new Flatten.Matrix(...args);\nFlatten.matrix = matrix;\n\n/**\n * Created by Alex Bol on 4/1/2017.\n */\n\n/**\n * Interval is a pair of numbers or a pair of any comparable objects on which may be defined predicates\n * *equal*, *less* and method *max(p1, p1)* that returns maximum in a pair.\n * When interval is an object rather than pair of numbers, this object should have properties *low*, *high*, *max*\n * and implement methods *less_than(), equal_to(), intersect(), not_intersect(), clone(), output()*.\n * Two static methods *comparable_max(), comparable_less_than()* define how to compare values in pair. <br/>\n * This interface is described in typescript definition file *index.d.ts*\n *\n * Axis aligned rectangle is an example of such interval.\n * We may look at rectangle as an interval between its low left and top right corners.\n * See **Box** class in [flatten-js](https://github.com/alexbol99/flatten-js) library as the example\n * of Interval interface implementation\n * @type {Interval}\n */\nconst Interval = class Interval {\n    /**\n     * Accept two comparable values and creates new instance of interval\n     * Predicate Interval.comparable_less(low, high) supposed to return true on these values\n     * @param low\n     * @param high\n     */\n    constructor(low, high) {\n        this.low = low;\n        this.high = high;\n    }\n\n    /**\n     * Clone interval\n     * @returns {Interval}\n     */\n    clone() {\n        return new Interval(this.low, this.high);\n    }\n\n    /**\n     * Propery max returns clone of this interval\n     * @returns {Interval}\n     */\n    get max() {\n        return this.clone();   // this.high;\n    }\n\n    /**\n     * Predicate returns true is this interval less than other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    less_than(other_interval) {\n        return this.low < other_interval.low ||\n            this.low == other_interval.low && this.high < other_interval.high;\n    }\n\n    /**\n     * Predicate returns true is this interval equals to other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    equal_to(other_interval) {\n        return this.low == other_interval.low && this.high == other_interval.high;\n    }\n\n    /**\n     * Predicate returns true if this interval intersects other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    intersect(other_interval) {\n        return !this.not_intersect(other_interval);\n    }\n\n    /**\n     * Predicate returns true if this interval does not intersect other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    not_intersect(other_interval) {\n        return (this.high < other_interval.low || other_interval.high < this.low);\n    }\n\n    /**\n     * Returns new interval merged with other interval\n     * @param {Interval} interval - Other interval to merge with\n     * @returns {Interval}\n     */\n    merge(other_interval) {\n        return new Interval(\n            this.low === undefined ? other_interval.low : Math.min(this.low, other_interval.low),\n            this.high === undefined ? other_interval.high : Math.max(this.high, other_interval.high)\n        );\n    }\n\n    /**\n     * Returns how key should return\n     */\n    output() {\n        return [this.low, this.high];\n    }\n\n    /**\n     * Function returns maximum between two comparable values\n     * @param interval1\n     * @param interval2\n     * @returns {Interval}\n     */\n    static comparable_max(interval1, interval2) {\n        return interval1.merge(interval2);\n    }\n\n    /**\n     * Predicate returns true if first value less than second value\n     * @param val1\n     * @param val2\n     * @returns {boolean}\n     */\n    static comparable_less_than(val1, val2 ) {\n        return val1 < val2;\n    }\n};\n\n/**\n * Created by Alex Bol on 3/28/2017.\n */\n\n\n// module.exports = {\n//     RB_TREE_COLOR_RED: 0,\n//     RB_TREE_COLOR_BLACK: 1\n// };\n\nconst RB_TREE_COLOR_RED = 0;\nconst RB_TREE_COLOR_BLACK = 1;\n\n/**\n * Created by Alex Bol on 4/1/2017.\n */\n\n\nclass Node {\n    constructor(key = undefined, value = undefined,\n                left = null, right = null, parent = null, color = RB_TREE_COLOR_BLACK) {\n        this.left = left;                     // reference to left child node\n        this.right = right;                   // reference to right child node\n        this.parent = parent;                 // reference to parent node\n        this.color = color;\n\n        this.item = {key: key, value: value};   // key is supposed to be instance of Interval\n\n        /* If not, this should by an array of two numbers */\n        if (key && key instanceof Array && key.length == 2) {\n            if (!Number.isNaN(key[0]) && !Number.isNaN(key[1])) {\n                this.item.key = new Interval(Math.min(key[0], key[1]), Math.max(key[0], key[1]));\n            }\n        }\n\n        this.max = this.item.key ? this.item.key.max : undefined;\n    }\n\n    isNil() {\n        return (this.item.key === undefined && this.item.value === undefined &&\n            this.left === null && this.right === null && this.color === RB_TREE_COLOR_BLACK);\n    }\n\n    _value_less_than(other_node) {\n        return this.item.value && other_node.item.value && this.item.value.less_than ?\n            this.item.value.less_than(other_node.item.value) :\n            this.item.value < other_node.item.value;\n    }\n\n    less_than(other_node) {\n        // if tree stores only keys\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\n            return this.item.key.less_than(other_node.item.key);\n        }\n        else {    // if tree stores keys and values\n            return this.item.key.less_than(other_node.item.key) ||\n                this.item.key.equal_to((other_node.item.key)) && this._value_less_than(other_node)\n        }\n    }\n\n    _value_equal(other_node) {\n        return this.item.value && other_node.item.value && this.item.value.equal_to ?\n            this.item.value.equal_to(other_node.item.value) :\n            this.item.value == other_node.item.value;\n    }\n    equal_to(other_node) {\n        // if tree stores only keys\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\n            return this.item.key.equal_to(other_node.item.key);\n        }\n        else {    // if tree stores keys and values\n            return this.item.key.equal_to(other_node.item.key) && this._value_equal(other_node);\n        }\n    }\n\n    intersect(other_node) {\n        return this.item.key.intersect(other_node.item.key);\n    }\n\n    copy_data(other_node) {\n        this.item.key = other_node.item.key;\n        this.item.value = other_node.item.value;\n    }\n\n    update_max() {\n        // use key (Interval) max property instead of key.high\n        this.max = this.item.key ? this.item.key.max : undefined;\n        if (this.right && this.right.max) {\n            const comparable_max = this.item.key.constructor.comparable_max;  // static method\n            this.max = comparable_max(this.max, this.right.max);\n        }\n        if (this.left && this.left.max) {\n            const comparable_max = this.item.key.constructor.comparable_max;  // static method\n            this.max = comparable_max(this.max, this.left.max);\n        }\n    }\n\n    // Other_node does not intersect any node of left subtree, if this.left.max < other_node.item.key.low\n    not_intersect_left_subtree(search_node) {\n        const comparable_less_than = this.item.key.constructor.comparable_less_than;  // static method\n        let high = this.left.max.high !== undefined ? this.left.max.high : this.left.max;\n        return comparable_less_than(high, search_node.item.key.low);\n    }\n\n    // Other_node does not intersect right subtree if other_node.item.key.high < this.right.key.low\n    not_intersect_right_subtree(search_node) {\n        const comparable_less_than = this.item.key.constructor.comparable_less_than;  // static method\n        let low = this.right.max.low !== undefined ? this.right.max.low : this.right.item.key.low;\n        return comparable_less_than(search_node.item.key.high, low);\n    }\n}\n\n/**\n * Created by Alex Bol on 3/31/2017.\n */\n\n// const nil_node = new Node();\n\n/**\n * Implementation of interval binary search tree <br/>\n * Interval tree stores items which are couples of {key:interval, value: value} <br/>\n * Interval is an object with high and low properties or simply pair [low,high] of numeric values <br />\n * @type {IntervalTree}\n */\nclass IntervalTree {\n    /**\n     * Construct new empty instance of IntervalTree\n     */\n    constructor() {\n        this.root = null;\n        this.nil_node = new Node();\n    }\n\n    /**\n     * Returns number of items stored in the interval tree\n     * @returns {number}\n     */\n    get size() {\n        let count = 0;\n        this.tree_walk(this.root, () => count++);\n        return count;\n    }\n\n    /**\n     * Returns array of sorted keys in the ascending order\n     * @returns {Array}\n     */\n    get keys() {\n        let res = [];\n        this.tree_walk(this.root, (node) => res.push(\n            node.item.key.output ? node.item.key.output() : node.item.key\n        ));\n        return res;\n    }\n\n    /**\n     * Return array of values in the ascending keys order\n     * @returns {Array}\n     */\n    get values() {\n        let res = [];\n        this.tree_walk(this.root, (node) => res.push(node.item.value));\n        return res;\n    }\n\n    /**\n     * Returns array of items (<key,value> pairs) in the ascended keys order\n     * @returns {Array}\n     */\n    get items() {\n        let res = [];\n        this.tree_walk(this.root, (node) => res.push({\n            key: node.item.key.output ? node.item.key.output() : node.item.key,\n            value: node.item.value\n        }));\n        return res;\n    }\n\n    /**\n     * Returns true if tree is empty\n     * @returns {boolean}\n     */\n    isEmpty() {\n        return (this.root == null || this.root == this.nil_node);\n    }\n\n    /**\n     * Clear tree\n     */\n    clear() {\n        this.root = null;\n    }\n\n    /**\n     * Insert new item into interval tree\n     * @param {Interval} key - interval object or array of two numbers [low, high]\n     * @param {any} value - value representing any object (optional)\n     * @returns {Node} returns reference to inserted node as an object {key:interval, value: value}\n     */\n    insert(key, value = key) {\n        if (key === undefined) return;\n        let insert_node = new Node(key, value, this.nil_node, this.nil_node, null, RB_TREE_COLOR_RED);\n        this.tree_insert(insert_node);\n        this.recalc_max(insert_node);\n        return insert_node;\n    }\n\n    /**\n     * Returns true if item {key,value} exist in the tree\n     * @param {Interval} key - interval correspondent to keys stored in the tree\n     * @param {any} value - value object to be checked\n     * @returns {boolean} true if item {key, value} exist in the tree, false otherwise\n     */\n    exist(key, value = key) {\n        let search_node = new Node(key, value);\n        return this.tree_search(this.root, search_node) ? true : false;\n    }\n\n    /**\n     * Remove entry {key, value} from the tree\n     * @param {Interval} key - interval correspondent to keys stored in the tree\n     * @param {any} value - value object\n     * @returns {boolean} true if item {key, value} deleted, false if not found\n     */\n    remove(key, value = key) {\n        let search_node = new Node(key, value);\n        let delete_node = this.tree_search(this.root, search_node);\n        if (delete_node) {\n            this.tree_delete(delete_node);\n        }\n        return delete_node;\n    }\n\n    /**\n     * Returns array of entry values which keys intersect with given interval <br/>\n     * If no values stored in the tree, returns array of keys which intersect given interval\n     * @param {Interval} interval - search interval, or tuple [low, high]\n     * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output\n     * @returns {Array}\n     */\n    search(interval, outputMapperFn = (value, key) => value === key ? key.output() : value) {\n        let search_node = new Node(interval);\n        let resp_nodes = [];\n        this.tree_search_interval(this.root, search_node, resp_nodes);\n        return resp_nodes.map(node => outputMapperFn(node.item.value, node.item.key))\n    }\n\n    /**\n     * Returns true if intersection between given and any interval stored in the tree found\n     * @param {Interval} interval - search interval or tuple [low, high]\n     * @returns {boolean}\n     */\n    intersect_any(interval) {\n        let search_node = new Node(interval);\n        let found = this.tree_find_any_interval(this.root, search_node);\n        return found;\n    }\n\n    /**\n     * Tree visitor. For each node implement a callback function. <br/>\n     * Method calls a callback function with two parameters (key, value)\n     * @param visitor(key,value) - function to be called for each tree item\n     */\n    forEach(visitor) {\n        this.tree_walk(this.root, (node) => visitor(node.item.key, node.item.value));\n    }\n\n    /** Value Mapper. Walk through every node and map node value to another value\n    * @param callback(value,key) - function to be called for each tree item\n    */\n    map(callback) {\n        const tree = new IntervalTree();\n        this.tree_walk(this.root, (node) => tree.insert(node.item.key, callback(node.item.value, node.item.key)));\n        return tree;\n    }\n\n    recalc_max(node) {\n        let node_current = node;\n        while (node_current.parent != null) {\n            node_current.parent.update_max();\n            node_current = node_current.parent;\n        }\n    }\n\n    tree_insert(insert_node) {\n        let current_node = this.root;\n        let parent_node = null;\n\n        if (this.root == null || this.root == this.nil_node) {\n            this.root = insert_node;\n        }\n        else {\n            while (current_node != this.nil_node) {\n                parent_node = current_node;\n                if (insert_node.less_than(current_node)) {\n                    current_node = current_node.left;\n                }\n                else {\n                    current_node = current_node.right;\n                }\n            }\n\n            insert_node.parent = parent_node;\n\n            if (insert_node.less_than(parent_node)) {\n                parent_node.left = insert_node;\n            }\n            else {\n                parent_node.right = insert_node;\n            }\n        }\n\n        this.insert_fixup(insert_node);\n    }\n\n// After insertion insert_node may have red-colored parent, and this is a single possible violation\n// Go upwords to the root and re-color until violation will be resolved\n    insert_fixup(insert_node) {\n        let current_node;\n        let uncle_node;\n\n        current_node = insert_node;\n        while (current_node != this.root && current_node.parent.color == RB_TREE_COLOR_RED) {\n            if (current_node.parent == current_node.parent.parent.left) {   // parent is left child of grandfather\n                uncle_node = current_node.parent.parent.right;              // right brother of parent\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 1. Uncle is red\n                    // re-color father and uncle into black\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    current_node = current_node.parent.parent;\n                }\n                else {                                                    // Case 2 & 3. Uncle is black\n                    if (current_node == current_node.parent.right) {     // Case 2. Current if right child\n                        // This case is transformed into Case 3.\n                        current_node = current_node.parent;\n                        this.rotate_left(current_node);\n                    }\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 3. Current is left child.\n                    // Re-color father and grandfather, rotate grandfather right\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    this.rotate_right(current_node.parent.parent);\n                }\n            }\n            else {                                                         // parent is right child of grandfather\n                uncle_node = current_node.parent.parent.left;              // left brother of parent\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 4. Uncle is red\n                    // re-color father and uncle into black\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    current_node = current_node.parent.parent;\n                }\n                else {\n                    if (current_node == current_node.parent.left) {             // Case 5. Current is left child\n                        // Transform into case 6\n                        current_node = current_node.parent;\n                        this.rotate_right(current_node);\n                    }\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 6. Current is right child.\n                    // Re-color father and grandfather, rotate grandfather left\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    this.rotate_left(current_node.parent.parent);\n                }\n            }\n        }\n\n        this.root.color = RB_TREE_COLOR_BLACK;\n    }\n\n    tree_delete(delete_node) {\n        let cut_node;   // node to be cut - either delete_node or successor_node  (\"y\" from 14.4)\n        let fix_node;   // node to fix rb tree property   (\"x\" from 14.4)\n\n        if (delete_node.left == this.nil_node || delete_node.right == this.nil_node) {  // delete_node has less then 2 children\n            cut_node = delete_node;\n        }\n        else {                                                    // delete_node has 2 children\n            cut_node = this.tree_successor(delete_node);\n        }\n\n        // fix_node if single child of cut_node\n        if (cut_node.left != this.nil_node) {\n            fix_node = cut_node.left;\n        }\n        else {\n            fix_node = cut_node.right;\n        }\n\n        // remove cut_node from parent\n        /*if (fix_node != this.nil_node) {*/\n            fix_node.parent = cut_node.parent;\n        /*}*/\n\n        if (cut_node == this.root) {\n            this.root = fix_node;\n        }\n        else {\n            if (cut_node == cut_node.parent.left) {\n                cut_node.parent.left = fix_node;\n            }\n            else {\n                cut_node.parent.right = fix_node;\n            }\n            cut_node.parent.update_max();        // update max property of the parent\n        }\n\n        this.recalc_max(fix_node);              // update max property upward from fix_node to root\n\n        // COPY DATA !!!\n        // Delete_node becomes cut_node, it means that we cannot hold reference\n        // to node in outer structure and we will have to delete by key, additional search need\n        if (cut_node != delete_node) {\n            delete_node.copy_data(cut_node);\n            delete_node.update_max();           // update max property of the cut node at the new place\n            this.recalc_max(delete_node);       // update max property upward from delete_node to root\n        }\n\n        if (/*fix_node != this.nil_node && */cut_node.color == RB_TREE_COLOR_BLACK) {\n            this.delete_fixup(fix_node);\n        }\n    }\n\n    delete_fixup(fix_node) {\n        let current_node = fix_node;\n        let brother_node;\n\n        while (current_node != this.root && current_node.parent != null && current_node.color == RB_TREE_COLOR_BLACK) {\n            if (current_node == current_node.parent.left) {          // fix node is left child\n                brother_node = current_node.parent.right;\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\n                    this.rotate_left(current_node.parent);\n                    brother_node = current_node.parent.right;                      // update brother\n                }\n                // Derive to cases 2..4: brother is black\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {  // case 2: both nephews black\n                    brother_node.color = RB_TREE_COLOR_RED;              // re-color brother\n                    current_node = current_node.parent;                  // continue iteration\n                }\n                else {\n                    if (brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 3: left nephew red, right nephew black\n                        brother_node.color = RB_TREE_COLOR_RED;          // re-color brother\n                        brother_node.left.color = RB_TREE_COLOR_BLACK;   // re-color nephew\n                        this.rotate_right(brother_node);\n                        brother_node = current_node.parent.right;                     // update brother\n                        // Derive to case 4: left nephew black, right nephew red\n                    }\n                    // case 4: left nephew black, right nephew red\n                    brother_node.color = current_node.parent.color;\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    brother_node.right.color = RB_TREE_COLOR_BLACK;\n                    this.rotate_left(current_node.parent);\n                    current_node = this.root;                         // exit from loop\n                }\n            }\n            else {                                             // fix node is right child\n                brother_node = current_node.parent.left;\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\n                    this.rotate_right(current_node.parent);\n                    brother_node = current_node.parent.left;                        // update brother\n                }\n                // Go to cases 2..4\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 2\n                    brother_node.color = RB_TREE_COLOR_RED;             // re-color brother\n                    current_node = current_node.parent;                              // continue iteration\n                }\n                else {\n                    if (brother_node.left.color == RB_TREE_COLOR_BLACK) {  // case 3: right nephew red, left nephew black\n                        brother_node.color = RB_TREE_COLOR_RED;            // re-color brother\n                        brother_node.right.color = RB_TREE_COLOR_BLACK;    // re-color nephew\n                        this.rotate_left(brother_node);\n                        brother_node = current_node.parent.left;                        // update brother\n                        // Derive to case 4: right nephew black, left nephew red\n                    }\n                    // case 4: right nephew black, left nephew red\n                    brother_node.color = current_node.parent.color;\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    brother_node.left.color = RB_TREE_COLOR_BLACK;\n                    this.rotate_right(current_node.parent);\n                    current_node = this.root;                               // force exit from loop\n                }\n            }\n        }\n\n        current_node.color = RB_TREE_COLOR_BLACK;\n    }\n\n    tree_search(node, search_node) {\n        if (node == null || node == this.nil_node)\n            return undefined;\n\n        if (search_node.equal_to(node)) {\n            return node;\n        }\n        if (search_node.less_than(node)) {\n            return this.tree_search(node.left, search_node);\n        }\n        else {\n            return this.tree_search(node.right, search_node);\n        }\n    }\n\n    // Original search_interval method; container res support push() insertion\n    // Search all intervals intersecting given one\n    tree_search_interval(node, search_node, res) {\n        if (node != null && node != this.nil_node) {\n            // if (node->left != this.nil_node && node->left->max >= low) {\n            if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) {\n                this.tree_search_interval(node.left, search_node, res);\n            }\n            // if (low <= node->high && node->low <= high) {\n            if (node.intersect(search_node)) {\n                res.push(node);\n            }\n            // if (node->right != this.nil_node && node->low <= high) {\n            if (node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) {\n                this.tree_search_interval(node.right, search_node, res);\n            }\n        }\n    }\n\n    tree_find_any_interval(node, search_node) {\n        let found = false;\n        if (node != null && node != this.nil_node) {\n            // if (node->left != this.nil_node && node->left->max >= low) {\n            if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) {\n                found = this.tree_find_any_interval(node.left, search_node);\n            }\n            // if (low <= node->high && node->low <= high) {\n            if (!found) {\n                found = node.intersect(search_node);\n            }\n            // if (node->right != this.nil_node && node->low <= high) {\n            if (!found && node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) {\n                found = this.tree_find_any_interval(node.right, search_node);\n            }\n        }\n        return found;\n    }\n\n    local_minimum(node) {\n        let node_min = node;\n        while (node_min.left != null && node_min.left != this.nil_node) {\n            node_min = node_min.left;\n        }\n        return node_min;\n    }\n\n    // not in use\n    local_maximum(node) {\n        let node_max = node;\n        while (node_max.right != null && node_max.right != this.nil_node) {\n            node_max = node_max.right;\n        }\n        return node_max;\n    }\n\n    tree_successor(node) {\n        let node_successor;\n        let current_node;\n        let parent_node;\n\n        if (node.right != this.nil_node) {\n            node_successor = this.local_minimum(node.right);\n        }\n        else {\n            current_node = node;\n            parent_node = node.parent;\n            while (parent_node != null && parent_node.right == current_node) {\n                current_node = parent_node;\n                parent_node = parent_node.parent;\n            }\n            node_successor = parent_node;\n        }\n        return node_successor;\n    }\n\n    //           |            right-rotate(T,y)       |\n    //           y            ---------------.       x\n    //          / \\                                  / \\\n    //         x   c          left-rotate(T,x)      a   y\n    //        / \\             <---------------         / \\\n    //       a   b                                    b   c\n\n    rotate_left(x) {\n        let y = x.right;\n\n        x.right = y.left;           // b goes to x.right\n\n        if (y.left != this.nil_node) {\n            y.left.parent = x;     // x becomes parent of b\n        }\n        y.parent = x.parent;       // move parent\n\n        if (x == this.root) {\n            this.root = y;           // y becomes root\n        }\n        else {                        // y becomes child of x.parent\n            if (x == x.parent.left) {\n                x.parent.left = y;\n            }\n            else {\n                x.parent.right = y;\n            }\n        }\n        y.left = x;                 // x becomes left child of y\n        x.parent = y;               // and y becomes parent of x\n\n        if (x != null && x != this.nil_node) {\n            x.update_max();\n        }\n\n        y = x.parent;\n        if (y != null && y != this.nil_node) {\n            y.update_max();\n        }\n    }\n\n    rotate_right(y) {\n        let x = y.left;\n\n        y.left = x.right;           // b goes to y.left\n\n        if (x.right != this.nil_node) {\n            x.right.parent = y;        // y becomes parent of b\n        }\n        x.parent = y.parent;          // move parent\n\n        if (y == this.root) {        // x becomes root\n            this.root = x;\n        }\n        else {                        // y becomes child of x.parent\n            if (y == y.parent.left) {\n                y.parent.left = x;\n            }\n            else {\n                y.parent.right = x;\n            }\n        }\n        x.right = y;                 // y becomes right child of x\n        y.parent = x;               // and x becomes parent of y\n\n        if (y != null && y != this.nil_node) {\n            y.update_max();\n        }\n\n        x = y.parent;\n        if (x != null && x != this.nil_node) {\n            x.update_max();\n        }\n    }\n\n    tree_walk(node, action) {\n        if (node != null && node != this.nil_node) {\n            this.tree_walk(node.left, action);\n            // arr.push(node.toArray());\n            action(node);\n            this.tree_walk(node.right, action);\n        }\n    }\n\n    /* Return true if all red nodes have exactly two black child nodes */\n    testRedBlackProperty() {\n        let res = true;\n        this.tree_walk(this.root, function (node) {\n            if (node.color == RB_TREE_COLOR_RED) {\n                if (!(node.left.color == RB_TREE_COLOR_BLACK && node.right.color == RB_TREE_COLOR_BLACK)) {\n                    res = false;\n                }\n            }\n        });\n        return res;\n    }\n\n    /* Throw error if not every path from root to bottom has same black height */\n    testBlackHeightProperty(node) {\n        let height = 0;\n        let heightLeft = 0;\n        let heightRight = 0;\n        if (node.color == RB_TREE_COLOR_BLACK) {\n            height++;\n        }\n        if (node.left != this.nil_node) {\n            heightLeft = this.testBlackHeightProperty(node.left);\n        }\n        else {\n            heightLeft = 1;\n        }\n        if (node.right != this.nil_node) {\n            heightRight = this.testBlackHeightProperty(node.right);\n        }\n        else {\n            heightRight = 1;\n        }\n        if (heightLeft != heightRight) {\n            throw new Error('Red-black height property violated');\n        }\n        height += heightLeft;\n        return height;\n    };\n}\n\n/**\n * Created by Alex Bol on 3/12/2017.\n */\n\n\n/**\n * Class representing a planar set - a generic container with ability to keep and retrieve shapes and\n * perform spatial queries. Planar set is an extension of Set container, so it supports\n * Set properties and methods\n */\nclass PlanarSet extends Set {\n    /**\n     * Create new instance of PlanarSet\n     * @param shapes - array or set of geometric objects to store in planar set\n     * Each object should have a <b>box</b> property\n     */\n    constructor(shapes) {\n        super(shapes);\n        this.index = new IntervalTree();\n        this.forEach(shape => this.index.insert(shape));\n    }\n\n    /**\n     * Add new shape to planar set and to its spatial index.<br/>\n     * If shape already exist, it will not be added again.\n     * This happens with no error, it is possible to use <i>size</i> property to check if\n     * a shape was actually added.<br/>\n     * Method returns planar set object updated and may be chained\n     * @param {AnyShape | {Box, AnyShape}} entry - shape to be added, should have valid <i>box</i> property\n     * Another option to transfer as an object {key: Box, value: AnyShape}\n     * @returns {PlanarSet}\n     */\n    add(entry) {\n        let size = this.size;\n        const {key, value} = entry;\n        const box = key || entry.box;\n        const shape = value || entry;\n        super.add(shape);\n        // size not changed - item not added, probably trying to add same item twice\n        if (this.size > size) {\n            this.index.insert(box, shape);\n        }\n        return this;         // in accordance to Set.add interface\n    }\n\n    /**\n     * Delete shape from planar set. Returns true if shape was actually deleted, false otherwise\n     * @param {AnyShape | {Box, AnyShape}} entry - shape to be deleted\n     * @returns {boolean}\n     */\n    delete(entry) {\n        const {key, value} = entry;\n        const box = key || entry.box;\n        const shape = value || entry;\n        let deleted = super.delete(shape);\n        if (deleted) {\n            this.index.remove(box, shape);\n        }\n        return deleted;\n    }\n\n    /**\n     * Clear planar set\n     */\n    clear() {\n        super.clear();\n        this.index = new IntervalTree();\n    }\n\n    /**\n     * 2d range search in planar set.<br/>\n     * Returns array of all shapes in planar set which bounding box is intersected with query box\n     * @param {Box} box - query box\n     * @returns {AnyShape[]}\n     */\n    search(box) {\n        let resp = this.index.search(box);\n        return resp;\n    }\n\n    /**\n     * Point location test. Returns array of shapes which contains given point\n     * @param {Point} point - query point\n     * @returns {AnyShape[]}\n     */\n    hit(point) {\n        let box = new Flatten.Box(point.x - 1, point.y - 1, point.x + 1, point.y + 1);\n        let resp = this.index.search(box);\n        return resp.filter((shape) => point.on(shape));\n    }\n\n    /**\n     * Returns svg string to draw all shapes in planar set\n     * @returns {String}\n     */\n    svg() {\n        let svgcontent = [...this].reduce((acc, shape) => acc + shape.svg(), \"\");\n        return svgcontent;\n    }\n}\n\nFlatten.PlanarSet = PlanarSet;\n\n/**\n * Base class representing shape\n * Implement common methods of affine transformations\n */\nclass Shape {\n    get name() {\n        throw(Errors.CANNOT_INVOKE_ABSTRACT_METHOD);\n    }\n\n    get box() {\n        throw(Errors.CANNOT_INVOKE_ABSTRACT_METHOD);\n    }\n\n    clone() {\n        throw(Errors.CANNOT_INVOKE_ABSTRACT_METHOD);\n    }\n\n    /**\n     * Returns new shape translated by given vector.\n     * Translation vector may be also defined by a pair of numbers.\n     * @param {Vector | (number, number) } args - Translation vector\n     * or tuple of numbers\n     * @returns {Shape}\n     */\n    translate(...args) {\n        return this.transform(new Matrix().translate(...args))\n    }\n\n    /**\n     * Returns new shape rotated by given angle around given center point.\n     * If center point is omitted, rotates around zero point (0,0).\n     * Positive value of angle defines rotation in counterclockwise direction,\n     * negative angle defines rotation in clockwise direction\n     * @param {number} angle - angle in radians\n     * @param {Point} [center=(0,0)] center\n     * @returns {Shape}\n     */\n    rotate(angle, center = new Flatten.Point()) {\n        return this.transform(new Matrix().rotate(angle, center.x, center.y));\n    }\n\n    /**\n     * Return new shape with coordinates multiplied by scaling factor\n     * @param {number} sx - x-axis scaling factor\n     * @param {number} sy - y-axis scaling factor\n     * @returns {Shape}\n     */\n    scale(sx, sy) {\n        return this.transform(new Matrix().scale(sx, sy));\n    }\n\n    transform(...args) {\n        throw(Errors.CANNOT_INVOKE_ABSTRACT_METHOD);\n    }\n\n    /**\n     * This method returns an object that defines how data will be\n     * serialized when called JSON.stringify() method\n     * @returns {Object}\n     */\n    toJSON() {\n        return Object.assign({}, this, {name: this.name});\n    }\n\n    svg(attrs = {}) {\n        throw(Errors.CANNOT_INVOKE_ABSTRACT_METHOD);\n    }\n}\n\n/**\n * Created by Alex Bol on 2/18/2017.\n */\n\n\n/**\n *\n * Class representing a point\n * @type {Point}\n */\nlet Point$1 = class Point extends Shape {\n    /**\n     * Point may be constructed by two numbers, or by array of two numbers\n     * @param {number} x - x-coordinate (float number)\n     * @param {number} y - y-coordinate (float number)\n     */\n    constructor(...args) {\n        super();\n        /**\n         * x-coordinate (float number)\n         * @type {number}\n         */\n        this.x = 0;\n        /**\n         * y-coordinate (float number)\n         * @type {number}\n         */\n        this.y = 0;\n\n        if (args.length === 0) {\n            return;\n        }\n\n        if (args.length === 1 && args[0] instanceof Array && args[0].length === 2) {\n            let arr = args[0];\n            if (typeof (arr[0]) == \"number\" && typeof (arr[1]) == \"number\") {\n                this.x = arr[0];\n                this.y = arr[1];\n                return;\n            }\n        }\n\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"point\") {\n            let {x, y} = args[0];\n            this.x = x;\n            this.y = y;\n            return;\n        }\n\n        if (args.length === 2) {\n            if (typeof (args[0]) == \"number\" && typeof (args[1]) == \"number\") {\n                this.x = args[0];\n                this.y = args[1];\n                return;\n            }\n        }\n        throw Errors.ILLEGAL_PARAMETERS;\n    }\n\n    /**\n     * Returns bounding box of a point\n     * @returns {Box}\n     */\n    get box() {\n        return new Flatten.Box(this.x, this.y, this.x, this.y);\n    }\n\n    /**\n     * Return new cloned instance of point\n     * @returns {Point}\n     */\n    clone() {\n        return new Flatten.Point(this.x, this.y);\n    }\n\n    get vertices() {\n        return [this.clone()];\n    }\n\n    /**\n     * Returns true if points are equal up to [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\n     * @param {Point} pt Query point\n     * @returns {boolean}\n     */\n    equalTo(pt) {\n        return Flatten.Utils.EQ(this.x, pt.x) && Flatten.Utils.EQ(this.y, pt.y);\n    }\n\n    /**\n     * Defines predicate \"less than\" between points. Returns true if the point is less than query points, false otherwise <br/>\n     * By definition point1 < point2 if {point1.y < point2.y || point1.y == point2.y && point1.x < point2.x <br/>\n     * Numeric values compared with [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\n     * @param {Point} pt Query point\n     * @returns {boolean}\n     */\n    lessThan(pt) {\n        if (Flatten.Utils.LT(this.y, pt.y))\n            return true;\n        if (Flatten.Utils.EQ(this.y, pt.y) && Flatten.Utils.LT(this.x, pt.x))\n            return true;\n        return false;\n    }\n\n    /**\n     * Return new point transformed by affine transformation matrix\n     * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\n     * @returns {Point}\n     */\n    transform(m) {\n        return new Flatten.Point(m.transform([this.x, this.y]))\n    }\n\n    /**\n     * Returns projection point on given line\n     * @param {Line} line Line this point be projected on\n     * @returns {Point}\n     */\n    projectionOn(line) {\n        if (this.equalTo(line.pt))                   // this point equal to line anchor point\n            return this.clone();\n\n        let vec = new Flatten.Vector(this, line.pt);\n        if (Flatten.Utils.EQ_0(vec.cross(line.norm)))    // vector to point from anchor point collinear to normal vector\n            return line.pt.clone();\n\n        let dist = vec.dot(line.norm);             // signed distance\n        let proj_vec = line.norm.multiply(dist);\n        return this.translate(proj_vec);\n    }\n\n    /**\n     * Returns true if point belongs to the \"left\" semi-plane, which means, point belongs to the same semi plane where line normal vector points to\n     * Return false if point belongs to the \"right\" semi-plane or to the line itself\n     * @param {Line} line Query line\n     * @returns {boolean}\n     */\n    leftTo(line) {\n        let vec = new Flatten.Vector(line.pt, this);\n        let onLeftSemiPlane = Flatten.Utils.GT(vec.dot(line.norm), 0);\n        return onLeftSemiPlane;\n    }\n\n    /**\n     * Calculate distance and shortest segment from point to shape and return as array [distance, shortest segment]\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\n     * @returns {number} distance from point to shape\n     * @returns {Segment} shortest segment between point and shape (started at point, ended at shape)\n     */\n    distanceTo(shape) {\n        if (shape instanceof Point) {\n            let dx = shape.x - this.x;\n            let dy = shape.y - this.y;\n            return [Math.sqrt(dx * dx + dy * dy), new Flatten.Segment(this, shape)];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            return Flatten.Distance.point2line(this, shape);\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return Flatten.Distance.point2circle(this, shape);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return Flatten.Distance.point2segment(this, shape);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return Flatten.Distance.point2arc(this, shape);\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            return Flatten.Distance.point2polygon(this, shape);\n        }\n\n        if (shape instanceof Flatten.PlanarSet) {\n            return Flatten.Distance.shape2planarSet(this, shape);\n        }\n    }\n\n    /**\n     * Returns true if point is on a shape, false otherwise\n     * @param {Shape} shape\n     * @returns {boolean}\n     */\n    on(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.equalTo(shape);\n        }\n\n        if (shape instanceof Flatten.Box) {\n            return shape.contains(this);\n        }\n\n        if (shape instanceof Flatten.Line) {\n            return shape.contains(this);\n        }\n\n        if (shape instanceof Flatten.Ray) {\n            return shape.contains(this)\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return shape.contains(this);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return shape.contains(this);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return shape.contains(this);\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            return shape.contains(this);\n        }\n    }\n\n    get name() {\n        return \"point\"\n    }\n\n    /**\n     * Return string to draw point in svg as circle with radius \"r\" <br/>\n     * Accept any valid attributes of svg elements as svg object\n     * Defaults attribues are: <br/>\n     * {\n     *    r:\"3\",\n     *    stroke:\"black\",\n     *    strokeWidth:\"1\",\n     *    fill:\"red\"\n     * }\n     * @param {Object} attrs - Any valid attributes of svg circle element, like \"r\", \"stroke\", \"strokeWidth\", \"fill\"\n     * @returns {String}\n     */\n    svg(attrs = {}) {\n        const r = attrs.r ?? 3;            // default radius - 3\n        return `\\n<circle cx=\"${this.x}\" cy=\"${this.y}\" r=\"${r}\"\n            ${convertToString({fill: \"red\", ...attrs})} />`;\n    }\n};\n\nFlatten.Point = Point$1;\n/**\n * Function to create point equivalent to \"new\" constructor\n * @param args\n */\nconst point = (...args) => new Flatten.Point(...args);\nFlatten.point = point;\n\n// export {Point};\n\n/**\n * Created by Alex Bol on 2/19/2017.\n */\n\n\n/**\n * Class representing a vector\n * @type {Vector}\n */\nlet Vector$1 = class Vector extends Shape {\n    /**\n     * Vector may be constructed by two points, or by two float numbers,\n     * or by array of two numbers\n     * @param {Point} ps - start point\n     * @param {Point} pe - end point\n     */\n    constructor(...args) {\n        super();\n        /**\n         * x-coordinate of a vector (float number)\n         * @type {number}\n         */\n        this.x = 0;\n        /**\n         * y-coordinate of a vector (float number)\n         * @type {number}\n         */\n        this.y = 0;\n\n        /* return zero vector */\n        if (args.length === 0) {\n            return;\n        }\n\n        if (args.length === 1 && args[0] instanceof Array && args[0].length === 2) {\n            let arr = args[0];\n            if (typeof (arr[0]) == \"number\" && typeof (arr[1]) == \"number\") {\n                this.x = arr[0];\n                this.y = arr[1];\n                return;\n            }\n        }\n\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"vector\") {\n            let {x, y} = args[0];\n            this.x = x;\n            this.y = y;\n            return;\n        }\n\n        if (args.length === 2) {\n            let a1 = args[0];\n            let a2 = args[1];\n\n            if (typeof (a1) == \"number\" && typeof (a2) == \"number\") {\n                this.x = a1;\n                this.y = a2;\n                return;\n            }\n\n            if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\n                this.x = a2.x - a1.x;\n                this.y = a2.y - a1.y;\n                return;\n            }\n\n        }\n\n        throw Errors.ILLEGAL_PARAMETERS;\n    }\n\n    /**\n     * Method clone returns new instance of Vector\n     * @returns {Vector}\n     */\n    clone() {\n        return new Flatten.Vector(this.x, this.y);\n    }\n\n    /**\n     * Slope of the vector in radians from 0 to 2PI\n     * @returns {number}\n     */\n    get slope() {\n        let angle = Math.atan2(this.y, this.x);\n        if (angle < 0) angle = 2 * Math.PI + angle;\n        return angle;\n    }\n\n    /**\n     * Length of vector\n     * @returns {number}\n     */\n    get length() {\n        return Math.sqrt(this.dot(this));\n    }\n\n    /**\n     * Returns true if vectors are equal up to [DP_TOL]{@link http://localhost:63342/flatten-js/docs/global.html#DP_TOL}\n     * tolerance\n     * @param {Vector} v\n     * @returns {boolean}\n     */\n    equalTo(v) {\n        return Flatten.Utils.EQ(this.x, v.x) && Flatten.Utils.EQ(this.y, v.y);\n    }\n\n    /**\n     * Returns new vector multiplied by scalar\n     * @param {number} scalar\n     * @returns {Vector}\n     */\n    multiply(scalar) {\n        return (new Flatten.Vector(scalar * this.x, scalar * this.y));\n    }\n\n    /**\n     * Returns scalar product (dot product) of two vectors <br/>\n     * <code>dot_product = (this * v)</code>\n     * @param {Vector} v Other vector\n     * @returns {number}\n     */\n    dot(v) {\n        return (this.x * v.x + this.y * v.y);\n    }\n\n    /**\n     * Returns vector product (cross product) of two vectors <br/>\n     * <code>cross_product = (this x v)</code>\n     * @param {Vector} v Other vector\n     * @returns {number}\n     */\n    cross(v) {\n        return (this.x * v.y - this.y * v.x);\n    }\n\n    /**\n     * Returns unit vector.<br/>\n     * Throw error if given vector has zero length\n     * @returns {Vector}\n     */\n    normalize() {\n        if (!Flatten.Utils.EQ_0(this.length)) {\n            return (new Flatten.Vector(this.x / this.length, this.y / this.length));\n        }\n        throw Errors.ZERO_DIVISION;\n    }\n\n    /**\n     * Returns new vector rotated by given angle,\n     * positive angle defines rotation in counterclockwise direction,\n     * negative - in clockwise direction\n     * Vector only can be rotated around (0,0) point!\n     * @param {number} angle - Angle in radians\n     * @returns {Vector}\n     */\n    rotate(angle, center = new Flatten.Point()) {\n        if (center.x === 0 && center.y === 0) {\n            return this.transform(new Matrix().rotate(angle));\n        }\n        throw(Errors.OPERATION_IS_NOT_SUPPORTED);\n    }\n\n    /**\n     * Return new vector transformed by affine transformation matrix m\n     * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\n     * @returns {Vector}\n     */\n    transform(m) {\n        return new Flatten.Vector(m.transform([this.x, this.y]))\n    }\n\n    /**\n     * Returns vector rotated 90 degrees counterclockwise\n     * @returns {Vector}\n     */\n    rotate90CCW() {\n        return new Flatten.Vector(-this.y, this.x);\n    };\n\n    /**\n     * Returns vector rotated 90 degrees clockwise\n     * @returns {Vector}\n     */\n    rotate90CW() {\n        return new Flatten.Vector(this.y, -this.x);\n    };\n\n    /**\n     * Return inverted vector\n     * @returns {Vector}\n     */\n    invert() {\n        return new Flatten.Vector(-this.x, -this.y);\n    }\n\n    /**\n     * Return result of addition of other vector to this vector as a new vector\n     * @param {Vector} v Other vector\n     * @returns {Vector}\n     */\n    add(v) {\n        return new Flatten.Vector(this.x + v.x, this.y + v.y);\n    }\n\n    /**\n     * Return result of subtraction of other vector from current vector as a new vector\n     * @param {Vector} v Another vector\n     * @returns {Vector}\n     */\n    subtract(v) {\n        return new Flatten.Vector(this.x - v.x, this.y - v.y);\n    }\n\n    /**\n     * Return angle between this vector and other vector. <br/>\n     * Angle is measured from 0 to 2*PI in the counterclockwise direction\n     * from current vector to  another.\n     * @param {Vector} v Another vector\n     * @returns {number}\n     */\n    angleTo(v) {\n        let norm1 = this.normalize();\n        let norm2 = v.normalize();\n        let angle = Math.atan2(norm1.cross(norm2), norm1.dot(norm2));\n        if (angle < 0) angle += 2 * Math.PI;\n        return angle;\n    }\n\n    /**\n     * Return vector projection of the current vector on another vector\n     * @param {Vector} v Another vector\n     * @returns {Vector}\n     */\n    projectionOn(v) {\n        let n = v.normalize();\n        let d = this.dot(n);\n        return n.multiply(d);\n    }\n\n    get name() {\n        return \"vector\"\n    }\n};\n\nFlatten.Vector = Vector$1;\n\n/**\n * Function to create vector equivalent to \"new\" constructor\n * @param args\n */\nconst vector$1 = (...args) => new Flatten.Vector(...args);\nFlatten.vector = vector$1;\n\n/**\n * Created by Alex Bol on 3/10/2017.\n */\n\n\n/**\n * Class representing a segment\n * @type {Segment}\n */\nclass Segment extends Shape {\n    /**\n     *\n     * @param {Point} ps - start point\n     * @param {Point} pe - end point\n     */\n    constructor(...args) {\n        super();\n        /**\n         * Start point\n         * @type {Point}\n         */\n        this.ps = new Flatten.Point();\n        /**\n         * End Point\n         * @type {Point}\n         */\n        this.pe = new Flatten.Point();\n\n        if (args.length === 0) {\n            return;\n        }\n\n        if (args.length === 1 && args[0] instanceof Array && args[0].length === 4) {\n            let coords = args[0];\n            this.ps = new Flatten.Point(coords[0], coords[1]);\n            this.pe = new Flatten.Point(coords[2], coords[3]);\n            return;\n        }\n\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"segment\") {\n            let {ps, pe} = args[0];\n            this.ps = new Flatten.Point(ps.x, ps.y);\n            this.pe = new Flatten.Point(pe.x, pe.y);\n            return;\n        }\n\n        // second point omitted issue #84\n        if (args.length === 1 && args[0] instanceof Flatten.Point) {\n            this.ps = args[0].clone();\n            return;\n        }\n\n        if (args.length === 2 && args[0] instanceof Flatten.Point && args[1] instanceof Flatten.Point) {\n            this.ps = args[0].clone();\n            this.pe = args[1].clone();\n            return;\n        }\n\n        if (args.length === 4) {\n            this.ps = new Flatten.Point(args[0], args[1]);\n            this.pe = new Flatten.Point(args[2], args[3]);\n            return;\n        }\n\n        throw Errors.ILLEGAL_PARAMETERS;\n    }\n\n    /**\n     * Return new cloned instance of segment\n     * @returns {Segment}\n     */\n    clone() {\n        return new Flatten.Segment(this.start, this.end);\n    }\n\n    /**\n     * Start point\n     * @returns {Point}\n     */\n    get start() {\n        return this.ps;\n    }\n\n    /**\n     * End point\n     * @returns {Point}\n     */\n    get end() {\n        return this.pe;\n    }\n\n\n    /**\n     * Returns array of start and end point\n     * @returns [Point,Point]\n     */\n    get vertices() {\n        return [this.ps.clone(), this.pe.clone()];\n    }\n\n    /**\n     * Length of a segment\n     * @returns {number}\n     */\n    get length() {\n        return this.start.distanceTo(this.end)[0];\n    }\n\n    /**\n     * Slope of the line - angle to axe x in radians from 0 to 2PI\n     * @returns {number}\n     */\n    get slope() {\n        let vec = new Flatten.Vector(this.start, this.end);\n        return vec.slope;\n    }\n\n    /**\n     * Bounding box\n     * @returns {Box}\n     */\n    get box() {\n        return new Flatten.Box(\n            Math.min(this.start.x, this.end.x),\n            Math.min(this.start.y, this.end.y),\n            Math.max(this.start.x, this.end.x),\n            Math.max(this.start.y, this.end.y)\n        )\n    }\n\n    /**\n     * Returns true if equals to query segment, false otherwise\n     * @param {Seg} seg - query segment\n     * @returns {boolean}\n     */\n    equalTo(seg) {\n        return this.ps.equalTo(seg.ps) && this.pe.equalTo(seg.pe);\n    }\n\n    /**\n     * Returns true if segment contains point\n     * @param {Point} pt Query point\n     * @returns {boolean}\n     */\n    contains(pt) {\n        return Flatten.Utils.EQ_0(this.distanceToPoint(pt));\n    }\n\n    /**\n     * Returns array of intersection points between segment and other shape\n     * @param {Shape} shape - Shape of the one of supported types <br/>\n     * @returns {Point[]}\n     */\n    intersect(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.contains(shape) ? [shape] : [];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            return intersectSegment2Line(this, shape);\n        }\n\n        if (shape instanceof Flatten.Ray) {\n            return intersectRay2Segment(shape, this);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return  intersectSegment2Segment(this, shape);\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return intersectSegment2Circle(this, shape);\n        }\n\n        if (shape instanceof Flatten.Box) {\n            return intersectSegment2Box(this, shape);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return intersectSegment2Arc(this, shape);\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            return  intersectSegment2Polygon(this, shape);\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment from segment to shape and return as array [distance, shortest segment]\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\n     * @returns {number} distance from segment to shape\n     * @returns {Segment} shortest segment between segment and shape (started at segment, ended at shape)\n     */\n    distanceTo(shape) {\n        if (shape instanceof Flatten.Point) {\n            let [dist, shortest_segment] = Flatten.Distance.point2segment(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            let [dist, shortest_segment] = Flatten.Distance.segment2circle(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            let [dist, shortest_segment] = Flatten.Distance.segment2line(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            let [dist, shortest_segment] = Flatten.Distance.segment2segment(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            let [dist, shortest_segment] = Flatten.Distance.segment2arc(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            let [dist, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.PlanarSet) {\n            let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);\n            return [dist, shortest_segment];\n        }\n    }\n\n    /**\n     * Returns unit vector in the direction from start to end\n     * @returns {Vector}\n     */\n    tangentInStart() {\n        let vec = new Flatten.Vector(this.start, this.end);\n        return vec.normalize();\n    }\n\n    /**\n     * Return unit vector in the direction from end to start\n     * @returns {Vector}\n     */\n    tangentInEnd() {\n        let vec = new Flatten.Vector(this.end, this.start);\n        return vec.normalize();\n    }\n\n    /**\n     * Returns new segment with swapped start and end points\n     * @returns {Segment}\n     */\n    reverse() {\n        return new Segment(this.end, this.start);\n    }\n\n    /**\n     * When point belongs to segment, return array of two segments split by given point,\n     * if point is inside segment. Returns clone of this segment if query point is incident\n     * to start or end point of the segment. Returns empty array if point does not belong to segment\n     * @param {Point} pt Query point\n     * @returns {Segment[]}\n     */\n    split(pt) {\n        if (this.start.equalTo(pt))\n            return [null, this.clone()];\n\n        if (this.end.equalTo(pt))\n            return [this.clone(), null];\n\n        return [\n            new Flatten.Segment(this.start, pt),\n            new Flatten.Segment(pt, this.end)\n        ]\n    }\n\n    /**\n     * Return middle point of the segment\n     * @returns {Point}\n     */\n    middle() {\n        return new Flatten.Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);\n    }\n\n    /**\n     * Get point at given length\n     * @param {number} length - The length along the segment\n     * @returns {Point}\n     */\n    pointAtLength(length) {\n        if (length > this.length || length < 0) return null;\n        if (length == 0) return this.start;\n        if (length == this.length) return this.end;\n        let factor = length / this.length;\n        return new Flatten.Point(\n            (this.end.x - this.start.x) * factor + this.start.x,\n            (this.end.y - this.start.y) * factor + this.start.y\n        );\n    }\n\n    distanceToPoint(pt) {\n        let [dist, ...rest] = Flatten.Distance.point2segment(pt, this);\n        return dist;\n    };\n\n    definiteIntegral(ymin = 0.0) {\n        let dx = this.end.x - this.start.x;\n        let dy1 = this.start.y - ymin;\n        let dy2 = this.end.y - ymin;\n        return (dx * (dy1 + dy2) / 2);\n    }\n\n    /**\n     * Return new segment transformed using affine transformation matrix\n     * @param {Matrix} matrix - affine transformation matrix\n     * @returns {Segment} - transformed segment\n     */\n    transform(matrix = new Flatten.Matrix()) {\n        return new Segment(this.ps.transform(matrix), this.pe.transform(matrix))\n    }\n\n    /**\n     * Returns true if segment start is equal to segment end up to DP_TOL\n     * @returns {boolean}\n     */\n    isZeroLength() {\n        return this.ps.equalTo(this.pe)\n    }\n\n    /**\n     * Sort given array of points from segment start to end, assuming all points lay on the segment\n     * @param {Point[]} - array of points\n     * @returns {Point[]} new array sorted\n     */\n    sortPoints(pts) {\n        let line = new Flatten.Line(this.start, this.end);\n        return line.sortPoints(pts);\n    }\n\n    get name() {\n        return \"segment\"\n    }\n\n    /**\n     * Return string to draw segment in svg\n     * @param {Object} attrs - an object with attributes for svg path element,\n     * like \"stroke\", \"strokeWidth\" <br/>\n     * Defaults are stroke:\"black\", strokeWidth:\"1\"\n     * @returns {string}\n     */\n    svg(attrs = {}) {\n        return `\\n<line x1=\"${this.start.x}\" y1=\"${this.start.y}\" x2=\"${this.end.x}\" y2=\"${this.end.y}\" ${convertToString(attrs)} />`;\n    }\n}\n\nFlatten.Segment = Segment;\n/**\n * Shortcut method to create new segment\n */\nconst segment = (...args) => new Flatten.Segment(...args);\nFlatten.segment = segment;\n\n/**\n * Created by Alex Bol on 2/20/2017.\n */\n\nlet {vector} = Flatten;\n\n/**\n * Class representing a line\n * @type {Line}\n */\nlet Line$1 = class Line extends Shape {\n    /**\n     * Line may be constructed by point and normal vector or by two points that a line passes through\n     * @param {Point} pt - point that a line passes through\n     * @param {Vector|Point} norm - normal vector to a line or second point a line passes through\n     */\n    constructor(...args) {\n        super();\n        /**\n         * Point a line passes through\n         * @type {Point}\n         */\n        this.pt = new Flatten.Point();\n        /**\n         * Normal vector to a line <br/>\n         * Vector is normalized (length == 1)<br/>\n         * Direction of the vector is chosen to satisfy inequality norm * p >= 0\n         * @type {Vector}\n         */\n        this.norm = new Flatten.Vector(0, 1);\n\n        if (args.length === 0) {\n            return;\n        }\n\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"line\") {\n            let {pt, norm} = args[0];\n            this.pt = new Flatten.Point(pt);\n            this.norm = new Flatten.Vector(norm);\n            return;\n        }\n\n        if (args.length === 2) {\n            let a1 = args[0];\n            let a2 = args[1];\n\n            if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\n                this.pt = a1;\n                this.norm = Line.points2norm(a1, a2);\n                if (this.norm.dot(vector(this.pt.x,this.pt.y)) >= 0) {\n                    this.norm.invert();\n                }\n                return;\n            }\n\n            if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Vector) {\n                if (Flatten.Utils.EQ_0(a2.x) && Flatten.Utils.EQ_0(a2.y)) {\n                    throw Errors.ILLEGAL_PARAMETERS;\n                }\n                this.pt = a1.clone();\n                this.norm = a2.clone();\n                this.norm = this.norm.normalize();\n                if (this.norm.dot(vector(this.pt.x,this.pt.y)) >= 0) {\n                    this.norm.invert();\n                }\n                return;\n            }\n\n            if (a1 instanceof Flatten.Vector && a2 instanceof Flatten.Point) {\n                if (Flatten.Utils.EQ_0(a1.x) && Flatten.Utils.EQ_0(a1.y)) {\n                    throw Errors.ILLEGAL_PARAMETERS;\n                }\n                this.pt = a2.clone();\n                this.norm = a1.clone();\n                this.norm = this.norm.normalize();\n                if (this.norm.dot(vector(this.pt.x,this.pt.y)) >= 0) {\n                    this.norm.invert();\n                }\n                return;\n            }\n        }\n\n        throw Errors.ILLEGAL_PARAMETERS;\n    }\n\n    /**\n     * Return new cloned instance of line\n     * @returns {Line}\n     */\n    clone() {\n        return new Flatten.Line(this.pt, this.norm);\n    }\n\n    /* The following methods need for implementation of Edge interface\n    /**\n     * Line has no start point\n     * @returns {undefined}\n     */\n    get start() {return undefined;}\n\n    /**\n     * Line has no end point\n     */\n    get end() {return undefined;}\n\n    /**\n     * Return positive infinity number as length\n     * @returns {number}\n     */\n    get length() {return Number.POSITIVE_INFINITY;}\n\n    /**\n     * Returns infinite box\n     * @returns {Box}\n     */\n    get box() {\n        return new Flatten.Box(\n            Number.NEGATIVE_INFINITY,\n            Number.NEGATIVE_INFINITY,\n            Number.POSITIVE_INFINITY,\n            Number.POSITIVE_INFINITY\n        )\n    }\n\n    /**\n     * Middle point is undefined\n     * @returns {undefined}\n     */\n    get middle() {return undefined}\n\n    /**\n     * Slope of the line - angle in radians between line and axe x from 0 to 2PI\n     * @returns {number} - slope of the line\n     */\n    get slope() {\n        let vec = new Flatten.Vector(this.norm.y, -this.norm.x);\n        return vec.slope;\n    }\n\n    /**\n     * Get coefficients [A,B,C] of a standard line equation in the form Ax + By = C\n     * @code [A, B, C] = line.standard\n     * @returns {number[]} - array of coefficients\n     */\n    get standard() {\n        let A = this.norm.x;\n        let B = this.norm.y;\n        let C = this.norm.dot(vector(this.pt.x, this.pt.y));\n\n        return [A, B, C];\n    }\n\n    /**\n     * Return true if parallel or incident to other line\n     * @param {Line} other_line - line to check\n     * @returns {boolean}\n     */\n    parallelTo(other_line) {\n        return Flatten.Utils.EQ_0(this.norm.cross(other_line.norm));\n    }\n\n    /**\n     * Returns true if incident to other line\n     * @param {Line} other_line - line to check\n     * @returns {boolean}\n     */\n    incidentTo(other_line) {\n        return this.parallelTo(other_line) && this.pt.on(other_line);\n    }\n\n    /**\n     * Returns true if point belongs to line\n     * @param {Point} pt Query point\n     * @returns {boolean}\n     */\n    contains(pt) {\n        if (this.pt.equalTo(pt)) {\n            return true;\n        }\n        /* Line contains point if vector to point is orthogonal to the line normal vector */\n        let vec = new Flatten.Vector(this.pt, pt);\n        return Flatten.Utils.EQ_0(this.norm.dot(vec));\n    }\n\n    /**\n     * Return coordinate of the point that lies on the line in the transformed\n     * coordinate system where center is the projection of the point(0,0) to\n     * the line and axe y is collinear to the normal vector. <br/>\n     * This method assumes that point lies on the line and does not check it\n     * @param {Point} pt - point on a line\n     * @returns {number}\n     */\n    coord(pt) {\n        return vector(pt.x, pt.y).cross(this.norm);\n    }\n\n    /**\n     * Returns array of intersection points\n     * @param {Shape} shape - shape to intersect with\n     * @returns {Point[]}\n     */\n    intersect(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.contains(shape) ? [shape] : [];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            return intersectLine2Line(this, shape);\n        }\n\n        if (shape instanceof Flatten.Ray) {\n            return intersectRay2Line(shape, this);\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return intersectLine2Circle(this, shape);\n        }\n\n        if (shape instanceof Flatten.Box) {\n            return intersectLine2Box(this, shape);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return intersectSegment2Line(shape, this);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return intersectLine2Arc(this, shape);\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            return  intersectLine2Polygon(this, shape);\n        }\n\n    }\n\n    /**\n     * Calculate distance and shortest segment from line to shape and returns array [distance, shortest_segment]\n     * @param {Shape} shape Shape of the one of the types Point, Circle, Segment, Arc, Polygon\n     * @returns {[number, Segment]}\n     */\n    distanceTo(shape) {\n        if (shape instanceof Flatten.Point) {\n            let [distance, shortest_segment] = Flatten.Distance.point2line(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            let [distance, shortest_segment] = Flatten.Distance.circle2line(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            let [distance, shortest_segment] = Flatten.Distance.segment2line(shape, this);\n            return [distance, shortest_segment.reverse()];\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            let [distance, shortest_segment] = Flatten.Distance.arc2line(shape, this);\n            return [distance, shortest_segment.reverse()];\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            let [distance, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\n            return [distance, shortest_segment];\n        }\n    }\n\n    /**\n     * Split line with a point or array of points and return array of shapes\n     * Assumed (but not checked) that all points lay on the line\n     * @param {Point | Point[]} pt\n     * @returns {MultilineShapes}\n     */\n    split(pt) {\n        if (pt instanceof Flatten.Point) {\n            return [new Flatten.Ray(pt, this.norm), new Flatten.Ray(pt, this.norm)]\n        }\n        else {\n            let multiline = new Flatten.Multiline([this]);\n            let sorted_points = this.sortPoints(pt);\n            multiline.split(sorted_points);\n            return multiline.toShapes();\n        }\n    }\n\n    /**\n     * Return new line rotated by angle\n     * @param {number} angle - angle in radians\n     * @param {Point} center - center of rotation\n     */\n    rotate(angle, center = new Flatten.Point()) {\n        return new Flatten.Line(\n            this.pt.rotate(angle, center),\n            this.norm.rotate(angle)\n        )\n    }\n\n    /**\n     * Return new line transformed by affine transformation matrix\n     * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\n     * @returns {Line}\n     */\n    transform(m) {\n        return new Flatten.Line(\n            this.pt.transform(m),\n            this.norm.clone()\n        )\n    }\n\n    /**\n     * Sort given array of points that lay on a line with respect to coordinate on a line\n     * The method assumes that points lay on the line and does not check this\n     * @param {Point[]} pts - array of points\n     * @returns {Point[]} new array sorted\n     */\n    sortPoints(pts) {\n        return pts.slice().sort( (pt1, pt2) => {\n            if (this.coord(pt1) < this.coord(pt2)) {\n                return -1;\n            }\n            if (this.coord(pt1) > this.coord(pt2)) {\n                return 1;\n            }\n            return 0;\n        })\n    }\n\n    get name() {\n        return \"line\"\n    }\n\n    /**\n     * Return string to draw svg segment representing line inside given box\n     * @param {Box} box Box representing drawing area\n     * @param {Object} attrs - an object with attributes of svg circle element\n     */\n    svg(box, attrs = {}) {\n        let ip = intersectLine2Box(this, box);\n        if (ip.length === 0)\n            return \"\";\n        let ps = ip[0];\n        let pe = ip.length === 2 ? ip[1] : ip.find(pt => !pt.equalTo(ps));\n        if (pe === undefined) pe = ps;\n        let segment = new Flatten.Segment(ps, pe);\n        return segment.svg(attrs);\n    }\n\n    static points2norm(pt1, pt2) {\n        if (pt1.equalTo(pt2)) {\n            throw Errors.ILLEGAL_PARAMETERS;\n        }\n        let vec = new Flatten.Vector(pt1, pt2);\n        let unit = vec.normalize();\n        return unit.rotate90CCW();\n    }\n};\n\nFlatten.Line = Line$1;\n/**\n * Function to create line equivalent to \"new\" constructor\n * @param args\n */\nconst line = (...args) => new Flatten.Line(...args);\nFlatten.line = line;\n\n/**\n * Created by Alex Bol on 3/6/2017.\n */\n\n\n/**\n * Class representing a circle\n * @type {Circle}\n */\nlet Circle$1 = class Circle extends Shape {\n    /**\n     * Class private property\n     * @type {string}\n     */\n\n    /**\n     *\n     * @param {Point} pc - circle center point\n     * @param {number} r - circle radius\n     */\n    constructor(...args) {\n        super();\n        /**\n         * Circle center\n         * @type {Point}\n         */\n        this.pc = new Flatten.Point();\n        /**\n         * Circle radius\n         * @type {number}\n         */\n        this.r = 1;\n\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"circle\") {\n            let {pc, r} = args[0];\n            this.pc = new Flatten.Point(pc);\n            this.r = r;\n        } else {\n            let [pc, r] = [...args];\n            if (pc && pc instanceof Flatten.Point) this.pc = pc.clone();\n            if (r !== undefined) this.r = r;\n        }\n        // throw Errors.ILLEGAL_PARAMETERS;    unreachable code\n    }\n\n    /**\n     * Return new cloned instance of circle\n     * @returns {Circle}\n     */\n    clone() {\n        return new Flatten.Circle(this.pc.clone(), this.r);\n    }\n\n    /**\n     * Circle center\n     * @returns {Point}\n     */\n    get center() {\n        return this.pc;\n    }\n\n    /**\n     * Circle bounding box\n     * @returns {Box}\n     */\n    get box() {\n        return new Flatten.Box(\n            this.pc.x - this.r,\n            this.pc.y - this.r,\n            this.pc.x + this.r,\n            this.pc.y + this.r\n        );\n    }\n\n    /**\n     * Return true if circle contains shape: no point of shape lies outside of the circle\n     * @param {Shape} shape - test shape\n     * @returns {boolean}\n     */\n    contains(shape) {\n        if (shape instanceof Flatten.Point) {\n            return Flatten.Utils.LE(shape.distanceTo(this.center)[0], this.r);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return Flatten.Utils.LE(shape.start.distanceTo(this.center)[0], this.r) &&\n                Flatten.Utils.LE(shape.end.distanceTo(this.center)[0], this.r);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return this.intersect(shape).length === 0 &&\n                Flatten.Utils.LE(shape.start.distanceTo(this.center)[0], this.r) &&\n                Flatten.Utils.LE(shape.end.distanceTo(this.center)[0], this.r);\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return this.intersect(shape).length === 0 &&\n                Flatten.Utils.LE(shape.r, this.r) &&\n                Flatten.Utils.LE(shape.center.distanceTo(this.center)[0], this.r);\n        }\n\n        /* TODO: box, polygon */\n    }\n\n    /**\n     * Transform circle to closed arc\n     * @param {boolean} counterclockwise\n     * @returns {Arc}\n     */\n    toArc(counterclockwise = true) {\n        return new Flatten.Arc(this.center, this.r, Math.PI, -Math.PI, counterclockwise);\n    }\n\n    /**\n     * Method scale is supported only for uniform scaling of the circle with (0,0) center\n     * @param {number} sx\n     * @param {number} sy\n     * @returns {Circle}\n     */\n    scale(sx, sy) {\n        if (sx !== sy)\n            throw Errors.OPERATION_IS_NOT_SUPPORTED\n        if (!(this.pc.x === 0.0 && this.pc.y === 0.0))\n            throw Errors.OPERATION_IS_NOT_SUPPORTED\n        return new Flatten.Circle(this.pc, this.r*sx)\n    }\n\n    /**\n     * Return new circle transformed using affine transformation matrix\n     * @param {Matrix} matrix - affine transformation matrix\n     * @returns {Circle}\n     */\n    transform(matrix = new Flatten.Matrix()) {\n        return new Flatten.Circle(this.pc.transform(matrix), this.r)\n    }\n\n    /**\n     * Returns array of intersection points between circle and other shape\n     * @param {Shape} shape Shape of the one of supported types\n     * @returns {Point[]}\n     */\n    intersect(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.contains(shape) ? [shape] : [];\n        }\n        if (shape instanceof Flatten.Line) {\n            return intersectLine2Circle(shape, this);\n        }\n        if (shape instanceof Flatten.Ray) {\n            return intersectRay2Circle(shape, this);\n        }\n        if (shape instanceof Flatten.Segment) {\n            return intersectSegment2Circle(shape, this);\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return intersectCircle2Circle(shape, this);\n        }\n\n        if (shape instanceof Flatten.Box) {\n            return intersectCircle2Box(this, shape);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return intersectArc2Circle(shape, this);\n        }\n        if (shape instanceof Flatten.Polygon) {\n            return intersectCircle2Polygon(this, shape);\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment from circle to shape and return array [distance, shortest segment]\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\n     * @returns {number} distance from circle to shape\n     * @returns {Segment} shortest segment between circle and shape (started at circle, ended at shape)\n\n     */\n    distanceTo(shape) {\n        if (shape instanceof Flatten.Point) {\n            let [distance, shortest_segment] = Flatten.Distance.point2circle(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            let [distance, shortest_segment] = Flatten.Distance.circle2circle(this, shape);\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            let [distance, shortest_segment] = Flatten.Distance.circle2line(this, shape);\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            let [distance, shortest_segment] = Flatten.Distance.segment2circle(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            let [distance, shortest_segment] = Flatten.Distance.arc2circle(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            let [distance, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.PlanarSet) {\n            let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);\n            return [dist, shortest_segment];\n        }\n    }\n\n    get name() {\n        return \"circle\"\n    }\n\n    /**\n     * Return string to draw circle in svg\n     * @param {Object} attrs - an object with attributes of svg circle element\n     * @returns {string}\n     */\n    svg(attrs = {}) {\n        return `\\n<circle cx=\"${this.pc.x}\" cy=\"${this.pc.y}\" r=\"${this.r}\"\n                ${convertToString({fill: \"none\", ...attrs})} />`;\n    }\n\n};\n\nFlatten.Circle = Circle$1;\n/**\n * Shortcut to create new circle\n * @param args\n */\nconst circle = (...args) => new Flatten.Circle(...args);\nFlatten.circle = circle;\n\n/**\n * Created by Alex Bol on 3/10/2017.\n */\n\n\n/**\n * Class representing a circular arc\n * @type {Arc}\n */\nclass Arc extends Shape {\n    /**\n     *\n     * @param {Point} pc - arc center\n     * @param {number} r - arc radius\n     * @param {number} startAngle - start angle in radians from 0 to 2*PI\n     * @param {number} endAngle - end angle in radians from 0 to 2*PI\n     * @param {boolean} counterClockwise - arc direction, true - clockwise, false - counterclockwise\n     */\n    constructor(...args) {\n        super();\n        /**\n         * Arc center\n         * @type {Point}\n         */\n        this.pc = new Flatten.Point();\n        /**\n         * Arc radius\n         * @type {number}\n         */\n        this.r = 1;\n        /**\n         * Arc start angle in radians\n         * @type {number}\n         */\n        this.startAngle = 0;\n        /**\n         * Arc end angle in radians\n         * @type {number}\n         */\n        this.endAngle = 2 * Math.PI;\n        /**\n         * Arc orientation\n         * @type {boolean}\n         */\n        this.counterClockwise = Flatten.CCW;\n\n        if (args.length === 0)\n            return;\n\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"arc\") {\n            let {pc, r, startAngle, endAngle, counterClockwise} = args[0];\n            this.pc = new Flatten.Point(pc.x, pc.y);\n            this.r = r;\n            this.startAngle = startAngle;\n            this.endAngle = endAngle;\n            this.counterClockwise = counterClockwise;\n        } else {\n            let [pc, r, startAngle, endAngle, counterClockwise] = [...args];\n            if (pc && pc instanceof Flatten.Point) this.pc = pc.clone();\n            if (r !== undefined) this.r = r;\n            if (startAngle !== undefined) this.startAngle = startAngle;\n            if (endAngle !== undefined) this.endAngle = endAngle;\n            if (counterClockwise !== undefined) this.counterClockwise = counterClockwise;\n        }\n\n        // throw Flatten.Errors.ILLEGAL_PARAMETERS; unreachable code\n    }\n\n    /**\n     * Return new cloned instance of arc\n     * @returns {Arc}\n     */\n    clone() {\n        return new Flatten.Arc(this.pc.clone(), this.r, this.startAngle, this.endAngle, this.counterClockwise);\n    }\n\n    /**\n     * Get sweep angle in radians. Sweep angle is non-negative number from 0 to 2*PI\n     * @returns {number}\n     */\n    get sweep() {\n        if (Flatten.Utils.EQ(this.startAngle, this.endAngle))\n            return 0.0;\n        if (Flatten.Utils.EQ(Math.abs(this.startAngle - this.endAngle), Flatten.PIx2)) {\n            return Flatten.PIx2;\n        }\n        let sweep;\n        if (this.counterClockwise) {\n            sweep = Flatten.Utils.GT(this.endAngle, this.startAngle) ?\n                this.endAngle - this.startAngle : this.endAngle - this.startAngle + Flatten.PIx2;\n        } else {\n            sweep = Flatten.Utils.GT(this.startAngle, this.endAngle) ?\n                this.startAngle - this.endAngle : this.startAngle - this.endAngle + Flatten.PIx2;\n        }\n\n        if (Flatten.Utils.GT(sweep, Flatten.PIx2)) {\n            sweep -= Flatten.PIx2;\n        }\n        if (Flatten.Utils.LT(sweep, 0)) {\n            sweep += Flatten.PIx2;\n        }\n        return sweep;\n    }\n\n    /**\n     * Get start point of arc\n     * @returns {Point}\n     */\n    get start() {\n        let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);\n        return p0.rotate(this.startAngle, this.pc);\n    }\n\n    /**\n     * Get end point of arc\n     * @returns {Point}\n     */\n    get end() {\n        let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);\n        return p0.rotate(this.endAngle, this.pc);\n    }\n\n    /**\n     * Get center of arc\n     * @returns {Point}\n     */\n    get center() {\n        return this.pc.clone();\n    }\n\n    get vertices() {\n        return [this.start.clone(), this.end.clone()];\n    }\n\n    /**\n     * Get arc length\n     * @returns {number}\n     */\n    get length() {\n        return Math.abs(this.sweep * this.r);\n    }\n\n    /**\n     * Get bounding box of the arc\n     * @returns {Box}\n     */\n    get box() {\n        let func_arcs = this.breakToFunctional();\n        let box = func_arcs.reduce((acc, arc) => acc.merge(arc.start.box), new Flatten.Box());\n        box = box.merge(this.end.box);\n        return box;\n    }\n\n    /**\n     * Returns true if arc contains point, false otherwise\n     * @param {Point} pt - point to test\n     * @returns {boolean}\n     */\n    contains(pt) {\n        // first check if  point on circle (pc,r)\n        if (!Flatten.Utils.EQ(this.pc.distanceTo(pt)[0], this.r))\n            return false;\n\n        // point on circle\n\n        if (pt.equalTo(this.start))\n            return true;\n\n        let angle = new Flatten.Vector(this.pc, pt).slope;\n        let test_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise);\n        return Flatten.Utils.LE(test_arc.length, this.length);\n    }\n\n    /**\n     * When given point belongs to arc, return array of two arcs split by this point. If points is incident\n     * to start or end point of the arc, return clone of the arc. If point does not belong to the arcs, return\n     * empty array.\n     * @param {Point} pt Query point\n     * @returns {Arc[]}\n     */\n    split(pt) {\n        if (this.start.equalTo(pt))\n            return [null, this.clone()];\n\n        if (this.end.equalTo(pt))\n            return [this.clone(), null];\n\n        let angle = new Flatten.Vector(this.pc, pt).slope;\n\n        return [\n            new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise),\n            new Flatten.Arc(this.pc, this.r, angle, this.endAngle, this.counterClockwise)\n        ]\n    }\n\n    /**\n     * Return middle point of the arc\n     * @returns {Point}\n     */\n    middle() {\n        let endAngle = this.counterClockwise ? this.startAngle + this.sweep / 2 : this.startAngle - this.sweep / 2;\n        let arc = new Flatten.Arc(this.pc, this.r, this.startAngle, endAngle, this.counterClockwise);\n        return arc.end;\n    }\n\n    /**\n     * Get point at given length\n     * @param {number} length - The length along the arc\n     * @returns {Point}\n     */\n    pointAtLength(length) {\n        if (length > this.length || length < 0) return null;\n        if (length === 0) return this.start;\n        if (length === this.length) return this.end;\n        let factor = length / this.length;\n        let endAngle = this.counterClockwise ? this.startAngle + this.sweep * factor : this.startAngle - this.sweep * factor;\n        let arc = new Flatten.Arc(this.pc, this.r, this.startAngle, endAngle, this.counterClockwise);\n        return arc.end;\n    }\n\n    /**\n     * Returns chord height (\"sagitta\") of the arc\n     * @returns {number}\n     */\n    chordHeight() {\n        return (1.0 - Math.cos(Math.abs(this.sweep / 2.0))) * this.r;\n    }\n\n    /**\n     * Returns array of intersection points between arc and other shape\n     * @param {Shape} shape Shape of the one of supported types <br/>\n     * @returns {Point[]}\n     */\n    intersect(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.contains(shape) ? [shape] : [];\n        }\n        if (shape instanceof Flatten.Line) {\n            return intersectLine2Arc(shape, this);\n        }\n        if (shape instanceof Flatten.Ray) {\n            return intersectRay2Arc(shape, this);\n        }\n        if (shape instanceof Flatten.Circle) {\n            return intersectArc2Circle(this, shape);\n        }\n        if (shape instanceof Flatten.Segment) {\n            return intersectSegment2Arc(shape, this);\n        }\n        if (shape instanceof Flatten.Box) {\n            return intersectArc2Box(this, shape);\n        }\n        if (shape instanceof Flatten.Arc) {\n            return intersectArc2Arc(this, shape);\n        }\n        if (shape instanceof Flatten.Polygon) {\n            return intersectArc2Polygon(this, shape);\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment from arc to shape and return array [distance, shortest segment]\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\n     * @returns {number} distance from arc to shape\n     * @returns {Segment} shortest segment between arc and shape (started at arc, ended at shape)\n\n     */\n    distanceTo(shape) {\n        if (shape instanceof Flatten.Point) {\n            let [dist, shortest_segment] = Flatten.Distance.point2arc(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            let [dist, shortest_segment] = Flatten.Distance.arc2circle(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            let [dist, shortest_segment] = Flatten.Distance.arc2line(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            let [dist, shortest_segment] = Flatten.Distance.segment2arc(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            let [dist, shortest_segment] = Flatten.Distance.arc2arc(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            let [dist, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.PlanarSet) {\n            let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);\n            return [dist, shortest_segment];\n        }\n    }\n\n    /**\n     * Breaks arc in extreme point 0, pi/2, pi, 3*pi/2 and returns array of sub-arcs\n     * @returns {Arc[]}\n     */\n    breakToFunctional() {\n        let func_arcs_array = [];\n        let angles = [0, Math.PI / 2, 2 * Math.PI / 2, 3 * Math.PI / 2];\n        let pts = [\n            this.pc.translate(this.r, 0),\n            this.pc.translate(0, this.r),\n            this.pc.translate(-this.r, 0),\n            this.pc.translate(0, -this.r)\n        ];\n\n        // If arc contains extreme point,\n        // create test arc started at start point and ended at this extreme point\n        let test_arcs = [];\n        for (let i = 0; i < 4; i++) {\n            if (pts[i].on(this)) {\n                test_arcs.push(new Flatten.Arc(this.pc, this.r, this.startAngle, angles[i], this.counterClockwise));\n            }\n        }\n\n        if (test_arcs.length === 0) {                  // arc does contain any extreme point\n            func_arcs_array.push(this.clone());\n        } else {                                        // arc passes extreme point\n            // sort these arcs by length\n            test_arcs.sort((arc1, arc2) => arc1.length - arc2.length);\n\n            for (let i = 0; i < test_arcs.length; i++) {\n                let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\n                let new_arc;\n                if (prev_arc) {\n                    new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, test_arcs[i].endAngle, this.counterClockwise);\n                } else {\n                    new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, test_arcs[i].endAngle, this.counterClockwise);\n                }\n                if (!Flatten.Utils.EQ_0(new_arc.length)) {\n                    func_arcs_array.push(new_arc.clone());\n                }\n            }\n\n            // add last sub arc\n            let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\n            let new_arc;\n            if (prev_arc) {\n                new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, this.endAngle, this.counterClockwise);\n            } else {\n                new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, this.endAngle, this.counterClockwise);\n            }\n            // It could be 2*PI when occasionally start = 0 and end = 2*PI but this is not valid for breakToFunctional\n            if (!Flatten.Utils.EQ_0(new_arc.length) && !Flatten.Utils.EQ(new_arc.sweep, 2*Math.PI)) {\n                func_arcs_array.push(new_arc.clone());\n            }\n        }\n        return func_arcs_array;\n    }\n\n    /**\n     * Return tangent unit vector in the start point in the direction from start to end\n     * @returns {Vector}\n     */\n    tangentInStart() {\n        let vec = new Flatten.Vector(this.pc, this.start);\n        let angle = this.counterClockwise ? Math.PI / 2. : -Math.PI / 2.;\n        return vec.rotate(angle).normalize();\n    }\n\n    /**\n     * Return tangent unit vector in the end point in the direction from end to start\n     * @returns {Vector}\n     */\n    tangentInEnd() {\n        let vec = new Flatten.Vector(this.pc, this.end);\n        let angle = this.counterClockwise ? -Math.PI / 2. : Math.PI / 2.;\n        return vec.rotate(angle).normalize();\n    }\n\n    /**\n     * Returns new arc with swapped start and end angles and reversed direction\n     * @returns {Arc}\n     */\n    reverse() {\n        return new Flatten.Arc(this.pc, this.r, this.endAngle, this.startAngle, !this.counterClockwise);\n    }\n\n    /**\n     * Return new arc transformed using affine transformation matrix <br/>\n     * @param {Matrix} matrix - affine transformation matrix\n     * @returns {Arc}\n     */\n    transform(matrix = new Flatten.Matrix()) {\n        let newStart = this.start.transform(matrix);\n        let newEnd = this.end.transform(matrix);\n        let newCenter = this.pc.transform(matrix);\n        let newDirection = this.counterClockwise;\n        if (matrix.a * matrix.d < 0) {\n          newDirection = !newDirection;\n        }\n        return Flatten.Arc.arcSE(newCenter, newStart, newEnd, newDirection);\n    }\n\n    static arcSE(center, start, end, counterClockwise) {\n        let {vector} = Flatten;\n        let startAngle = vector(center, start).slope;\n        let endAngle = vector(center, end).slope;\n        if (Flatten.Utils.EQ(startAngle, endAngle)) {\n            endAngle += 2 * Math.PI;\n            counterClockwise = true;\n        }\n        let r = vector(center, start).length;\n\n        return new Flatten.Arc(center, r, startAngle, endAngle, counterClockwise);\n    }\n\n    definiteIntegral(ymin = 0) {\n        let f_arcs = this.breakToFunctional();\n        let area = f_arcs.reduce((acc, arc) => acc + arc.circularSegmentDefiniteIntegral(ymin), 0.0);\n        return area;\n    }\n\n    circularSegmentDefiniteIntegral(ymin) {\n        let line = new Flatten.Line(this.start, this.end);\n        let onLeftSide = this.pc.leftTo(line);\n        let segment = new Flatten.Segment(this.start, this.end);\n        let areaTrapez = segment.definiteIntegral(ymin);\n        let areaCircularSegment = this.circularSegmentArea();\n        let area = onLeftSide ? areaTrapez - areaCircularSegment : areaTrapez + areaCircularSegment;\n        return area;\n    }\n\n    circularSegmentArea() {\n        return (0.5 * this.r * this.r * (this.sweep - Math.sin(this.sweep)))\n    }\n\n    /**\n     * Sort given array of points from arc start to end, assuming all points lay on the arc\n     * @param {Point[]} pts array of points\n     * @returns {Point[]} new array sorted\n     */\n    sortPoints(pts) {\n        let {vector} = Flatten;\n        return pts.slice().sort( (pt1, pt2) => {\n            let slope1 = vector(this.pc, pt1).slope;\n            let slope2 = vector(this.pc, pt2).slope;\n            if (slope1 < slope2) {\n                return -1;\n            }\n            if (slope1 > slope2) {\n                return 1;\n            }\n            return 0;\n        })\n    }\n\n    get name() {\n        return \"arc\"\n    }\n\n    /**\n     * Return string to draw arc in svg\n     * @param {Object} attrs - an object with attributes of svg path element\n     * @returns {string}\n     */\n    svg(attrs = {}) {\n        let largeArcFlag = this.sweep <= Math.PI ? \"0\" : \"1\";\n        let sweepFlag = this.counterClockwise ? \"1\" : \"0\";\n\n        if (Flatten.Utils.EQ(this.sweep, 2 * Math.PI)) {\n            let circle = new Flatten.Circle(this.pc, this.r);\n            return circle.svg(attrs);\n        } else {\n            return `\\n<path d=\"M${this.start.x},${this.start.y}\n                             A${this.r},${this.r} 0 ${largeArcFlag},${sweepFlag} ${this.end.x},${this.end.y}\"\n                    ${convertToString({fill: \"none\", ...attrs})} />`\n        }\n    }\n\n}\n\nFlatten.Arc = Arc;\n/**\n * Function to create arc equivalent to \"new\" constructor\n * @param args\n */\nconst arc = (...args) => new Flatten.Arc(...args);\nFlatten.arc = arc;\n\n/**\n * Created by Alex Bol on 3/7/2017.\n */\n\n/**\n * Class Box represents bounding box of the shape.\n * It may also represent axis-aligned rectangle\n * @type {Box}\n */\nclass Box extends Shape {\n    /**\n     *\n     * @param {number} xmin - minimal x coordinate\n     * @param {number} ymin - minimal y coordinate\n     * @param {number} xmax - maximal x coordinate\n     * @param {number} ymax - maximal y coordinate\n     */\n    constructor(xmin = undefined, ymin = undefined, xmax = undefined, ymax = undefined) {\n        super();\n        /**\n         * Minimal x coordinate\n         * @type {number}\n         */\n        this.xmin = xmin;\n        /**\n         * Minimal y coordinate\n         * @type {number}\n         */\n        this.ymin = ymin;\n        /**\n         * Maximal x coordinate\n         * @type {number}\n         */\n        this.xmax = xmax;\n        /**\n         * Maximal y coordinate\n         * @type {number}\n         */\n        this.ymax = ymax;\n    }\n\n    /**\n     * Return new cloned instance of box\n     * @returns {Box}\n     */\n    clone() {\n        return new Box(this.xmin, this.ymin, this.xmax, this.ymax);\n    }\n\n    /**\n     * Property low need for interval tree interface\n     * @returns {Point}\n     */\n    get low() {\n        return new Flatten.Point(this.xmin, this.ymin);\n    }\n\n    /**\n     * Property high need for interval tree interface\n     * @returns {Point}\n     */\n    get high() {\n        return new Flatten.Point(this.xmax, this.ymax);\n    }\n\n    /**\n     * Property max returns the box itself !\n     * @returns {Box}\n     */\n    get max() {\n        return this.clone();\n    }\n    \n    /**\n     * Return center of the box\n     * @returns {Point}\n     */\n    get center() {\n        return new Flatten.Point((this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2);\n    }\n\n    /**\n     * Return the width of the box\n     * @returns {number}\n     */\n    get width() {\n        return Math.abs(this.xmax - this.xmin);\n    }\n\n    /**\n     * Return the height of the box\n     * @returns {number}\n     */\n    get height() {\n        return Math.abs(this.ymax - this.ymin);\n    }\n    \n    /**\n     * Return property box like all other shapes\n     * @returns {Box}\n     */\n    get box() {\n        return this.clone();\n    }\n\n    /**\n     * Returns true if not intersected with other box\n     * @param {Box} other_box - other box to test\n     * @returns {boolean}\n     */\n    not_intersect(other_box) {\n        return (\n            this.xmax < other_box.xmin ||\n            this.xmin > other_box.xmax ||\n            this.ymax < other_box.ymin ||\n            this.ymin > other_box.ymax\n        );\n    }\n\n    /**\n     * Returns true if intersected with other box\n     * @param {Box} other_box - Query box\n     * @returns {boolean}\n     */\n    intersect(other_box) {\n        return !this.not_intersect(other_box);\n    }\n\n    /**\n     * Returns new box merged with other box\n     * @param {Box} other_box - Other box to merge with\n     * @returns {Box}\n     */\n    merge(other_box) {\n        return new Box(\n            this.xmin === undefined ? other_box.xmin : Math.min(this.xmin, other_box.xmin),\n            this.ymin === undefined ? other_box.ymin : Math.min(this.ymin, other_box.ymin),\n            this.xmax === undefined ? other_box.xmax : Math.max(this.xmax, other_box.xmax),\n            this.ymax === undefined ? other_box.ymax : Math.max(this.ymax, other_box.ymax)\n        );\n    }\n\n    /**\n     * Defines predicate \"less than\" between two boxes. Need for interval index\n     * @param {Box} other_box - other box\n     * @returns {boolean} - true if this box less than other box, false otherwise\n     */\n    less_than(other_box) {\n        if (this.low.lessThan(other_box.low))\n            return true;\n        if (this.low.equalTo(other_box.low) && this.high.lessThan(other_box.high))\n            return true;\n        return false;\n    }\n\n    /**\n     * Returns true if this box is equal to other box, false otherwise\n     * @param {Box} other_box - query box\n     * @returns {boolean}\n     */\n    equal_to(other_box) {\n        return (this.low.equalTo(other_box.low) && this.high.equalTo(other_box.high));\n    }\n\n    output() {\n        return this.clone();\n    }\n\n    static comparable_max(box1, box2) {\n        // return pt1.lessThan(pt2) ? pt2.clone() : pt1.clone();\n        return box1.merge(box2);\n    }\n\n    static comparable_less_than(pt1, pt2) {\n        return pt1.lessThan(pt2);\n    }\n\n    /**\n     * Set new values to the box object\n     * @param {number} xmin - mininal x coordinate\n     * @param {number} ymin - minimal y coordinate\n     * @param {number} xmax - maximal x coordinate\n     * @param {number} ymax - maximal y coordinate\n     */\n    set(xmin, ymin, xmax, ymax) {\n        this.xmin = xmin;\n        this.ymin = ymin;\n        this.xmax = xmax;\n        this.ymax = ymax;\n    }\n\n    /**\n     * Transform box into array of points from low left corner in counterclockwise\n     * @returns {Point[]}\n     */\n    toPoints() {\n        return [\n            new Flatten.Point(this.xmin, this.ymin),\n            new Flatten.Point(this.xmax, this.ymin),\n            new Flatten.Point(this.xmax, this.ymax),\n            new Flatten.Point(this.xmin, this.ymax)\n        ];\n    }\n\n    /**\n     * Transform box into array of segments from low left corner in counterclockwise\n     * @returns {Segment[]}\n     */\n    toSegments() {\n        let pts = this.toPoints();\n        return [\n            new Flatten.Segment(pts[0], pts[1]),\n            new Flatten.Segment(pts[1], pts[2]),\n            new Flatten.Segment(pts[2], pts[3]),\n            new Flatten.Segment(pts[3], pts[0])\n        ];\n    }\n\n    /**\n     * Box rotation is not supported\n     * Attempt to rotate box throws error\n     * @param {number} angle - angle in radians\n     * @param {Point} [center=(0,0)] center\n     */\n    rotate(angle, center = new Flatten.Point()) {\n            throw Errors.OPERATION_IS_NOT_SUPPORTED\n    }\n\n    /**\n     * Return new box transformed using affine transformation matrix\n     * New box is a bounding box of transformed corner points\n     * @param {Matrix} m - affine transformation matrix\n     * @returns {Box}\n     */\n    transform(m = new Flatten.Matrix()) {\n        const transformed_points = this.toPoints().map(pt => pt.transform(m));\n        return transformed_points.reduce(\n            (new_box, pt) => new_box.merge(pt.box), new Box())\n    }\n\n    /**\n     * Return true if box contains shape: no point of shape lies outside the box\n     * @param {AnyShape} shape - test shape\n     * @returns {boolean}\n     */\n    contains(shape) {\n        if (shape instanceof Flatten.Point) {\n            return (shape.x >= this.xmin) && (shape.x <= this.xmax) && (shape.y >= this.ymin) && (shape.y <= this.ymax);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return shape.vertices.every(vertex => this.contains(vertex))\n        }\n\n        if (shape instanceof Flatten.Box) {\n            return shape.toSegments().every(segment => this.contains(segment))\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return this.contains(shape.box)\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return shape.vertices.every(vertex => this.contains(vertex)) &&\n                shape.toSegments().every(segment => intersectSegment2Arc(segment, shape).length === 0)\n        }\n\n        if (shape instanceof Flatten.Line || shape instanceof Flatten.Ray) {\n            return false\n        }\n\n        if (shape instanceof Flatten.Multiline) {\n            return shape.toShapes().every(shape => this.contains(shape))\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            return this.contains(shape.box)\n        }\n    }\n\n    get name() {\n        return \"box\"\n    }\n\n    /**\n     * Return string to draw box in svg\n     * @param {Object} attrs - an object with attributes of svg rectangle element\n     * @returns {string}\n     */\n    svg(attrs = {}) {\n        const width = this.xmax - this.xmin;\n        const height = this.ymax - this.ymin;\n        return `\\n<rect x=\"${this.xmin}\" y=\"${this.ymin}\" width=${width} height=${height}\n                ${convertToString({fill: \"none\", ...attrs})} />`;\n    };\n}\n\nFlatten.Box = Box;\n/**\n * Shortcut to create new box\n * @param args\n * @returns {Box}\n */\nconst box = (...args) => new Flatten.Box(...args);\nFlatten.box = box;\n\n/**\n * Created by Alex Bol on 3/17/2017.\n */\n\n\n/**\n * Class representing an edge of polygon. Edge shape may be Segment or Arc.\n * Each edge contains references to the next and previous edges in the face of the polygon.\n *\n * @type {Edge}\n */\nclass Edge {\n    /**\n     * Construct new instance of edge\n     * @param {Shape} shape Shape of type Segment or Arc\n     */\n    constructor(shape) {\n        /**\n         * Shape of the edge: Segment or Arc\n         * @type {Segment|Arc}\n         */\n        this.shape = shape;\n        /**\n         * Pointer to the next edge in the face\n         * @type {Edge}\n         */\n        this.next = undefined;\n        /**\n         * Pointer to the previous edge in the face\n         * @type {Edge}\n         */\n        this.prev = undefined;\n        /**\n         * Pointer to the face containing this edge\n         * @type {Face}\n         */\n        this.face = undefined;\n        /**\n         * \"Arc distance\" from the face start\n         * @type {number}\n         */\n        this.arc_length = 0;\n        /**\n         * Start inclusion flag (inside/outside/boundary)\n         * @type {*}\n         */\n        this.bvStart = undefined;\n        /**\n         * End inclusion flag (inside/outside/boundary)\n         * @type {*}\n         */\n        this.bvEnd = undefined;\n        /**\n         * Edge inclusion flag (Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY)\n         * @type {*}\n         */\n        this.bv = undefined;\n        /**\n         * Overlap flag for boundary edge (Flatten.OVERLAP_SAME/Flatten.OVERLAP_OPPOSITE)\n         * @type {*}\n         */\n        this.overlap = undefined;\n    }\n\n    /**\n     * Get edge start point\n     */\n    get start() {\n        return this.shape.start;\n    }\n\n    /**\n     * Get edge end point\n     */\n    get end() {\n        return this.shape.end;\n    }\n\n    /**\n     * Get edge length\n     */\n    get length() {\n        return this.shape.length;\n    }\n\n    /**\n     * Get bounding box of the edge\n     * @returns {Box}\n     */\n    get box() {\n        return this.shape.box;\n    }\n\n    get isSegment() {\n        return this.shape instanceof Flatten.Segment;\n    }\n\n    get isArc() {\n        return this.shape instanceof Flatten.Arc;\n    }\n\n    get isLine() {\n        return this.shape instanceof Flatten.Line;\n    }\n\n    get isRay() {\n        return this.shape instanceof Flatten.Ray\n    }\n\n    /**\n     * Get middle point of the edge\n     * @returns {Point}\n     */\n    middle() {\n        return this.shape.middle();\n    }\n\n    /**\n     * Get point at given length\n     * @param {number} length - The length along the edge\n     * @returns {Point}\n     */\n    pointAtLength(length) {\n        return this.shape.pointAtLength(length);\n    }\n\n    /**\n     * Returns true if point belongs to the edge, false otherwise\n     * @param {Point} pt - test point\n     */\n    contains(pt) {\n        return this.shape.contains(pt);\n    }\n\n    /**\n     * Set inclusion flag of the edge with respect to another polygon\n     * Inclusion flag is one of Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY\n     * @param polygon\n     */\n    setInclusion(polygon) {\n        if (this.bv !== undefined) return this.bv;\n\n        if (this.shape instanceof Flatten.Line || this.shape instanceof Flatten.Ray) {\n            this.bv = Flatten.OUTSIDE;\n            return this.bv;\n        }\n\n        if (this.bvStart === undefined) {\n            this.bvStart = ray_shoot(polygon, this.start);\n        }\n        if (this.bvEnd === undefined) {\n            this.bvEnd = ray_shoot(polygon, this.end);\n        }\n        /* At least one end outside - the whole edge outside */\n        if (this.bvStart === Flatten.OUTSIDE || this.bvEnd == Flatten.OUTSIDE) {\n            this.bv = Flatten.OUTSIDE;\n        }\n        /* At least one end inside - the whole edge inside */\n        else if (this.bvStart === Flatten.INSIDE || this.bvEnd == Flatten.INSIDE) {\n            this.bv = Flatten.INSIDE;\n        }\n        /* Both are boundary - check the middle point */\n        else {\n            let bvMiddle = ray_shoot(polygon, this.middle());\n            // let boundary = this.middle().distanceTo(polygon)[0] < 10*Flatten.DP_TOL;\n            // let bvMiddle = boundary ? Flatten.BOUNDARY : ray_shoot(polygon, this.middle());\n            this.bv = bvMiddle;\n        }\n        return this.bv;\n    }\n\n    /**\n     * Set overlapping between two coincident boundary edges\n     * Overlapping flag is one of Flatten.OVERLAP_SAME or Flatten.OVERLAP_OPPOSITE\n     * @param edge\n     */\n    setOverlap(edge) {\n        let flag = undefined;\n        let shape1 = this.shape;\n        let shape2 = edge.shape;\n\n        if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Segment) {\n            if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end)) {\n                flag = Flatten.OVERLAP_SAME;\n            } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start)) {\n                flag = Flatten.OVERLAP_OPPOSITE;\n            }\n        } else if (shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Arc) {\n            if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && /*shape1.counterClockwise === shape2.counterClockwise &&*/\n                shape1.middle().equalTo(shape2.middle())) {\n                flag = Flatten.OVERLAP_SAME;\n            } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && /*shape1.counterClockwise !== shape2.counterClockwise &&*/\n                shape1.middle().equalTo(shape2.middle())) {\n                flag = Flatten.OVERLAP_OPPOSITE;\n            }\n        } else if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Arc ||\n            shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Segment) {\n            if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && shape1.middle().equalTo(shape2.middle())) {\n                flag = Flatten.OVERLAP_SAME;\n            } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && shape1.middle().equalTo(shape2.middle())) {\n                flag = Flatten.OVERLAP_OPPOSITE;\n            }\n        }\n\n        /* Do not update overlap flag if already set on previous chain */\n        if (this.overlap === undefined) this.overlap = flag;\n        if (edge.overlap === undefined) edge.overlap = flag;\n    }\n\n    svg() {\n        if (this.shape instanceof Flatten.Segment) {\n            return ` L${this.shape.end.x},${this.shape.end.y}`;\n        } else if (this.shape instanceof Flatten.Arc) {\n            let arc = this.shape;\n            let largeArcFlag;\n            let sweepFlag = arc.counterClockwise ? \"1\" : \"0\";\n\n            // Draw full circe arc as special case: split it into two half-circles\n            if (Flatten.Utils.EQ(arc.sweep, 2 * Math.PI)) {\n                let sign = arc.counterClockwise ? 1 : -1;\n                let halfArc1 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle, arc.startAngle + sign * Math.PI, arc.counterClockwise);\n                let halfArc2 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle + sign * Math.PI, arc.endAngle, arc.counterClockwise);\n\n                largeArcFlag = \"0\";\n\n                return ` A${halfArc1.r},${halfArc1.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc1.end.x},${halfArc1.end.y}\n                    A${halfArc2.r},${halfArc2.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc2.end.x},${halfArc2.end.y}`\n            } else {\n                largeArcFlag = arc.sweep <= Math.PI ? \"0\" : \"1\";\n\n                return ` A${arc.r},${arc.r} 0 ${largeArcFlag},${sweepFlag} ${arc.end.x},${arc.end.y}`;\n            }\n        }\n    }\n\n    toJSON() {\n        return this.shape.toJSON();\n    }\n}\nFlatten.Edge = Edge;\n\n/**\n * Class implements circular bidirectional linked list <br/>\n * LinkedListElement - object of any type that has properties next and prev.\n */\nclass CircularLinkedList extends LinkedList {\n    constructor(first, last) {\n        super(first, last);\n        this.setCircularLinks();\n    }\n\n    setCircularLinks() {\n        if (this.isEmpty()) return;\n        this.last.next = this.first;\n        this.first.prev = this.last;\n    }\n\n    [Symbol.iterator]() {\n        let element = undefined;\n        return {\n            next: () => {\n                let value = element ? element : this.first;\n                let done = this.first ? (element ? element === this.first : false) : true;\n                element = value ? value.next : undefined;\n                return {value: value, done: done};\n            }\n        };\n    };\n\n    /**\n     * Append new element to the end of the list\n     * @param {LinkedListElement} element - new element to be appended\n     * @returns {CircularLinkedList}\n     */\n    append(element) {\n        super.append(element);\n        this.setCircularLinks();\n        return this;\n    }\n\n    /**\n     * Insert new element to the list after elementBefore\n     * @param {LinkedListElement} newElement - new element to be inserted\n     * @param {LinkedListElement} elementBefore - element in the list to insert after it\n     * @returns {CircularLinkedList}\n     */\n    insert(newElement, elementBefore) {\n        super.insert(newElement, elementBefore);\n        this.setCircularLinks();\n        return this;\n    }\n\n    /**\n     * Remove element from the list\n     * @param {LinkedListElement} element - element to be removed from the list\n     * @returns {CircularLinkedList}\n     */\n    remove(element) {\n        super.remove(element);\n        // this.setCircularLinks();\n        return this;\n    }\n}\n\n/**\n * Created by Alex Bol on 3/17/2017.\n */\n\n\n/**\n * Class representing a face (closed loop) in a [polygon]{@link Flatten.Polygon} object.\n * Face is a circular bidirectional linked list of [edges]{@link Flatten.Edge}.\n * Face object cannot be instantiated with a constructor.\n * Instead, use [polygon.addFace()]{@link Flatten.Polygon#addFace} method.\n * <br/>\n * Note, that face only set entry point to the linked list of edges but does not contain edges by itself.\n * Container of edges is a property of the polygon object. <br/>\n *\n * @example\n * // Face implements \"next\" iterator which enables to iterate edges in for loop:\n * for (let edge of face) {\n *      console.log(edge.shape.length)     // do something\n * }\n *\n * // Instead, it is possible to iterate edges as linked list, starting from face.first:\n * let edge = face.first;\n * do {\n *   console.log(edge.shape.length);   // do something\n *   edge = edge.next;\n * } while (edge != face.first)\n */\nclass Face extends CircularLinkedList {\n    constructor(polygon, ...args) {\n        super();            // construct empty list of edges\n        /**\n         * Reference to the first edge in face\n         */\n        // this.first;\n        /**\n         * Reference to the last edge in face\n         */\n        // this.last;\n\n        this._box = undefined;  // new Box();\n        this._orientation = undefined;\n\n        if (args.length === 0) {\n            return;\n        }\n\n        /* If passed an array it supposed to be:\n         1) array of shapes that performs close loop or\n         2) array of points that performs set of vertices\n         */\n        if (args.length === 1) {\n            if (args[0] instanceof Array) {\n                // let argsArray = args[0];\n                let shapes = args[0];  // argsArray[0];\n                if (shapes.length === 0)\n                    return;\n\n                /* array of Flatten.Points */\n                if (shapes.every((shape) => {return shape instanceof Flatten.Point})) {\n                    let segments = Face.points2segments(shapes);\n                    this.shapes2face(polygon.edges, segments);\n                }\n                /* array of points as pairs of numbers */\n                else if (shapes.every((shape) => {return shape instanceof Array && shape.length === 2})) {\n                    let points = shapes.map((shape) => new Flatten.Point(shape[0],shape[1]));\n                    let segments = Face.points2segments(points);\n                    this.shapes2face(polygon.edges, segments);\n                }\n                /* array of segments ot arcs */\n                else if (shapes.every((shape) => {\n                    return (shape instanceof Flatten.Segment || shape instanceof Flatten.Arc)\n                })) {\n                    this.shapes2face(polygon.edges, shapes);\n                }\n                // this is from JSON.parse object\n                else if (shapes.every((shape) => {\n                    return (shape.name === \"segment\" || shape.name === \"arc\")\n                })) {\n                    let flattenShapes = [];\n                    for (let shape of shapes) {\n                        let flattenShape;\n                        if (shape.name === \"segment\") {\n                            flattenShape = new Flatten.Segment(shape);\n                        } else {\n                            flattenShape = new Flatten.Arc(shape);\n                        }\n                        flattenShapes.push(flattenShape);\n                    }\n                    this.shapes2face(polygon.edges, flattenShapes);\n                }\n            }\n            /* Create new face and copy edges into polygon.edges set */\n            else if (args[0] instanceof Face) {\n                let face = args[0];\n                this.first = face.first;\n                this.last = face.last;\n                for (let edge of face) {\n                    polygon.edges.add(edge);\n                }\n            }\n            /* Instantiate face from a circle in CCW orientation */\n            else if (args[0] instanceof Flatten.Circle) {\n                this.shapes2face(polygon.edges, [args[0].toArc(CCW)]);\n            }\n            /* Instantiate face from a box in CCW orientation */\n            else if (args[0] instanceof Flatten.Box) {\n                let box = args[0];\n                this.shapes2face(polygon.edges, [\n                    new Flatten.Segment(new Flatten.Point(box.xmin, box.ymin), new Flatten.Point(box.xmax, box.ymin)),\n                    new Flatten.Segment(new Flatten.Point(box.xmax, box.ymin), new Flatten.Point(box.xmax, box.ymax)),\n                    new Flatten.Segment(new Flatten.Point(box.xmax, box.ymax), new Flatten.Point(box.xmin, box.ymax)),\n                    new Flatten.Segment(new Flatten.Point(box.xmin, box.ymax), new Flatten.Point(box.xmin, box.ymin))\n                ]);\n            }\n        }\n        /* If passed two edges, consider them as start and end of the face loop */\n        /* THIS METHOD WILL BE USED BY BOOLEAN OPERATIONS */\n        /* Assume that edges already copied to polygon.edges set in the clip algorithm !!! */\n        if (args.length === 2 && args[0] instanceof Flatten.Edge && args[1] instanceof Flatten.Edge) {\n            this.first = args[0];                          // first edge in face or undefined\n            this.last = args[1];                           // last edge in face or undefined\n            this.last.next = this.first;\n            this.first.prev = this.last;\n\n            // set arc length\n            this.setArcLength();\n\n            // this.box = this.getBox();\n            // this.orientation = this.getOrientation();      // face direction cw or ccw\n        }\n    }\n\n    /**\n     * Return array of edges from first to last\n     * @returns {Array}\n     */\n    get edges() {\n        return this.toArray();\n    }\n\n    /**\n     * Return array of shapes which comprise face\n     * @returns {Array}\n     */\n    get shapes() {\n        return this.edges.map(edge => edge.shape.clone());\n    }\n\n    /**\n     * Return bounding box of the face\n     * @returns {Box}\n     */\n    get box() {\n        if (this._box === undefined) {\n            let box = new Flatten.Box();\n            for (let edge of this) {\n                box = box.merge(edge.box);\n            }\n            this._box = box;\n        }\n        return this._box;\n    }\n\n    /**\n     * Get all edges length\n     * @returns {number}\n     */\n    get perimeter() {\n        return this.last.arc_length + this.last.length\n    }\n\n    /**\n     * Get point on face boundary at given length\n     * @param {number} length - The length along the face boundary\n     * @returns {Point}\n     */\n    pointAtLength(length) {\n        if (length > this.perimeter || length < 0) return null;\n        let point = null;\n        for (let edge of this) {\n            if (length >= edge.arc_length &&\n                (edge === this.last || length < edge.next.arc_length)) {\n                point = edge.pointAtLength(length - edge.arc_length);\n                break;\n            }\n        }\n        return point;\n    }\n\n    static points2segments(points) {\n        let segments = [];\n        for (let i = 0; i < points.length; i++) {\n            // skip zero length segment\n            if (points[i].equalTo(points[(i + 1) % points.length]))\n                continue;\n            segments.push(new Flatten.Segment(points[i], points[(i + 1) % points.length]));\n        }\n        return segments;\n    }\n\n    shapes2face(edges, shapes) {\n        for (let shape of shapes) {\n            let edge = new Flatten.Edge(shape);\n            this.append(edge);\n            // this.box = this.box.merge(shape.box);\n            edges.add(edge);\n        }\n        // this.orientation = this.getOrientation();              // face direction cw or ccw\n    }\n\n    /**\n     * Append edge after the last edge of the face (and before the first edge). <br/>\n     * @param {Edge} edge - Edge to be appended to the linked list\n     * @returns {Face}\n     */\n    append(edge) {\n        super.append(edge);\n        // set arc length\n        this.setOneEdgeArcLength(edge);\n        edge.face = this;\n        // edges.add(edge);      // Add new edges into edges container\n        return this;\n    }\n\n    /**\n     * Insert edge newEdge into the linked list after the edge edgeBefore <br/>\n     * @param {Edge} newEdge - Edge to be inserted into linked list\n     * @param {Edge} edgeBefore - Edge to insert newEdge after it\n     * @returns {Face}\n     */\n    insert(newEdge, edgeBefore) {\n        super.insert(newEdge, edgeBefore);\n        // set arc length\n        this.setOneEdgeArcLength(newEdge);\n        newEdge.face = this;\n        return this;\n    }\n\n    /**\n     * Remove the given edge from the linked list of the face <br/>\n     * @param {Edge} edge - Edge to be removed\n     * @returns {Face}\n     */\n    remove(edge) {\n        super.remove(edge);\n        // Recalculate arc length\n        this.setArcLength();\n        return this;\n    }\n\n    /**\n     * Merge current edge with the next edge. Given edge will be extended,\n     * next edge after it will be removed. The distortion of the polygon\n     * is on the responsibility of the user of this method\n     * @param {Edge} edge - edge to be extended\n     * @returns {Face}\n     */\n    merge_with_next_edge(edge) {\n        edge.shape.end.x = edge.next.shape.end.x;\n        edge.shape.end.y = edge.next.shape.end.y;\n        this.remove(edge.next);\n        return this;\n    }\n\n    /**\n     * Reverse orientation of the face: first edge become last and vice a verse,\n     * all edges starts and ends swapped, direction of arcs inverted. If face was oriented\n     * clockwise, it becomes counterclockwise and vice versa\n     */\n    reverse() {\n        // collect edges in revert order with reverted shapes\n        let edges = [];\n        let edge_tmp = this.last;\n        do {\n            // reverse shape\n            edge_tmp.shape = edge_tmp.shape.reverse();\n            edges.push(edge_tmp);\n            edge_tmp = edge_tmp.prev;\n        } while (edge_tmp !== this.last);\n\n        // restore linked list\n        this.first = undefined;\n        this.last = undefined;\n        for (let edge of edges) {\n            if (this.first === undefined) {\n                edge.prev = edge;\n                edge.next = edge;\n                this.first = edge;\n                this.last = edge;\n            } else {\n                // append to end\n                edge.prev = this.last;\n                this.last.next = edge;\n\n                // update edge to be last\n                this.last = edge;\n\n                // restore circular links\n                this.last.next = this.first;\n                this.first.prev = this.last;\n\n            }\n            // set arc length\n            this.setOneEdgeArcLength(edge);\n        }\n\n        // Recalculate orientation, if set\n        if (this._orientation !== undefined) {\n            this._orientation = undefined;\n            this._orientation = this.orientation();\n        }\n    }\n\n\n    /**\n     * Set arc_length property for each of the edges in the face.\n     * Arc_length of the edge it the arc length from the first edge of the face\n     */\n    setArcLength() {\n        for (let edge of this) {\n            this.setOneEdgeArcLength(edge);\n            edge.face = this;\n        }\n    }\n\n    setOneEdgeArcLength(edge) {\n        if (edge === this.first) {\n            edge.arc_length = 0.0;\n        } else {\n            edge.arc_length = edge.prev.arc_length + edge.prev.length;\n        }\n    }\n\n    /**\n     * Returns the absolute value of the area of the face\n     * @returns {number}\n     */\n    area() {\n        return Math.abs(this.signedArea());\n    }\n\n    /**\n     * Returns signed area of the simple face.\n     * Face is simple if it has no self intersections that change its orientation.\n     * Then the area will be positive if the orientation of the face is clockwise,\n     * and negative if orientation is counterclockwise.\n     * It may be zero if polygon is degenerated.\n     * @returns {number}\n     */\n    signedArea() {\n        let sArea = 0;\n        let ymin = this.box.ymin;\n        for (let edge of this) {\n            sArea += edge.shape.definiteIntegral(ymin);\n        }\n        return sArea;\n    }\n\n    /**\n     * Return face orientation: one of Flatten.ORIENTATION.CCW, Flatten.ORIENTATION.CW, Flatten.ORIENTATION.NOT_ORIENTABLE <br/>\n     * According to Green theorem the area of a closed curve may be calculated as double integral,\n     * and the sign of the integral will be defined by the direction of the curve.\n     * When the integral (\"signed area\") will be negative, direction is counterclockwise,\n     * when positive - clockwise and when it is zero, polygon is not orientable.\n     * See {@link https://mathinsight.org/greens_theorem_find_area}\n     * @returns {number}\n     */\n    orientation() {\n        if (this._orientation === undefined) {\n            let area = this.signedArea();\n            if (Flatten.Utils.EQ_0(area)) {\n                this._orientation = ORIENTATION.NOT_ORIENTABLE;\n            } else if (Flatten.Utils.LT(area, 0)) {\n                this._orientation = ORIENTATION.CCW;\n            } else {\n                this._orientation = ORIENTATION.CW;\n            }\n        }\n        return this._orientation;\n    }\n\n    /**\n     * Returns true if face of the polygon is simple (no self-intersection points found)\n     * NOTE: this method is incomplete because it does not exclude touching points.\n     * Self intersection test should check if polygon change orientation in the test point.\n     * @param {PlanarSet} edges - reference to polygon edges to provide search index\n     * @returns {boolean}\n     */\n    isSimple(edges) {\n        let ip = Face.getSelfIntersections(this, edges, true);\n        return ip.length === 0;\n    }\n\n    static getSelfIntersections(face, edges, exitOnFirst = false) {\n        let int_points = [];\n\n        // calculate intersections\n        for (let edge1 of face) {\n\n            // request edges of polygon in the box of edge1\n            let resp = edges.search(edge1.box);\n\n            // for each edge2 in response\n            for (let edge2 of resp) {\n\n                // Skip itself\n                if (edge1 === edge2)\n                    continue;\n\n                // Skip is edge2 belongs to another face\n                if (edge2.face !== face)\n                    continue;\n\n                // Skip next and previous edge if both are segment (if one of them arc - calc intersection)\n                if (edge1.shape instanceof Flatten.Segment && edge2.shape instanceof Flatten.Segment &&\n                    (edge1.next === edge2 || edge1.prev === edge2))\n                    continue;\n\n                // calculate intersections between edge1 and edge2\n                let ip = edge1.shape.intersect(edge2.shape);\n\n                // for each intersection point\n                for (let pt of ip) {\n\n                    // skip start-end connections\n                    if (pt.equalTo(edge1.start) && pt.equalTo(edge2.end) && edge2 === edge1.prev)\n                        continue;\n                    if (pt.equalTo(edge1.end) && pt.equalTo(edge2.start) && edge2 === edge1.next)\n                        continue;\n\n                    int_points.push(pt);\n\n                    if (exitOnFirst)\n                        break;\n                }\n\n                if (int_points.length > 0 && exitOnFirst)\n                    break;\n            }\n\n            if (int_points.length > 0 && exitOnFirst)\n                break;\n\n        }\n        return int_points;\n    }\n\n    /**\n     * Returns edge which contains given point\n     * @param {Point} pt - test point\n     * @returns {Edge}\n     */\n    findEdgeByPoint(pt) {\n        let edgeFound;\n        for (let edge of this) {\n            if (pt.equalTo(edge.shape.start)) continue\n            if (pt.equalTo(edge.shape.end) || edge.shape.contains(pt)) {\n                edgeFound = edge;\n                break;\n            }\n        }\n        return edgeFound;\n    }\n\n    /**\n     * Returns new polygon created from one face\n     * @returns {Polygon}\n     */\n    toPolygon() {\n        return new Flatten.Polygon(this.shapes);\n    }\n\n    toJSON() {\n        return this.edges.map(edge => edge.toJSON());\n    }\n\n    /**\n     * Returns string to be assigned to \"d\" attribute inside defined \"path\"\n     * @returns {string}\n     */\n    svg() {\n        let svgStr = `\\nM${this.first.start.x},${this.first.start.y}`;\n        for (let edge of this) {\n            svgStr += edge.svg();\n        }\n        svgStr += ` z`;\n        return svgStr;\n    }\n\n}\n\nFlatten.Face = Face;\n\n/**\n * Class representing a ray (a half-infinite line).\n * @type {Ray}\n */\nclass Ray extends Shape {\n    /**\n     * Ray may be constructed by setting an <b>origin</b> point and a <b>normal</b> vector, so that any point <b>x</b>\n     * on a ray fit an equation: <br />\n     *  (<b>x</b> - <b>origin</b>) * <b>vector</b> = 0 <br />\n     * Ray defined by constructor is a right semi-infinite line with respect to the normal vector <br/>\n     * If normal vector is omitted ray is considered horizontal (normal vector is (0,1)). <br/>\n     * Don't be confused: direction of the normal vector is orthogonal to the ray <br/>\n     * @param {Point} pt - start point\n     * @param {Vector} norm - normal vector\n     */\n    constructor(...args) {\n        super();\n        this.pt = new Flatten.Point();\n        this.norm = new Flatten.Vector(0,1);\n\n        if (args.length === 0) {\n            return;\n        }\n\n        if (args.length >= 1 && args[0] instanceof Flatten.Point) {\n            this.pt = args[0].clone();\n        }\n\n        if (args.length === 1) {\n            return;\n        }\n\n        if (args.length === 2 && args[1] instanceof Flatten.Vector) {\n            this.norm = args[1].clone();\n            return;\n        }\n\n        throw Errors.ILLEGAL_PARAMETERS;\n    }\n\n    /**\n     * Return new cloned instance of ray\n     * @returns {Ray}\n     */\n    clone() {\n        return new Ray(this.pt, this.norm);\n    }\n\n    /**\n     * Slope of the ray - angle in radians between ray and axe x from 0 to 2PI\n     * @returns {number} - slope of the line\n     */\n    get slope() {\n        let vec = new Flatten.Vector(this.norm.y, -this.norm.x);\n        return vec.slope;\n    }\n\n    /**\n     * Returns half-infinite bounding box of the ray\n     * @returns {Box} - bounding box\n     */\n    get box() {\n        let slope = this.slope;\n        return new Flatten.Box(\n            slope > Math.PI/2 && slope < 3*Math.PI/2 ? Number.NEGATIVE_INFINITY : this.pt.x,\n            slope >= 0 && slope <= Math.PI ? this.pt.y : Number.NEGATIVE_INFINITY,\n            slope >= Math.PI/2 && slope <= 3*Math.PI/2 ? this.pt.x : Number.POSITIVE_INFINITY,\n            slope >= Math.PI && slope <= 2*Math.PI || slope === 0 ? this.pt.y : Number.POSITIVE_INFINITY\n        )\n    }\n\n    /**\n     * Return ray start point\n     * @returns {Point} - ray start point\n     */\n    get start() {\n        return this.pt;\n    }\n\n    /**\n     * Ray has no end point?\n     * @returns {undefined}\n     */\n    get end() {return undefined;}\n\n    /**\n     * Return positive infinity number as length\n     * @returns {number}\n     */\n    get length() {return Number.POSITIVE_INFINITY;}\n\n    /**\n     * Returns true if point belongs to ray\n     * @param {Point} pt Query point\n     * @returns {boolean}\n     */\n    contains(pt) {\n        if (this.pt.equalTo(pt)) {\n            return true;\n        }\n        /* Ray contains point if vector to point is orthogonal to the ray normal vector\n            and cross product from vector to point is positive */\n        let vec = new Flatten.Vector(this.pt, pt);\n        return Flatten.Utils.EQ_0(this.norm.dot(vec)) && Flatten.Utils.GE(vec.cross(this.norm),0);\n    }\n\n    /**\n     * Return coordinate of the point that lies on the ray in the transformed\n     * coordinate system where center is the projection of the point(0,0) to\n     * the line containing this ray and axe y is collinear to the normal vector. <br/>\n     * This method assumes that point lies on the ray\n     * @param {Point} pt - point on a ray\n     * @returns {number}\n     */\n    coord(pt) {\n        return vector$1(pt.x, pt.y).cross(this.norm);\n    }\n\n    /**\n     * Split ray with point and return array of segment and new ray\n     * @param {Point} pt\n     * @returns [Segment,Ray]\n     */\n    split(pt) {\n        if (!this.contains(pt))\n            return [];\n\n        if (this.pt.equalTo(pt)) {\n            return [this]\n        }\n\n        return [\n            new Flatten.Segment(this.pt, pt),\n            new Flatten.Ray(pt, this.norm)\n        ]\n    }\n\n    /**\n     * Returns array of intersection points between ray and another shape\n     * @param {Shape} shape - Shape to intersect with ray\n     * @returns {Point[]} array of intersection points\n     */\n    intersect(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.contains(shape) ? [shape] : [];\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return intersectRay2Segment(this, shape);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return intersectRay2Arc(this, shape);\n        }\n\n        if (shape instanceof Flatten.Line) {\n            return intersectRay2Line(this, shape);\n        }\n\n        if (shape instanceof Flatten.Ray) {\n            return intersectRay2Ray(this, shape)\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return intersectRay2Circle(this, shape);\n        }\n\n        if (shape instanceof Flatten.Box) {\n            return intersectRay2Box(this, shape);\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            return  intersectRay2Polygon(this, shape);\n        }\n    }\n\n    /**\n     * Return new line rotated by angle\n     * @param {number} angle - angle in radians\n     * @param {Point} center - center of rotation\n     */\n    rotate(angle, center = new Flatten.Point()) {\n        return new Flatten.Ray(\n            this.pt.rotate(angle, center),\n            this.norm.rotate(angle)\n        )\n    }\n\n    /**\n     * Return new ray transformed by affine transformation matrix\n     * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\n     * @returns {Ray}\n     */\n    transform(m) {\n        return new Flatten.Ray(\n            this.pt.transform(m),\n            this.norm.clone()\n        )\n    }\n\n    get name() {\n        return \"ray\"\n    }\n\n    /**\n     * Return string to draw svg segment representing ray inside given box\n     * @param {Box} box Box representing drawing area\n     * @param {Object} attrs - an object with attributes of svg segment element\n     */\n    svg(box, attrs = {}) {\n        let line = new Flatten.Line(this.pt, this.norm);\n        let ip = intersectLine2Box(line, box);\n        ip = ip.filter( pt => this.contains(pt) );\n        if (ip.length === 0 || ip.length === 2)\n            return \"\";\n        let segment = new Flatten.Segment(this.pt, ip[0]);\n        return segment.svg(attrs);\n    }\n\n}\n\nFlatten.Ray = Ray;\n\nconst ray = (...args) => new Flatten.Ray(...args);\nFlatten.ray = ray;\n\n/**\n * Created by Alex Bol on 3/15/2017.\n */\n\n\n/**\n * Class representing a polygon.<br/>\n * Polygon in FlattenJS is a multipolygon comprised from a set of [faces]{@link Flatten.Face}. <br/>\n * Face, in turn, is a closed loop of [edges]{@link Flatten.Edge}, where edge may be segment or circular arc<br/>\n * @type {Polygon}\n */\nclass Polygon {\n    /**\n     * Constructor creates new instance of polygon. With no arguments new polygon is empty.<br/>\n     * Constructor accepts as argument array that define loop of shapes\n     * or array of arrays in case of multi polygon <br/>\n     * Loop may be defined in different ways: <br/>\n     * - array of shapes of type Segment or Arc <br/>\n     * - array of points (Flatten.Point) <br/>\n     * - array of numeric pairs which represent points <br/>\n     * - box or circle object <br/>\n     * Alternatively, it is possible to use polygon.addFace method\n     * @param {args} - array of shapes or array of arrays\n     */\n    constructor() {\n        /**\n         * Container of faces (closed loops), may be empty\n         * @type {PlanarSet}\n         */\n        this.faces = new Flatten.PlanarSet();\n        /**\n         * Container of edges\n         * @type {PlanarSet}\n         */\n        this.edges = new Flatten.PlanarSet();\n\n        /* It may be array of something that may represent one loop (face) or\n         array of arrays that represent multiple loops\n         */\n        let args = [...arguments];\n        if (args.length === 1 &&\n            ((args[0] instanceof Array && args[0].length > 0) ||\n                args[0] instanceof Flatten.Circle || args[0] instanceof Flatten.Box)) {\n            let argsArray = args[0];\n            if (args[0] instanceof Array && args[0].every((loop) => {\n                return loop instanceof Array\n            })) {\n                if (argsArray.every(el => {\n                    return el instanceof Array && el.length === 2 && typeof (el[0]) === \"number\" && typeof (el[1]) === \"number\"\n                })) {\n                    this.faces.add(new Flatten.Face(this, argsArray));    // one-loop polygon as array of pairs of numbers\n                } else {\n                    for (let loop of argsArray) {   // multi-loop polygon\n                        /* Check extra level of nesting for GeoJSON-style multi polygons */\n                        if (loop instanceof Array && loop[0] instanceof Array &&\n                            loop[0].every(el => {\n                                return el instanceof Array && el.length === 2 && typeof (el[0]) === \"number\" && typeof (el[1]) === \"number\"\n                            })) {\n                            for (let loop1 of loop) {\n                                this.faces.add(new Flatten.Face(this, loop1));\n                            }\n                        } else {\n                            this.faces.add(new Flatten.Face(this, loop));\n                        }\n                    }\n                }\n            } else {\n                this.faces.add(new Flatten.Face(this, argsArray));    // one-loop polygon\n            }\n        }\n    }\n\n    /**\n     * (Getter) Returns bounding box of the polygon\n     * @returns {Box}\n     */\n    get box() {\n        return [...this.faces].reduce((acc, face) => acc.merge(face.box), new Flatten.Box());\n    }\n\n    /**\n     * (Getter) Returns array of vertices\n     * @returns {Array}\n     */\n    get vertices() {\n        return [...this.edges].map(edge => edge.start);\n    }\n\n    /**\n     * Create new cloned instance of the polygon\n     * @returns {Polygon}\n     */\n    clone() {\n        let polygon = new Polygon();\n        for (let face of this.faces) {\n            polygon.addFace(face.shapes);\n        }\n        return polygon;\n    }\n\n    /**\n     * Return true is polygon has no edges\n     * @returns {boolean}\n     */\n    isEmpty() {\n        return this.edges.size === 0;\n    }\n\n    /**\n     * Return true if polygon is valid for boolean operations\n     * Polygon is valid if <br/>\n     * 1. All faces are simple polygons (there are no self-intersected polygons) <br/>\n     * 2. All faces are orientable and there is no island inside island or hole inside hole - TODO <br/>\n     * 3. There is no intersections between faces (excluding touching) - TODO <br/>\n     * @returns {boolean}\n     */\n    isValid() {\n        let valid = true;\n        // 1. Polygon is invalid if at least one face is not simple\n        for (let face of this.faces) {\n            if (!face.isSimple(this.edges)) {\n                valid = false;\n                break;\n            }\n        }\n        // 2. TODO: check if no island inside island and no hole inside hole\n        // 3. TODO: check the there is no intersection between faces\n        return valid;\n    }\n\n    /**\n     * Returns area of the polygon. Area of an island will be added, area of a hole will be subtracted\n     * @returns {number}\n     */\n    area() {\n        let signedArea = [...this.faces].reduce((acc, face) => acc + face.signedArea(), 0);\n        return Math.abs(signedArea);\n    }\n\n    /**\n     * Add new face to polygon. Returns added face\n     * @param {Point[]|Segment[]|Arc[]|Circle|Box} args -  new face may be create with one of the following ways: <br/>\n     * 1) array of points that describe closed path (edges are segments) <br/>\n     * 2) array of shapes (segments and arcs) which describe closed path <br/>\n     * 3) circle - will be added as counterclockwise arc <br/>\n     * 4) box - will be added as counterclockwise rectangle <br/>\n     * You can chain method face.reverse() is you need to change direction of the creates face\n     * @returns {Face}\n     */\n    addFace(...args) {\n        let face = new Flatten.Face(this, ...args);\n        this.faces.add(face);\n        return face;\n    }\n\n    /**\n     * Delete existing face from polygon\n     * @param {Face} face Face to be deleted\n     * @returns {boolean}\n     */\n    deleteFace(face) {\n        for (let edge of face) {\n            this.edges.delete(edge);\n        }\n        return this.faces.delete(face);\n    }\n\n    /**\n     * Clear all faces and create new faces from edges\n     */\n    recreateFaces() {\n        // Remove all faces\n        this.faces.clear();\n        for (let edge of this.edges) {\n            edge.face = null;\n        }\n\n        // Restore faces\n        let first;\n        let unassignedEdgeFound = true;\n        while (unassignedEdgeFound) {\n            unassignedEdgeFound = false;\n            for (let edge of this.edges) {\n                if (edge.face === null) {\n                    first = edge;\n                    unassignedEdgeFound = true;\n                    break;\n                }\n            }\n\n            if (unassignedEdgeFound) {\n                let last = first;\n                do {\n                    last = last.next;\n                } while (last.next !== first)\n\n                this.addFace(first, last);\n            }\n        }\n    }\n\n    /**\n     * Delete chain of edges from the face.\n     * @param {Face} face Face to remove chain\n     * @param {Edge} edgeFrom Start of the chain of edges to be removed\n     * @param {Edge} edgeTo End of the chain of edges to be removed\n     */\n    removeChain(face, edgeFrom, edgeTo) {\n        // Special case: all edges removed\n        if (edgeTo.next === edgeFrom) {\n            this.deleteFace(face);\n            return;\n        }\n        for (let edge = edgeFrom; edge !== edgeTo.next; edge = edge.next) {\n            face.remove(edge);\n            this.edges.delete(edge);      // delete from PlanarSet of edges and update index\n            if (face.isEmpty()) {\n                this.deleteFace(face);    // delete from PlanarSet of faces and update index\n                break;\n            }\n        }\n    }\n\n    /**\n     * Add point as a new vertex and split edge. Point supposed to belong to an edge.\n     * When edge is split, new edge created from the start of the edge to the new vertex\n     * and inserted before current edge.\n     * Current edge is trimmed and updated.\n     * Method returns new edge added. If no edge added, it returns edge before vertex\n     * @param {Point} pt Point to be added as a new vertex\n     * @param {Edge} edge Edge to be split with new vertex and then trimmed from start\n     * @returns {Edge}\n     */\n    addVertex(pt, edge) {\n        let shapes = edge.shape.split(pt);\n        // if (shapes.length < 2) return;\n\n        if (shapes[0] === null)   // point incident to edge start vertex, return previous edge\n            return edge.prev;\n\n        if (shapes[1] === null)   // point incident to edge end vertex, return edge itself\n            return edge;\n\n        let newEdge = new Flatten.Edge(shapes[0]);\n        let edgeBefore = edge.prev;\n\n        /* Insert first split edge into linked list after edgeBefore */\n        edge.face.insert(newEdge, edgeBefore);\n\n        // Remove old edge from edges container and 2d index\n        this.edges.delete(edge);\n\n        // Insert new edge to the edges container and 2d index\n        this.edges.add(newEdge);\n\n        // Update edge shape with second split edge keeping links\n        edge.shape = shapes[1];\n\n        // Add updated edge to the edges container and 2d index\n        this.edges.add(edge);\n\n        return newEdge;\n    }\n\n    /**\n     * Merge given edge with next edge and remove vertex between them\n     * @param {Edge} edge\n     */\n    removeEndVertex(edge) {\n        const edge_next = edge.next;\n        if (edge_next === edge) return\n        edge.face.merge_with_next_edge(edge);\n        this.edges.delete(edge_next);\n    }\n\n    /**\n     * Cut polygon with multiline and return a new polygon\n     * @param {Multiline} multiline\n     * @returns {Polygon}\n     */\n    cut(multiline) {\n        let newPoly = this.clone();\n\n        // smart intersections\n        let intersections = {\n            int_points1: [],\n            int_points2: [],\n            int_points1_sorted: [],\n            int_points2_sorted: []\n        };\n\n        // intersect each edge of multiline with each edge of the polygon\n        // and create smart intersections\n        for (let edge1 of multiline.edges) {\n            for (let edge2 of newPoly.edges) {\n                let ip = intersectEdge2Edge(edge1, edge2);\n                // for each intersection point\n                for (let pt of ip) {\n                    addToIntPoints(edge1, pt, intersections.int_points1);\n                    addToIntPoints(edge2, pt, intersections.int_points2);\n                }\n            }\n        }\n\n        // No intersections - return a copy of the original polygon\n        if (intersections.int_points1.length === 0)\n            return newPoly;\n\n        // sort smart intersections\n        intersections.int_points1_sorted = getSortedArray(intersections.int_points1);\n        intersections.int_points2_sorted = getSortedArray(intersections.int_points2);\n\n        // split by intersection points\n        splitByIntersections(multiline, intersections.int_points1_sorted);\n        splitByIntersections(newPoly, intersections.int_points2_sorted);\n\n        // filter duplicated intersection points\n        filterDuplicatedIntersections(intersections);\n\n        // sort intersection points again after filtering\n        intersections.int_points1_sorted = getSortedArray(intersections.int_points1);\n        intersections.int_points2_sorted = getSortedArray(intersections.int_points2);\n\n        // initialize inclusion flags for edges of multiline incident to intersections\n        initializeInclusionFlags(intersections.int_points1);\n\n        // calculate inclusion flag for edges of multiline incident to intersections\n        calculateInclusionFlags(intersections.int_points1, newPoly);\n\n        // filter intersections between two edges that got same inclusion flag\n        for (let int_point1 of intersections.int_points1_sorted) {\n            if (int_point1.edge_before && int_point1.edge_after &&\n                int_point1.edge_before.bv === int_point1.edge_after.bv) {\n                intersections.int_points2[int_point1.id] = -1;   // to be filtered out\n                int_point1.id = -1;                              // to be filtered out\n            }\n        }\n        intersections.int_points1 = intersections.int_points1.filter( int_point => int_point.id >= 0);\n        intersections.int_points2 = intersections.int_points2.filter( int_point => int_point.id >= 0);\n\n        // No intersections left after filtering - return a copy of the original polygon\n        if (intersections.int_points1.length === 0)\n            return newPoly;\n\n        // sort intersection points 3d time after filtering\n        intersections.int_points1_sorted = getSortedArray(intersections.int_points1);\n        intersections.int_points2_sorted = getSortedArray(intersections.int_points2);\n\n        // Add new inner edges between intersection points\n        let int_point1_prev;\n        let int_point1_curr;\n        for (let i = 1; i <  intersections.int_points1_sorted.length; i++) {\n            int_point1_curr = intersections.int_points1_sorted[i];\n            int_point1_prev = intersections.int_points1_sorted[i-1];\n            if (int_point1_curr.edge_before && int_point1_curr.edge_before.bv === INSIDE$2) {\n                let edgeFrom = int_point1_prev.edge_after;\n                let edgeTo = int_point1_curr.edge_before;\n                let newEdges = multiline.getChain(edgeFrom, edgeTo);\n                insertBetweenIntPoints(intersections.int_points2[int_point1_prev.id], intersections.int_points2[int_point1_curr.id], newEdges);\n                newEdges.forEach(edge => newPoly.edges.add(edge));\n\n                newEdges = newEdges.reverse().map(edge => new Flatten.Edge(edge.shape.reverse()));\n                for (let k=0; k < newEdges.length-1; k++) {\n                    newEdges[k].next = newEdges[k+1];\n                    newEdges[k+1].prev = newEdges[k];\n                }\n                insertBetweenIntPoints(intersections.int_points2[int_point1_curr.id], intersections.int_points2[int_point1_prev.id], newEdges);\n                newEdges.forEach(edge => newPoly.edges.add(edge));\n            }\n\n        }\n\n        // Recreate faces\n        newPoly.recreateFaces();\n\n        return newPoly\n    }\n\n    /**\n     * A special case of cut() function\n     * The return is a polygon cut with line\n     * @param {Line} line - cutting line\n     * @returns {Polygon} newPoly - resulted polygon\n     */\n    cutWithLine(line) {\n        let multiline = new Multiline([line]);\n        return this.cut(multiline);\n    }\n\n    /**\n     * Returns the first found edge of polygon that contains given point\n     * If point is a vertex, return the edge where the point is an end vertex, not a start one\n     * @param {Point} pt\n     * @returns {Edge}\n     */\n    findEdgeByPoint(pt) {\n        let edge;\n        for (let face of this.faces) {\n            edge = face.findEdgeByPoint(pt);\n            if (edge !== undefined)\n                break;\n        }\n        return edge;\n    }\n\n    /**\n     * Split polygon into array of polygons, where each polygon is an outer face with all\n     * containing inner faces\n     * @returns {Flatten.Polygon[]}\n     */\n    splitToIslands() {\n        if (this.isEmpty()) return [];      // return empty array if polygon is empty\n        let polygons = this.toArray();      // split into array of one-loop polygons\n        /* Sort polygons by area in descending order */\n        polygons.sort((polygon1, polygon2) => polygon2.area() - polygon1.area());\n        /* define orientation of the island by orientation of the first polygon in array */\n        let orientation = [...polygons[0].faces][0].orientation();\n        /* Create output array from polygons with same orientation as a first polygon (array of islands) */\n        let newPolygons = polygons.filter(polygon => [...polygon.faces][0].orientation() === orientation);\n        for (let polygon of polygons) {\n            let face = [...polygon.faces][0];\n            if (face.orientation() === orientation) continue;  // skip same orientation\n            /* Proceed with opposite orientation */\n            /* Look if any of island polygons contains tested polygon as a hole */\n            for (let islandPolygon of newPolygons) {\n                if (face.shapes.every(shape => islandPolygon.contains(shape))) {\n                    islandPolygon.addFace(face.shapes);      // add polygon as a hole in islandPolygon\n                    break;\n                }\n            }\n        }\n        // TODO: assert if not all polygons added into output\n        return newPolygons;\n    }\n\n    /**\n     * Reverse orientation of all faces to opposite\n     * @returns {Polygon}\n     */\n    reverse() {\n        for (let face of this.faces) {\n            face.reverse();\n        }\n        return this;\n    }\n\n    /**\n     * Returns true if polygon contains shape: no point of shape lay outside of the polygon,\n     * false otherwise\n     * @param {Shape} shape - test shape\n     * @returns {boolean}\n     */\n    contains(shape) {\n        if (shape instanceof Flatten.Point) {\n            let rel = ray_shoot(this, shape);\n            return rel === INSIDE$2 || rel === BOUNDARY$1;\n        } else {\n            return cover(this, shape);\n        }\n    }\n\n    /**\n     * Return distance and shortest segment between polygon and other shape as array [distance, shortest_segment]\n     * @param {Shape} shape Shape of one of the types Point, Circle, Line, Segment, Arc or Polygon\n     * @returns {Number | Segment}\n     */\n    distanceTo(shape) {\n        // let {Distance} = Flatten;\n\n        if (shape instanceof Flatten.Point) {\n            let [dist, shortest_segment] = Flatten.Distance.point2polygon(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Circle ||\n            shape instanceof Flatten.Line ||\n            shape instanceof Flatten.Segment ||\n            shape instanceof Flatten.Arc) {\n            let [dist, shortest_segment] = Flatten.Distance.shape2polygon(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [dist, shortest_segment];\n        }\n\n        /* this method is bit faster */\n        if (shape instanceof Flatten.Polygon) {\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\n            let dist, shortest_segment;\n\n            for (let edge of this.edges) {\n                // let [dist, shortest_segment] = Distance.shape2polygon(edge.shape, shape);\n                let min_stop = min_dist_and_segment[0];\n                [dist, shortest_segment] = Flatten.Distance.shape2planarSet(edge.shape, shape.edges, min_stop);\n                if (Flatten.Utils.LT(dist, min_stop)) {\n                    min_dist_and_segment = [dist, shortest_segment];\n                }\n            }\n            return min_dist_and_segment;\n        }\n    }\n\n    /**\n     * Return array of intersection points between polygon and other shape\n     * @param shape Shape of the one of supported types <br/>\n     * @returns {Point[]}\n     */\n    intersect(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.contains(shape) ? [shape] : [];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            return intersectLine2Polygon(shape, this);\n        }\n\n        if (shape instanceof Flatten.Ray) {\n            return intersectRay2Polygon(shape, this);\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return intersectCircle2Polygon(shape, this);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return intersectSegment2Polygon(shape, this);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return intersectArc2Polygon(shape, this);\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            return intersectPolygon2Polygon(shape, this);\n        }\n    }\n\n    /**\n     * Returns new polygon translated by vector vec\n     * @param {Vector} vec\n     * @returns {Polygon}\n     */\n    translate(vec) {\n        let newPolygon = new Polygon();\n        for (let face of this.faces) {\n            newPolygon.addFace(face.shapes.map(shape => shape.translate(vec)));\n        }\n        return newPolygon;\n    }\n\n    /**\n     * Return new polygon rotated by given angle around given point\n     * If point omitted, rotate around origin (0,0)\n     * Positive value of angle defines rotation counterclockwise, negative - clockwise\n     * @param {number} angle - rotation angle in radians\n     * @param {Point} center - rotation center, default is (0,0)\n     * @returns {Polygon} - new rotated polygon\n     */\n    rotate(angle = 0, center = new Flatten.Point()) {\n        let newPolygon = new Polygon();\n        for (let face of this.faces) {\n            newPolygon.addFace(face.shapes.map(shape => shape.rotate(angle, center)));\n        }\n        return newPolygon;\n    }\n\n    /**\n     * Return new polygon with coordinates multiplied by scaling factor\n     * @param {number} sx - x-axis scaling factor\n     * @param {number} sy - y-axis scaling factor\n     * @returns {Polygon}\n     */\n    scale(sx, sy) {\n        let newPolygon = new Polygon();\n        for (let face of this.faces) {\n            newPolygon.addFace(face.shapes.map(shape => shape.scale(sx, sy)));\n        }\n        return newPolygon;\n    }\n\n    /**\n     * Return new polygon transformed using affine transformation matrix\n     * @param {Matrix} matrix - affine transformation matrix\n     * @returns {Polygon} - new polygon\n     */\n    transform(matrix = new Flatten.Matrix()) {\n        let newPolygon = new Polygon();\n        for (let face of this.faces) {\n            newPolygon.addFace(face.shapes.map(shape => shape.transform(matrix)));\n        }\n        return newPolygon;\n    }\n\n    /**\n     * This method returns an object that defines how data will be\n     * serialized when called JSON.stringify() method\n     * @returns {Object}\n     */\n    toJSON() {\n        return [...this.faces].map(face => face.toJSON());\n    }\n\n    /**\n     * Transform all faces into array of polygons\n     * @returns {Flatten.Polygon[]}\n     */\n    toArray() {\n        return [...this.faces].map(face => face.toPolygon());\n    }\n\n    /**\n     * Return string to draw polygon in svg\n     * @param attrs  - an object with attributes for svg path element\n     * @returns {string}\n     */\n    svg(attrs = {}) {\n        let svgStr = `\\n<path ${convertToString({fillRule: \"evenodd\", fill: \"lightcyan\", ...attrs})} d=\"`;\n        for (let face of this.faces) {\n            svgStr += face.svg();\n        }\n        svgStr += `\" >\\n</path>`;\n        return svgStr;\n    }\n}\n\nFlatten.Polygon = Polygon;\n\n/**\n * Shortcut method to create new polygon\n */\nconst polygon = (...args) => new Flatten.Polygon(...args);\nFlatten.polygon = polygon;\n\nconst {Circle, Line, Point, Vector, Utils} = Flatten;\n/**\n * Class Inversion represent operator of inversion in circle\n * Inversion is a transformation of the Euclidean plane that maps generalized circles\n * (where line is considered as a circle with infinite radius) into generalized circles\n * See also https://en.wikipedia.org/wiki/Inversive_geometry and\n * http://mathworld.wolfram.com/Inversion.html <br/>\n * @type {Inversion}\n */\nclass Inversion {\n    /**\n     * Inversion constructor\n     * @param {Circle} inversion_circle inversion circle\n     */\n    constructor(inversion_circle) {\n        this.circle = inversion_circle;\n    }\n\n\n    get inversion_circle() {\n        return this.circle;\n    }\n\n    static inversePoint(inversion_circle, point) {\n        const v = new Vector(inversion_circle.pc, point);\n        const k2 = inversion_circle.r * inversion_circle.r;\n        const len2 = v.dot(v);\n        const reflected_point = Utils.EQ_0(len2) ?\n            new Point(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY) :\n            inversion_circle.pc.translate(v.multiply(k2 / len2));\n        return reflected_point;\n    }\n\n    static inverseCircle(inversion_circle, circle) {\n        const dist = inversion_circle.pc.distanceTo(circle.pc)[0];\n        if (Utils.EQ(dist, circle.r)) {     // Circle passing through inversion center mapped into line\n            let d = (inversion_circle.r * inversion_circle.r) / (2 * circle.r);\n            let v = new Vector(inversion_circle.pc, circle.pc);\n            v = v.normalize();\n            let pt = inversion_circle.pc.translate(v.multiply(d));\n\n            return new Line(pt, v);\n        } else {                           // Circle not passing through inversion center - map into another circle */\n            /* Taken from http://mathworld.wolfram.com */\n            let v = new Vector(inversion_circle.pc, circle.pc);\n            let s = inversion_circle.r * inversion_circle.r / (v.dot(v) - circle.r * circle.r);\n            let pc = inversion_circle.pc.translate(v.multiply(s));\n            let r = Math.abs(s) * circle.r;\n\n            return new Circle(pc, r);\n        }\n    }\n\n    static inverseLine(inversion_circle, line) {\n        const [dist, shortest_segment] = inversion_circle.pc.distanceTo(line);\n        if (Utils.EQ_0(dist)) {            // Line passing through inversion center, is mapping to itself\n            return line.clone();\n        } else {                           // Line not passing through inversion center is mapping into circle\n            let r = inversion_circle.r * inversion_circle.r / (2 * dist);\n            let v = new Vector(inversion_circle.pc, shortest_segment.end);\n            v = v.multiply(r / dist);\n            return new Circle(inversion_circle.pc.translate(v), r);\n        }\n    }\n\n    inverse(shape) {\n        if (shape instanceof Point) {\n            return Inversion.inversePoint(this.circle, shape);\n        }\n        else if (shape instanceof Circle) {\n            return Inversion.inverseCircle(this.circle, shape);\n        }\n        else if (shape instanceof Line) {\n            return Inversion.inverseLine(this.circle, shape);\n        }\n    }\n}\nFlatten.Inversion = Inversion;\n\n/**\n * Shortcut to create inversion operator\n * @param circle\n * @returns {Inversion}\n */\nconst inversion = (circle) => new Flatten.Inversion(circle);\nFlatten.inversion = inversion;\n\nclass Distance {\n    /**\n     * Calculate distance and shortest segment between points\n     * @param pt1\n     * @param pt2\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static point2point(pt1, pt2) {\n        return pt1.distanceTo(pt2);\n    }\n\n    /**\n     * Calculate distance and shortest segment between point and line\n     * @param pt\n     * @param line\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static point2line(pt, line) {\n        let closest_point = pt.projectionOn(line);\n        let vec = new Flatten.Vector(pt, closest_point);\n        return [vec.length, new Flatten.Segment(pt, closest_point)];\n    }\n\n    /**\n     * Calculate distance and shortest segment between point and circle\n     * @param pt\n     * @param circle\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static point2circle(pt, circle) {\n        let [dist2center, shortest_dist] = pt.distanceTo(circle.center);\n        if (Flatten.Utils.EQ_0(dist2center)) {\n            return [circle.r, new Flatten.Segment(pt, circle.toArc().start)];\n        } else {\n            let dist = Math.abs(dist2center - circle.r);\n            let v = new Flatten.Vector(circle.pc, pt).normalize().multiply(circle.r);\n            let closest_point = circle.pc.translate(v);\n            return [dist, new Flatten.Segment(pt, closest_point)];\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment between point and segment\n     * @param pt\n     * @param segment\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static point2segment(pt, segment) {\n        /* Degenerated case of zero-length segment */\n        if (segment.start.equalTo(segment.end)) {\n            return Distance.point2point(pt, segment.start);\n        }\n\n        let v_seg = new Flatten.Vector(segment.start, segment.end);\n        let v_ps2pt = new Flatten.Vector(segment.start, pt);\n        let v_pe2pt = new Flatten.Vector(segment.end, pt);\n        let start_sp = v_seg.dot(v_ps2pt);\n        /* dot product v_seg * v_ps2pt */\n        let end_sp = -v_seg.dot(v_pe2pt);\n        /* minus dot product v_seg * v_pe2pt */\n\n        let dist;\n        let closest_point;\n        if (Flatten.Utils.GE(start_sp, 0) && Flatten.Utils.GE(end_sp, 0)) {    /* point inside segment scope */\n            let v_unit = segment.tangentInStart(); // new Flatten.Vector(v_seg.x / this.length, v_seg.y / this.length);\n            /* unit vector ||v_unit|| = 1 */\n            dist = Math.abs(v_unit.cross(v_ps2pt));\n            /* dist = abs(v_unit x v_ps2pt) */\n            closest_point = segment.start.translate(v_unit.multiply(v_unit.dot(v_ps2pt)));\n            return [dist, new Flatten.Segment(pt, closest_point)];\n        } else if (start_sp < 0) {                             /* point is out of scope closer to ps */\n            return pt.distanceTo(segment.start);\n        } else {                                               /* point is out of scope closer to pe */\n            return pt.distanceTo(segment.end);\n        }\n    };\n\n    /**\n     * Calculate distance and shortest segment between point and arc\n     * @param pt\n     * @param arc\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static point2arc(pt, arc) {\n        let circle = new Flatten.Circle(arc.pc, arc.r);\n        let dist_and_segment = [];\n        let dist, shortest_segment;\n        [dist, shortest_segment] = Distance.point2circle(pt, circle);\n        if (shortest_segment.end.on(arc)) {\n            dist_and_segment.push(Distance.point2circle(pt, circle));\n        }\n        dist_and_segment.push(Distance.point2point(pt, arc.start));\n        dist_and_segment.push(Distance.point2point(pt, arc.end));\n\n        Distance.sort(dist_and_segment);\n\n        return dist_and_segment[0];\n    }\n\n    /**\n     * Calculate distance and shortest segment between segment and line\n     * @param seg\n     * @param line\n     * @returns {Number | Segment}\n     */\n    static segment2line(seg, line) {\n        let ip = seg.intersect(line);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];   // distance = 0, closest point is the first point\n        }\n        let dist_and_segment = [];\n        dist_and_segment.push(Distance.point2line(seg.start, line));\n        dist_and_segment.push(Distance.point2line(seg.end, line));\n\n        Distance.sort(dist_and_segment);\n        return dist_and_segment[0];\n\n    }\n\n    /**\n     * Calculate distance and shortest segment between two segments\n     * @param seg1\n     * @param seg2\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static segment2segment(seg1, seg2) {\n        let ip = intersectSegment2Segment(seg1, seg2);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];   // distance = 0, closest point is the first point\n        }\n\n        // Seg1 and seg2 not intersected\n        let dist_and_segment = [];\n        let dist_tmp, shortest_segment_tmp;\n        [dist_tmp, shortest_segment_tmp] = Distance.point2segment(seg2.start, seg1);\n        dist_and_segment.push([dist_tmp, shortest_segment_tmp.reverse()]);\n        [dist_tmp, shortest_segment_tmp] = Distance.point2segment(seg2.end, seg1);\n        dist_and_segment.push([dist_tmp, shortest_segment_tmp.reverse()]);\n        dist_and_segment.push(Distance.point2segment(seg1.start, seg2));\n        dist_and_segment.push(Distance.point2segment(seg1.end, seg2));\n\n        Distance.sort(dist_and_segment);\n        return dist_and_segment[0];\n    }\n\n    /**\n     * Calculate distance and shortest segment between segment and circle\n     * @param seg\n     * @param circle\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static segment2circle(seg, circle) {\n        /* Case 1 Segment and circle intersected. Return the first point and zero distance */\n        let ip = seg.intersect(circle);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        // No intersection between segment and circle\n\n        /* Case 2. Distance to projection of center point to line bigger than radius\n         * And projection point belong to segment\n          * Then measure again distance from projection to circle and return it */\n        let line = new Flatten.Line(seg.ps, seg.pe);\n        let [dist, shortest_segment] = Distance.point2line(circle.center, line);\n        if (Flatten.Utils.GE(dist, circle.r) && shortest_segment.end.on(seg)) {\n            return Distance.point2circle(shortest_segment.end, circle);\n        }\n        /* Case 3. Otherwise closest point is one of the end points of the segment */\n        else {\n            let [dist_from_start, shortest_segment_from_start] = Distance.point2circle(seg.start, circle);\n            let [dist_from_end, shortest_segment_from_end] = Distance.point2circle(seg.end, circle);\n            return Flatten.Utils.LT(dist_from_start, dist_from_end) ?\n                [dist_from_start, shortest_segment_from_start] :\n                [dist_from_end, shortest_segment_from_end];\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment between segment and arc\n     * @param seg\n     * @param arc\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static segment2arc(seg, arc) {\n        /* Case 1 Segment and arc intersected. Return the first point and zero distance */\n        let ip = seg.intersect(arc);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        // No intersection between segment and arc\n        let line = new Flatten.Line(seg.ps, seg.pe);\n        let circle = new Flatten.Circle(arc.pc, arc.r);\n\n        /* Case 2. Distance to projection of center point to line bigger than radius AND\n         * projection point belongs to segment AND\n           * distance from projection point to circle belongs to arc  =>\n           * return this distance from projection to circle */\n        let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\n        if (Flatten.Utils.GE(dist_from_center, circle.r) && shortest_segment_from_center.end.on(seg)) {\n            let [dist_from_projection, shortest_segment_from_projection] =\n                Distance.point2circle(shortest_segment_from_center.end, circle);\n            if (shortest_segment_from_projection.end.on(arc)) {\n                return [dist_from_projection, shortest_segment_from_projection];\n            }\n        }\n        /* Case 3. Otherwise closest point is one of the end points of the segment */\n        let dist_and_segment = [];\n        dist_and_segment.push(Distance.point2arc(seg.start, arc));\n        dist_and_segment.push(Distance.point2arc(seg.end, arc));\n\n        let dist_tmp, segment_tmp;\n        [dist_tmp, segment_tmp] = Distance.point2segment(arc.start, seg);\n        dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\n\n        [dist_tmp, segment_tmp] = Distance.point2segment(arc.end, seg);\n        dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\n\n        Distance.sort(dist_and_segment);\n        return dist_and_segment[0];\n    }\n\n    /**\n     * Calculate distance and shortest segment between two circles\n     * @param circle1\n     * @param circle2\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static circle2circle(circle1, circle2) {\n        let ip = circle1.intersect(circle2);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        // Case 1. Concentric circles. Convert to arcs and take distance between two arc starts\n        if (circle1.center.equalTo(circle2.center)) {\n            let arc1 = circle1.toArc();\n            let arc2 = circle2.toArc();\n            return Distance.point2point(arc1.start, arc2.start);\n        } else {\n            // Case 2. Not concentric circles\n            let line = new Flatten.Line(circle1.center, circle2.center);\n            let ip1 = line.intersect(circle1);\n            let ip2 = line.intersect(circle2);\n\n            let dist_and_segment = [];\n\n            dist_and_segment.push(Distance.point2point(ip1[0], ip2[0]));\n            dist_and_segment.push(Distance.point2point(ip1[0], ip2[1]));\n            dist_and_segment.push(Distance.point2point(ip1[1], ip2[0]));\n            dist_and_segment.push(Distance.point2point(ip1[1], ip2[1]));\n\n            Distance.sort(dist_and_segment);\n            return dist_and_segment[0];\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment between two circles\n     * @param circle\n     * @param line\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static circle2line(circle, line) {\n        let ip = circle.intersect(line);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\n        let [dist, shortest_segment] = Distance.point2circle(shortest_segment_from_center.end, circle);\n        shortest_segment = shortest_segment.reverse();\n        return [dist, shortest_segment];\n    }\n\n    /**\n     * Calculate distance and shortest segment between arc and line\n     * @param arc\n     * @param line\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static arc2line(arc, line) {\n        /* Case 1 Line and arc intersected. Return the first point and zero distance */\n        let ip = line.intersect(arc);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        let circle = new Flatten.Circle(arc.center, arc.r);\n\n        /* Case 2. Distance to projection of center point to line bigger than radius AND\n         * projection point belongs to segment AND\n           * distance from projection point to circle belongs to arc  =>\n           * return this distance from projection to circle */\n        let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\n        if (Flatten.Utils.GE(dist_from_center, circle.r)) {\n            let [dist_from_projection, shortest_segment_from_projection] =\n                Distance.point2circle(shortest_segment_from_center.end, circle);\n            if (shortest_segment_from_projection.end.on(arc)) {\n                return [dist_from_projection, shortest_segment_from_projection];\n            }\n        } else {\n            let dist_and_segment = [];\n            dist_and_segment.push(Distance.point2line(arc.start, line));\n            dist_and_segment.push(Distance.point2line(arc.end, line));\n\n            Distance.sort(dist_and_segment);\n            return dist_and_segment[0];\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment between arc and circle\n     * @param arc\n     * @param circle2\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static arc2circle(arc, circle2) {\n        let ip = arc.intersect(circle2);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        let circle1 = new Flatten.Circle(arc.center, arc.r);\n\n        let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);\n        if (shortest_segment.start.on(arc)) {\n            return [dist, shortest_segment];\n        } else {\n            let dist_and_segment = [];\n\n            dist_and_segment.push(Distance.point2circle(arc.start, circle2));\n            dist_and_segment.push(Distance.point2circle(arc.end, circle2));\n\n            Distance.sort(dist_and_segment);\n\n            return dist_and_segment[0];\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment between two arcs\n     * @param arc1\n     * @param arc2\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static arc2arc(arc1, arc2) {\n        let ip = arc1.intersect(arc2);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        let circle1 = new Flatten.Circle(arc1.center, arc1.r);\n        let circle2 = new Flatten.Circle(arc2.center, arc2.r);\n\n        let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);\n        if (shortest_segment.start.on(arc1) && shortest_segment.end.on(arc2)) {\n            return [dist, shortest_segment];\n        } else {\n            let dist_and_segment = [];\n\n            let dist_tmp, segment_tmp;\n\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc1.start, arc2);\n            if (segment_tmp.end.on(arc2)) {\n                dist_and_segment.push([dist_tmp, segment_tmp]);\n            }\n\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc1.end, arc2);\n            if (segment_tmp.end.on(arc2)) {\n                dist_and_segment.push([dist_tmp, segment_tmp]);\n            }\n\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc2.start, arc1);\n            if (segment_tmp.end.on(arc1)) {\n                dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\n            }\n\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc2.end, arc1);\n            if (segment_tmp.end.on(arc1)) {\n                dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\n            }\n\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.start);\n            dist_and_segment.push([dist_tmp, segment_tmp]);\n\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.end);\n            dist_and_segment.push([dist_tmp, segment_tmp]);\n\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.start);\n            dist_and_segment.push([dist_tmp, segment_tmp]);\n\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.end);\n            dist_and_segment.push([dist_tmp, segment_tmp]);\n\n            Distance.sort(dist_and_segment);\n\n            return dist_and_segment[0];\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment between point and polygon\n     * @param point\n     * @param polygon\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static point2polygon(point, polygon) {\n        let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\n        for (let edge of polygon.edges) {\n            let [dist, shortest_segment] = (edge.shape instanceof Flatten.Segment) ?\n                Distance.point2segment(point, edge.shape) : Distance.point2arc(point, edge.shape);\n            if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\n                min_dist_and_segment = [dist, shortest_segment];\n            }\n        }\n        return min_dist_and_segment;\n    }\n\n    static shape2polygon(shape, polygon) {\n        let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\n        for (let edge of polygon.edges) {\n            let [dist, shortest_segment] = shape.distanceTo(edge.shape);\n            if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\n                min_dist_and_segment = [dist, shortest_segment];\n            }\n        }\n        return min_dist_and_segment;\n    }\n\n    /**\n     * Calculate distance and shortest segment between two polygons\n     * @param polygon1\n     * @param polygon2\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static polygon2polygon(polygon1, polygon2) {\n        let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\n        for (let edge1 of polygon1.edges) {\n            for (let edge2 of polygon2.edges) {\n                let [dist, shortest_segment] = edge1.shape.distanceTo(edge2.shape);\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\n                    min_dist_and_segment = [dist, shortest_segment];\n                }\n            }\n        }\n        return min_dist_and_segment;\n    }\n\n    /**\n     * Returns [mindist, maxdist] array of squared minimal and maximal distance between boxes\n     * Minimal distance by x is\n     *    (box2.xmin - box1.xmax), if box1 is left to box2\n     *    (box1.xmin - box2.xmax), if box2 is left to box1\n     *    0,                       if box1 and box2 are intersected by x\n     * Minimal distance by y is defined in the same way\n     *\n     * Maximal distance is estimated as a sum of squared dimensions of the merged box\n     *\n     * @param box1\n     * @param box2\n     * @returns {Number | Number} - minimal and maximal distance\n     */\n    static box2box_minmax(box1, box2) {\n        let mindist_x = Math.max(Math.max(box1.xmin - box2.xmax, 0), Math.max(box2.xmin - box1.xmax, 0));\n        let mindist_y = Math.max(Math.max(box1.ymin - box2.ymax, 0), Math.max(box2.ymin - box1.ymax, 0));\n        let mindist = mindist_x * mindist_x + mindist_y * mindist_y;\n\n        let box = box1.merge(box2);\n        let dx = box.xmax - box.xmin;\n        let dy = box.ymax - box.ymin;\n        let maxdist = dx * dx + dy * dy;\n\n        return [mindist, maxdist];\n    }\n\n    static minmax_tree_process_level(shape, level, min_stop, tree) {\n        // Calculate minmax distance to each shape in current level\n        // Insert result into the interval tree for further processing\n        // update min_stop with maxdist, it will be the new stop distance\n        let mindist, maxdist;\n        for (let node of level) {\n\n            // [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\n            // if (Flatten.Utils.GT(mindist, min_stop))\n            //     continue;\n\n            // Estimate min-max dist to the shape stored in the node.item, using node.item.key which is shape's box\n            [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.item.key);\n            if (node.item.value instanceof Flatten.Edge) {\n                tree.insert([mindist, maxdist], node.item.value.shape);\n            } else {\n                tree.insert([mindist, maxdist], node.item.value);\n            }\n            if (Flatten.Utils.LT(maxdist, min_stop)) {\n                min_stop = maxdist;                       // this will be the new distance estimation\n            }\n        }\n\n        if (level.length === 0)\n            return min_stop;\n\n        // Calculate new level from left and right children of the current\n        let new_level_left = level.map(node => node.left.isNil() ? undefined : node.left).filter(node => node !== undefined);\n        let new_level_right = level.map(node => node.right.isNil() ? undefined : node.right).filter(node => node !== undefined);\n        // Merge left and right subtrees and leave only relevant subtrees\n        let new_level = [...new_level_left, ...new_level_right].filter(node => {\n            // Node subtree quick reject, node.max is a subtree box\n            let [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\n            return (Flatten.Utils.LE(mindist, min_stop));\n        });\n\n        min_stop = Distance.minmax_tree_process_level(shape, new_level, min_stop, tree);\n        return min_stop;\n    }\n\n    /**\n     * Calculates sorted tree of [mindist, maxdist] intervals between query shape\n     * and shapes of the planar set.\n     * @param shape\n     * @param set\n     */\n    static minmax_tree(shape, set, min_stop) {\n        let tree = new IntervalTree();\n        let level = [set.index.root];\n        let squared_min_stop = min_stop < Number.POSITIVE_INFINITY ? min_stop * min_stop : Number.POSITIVE_INFINITY;\n        squared_min_stop = Distance.minmax_tree_process_level(shape, level, squared_min_stop, tree);\n        return tree;\n    }\n\n    static minmax_tree_calc_distance(shape, node, min_dist_and_segment) {\n        let min_dist_and_segment_new, stop;\n        if (node != null && !node.isNil()) {\n            [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.left, min_dist_and_segment);\n\n            if (stop) {\n                return [min_dist_and_segment_new, stop];\n            }\n\n            if (Flatten.Utils.LT(min_dist_and_segment_new[0], Math.sqrt(node.item.key.low))) {\n                return [min_dist_and_segment_new, true];   // stop condition\n            }\n\n            let [dist, shortest_segment] = Distance.distance(shape, node.item.value);\n            // console.log(dist)\n            if (Flatten.Utils.LT(dist, min_dist_and_segment_new[0])) {\n                min_dist_and_segment_new = [dist, shortest_segment];\n            }\n\n            [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.right, min_dist_and_segment_new);\n\n            return [min_dist_and_segment_new, stop];\n        }\n\n        return [min_dist_and_segment, false];\n    }\n\n    /**\n     * Calculates distance between shape and Planar Set of shapes\n     * @param shape\n     * @param {PlanarSet} set\n     * @param {Number} min_stop\n     * @returns {*}\n     */\n    static shape2planarSet(shape, set, min_stop = Number.POSITIVE_INFINITY) {\n        let min_dist_and_segment = [min_stop, new Flatten.Segment()];\n        let stop = false;\n        if (set instanceof Flatten.PlanarSet) {\n            let tree = Distance.minmax_tree(shape, set, min_stop);\n            [min_dist_and_segment, stop] = Distance.minmax_tree_calc_distance(shape, tree.root, min_dist_and_segment);\n        }\n        return min_dist_and_segment;\n    }\n\n    static sort(dist_and_segment) {\n        dist_and_segment.sort((d1, d2) => {\n            if (Flatten.Utils.LT(d1[0], d2[0])) {\n                return -1;\n            }\n            if (Flatten.Utils.GT(d1[0], d2[0])) {\n                return 1;\n            }\n            return 0;\n        });\n    }\n\n    static distance(shape1, shape2) {\n        return shape1.distanceTo(shape2);\n    }\n}\n\nFlatten.Distance = Distance;\n\n/**\n * Created by Alex Bol on 2/18/2017.\n */\n\n\nFlatten.BooleanOperations = BooleanOperations;\nFlatten.Relations = Relations;\n\nexport { Arc, BOUNDARY$1 as BOUNDARY, BooleanOperations, Box, CCW, CW, Circle$1 as Circle, Distance, Edge, Errors, Face, INSIDE$2 as INSIDE, Inversion, Line$1 as Line, Matrix, Multiline, ORIENTATION, OUTSIDE$1 as OUTSIDE, OVERLAP_OPPOSITE$1 as OVERLAP_OPPOSITE, OVERLAP_SAME$1 as OVERLAP_SAME, PlanarSet, Point$1 as Point, Polygon, Ray, Relations, Segment, smart_intersections as SmartIntersections, Utils$1 as Utils, Vector$1 as Vector, arc, box, circle, Flatten as default, inversion, line, matrix, multiline, point, polygon, ray, ray_shoot, segment, vector$1 as vector };\n","import type {LatLngExpression} from 'leaflet';\nimport L, {Bounds, LatLng, LatLngBounds, Path, Point, Util} from 'leaflet';\nimport Flatten from '@flatten-js/core';\nimport Matrix = Flatten.Matrix;\nimport type {Points, Shape, ShapeSet, Units} from './types';\nimport type {ShapeOptions, TrackSymbolOptions} from './options';\n\nconst DEFAULT_SIZE = 24;\nconst DEFAULT_LEADER_TIME = 60;\n\n/**\n * Track symbol.\n */\nexport class TrackSymbol\n    extends Path {\n\n    /** Default 'withHeading' shape points. */\n    public static DEFAULT_HEADING_SHAPE_POINTS: Points = [[0.75, 0], [-0.25, 0.3], [-0.25, -0.3]];\n\n    /** Default 'withoutHeading' shape points. */\n    public static DEFAULT_NOHEADING_SHAPE_POINTS: Points = [[0.3, 0], [0, 0.3], [-0.3, 0], [0, -0.3]];\n\n    /** Default shape set. */\n    private static DEFAULT_SHAPE_SET: ShapeSet = {\n        withHeading: {\n            points: TrackSymbol.DEFAULT_HEADING_SHAPE_POINTS,\n            length: DEFAULT_SIZE,\n            breadth: DEFAULT_SIZE,\n            units: \"pixels\",\n        },\n        withoutHeading: {\n            points: TrackSymbol.DEFAULT_NOHEADING_SHAPE_POINTS,\n            length: DEFAULT_SIZE,\n            breadth: DEFAULT_SIZE,\n            units: \"pixels\",\n        },\n    };\n\n    /** Location. */\n    private _latLng: LatLng;\n    /** Heading (radians, from north, clockwise. */\n    private _heading?: number;\n    /** Course (radians, from north, clockwise. */\n    private _course?: number;\n    /** Speed (m/s). */\n    private _speed?: number;\n    /** Shape options. */\n    private _shapeOptions: ShapeOptions;\n\n    /** Current shape points. */\n    private _currentShapePoints: Point[] | undefined;\n    /** Current leader points. */\n    private _currentLeaderPoints: Point[] | undefined;\n    /** Current bounds. */\n    private _currentBounds: Bounds | undefined;\n    /** Current lat/lng bounds. */\n    private _currentLatLngBounds: LatLngBounds | undefined;\n\n    /**\n     * TrackSymbol constructor.\n     *\n     * @param latLng - Initial location.\n     * @param options - Options.\n     */\n    constructor(latLng: LatLngExpression, options?: TrackSymbolOptions) {\n        super();\n\n        Util.setOptions(this, options);\n        if (latLng == undefined) {\n            throw Error(\"latLng required\");\n        }\n        options = options || {};\n        this._latLng = L.latLng(latLng);\n        this._heading = options.heading;\n        this._course = options.course;\n        this._speed = options.speed;\n        this._shapeOptions = options.shapeOptions || {\n            leaderTime: DEFAULT_LEADER_TIME,\n            defaultShapeSet: TrackSymbol.DEFAULT_SHAPE_SET,\n        };\n        this._setShapeOptions(options.shapeOptions);\n    }\n\n    // ---- Leaflet\n\n    /**\n     * Project to layer.\n     *\n     * [Leaflet internal]\n     */\n    protected _project() {\n        this._currentShapePoints = this._getProjectedShapePoints();\n        this._currentLeaderPoints = this._getLeaderShapePoints();\n\n        const bounds = new Bounds();\n        for (let i = 0; i < this._currentShapePoints.length; i++) {\n            const point = this._currentShapePoints[i];\n            bounds.extend(point);\n        }\n        if (this._currentLeaderPoints !== undefined) {\n            for (let i = 0; i < this._currentLeaderPoints.length; i++) {\n                const point = this._currentShapePoints[i];\n                bounds.extend(point);\n            }\n        }\n        this._currentBounds = bounds;\n        this._currentLatLngBounds = new LatLngBounds(\n            this._map.layerPointToLatLng(bounds.getBottomLeft()),\n            this._map.layerPointToLatLng(bounds.getTopRight())\n        );\n    }\n\n    /**\n     * Update element.\n     *\n     * [Leaflet internal]\n     */\n    protected _update() {\n        if (!this._map) {\n            return;\n        }\n        const el = this.getElement();\n        if (el === undefined) {\n            return;\n        }\n        const paths: string[] = [];\n        if (this._currentShapePoints !== undefined) {\n            paths.push(TrackSymbol._toSVGPath(this._currentShapePoints, true));\n        }\n        if (this._currentLeaderPoints !== undefined) {\n            paths.push(TrackSymbol._toSVGPath(this._currentLeaderPoints, false));\n        }\n        const viewPath = paths.join(' ');\n        el.setAttribute('d', viewPath);\n    }\n\n    // ----\n\n    /**\n     * Set shape options.\n     *\n     * @param shapeOptions - Shape options.\n     */\n    private _setShapeOptions(shapeOptions: ShapeOptions | undefined) {\n        this._shapeOptions = shapeOptions || {\n            leaderTime: DEFAULT_LEADER_TIME,\n            defaultShapeSet: TrackSymbol.DEFAULT_SHAPE_SET,\n        };\n        if (this._shapeOptions.leaderTime === undefined) {\n            this._shapeOptions.leaderTime = DEFAULT_LEADER_TIME;\n        }\n        if (this._shapeOptions.defaultShapeSet === undefined) {\n            this._shapeOptions.defaultShapeSet = TrackSymbol.DEFAULT_SHAPE_SET;\n        }\n        if (this._shapeOptions.shapeSetEntries !== undefined) {\n            this._shapeOptions.shapeSetEntries\n                .sort((a, b) => b.minZoomLevel - a.minZoomLevel);\n        }\n    }\n\n    // ---\n\n    /**\n     * Sets the location.\n     *\n     * @param latLng - Location.\n     * @returns this\n     */\n    public setLatLng(latLng: LatLngExpression): this {\n        const oldLatLng = this._latLng;\n        this._latLng = L.latLng(latLng);\n        this.fire('move', {\n            oldLatLng: oldLatLng,\n            latlng: this._latLng,\n        });\n        return this.redraw();\n    }\n\n    /**\n     * Sets the heading.\n     *\n     * @param heading - Heading (unit: radians, from north, clockwise).\n     * @returns this\n     */\n    public setHeading(heading: number | undefined): this {\n        this._heading = heading;\n        return this.redraw();\n    }\n\n    /**\n     * Sets the course over ground.\n     *\n     * @param course - Course over ground (unit: radians, from north, clockwise).\n     * @returns this\n     */\n    public setCourse(course: number | undefined): this {\n        this._course = course;\n        return this.redraw();\n    }\n\n    /**\n     * Sets the speed.\n     *\n     * @param speed - Speed (unit: m/s).\n     * @returns this\n     */\n    public setSpeed(speed: number | undefined): this {\n        this._speed = speed;\n        return this.redraw();\n    }\n\n    /**\n     * Sets the shape options.\n     *\n     * @param shapeOptions - Shape options.\n     * @returns this\n     */\n    public setShapeOptions(shapeOptions: ShapeOptions): this {\n        this._setShapeOptions(shapeOptions);\n        return this.redraw();\n    }\n\n    /**\n     * Returns the bounding box.\n     *\n     * @returns The bounding box.\n     */\n    public getBounds(): LatLngBounds | undefined {\n        return this._currentLatLngBounds;\n    }\n\n    /**\n     * Returns the location.\n     *\n     * @returns The location.\n     */\n    public getLatLng(): LatLng {\n        return this._latLng;\n    }\n\n    /**\n     * Returns the speed.\n     *\n     * @returns The speed (m/s).\n     */\n    public getSpeed(): number | undefined {\n        return this._speed;\n    }\n\n    /**\n     * Returns the heading.\n     *\n     * @returns The heading (radians, from north, clockwise).\n     */\n    public getHeading(): number | undefined {\n        return this._heading;\n    }\n\n    /**\n     * Returns the course.\n     *\n     * @returns The course (radians, from north, clockwise).\n     */\n    public getCourse(): number | undefined {\n        return this._course;\n    }\n\n    /**\n     * Creates a shape.\n     *\n     * @param points - Points.\n     * @param size - Size (units: pixels).\n     * @returns The new shape.\n     */\n    public static createShape(points: Points, size: number): Shape {\n        return {\n            points: points,\n            length: size,\n            breadth: size,\n            units: \"pixels\",\n        };\n    }\n\n    /**\n     * Creates a shape set.\n     *\n     * @param size - Size (units: pixels).\n     * @returns The new shape set.\n     */\n    public static createShapeSet(size: number): ShapeSet {\n        return {\n            withHeading: TrackSymbol.createShape(TrackSymbol.DEFAULT_HEADING_SHAPE_POINTS, size),\n            withoutHeading: TrackSymbol.createShape(TrackSymbol.DEFAULT_NOHEADING_SHAPE_POINTS, size),\n        };\n    }\n\n    /**\n     * Get latitude size of y-distance.\n     *\n     * @param value - Y distance (m).\n     * @returns dLat\n     */\n    private _getLatSizeOf(value: number): number {\n        return (value / 40075017) * 360;\n    }\n\n    /**\n     * Get longitude size of x-distance.\n     *\n     * @param value - X distance (m).\n     * @returns dLng\n     */\n    private _getLngSizeOf(value: number): number {\n        return ((value / 40075017) * 360) / Math.cos((Math.PI / 180) * this._latLng.lat);\n    }\n\n    /**\n     * Get view angle from model.\n     *\n     * @param modelAngle - Model angle (radians).\n     * @returns View angle from model (radians).\n     */\n    private _getViewAngleFromModel(modelAngle: number): number {\n        return modelAngle - Math.PI / 2.0;\n    }\n\n    /**\n     * Get leader shape points.\n     *\n     * @returns Points.\n     */\n    private _getLeaderShapePoints(): Point[] | undefined {\n        if ((this._course === undefined) || (this._speed === undefined)\n            || (this._shapeOptions === undefined) || (this._shapeOptions.leaderTime === undefined)) {\n            return undefined;\n        }\n        const angle = this._getViewAngleFromModel(this._course);\n        const leaderLength = this._speed * this._shapeOptions.leaderTime;\n        const leaderEndLatLng = this._calcRelativeLatLng(this._latLng, leaderLength, angle);\n        return this._latLngsToLayerPoints(this._latLng, leaderEndLatLng);\n    }\n\n    /**\n     * Calculate relative lat/lng.\n     *\n     * @param latLng - LatLng.\n     * @param distance - Distance (meters).\n     * @param angle - Angle (radians).\n     * @returns Calculated LatLng.\n     */\n    private _calcRelativeLatLng(latLng: LatLng, distance: number, angle: number): LatLng {\n        return new LatLng(\n            latLng.lat - this._getLatSizeOf(distance * Math.sin(angle)),\n            latLng.lng + this._getLngSizeOf(distance * Math.cos(angle))\n        );\n    }\n\n    /**\n     * Convert LatLngs to map layer points.\n     *\n     * @param latLngs - LatLngs.\n     * @returns Points.\n     */\n    private _latLngsToLayerPoints(...latLngs: LatLng[]): Point[] {\n        return latLngs.map(latLng => this._map.latLngToLayerPoint(latLng));\n    }\n\n    /**\n     * Gets the shape set.\n     *\n     * @returns The shape set.\n     */\n    private _getShapeSet(): ShapeSet {\n        if ((this._shapeOptions.shapeSetEntries === undefined)\n            || (this._shapeOptions.shapeSetEntries.length == 0)) {\n            return this._shapeOptions.defaultShapeSet ? this._shapeOptions.defaultShapeSet : TrackSymbol.DEFAULT_SHAPE_SET;\n        }\n        const zoomLevel = this._map.getZoom();\n        const shapeSetEntriesFiltered = this._shapeOptions.shapeSetEntries\n            .sort((a, b) => b.minZoomLevel - a.minZoomLevel)\n            .filter(shapeSetEntry => zoomLevel >= shapeSetEntry.minZoomLevel);\n        if (shapeSetEntriesFiltered.length > 0) {\n            return shapeSetEntriesFiltered[0].shapeSet;\n        } else {\n            return this._shapeOptions.defaultShapeSet ? this._shapeOptions.defaultShapeSet : TrackSymbol.DEFAULT_SHAPE_SET;\n        }\n    }\n\n    /**\n     * Gets the shape.\n     *\n     * @returns The shape.\n     */\n    private _getShape(): Shape {\n        const shapeSet = this._getShapeSet();\n        return (this._heading !== undefined) ? shapeSet.withHeading : shapeSet.withoutHeading;\n    }\n\n    /**\n     * Get transformed shape points.\n     *\n     * @returns Transformed points and units.\n     */\n    private _getTransformedShapePoints(): [Points, Units] {\n        const shape = this._getShape();\n        let m = new Matrix();\n        if (this._heading !== undefined) {\n            const headingAngle = this._getViewAngleFromModel(this._heading);\n            m = m.rotate(headingAngle);\n        }\n        if (shape.center !== undefined) {\n            m = m.translate(-shape.center[0], -shape.center[1]);\n        }\n        m = m.scale(shape.length, shape.breadth);\n        const points = shape.points.map(point => m.transform(point));\n        return [points, shape.units];\n    }\n\n    /**\n     * Get projected shape points.\n     *\n     * @returns Points projected to map layer.\n     */\n    private _getProjectedShapePoints(): Point[] {\n        const [points, units] = this._getTransformedShapePoints();\n        switch (units) {\n            case \"pixels\": {\n                const p = this._map.latLngToLayerPoint(this._latLng);\n                const m = new Matrix().translate(p.x, p.y);\n                return points.map(point => {\n                    const p1 = m.transform(point);\n                    return new Point(p1[0], p1[1]);\n                });\n            }\n            case \"meters\": {\n                return points.map(point => this._map.latLngToLayerPoint(\n                    new LatLng(\n                        this._latLng.lat - this._getLatSizeOf(point[1]),\n                        this._latLng.lng + this._getLngSizeOf(point[0])\n                    )\n                ));\n            }\n            default:\n                throw `unsupported units: ${units}`;\n        }\n    }\n\n    /**\n     * Converts points to an SVG path string.\n     *\n     * @param points - Points.\n     * @param close - Close path.\n     * @returns SVG path string.\n     */\n    private static _toSVGPath(points: Point[], close: boolean): string {\n        let result = '';\n        for (let i = 0; i < points.length; i++) {\n            const point = points[i];\n            if (result === '') {\n                result = `M ${point.x} ${point.y} `;\n            } else {\n                result += `L ${point.x} ${point.y} `;\n            }\n        }\n        if (close) {\n            result += 'Z';\n        }\n        return result;\n    }\n}\n","import {TrackSymbol} from '../trackSymbol';\nimport type {ShapeOptions} from '../options';\nimport type {Points, ShapeSet} from '../types';\nimport type {AISTrackSymbolOptions} from './options';\nimport type {Dimension, ETA, PositionReport, ShipStaticData} from './types';\nimport {DomUtil, Util} from 'leaflet';\n\nconst DEFAULT_SIZE = 24;\nconst DEFAULT_MIN_ZOOM_LEVEL = 14;\nconst DEFAULT_LEADER_TIME = 60;\nconst KNOTS_PER_METER_PER_SECOND = 1.944;\nconst MAX_SOG_EXCLUSIVE = 102.3;\nconst MAX_COG_EXCLUSIVE = 360;\nconst MAX_HEADING_EXCLUSIVE = 360;\n\ninterface ShipType {\n    name: string;\n    color: string;\n    fillColor: string;\n}\n\nconst RESERVED_COLOR = \"#000000\";\nconst RESERVED_FILL_COLOR = \"#d3d3d3\";\nconst WIG_COLOR = \"#000000\";\nconst WIG_FILL_COLOR = \"#d3d3d3\";\nconst TYPE_3X_COLOR = \"#8b008b\";\nconst TYPE_3X_FILL_COLOR = \"#ff00ff\";\nconst HSC_COLOR = \"#00008b\";\nconst HSC_FILL_COLOR = \"#ffff00\";\nconst TYPE_5X_COLOR = \"#008b8b\";\nconst TYPE_5X_FILL_COLOR = \"#00ffff\";\nconst PASSENGER_COLOR = \"#00008b\";\nconst PASSENGER_FILL_COLOR = \"#0000ff\";\nconst CARGO_COLOR = \"#006400\";\nconst CARGO_FILL_COLOR = \"#90ee90\";\nconst TANKER_COLOR = \"#8b0000\";\nconst TANKER_FILL_COLOR = \"#ff0000\";\nconst OTHER_COLOR = \"#008b8b\";\nconst OTHER_FILL_COLOR = \"#00ffff\";\n\nconst TYPES: { [key: number]: ShipType } = {\n    0: newShipType('Not available', WIG_COLOR, WIG_FILL_COLOR),\n    20: newShipType('Wing in ground (WIG), all ships of this type', WIG_COLOR, WIG_FILL_COLOR),\n    21: newShipType('Wing in ground (WIG), Hazardous category A', WIG_COLOR, WIG_FILL_COLOR),\n    22: newShipType('Wing in ground (WIG), Hazardous category B', WIG_COLOR, WIG_FILL_COLOR),\n    23: newShipType('Wing in ground (WIG), Hazardous category C', WIG_COLOR, WIG_FILL_COLOR),\n    24: newShipType('Wing in ground (WIG), Hazardous category D', WIG_COLOR, WIG_FILL_COLOR),\n    25: newShipType('Wing in ground (WIG), Reserved for future use', WIG_COLOR, WIG_FILL_COLOR),\n    26: newShipType('Wing in ground (WIG), Reserved for future use', WIG_COLOR, WIG_FILL_COLOR),\n    27: newShipType('Wing in ground (WIG), Reserved for future use', WIG_COLOR, WIG_FILL_COLOR),\n    28: newShipType('Wing in ground (WIG), Reserved for future use', WIG_COLOR, WIG_FILL_COLOR),\n    29: newShipType('Wing in ground (WIG), Reserved for future use', WIG_COLOR, WIG_FILL_COLOR),\n    30: newShipType('Fishing', TYPE_3X_COLOR, TYPE_3X_FILL_COLOR),\n    31: newShipType('Towing', TYPE_3X_COLOR, TYPE_3X_FILL_COLOR),\n    32: newShipType('Towing: length exceeds 200m or breadth exceeds 25m', TYPE_3X_COLOR, TYPE_3X_FILL_COLOR),\n    33: newShipType('Dredging or underwater ops', TYPE_3X_COLOR, TYPE_3X_FILL_COLOR),\n    34: newShipType('Diving ops', TYPE_3X_COLOR, TYPE_3X_FILL_COLOR),\n    35: newShipType('Military ops', TYPE_3X_COLOR, TYPE_3X_FILL_COLOR),\n    36: newShipType('Sailing', TYPE_3X_COLOR, TYPE_3X_FILL_COLOR),\n    37: newShipType('Pleasure Craft', TYPE_3X_COLOR, TYPE_3X_FILL_COLOR),\n    40: newShipType('High speed craft (HSC), all ships of this type', HSC_COLOR, HSC_FILL_COLOR),\n    41: newShipType('High speed craft (HSC), Hazardous category A', HSC_COLOR, HSC_FILL_COLOR),\n    42: newShipType('High speed craft (HSC), Hazardous category B', HSC_COLOR, HSC_FILL_COLOR),\n    43: newShipType('High speed craft (HSC), Hazardous category C', HSC_COLOR, HSC_FILL_COLOR),\n    44: newShipType('High speed craft (HSC), Hazardous category D', HSC_COLOR, HSC_FILL_COLOR),\n    45: newShipType('High speed craft (HSC), Reserved for future use', HSC_COLOR, HSC_FILL_COLOR),\n    46: newShipType('High speed craft (HSC), Reserved for future use', HSC_COLOR, HSC_FILL_COLOR),\n    47: newShipType('High speed craft (HSC), Reserved for future use', HSC_COLOR, HSC_FILL_COLOR),\n    48: newShipType('High speed craft (HSC), Reserved for future use', HSC_COLOR, HSC_FILL_COLOR),\n    49: newShipType('High speed craft (HSC), No additional information', HSC_COLOR, HSC_FILL_COLOR),\n    50: newShipType('Pilot Vessel', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    51: newShipType('Search and Rescue vessel', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    52: newShipType('Tug', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    53: newShipType('Port Tender', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    54: newShipType('Anti-pollution equipment', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    55: newShipType('Law Enforcement', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    56: newShipType('Spare - Local Vessel', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    57: newShipType('Spare - Local Vessel', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    58: newShipType('Medical Transport', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    59: newShipType('Noncombatant ship according to RR Resolution No. 18', '', ''),\n    60: newShipType('Passenger, all ships of this type', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    61: newShipType('Passenger, Hazardous category A', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    62: newShipType('Passenger, Hazardous category B', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    63: newShipType('Passenger, Hazardous category C', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    64: newShipType('Passenger, Hazardous category D', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    65: newShipType('Passenger, Reserved for future use', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    66: newShipType('Passenger, Reserved for future use', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    67: newShipType('Passenger, Reserved for future use', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    68: newShipType('Passenger, Reserved for future use', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    69: newShipType('Passenger, No additional information', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    70: newShipType('Cargo, all ships of this type', CARGO_COLOR, CARGO_FILL_COLOR),\n    71: newShipType('Cargo, Hazardous category A', CARGO_COLOR, CARGO_FILL_COLOR),\n    72: newShipType('Cargo, Hazardous category B', CARGO_COLOR, CARGO_FILL_COLOR),\n    73: newShipType('Cargo, Hazardous category C', CARGO_COLOR, CARGO_FILL_COLOR),\n    74: newShipType('Cargo, Hazardous category D', CARGO_COLOR, CARGO_FILL_COLOR),\n    75: newShipType('Cargo, Reserved for future use', CARGO_COLOR, CARGO_FILL_COLOR),\n    76: newShipType('Cargo, Reserved for future use', CARGO_COLOR, CARGO_FILL_COLOR),\n    77: newShipType('Cargo, Reserved for future use', CARGO_COLOR, CARGO_FILL_COLOR),\n    78: newShipType('Cargo, Reserved for future use', CARGO_COLOR, CARGO_FILL_COLOR),\n    79: newShipType('Cargo, No additional information', CARGO_COLOR, CARGO_FILL_COLOR),\n    80: newShipType('Tanker, all ships of this type', TANKER_COLOR, TANKER_FILL_COLOR),\n    81: newShipType('Tanker, Hazardous category A', TANKER_COLOR, TANKER_FILL_COLOR),\n    82: newShipType('Tanker, Hazardous category B', TANKER_COLOR, TANKER_FILL_COLOR),\n    83: newShipType('Tanker, Hazardous category C', TANKER_COLOR, TANKER_FILL_COLOR),\n    84: newShipType('Tanker, Hazardous category D', TANKER_COLOR, TANKER_FILL_COLOR),\n    85: newShipType('Tanker, Reserved for future use', TANKER_COLOR, TANKER_FILL_COLOR),\n    86: newShipType('Tanker, Reserved for future use', TANKER_COLOR, TANKER_FILL_COLOR),\n    87: newShipType('Tanker, Reserved for future use', TANKER_COLOR, TANKER_FILL_COLOR),\n    88: newShipType('Tanker, Reserved for future use', TANKER_COLOR, TANKER_FILL_COLOR),\n    89: newShipType('Tanker, No additional information', TANKER_COLOR, TANKER_FILL_COLOR),\n    90: newShipType('Other Type, all ships of this type', OTHER_COLOR, OTHER_FILL_COLOR),\n    91: newShipType('Other Type, Hazardous category A', OTHER_COLOR, OTHER_FILL_COLOR),\n    92: newShipType('Other Type, Hazardous category B', OTHER_COLOR, OTHER_FILL_COLOR),\n    93: newShipType('Other Type, Hazardous category C', OTHER_COLOR, OTHER_FILL_COLOR),\n    94: newShipType('Other Type, Hazardous category D', OTHER_COLOR, OTHER_FILL_COLOR),\n    95: newShipType('Other Type, Reserved for future use', OTHER_COLOR, OTHER_FILL_COLOR),\n    96: newShipType('Other Type, Reserved for future use', OTHER_COLOR, OTHER_FILL_COLOR),\n    97: newShipType('Other Type, Reserved for future use', OTHER_COLOR, OTHER_FILL_COLOR),\n    98: newShipType('Other Type, Reserved for future use', OTHER_COLOR, OTHER_FILL_COLOR),\n    99: newShipType('Other Type, no additional information', OTHER_COLOR, OTHER_FILL_COLOR),\n};\nconst RESERVED_TYPE = newShipType('Reserved', RESERVED_COLOR, RESERVED_FILL_COLOR);\nconst UNKNOWN_TYPE = newShipType('Unknown', RESERVED_COLOR, RESERVED_FILL_COLOR);\n\nexport class AISTrackSymbol\n    extends TrackSymbol {\n\n    /** Default silhouette shape points. */\n    public static DEFAULT_SILHOUETTE_SHAPE_POINTS: Points = [[1, 0.5], [0.75, 1], [0, 1], [0, 0], [0.75, 0]];\n\n    private readonly _leaderTime: number;\n    private readonly _minZoomLevel: number;\n    private readonly _size: number;\n    private _positionReport: PositionReport;\n    private _shipStaticData?: ShipStaticData;\n\n    /**\n     * AISTrackSymbol constructor.\n     *\n     * @param positionReport - Position report.\n     * @param options - Options.\n     */\n    constructor(positionReport: PositionReport, options?: AISTrackSymbolOptions) {\n        super([positionReport.latitude, positionReport.longitude], options);\n\n        Util.setOptions(this, options);\n        options = options || {};\n        this._leaderTime = options.leaderTime || DEFAULT_LEADER_TIME;\n        this._minZoomLevel = options.minZoomLevel || DEFAULT_MIN_ZOOM_LEVEL;\n        this._size = options.size || DEFAULT_SIZE;\n        this._positionReport = positionReport;\n        this.setPositionReport(positionReport);\n        this.setShipStaticData(options.shipStaticData);\n    }\n\n    /**\n     * Get ETA from Date.\n     *\n     * @param date - Date.\n     * @returns ETA\n     */\n    public static etaFromDate(date: Date | null | undefined): ETA | undefined {\n        if ((date === null) || (date === undefined)) {\n            return undefined;\n        }\n        return {\n            month: date.getMonth() + 1,\n            day: date.getDate(),\n            hour: date.getHours(),\n            minute: date.getMinutes(),\n        }\n    }\n\n    /**\n     * Sets the position report.\n     *\n     * @param positionReport - Position report.\n     * @returns this\n     */\n    public setPositionReport(positionReport: PositionReport): this {\n        this._positionReport = positionReport;\n        this.setLatLng([positionReport.latitude, positionReport.longitude]);\n        if ((positionReport.trueHeading !== null) && (positionReport.trueHeading !== undefined) && (positionReport.trueHeading < MAX_HEADING_EXCLUSIVE)) {\n            this.setHeading(toRadians(positionReport.trueHeading));\n        } else {\n            this.setHeading(undefined);\n        }\n        if ((positionReport.cog !== null) && (positionReport.cog !== undefined) && (positionReport.cog < MAX_COG_EXCLUSIVE)) {\n            this.setCourse(toRadians(positionReport.cog));\n        } else {\n            this.setCourse(undefined);\n        }\n        if ((positionReport.sog !== null) && (positionReport.sog !== undefined) && (positionReport.sog < MAX_SOG_EXCLUSIVE)) {\n            this.setSpeed(positionReport.sog / KNOTS_PER_METER_PER_SECOND);\n        } else {\n            this.setSpeed(undefined);\n        }\n        this.bindPopup(this._getPopupContent(this._positionReport, this._shipStaticData));\n        return this.redraw();\n    }\n\n    /**\n     * Sets the ship static data.\n     *\n     * @param shipStaticData - Ship static data.\n     * @returns this\n     */\n    public setShipStaticData(shipStaticData?: ShipStaticData): this {\n        this._shipStaticData = shipStaticData;\n        const shipType = getShipType((shipStaticData !== null) && (shipStaticData !== undefined) ? shipStaticData.type : undefined);\n        this.setStyle({\n            color: shipType.color,\n            fill: true,\n            fillOpacity: 1.0,\n            fillColor: shipType.fillColor,\n        });\n        this.bindPopup(this._getPopupContent(this._positionReport, this._shipStaticData));\n        return this.setShapeOptions(AISTrackSymbol._getShapeOptions(this._leaderTime, this._minZoomLevel, this._size,\n            shipStaticData));\n    }\n\n    private static _getShapeOptions(leaderTime: number, minZoomLevel: number, size: number,\n                                    shipStaticData?: ShipStaticData): ShapeOptions {\n        const shapeOptions: ShapeOptions = {\n            leaderTime: leaderTime,\n            defaultShapeSet: TrackSymbol.createShapeSet(size),\n        };\n        const shapeSet = AISTrackSymbol._getShapeSet(size, shipStaticData);\n        if (shapeSet !== null) {\n            shapeOptions.shapeSetEntries = [{\n                shapeSet: shapeSet,\n                minZoomLevel: minZoomLevel,\n            }];\n        }\n        return shapeOptions;\n    }\n\n    private static _getShapeSet(size: number, shipStaticData?: ShipStaticData): ShapeSet | null {\n        if ((shipStaticData === null) || (shipStaticData === undefined)\n            || (shipStaticData.dimension === null) || (shipStaticData.dimension === undefined)\n            || !isDimensionValid(shipStaticData.dimension)) {\n            return null;\n        }\n        return {\n            withHeading: {\n                points: AISTrackSymbol.DEFAULT_SILHOUETTE_SHAPE_POINTS,\n                center: [shipStaticData.dimension.B, shipStaticData.dimension.D],\n                length: shipStaticData.dimension.A + shipStaticData.dimension.B,\n                breadth: shipStaticData.dimension.C + shipStaticData.dimension.D,\n                units: \"meters\",\n            },\n            withoutHeading: TrackSymbol.createShape(TrackSymbol.DEFAULT_NOHEADING_SHAPE_POINTS, size),\n        };\n    }\n\n    private _getPopupContent(positionReport?: PositionReport, shipStaticData?: ShipStaticData): HTMLElement {\n        let content = \"<table>\";\n        if ((shipStaticData !== null) && (shipStaticData !== undefined)) {\n            content += createTableRow(\"User ID\", shipStaticData.userId);\n            content += createTableRow(\"IMO Number\", shipStaticData.imoNumber);\n            content += createTableRow(\"Call sign\", shipStaticData.callSign);\n            content += createTableRow(\"Name\", shipStaticData.name);\n        }\n        if ((positionReport !== null) && (positionReport !== undefined)) {\n            content += createTableRow(\"Location\", `${toFixed(positionReport.latitude, 5)}, ${toFixed(positionReport.longitude, 5)}`);\n            content += createTableRow(\"SOG\",\n                toFixed(positionReport.sog, 2, v => v < MAX_SOG_EXCLUSIVE), \"knots\");\n            content += createTableRow(\"COG\",\n                toFixed(positionReport.cog, 1), \"°\");\n            content += createTableRow(\"Heading\",\n                toFixed(positionReport.trueHeading, 1), \"°\");\n            content += createTableRow(\"Navigation status\",\n                toNavigationStatusString(positionReport.navigationalStatus));\n        }\n        if ((shipStaticData !== null) && (shipStaticData !== undefined)) {\n            content += createTableRow(\"Type\", toTypeString(shipStaticData.type));\n            if ((shipStaticData.dimension !== null) && (shipStaticData.dimension !== undefined)\n                && isDimensionValid(shipStaticData.dimension)) {\n                content += createTableRow(\"Ship length\",\n                    shipStaticData.dimension.A + shipStaticData.dimension.B, \"m\");\n                content += createTableRow(\"Ship width\",\n                    shipStaticData.dimension.C + shipStaticData.dimension.D, \"m\");\n            }\n            content += createTableRow(\"Fix type\", toFixTypeString(shipStaticData.fixType));\n            content += createTableRow(\"ETA\", toETAString(shipStaticData.eta));\n            content += createTableRow(\"Maximum static draught\",\n                toFixed(shipStaticData.maximumStaticDraught, 1), \"m\");\n            content += createTableRow(\"Destination\", shipStaticData.destination);\n            content += createTableRow(\"DTE\", shipStaticData.dte);\n        }\n        content += \"</table>\";\n        const popupContent = DomUtil.create(\"div\");\n        popupContent.innerHTML = content;\n        return popupContent;\n    }\n}\n\nfunction toFixed(v: number | null | undefined, fractionDigits?: number, isValid?: (v: number) => boolean): string | undefined {\n    if ((v === null) || (v === undefined)) {\n        return undefined;\n    }\n    if (isValid && !isValid(v)) {\n        return undefined;\n    }\n    return v.toFixed(fractionDigits);\n}\n\nfunction toTypeString(type: number | null | undefined): string | undefined {\n    if ((type === null) || (type === undefined)) {\n        return undefined;\n    }\n    const shipType = getShipType(type);\n    return shipType.name;\n}\n\nfunction toFixTypeString(fixType: number | null | undefined): string | undefined {\n    if ((fixType === null) || (fixType === undefined)) {\n        return undefined;\n    }\n    switch (fixType) {\n        case 0:\n            return undefined;\n        case 1:\n            return 'GPS';\n        case 2:\n            return 'GLONASS';\n        case 3:\n            return 'combined GPS/GLONASS';\n        case 4:\n            return 'Loran-C';\n        case 5:\n            return 'Chayka';\n        case 6:\n            return 'integrated navigation system';\n        case 7:\n            return 'surveyed';\n        case 8:\n            return 'Galileo';\n        case 9:\n        case 10:\n        case 11:\n        case 12:\n        case 13:\n        case 14:\n            return `not used (${fixType})`;\n        case 15:\n            return \"internal GNSS\";\n        default:\n            return `unknown (${fixType})`;\n    }\n}\n\nfunction toNavigationStatusString(navigationStatus: number | null | undefined): string | undefined {\n    if ((navigationStatus === null) || (navigationStatus === undefined)) {\n        return undefined;\n    }\n    switch (navigationStatus) {\n        case 0:\n            return 'Under way using engine';\n        case 1:\n            return 'At anchor';\n        case 2:\n            return 'Not under command';\n        case 3:\n            return 'Restricted manoeuverability';\n        case 4:\n            return 'Constrained by her draught';\n        case 5:\n            return 'Moored';\n        case 6:\n            return 'Aground';\n        case 7:\n            return 'Engaged in Fishing';\n        case 8:\n            return 'Under way sailing';\n        case 9:\n            return 'Reserved for future amendment of Navigational Status for HSC';\n        case 10:\n            return 'Reserved for future amendment of Navigational Status for WIG';\n        case 11:\n            return 'Reserved for future use';\n        case 12:\n            return 'Reserved for future use';\n        case 13:\n            return 'Reserved for future use';\n        case 14:\n            return 'AIS-SART is active';\n        case 15:\n            return 'Not defined (default)';\n        default:\n            return `unknown (${navigationStatus})`;\n    }\n}\n\nfunction toETAString(eta: ETA | null | undefined): string | undefined {\n    if ((eta === null) || (eta === undefined)) {\n        return undefined;\n    }\n    const parts: string[] = [];\n    if (!isNullOrUndefined(eta.month) && !isNullOrUndefined(eta.day)) {\n        parts.push(`${eta.month.toString().padStart(2, '0')}/${eta.day.toString().padStart(2, '0')}`);\n    }\n    if (!isNullOrUndefined(eta.hour) && !isNullOrUndefined(eta.minute)) {\n        parts.push(`${eta.hour.toString().padStart(2, '0')}:${eta.minute.toString().padStart(2, '0')}`);\n    }\n    if (parts.length === 0) {\n        return undefined;\n    }\n    return `${parts.join(' ')} UTC`;\n}\n\nfunction toRadians(degs: number | null | undefined): number | undefined {\n    if ((degs === null) || (degs === undefined)) {\n        return undefined;\n    }\n    return degs * Math.PI / 180;\n}\n\nfunction isNullOrUndefined(v: any): boolean {\n    return (v === null) || (v === undefined);\n}\n\nfunction isDimensionValid(dimension: Dimension | null | undefined): boolean {\n    return (dimension !== null) && (dimension !== undefined)\n        && (dimension.A > 0) && (dimension.B > 0) && (dimension.C > 0) && (dimension.D > 0);\n}\n\nfunction createTableRow(name: string, value: any, unit?: string): string {\n    if ((value === null) || (value === undefined)) {\n        return '';\n    }\n    const sValue = String(value);\n    return `<tr><td>${name}</td><td>${sValue} ${isNullOrUndefined(unit) ? \"\" : unit}</td></tr>`;\n}\n\nfunction newShipType(name: string, color: string, fillColor: string): ShipType {\n    return {\n        name: name,\n        color: color,\n        fillColor: fillColor,\n    };\n}\n\nfunction getShipType(type: number | null | undefined): ShipType {\n    if ((type === null) || (type === undefined)) {\n        return TYPES[0];\n    }\n    if ((type < 0) || (type > 99)) {\n        return UNKNOWN_TYPE;\n    }\n    const shipType = TYPES[type];\n    if (!isNullOrUndefined(shipType)) {\n        return shipType;\n    }\n    return RESERVED_TYPE;\n}\n","//@ts-strict-ignore\nimport L from 'leaflet';\nimport type {LatLngExpression} from 'leaflet';\nimport {TrackSymbol} from './trackSymbol';\nimport type {ShapeSetEntry, ShapeOptions, TrackSymbolOptions} from './options';\nimport type {Points, Shape, ShapeSet, Units} from './types';\nimport {AISTrackSymbol} from './ais/aisTrackSymbol';\nimport type {AISTrackSymbolOptions} from './ais/options';\nimport type {AISMessage, Dimension, ETA, PositionReport, ShipStaticData} from './ais/types';\n\nexport {\n    Points,\n    Shape,\n    ShapeOptions,\n    ShapeSet,\n    ShapeSetEntry,\n    TrackSymbol,\n    TrackSymbolOptions,\n    Units,\n};\n\nexport {\n    AISMessage,\n    AISTrackSymbol,\n    AISTrackSymbolOptions,\n    Dimension,\n    ETA,\n    PositionReport,\n    ShipStaticData,\n};\n\nL['trackSymbol'] = function(latLng: LatLngExpression, options?: TrackSymbolOptions): TrackSymbol {\n    return new TrackSymbol(latLng, options);\n}\nL['TrackSymbol'] = TrackSymbol;\n\nL['aisTrackSymbol'] = function(positionReport: PositionReport, options?: AISTrackSymbolOptions): AISTrackSymbol {\n    return new AISTrackSymbol(positionReport, options);\n}\nL['AISTrackSymbol'] = AISTrackSymbol;\n\nexport default TrackSymbol;\n"],"names":["ORIENTATION","PIx2","INSIDE$2","OUTSIDE$1","BOUNDARY$1","CONTAINS","INTERLACE","OVERLAP_SAME$1","OVERLAP_OPPOSITE$1","NOT_VERTEX$1","START_VERTEX$1","END_VERTEX$1","Constants","DP_TOL","setTolerance","tolerance","getTolerance","DECIMALS","EQ_0","x","EQ","y","GT","GE","LT","LE","Utils$1","Flatten","c","value","Errors","LinkedList","first","last","counter","edge","start","end","elements","from","to","element","newElement","elementBefore","elementAfter","controlEdge","addToIntPoints","pt","int_points","id","shapes","len","is_vertex","arc_length","sortIntersections","intersections","getSortedArray","faceMap","ip","compareFn","ip1","ip2","filterDuplicatedIntersections","do_squeeze","int_point_ref1","int_point_ref2","int_point_cur1","int_point_cur2","i","j","int_point","index","initializeInclusionFlags","calculateInclusionFlags","polygon","setOverlappingFlags","cur_face","first_int_point_in_face_id","next_int_point1","num_int_points","cur_int_point1","int_points_cur_pool_start","int_points_cur_pool_num","intPointsPoolCount","next_int_point_id","int_points_next_pool_num","next_int_point1_tmp","edge_from1","edge_to1","cur_int_point2","next_int_point2","edge_from2","edge_to2","cur_int_point_num","int_point_current","int_point_next","int_points_pool_num","splitByIntersections","newEdge","insertBetweenIntPoints","int_point1","int_point2","new_edges","edge_before","edge_after","INSIDE$1","OUTSIDE","BOUNDARY","OVERLAP_SAME","OVERLAP_OPPOSITE","NOT_VERTEX","START_VERTEX","END_VERTEX","BOOLEAN_UNION","BOOLEAN_INTERSECT","BOOLEAN_SUBTRACT","unify","polygon1","polygon2","res_poly","wrk_poly","booleanOpBinary","subtract","polygon2_reversed","intersect$1","innerClip","clip_shapes1","face","clip_shapes2","outerClip","calculateIntersections","getIntersections","ip_sorted1","ip_sorted2","filterNotRelevantEdges","op","notIntersectedFacesRes","getNotIntersectedFaces","notIntersectedFacesWrk","calcInclusionForNotIntersectedFaces","fixBoundaryConflicts","removeNotRelevantChains","removeNotRelevantNotIntersectedFaces","swapLinksAndRestore","copyWrkToRes","swapLinks","removeOldFaces","restoreFaces","restore","edge1","resp","edge2","poly","notIntersected","notIntersectedFaces","poly2","poly1","int_points1","int_points1_sorted","int_points2","iterate_more","edge_tmp","new_bv","dist","segment","newEdge1","int_point2_edge_after","newEdge2","is_res_polygon","first_int_point_in_face_num","int_points_from_pull_start","int_points_from_pull_num","next_int_point_num","int_points_to_pull_start","int_points_to_pull_num","edge_from","edge_to","k","res_polygon","wrk_polygon","other_int_points","int_point_tmp","rel","BooleanOperations","EQUAL","INTERSECT","TOUCH","INSIDE","COVERED","DE9IM","geom","e","intersectLine2Line","line1","line2","A1","B1","C1","A2","B2","C2","det","detX","detY","intersectLine2Circle","line","circle","prj","delta","v_trans","intersectLine2Box","box","ips","seg","ips_tmp","intersectSegment2Line","ptInIntPoints","intersectLine2Arc","arc","ip_tmp","intersectSegment2Segment","seg1","seg2","new_ip","isPointInSegmentBox","point","intersectSegment2Circle","_","intersectSegment2Arc","intersectSegment2Box","intersectCircle2Circle","circle1","circle2","vec","r1","r2","a","mid_pt","h","intersectCircle2Box","intersectArc2Arc","arc1","arc2","intersectArc2Circle","intersectArc2Box","intersectEdge2Segment","intersectEdge2Arc","intersectEdge2Line","intersectEdge2Ray","ray","intersectRay2Segment","intersectRay2Arc","intersectEdge2Circle","intersectSegment2Polygon","intersectArc2Polygon","intersectLine2Polygon","intersectCircle2Polygon","intersectEdge2Edge","intersectEdge2Polygon","resp_edges","resp_edge","intersectPolygon2Polygon","intersectShape2Polygon","shape","new_pt","createLineFromRay","intersectRay2Circle","intersectRay2Box","intersectRay2Line","intersectRay2Ray","ray1","ray2","intersectRay2Polygon","defaultAttributes","SVGAttributes","args","property","acc","key","SVGKey","str","convertToString","attrs","Multiline","v","edgeBefore","edgeFrom","edgeTo","edges","edgeFound","angle","center","matrix","svgStr","multiline","ray_shoot","contains","searchBox","i1","i2","intersection","prev_edge","prev_tangent","prev_point","cur_tangent","cur_point","prev_on_the_left","cur_on_the_left","next_edge","next_tangent","next_point","next_on_the_left","equal","shape1","shape2","relate","intersect","touch","disjoint","inside","covered","contain","cover","relateLine2Line","relateLine2Circle","relateLine2Box","relateLine2Polygon","relateShape2Polygon","relatePolygon2Polygon","denim","ip_sorted","splitShapes","boolean_intersection","boolean_difference1","boolean_difference2","inner_clip_shapes1","inner_clip_shapes2","outer_clip_shapes1","outer_clip_shapes2","Relations","Matrix$1","Matrix","b","d","tx","ty","vector","other_matrix","centerX","centerY","cos","sin","sx","sy","Interval","low","high","other_interval","interval1","interval2","val1","val2","RB_TREE_COLOR_RED","RB_TREE_COLOR_BLACK","Node","left","right","parent","color","other_node","comparable_max","search_node","comparable_less_than","IntervalTree","count","res","node","insert_node","delete_node","interval","outputMapperFn","resp_nodes","visitor","callback","tree","node_current","current_node","parent_node","uncle_node","cut_node","fix_node","brother_node","found","node_min","node_max","node_successor","action","height","heightLeft","heightRight","PlanarSet","entry","size","deleted","Shape","Point$1","Point","arr","m","proj_vec","dx","dy","r","Vector$1","a1","a2","scalar","norm1","norm2","n","vector$1","Segment","coords","ps","pe","shortest_segment","length","factor","rest","ymin","dy1","dy2","pts","Line$1","Line","norm","A","B","C","other_line","distance","sorted_points","pt1","pt2","Circle$1","pc","counterclockwise","Arc","startAngle","endAngle","counterClockwise","sweep","test_arc","func_arcs_array","angles","test_arcs","prev_arc","new_arc","newStart","newEnd","newCenter","newDirection","onLeftSide","areaTrapez","areaCircularSegment","slope1","slope2","largeArcFlag","sweepFlag","Box","xmin","xmax","ymax","other_box","box1","box2","new_box","vertex","width","Edge","bvMiddle","flag","sign","halfArc1","halfArc2","CircularLinkedList","done","Face","segments","points","flattenShapes","flattenShape","sArea","area","exitOnFirst","Ray","slope","Polygon","argsArray","loop","el","loop1","valid","signedArea","unassignedEdgeFound","edge_next","newPoly","int_point1_prev","int_point1_curr","newEdges","polygons","orientation","newPolygons","islandPolygon","min_dist_and_segment","min_stop","newPolygon","Circle","Vector","Utils","Inversion","inversion_circle","k2","len2","s","inversion","Distance","closest_point","dist2center","shortest_dist","v_seg","v_ps2pt","v_pe2pt","start_sp","end_sp","v_unit","dist_and_segment","dist_tmp","shortest_segment_tmp","dist_from_start","shortest_segment_from_start","dist_from_end","shortest_segment_from_end","dist_from_center","shortest_segment_from_center","dist_from_projection","shortest_segment_from_projection","segment_tmp","mindist_x","mindist_y","mindist","maxdist","level","new_level_left","new_level_right","new_level","set","squared_min_stop","min_dist_and_segment_new","stop","d1","d2","DEFAULT_SIZE","DEFAULT_LEADER_TIME","_TrackSymbol","Path","latLng","options","Util","L","bounds","Bounds","LatLngBounds","paths","viewPath","shapeOptions","oldLatLng","heading","course","speed","modelAngle","leaderLength","leaderEndLatLng","LatLng","latLngs","zoomLevel","shapeSetEntriesFiltered","shapeSetEntry","shapeSet","headingAngle","units","p","p1","close","result","TrackSymbol","DEFAULT_MIN_ZOOM_LEVEL","KNOTS_PER_METER_PER_SECOND","MAX_SOG_EXCLUSIVE","MAX_COG_EXCLUSIVE","MAX_HEADING_EXCLUSIVE","RESERVED_COLOR","RESERVED_FILL_COLOR","WIG_COLOR","WIG_FILL_COLOR","TYPE_3X_COLOR","TYPE_3X_FILL_COLOR","HSC_COLOR","HSC_FILL_COLOR","TYPE_5X_COLOR","TYPE_5X_FILL_COLOR","PASSENGER_COLOR","PASSENGER_FILL_COLOR","CARGO_COLOR","CARGO_FILL_COLOR","TANKER_COLOR","TANKER_FILL_COLOR","OTHER_COLOR","OTHER_FILL_COLOR","TYPES","newShipType","RESERVED_TYPE","UNKNOWN_TYPE","_AISTrackSymbol","positionReport","date","toRadians","shipStaticData","shipType","getShipType","leaderTime","minZoomLevel","isDimensionValid","content","createTableRow","toFixed","toNavigationStatusString","toTypeString","toFixTypeString","toETAString","popupContent","DomUtil","AISTrackSymbol","fractionDigits","isValid","type","fixType","navigationStatus","eta","parts","isNullOrUndefined","degs","dimension","name","unit","sValue","fillColor"],"mappings":"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","x_google_ignoreList":[0]}