(function(Z,w){typeof exports=="object"&&typeof module<"u"?w(exports,require("leaflet")):typeof define=="function"&&define.amd?define(["exports","leaflet"],w):(Z=typeof globalThis<"u"?globalThis:Z||self,w(Z["leaflet-tracksymbol2"]={},Z.L))})(this,function(Z,w){"use strict";const qt={CCW:-1,CW:1,NOT_ORIENTABLE:0},Pn=2*Math.PI,Dt=1,we=0,M=2,An=3,bn=4,Ln=1,On=2,Jt=0,bt=1,ht=2;var Wt=Object.freeze({__proto__:null,BOUNDARY:M,CCW:!0,CONTAINS:An,CW:!1,END_VERTEX:ht,INSIDE:Dt,INTERLACE:bn,NOT_VERTEX:Jt,ORIENTATION:qt,OUTSIDE:we,OVERLAP_OPPOSITE:On,OVERLAP_SAME:Ln,PIx2:Pn,START_VERTEX:bt});let U=1e-6;function ye(r){U=r}function Pe(){return U}const Nn=3;function te(r){return r<U&&r>-U}function ot(r,t){return r-t<U&&r-t>-U}function Ae(r,t){return r-t>U}function Cn(r,t){return r-t>-U}function be(r,t){return r-t<-U}function Rn(r,t){return r-t<U}var Mn=Object.freeze({__proto__:null,DECIMALS:Nn,EQ:ot,EQ_0:te,GE:Cn,GT:Ae,LE:Rn,LT:be,getTolerance:Pe,setTolerance:ye});let i={Utils:Mn,Errors:void 0,Matrix:void 0,Planar_set:void 0,Point:void 0,Vector:void 0,Line:void 0,Circle:void 0,Segment:void 0,Arc:void 0,Box:void 0,Edge:void 0,Face:void 0,Ray:void 0,Ray_shooting:void 0,Multiline:void 0,Polygon:void 0,Distance:void 0,Inversion:void 0};for(let r in Wt)i[r]=Wt[r];Object.defineProperty(i,"DP_TOL",{get:function(){return Pe()},set:function(r){ye(r)}});class T{static get ILLEGAL_PARAMETERS(){return new ReferenceError("Illegal Parameters")}static get ZERO_DIVISION(){return new Error("Zero division")}static get UNRESOLVED_BOUNDARY_CONFLICT(){return new Error("Unresolved boundary conflict in boolean operation")}static get INFINITE_LOOP(){return new Error("Infinite loop")}static get CANNOT_COMPLETE_BOOLEAN_OPERATION(){return new Error("Cannot complete boolean operation")}static get CANNOT_INVOKE_ABSTRACT_METHOD(){return new Error("Abstract method cannot be invoked")}static get OPERATION_IS_NOT_SUPPORTED(){return new Error("Operation is not supported")}static get UNSUPPORTED_SHAPE_TYPE(){return new Error("Unsupported shape type")}}i.Errors=T;class ee{constructor(t,e){this.first=t,this.last=e||this.first}[Symbol.iterator](){let t;return{next:()=>(t=t?t.next:this.first,{value:t,done:t===void 0})}}get size(){let t=0;for(let e of this)t++;return t}toArray(t=void 0,e=void 0){let n=[],s=t||this.first,l=e||this.last,o=s;if(o===void 0)return n;do n.push(o),o=o.next;while(o!==l.next);return n}append(t){return this.isEmpty()?this.first=t:(t.prev=this.last,this.last.next=t),this.last=t,this.last.next=void 0,this.first.prev=void 0,this}insert(t,e){if(this.isEmpty())this.first=t,this.last=t;else if(e==null)t.next=this.first,this.first.prev=t,this.first=t;else{let n=e.next;e.next=t,n&&(n.prev=t),t.prev=e,t.next=n,this.last===e&&(this.last=t)}return this.last.next=void 0,this.first.prev=void 0,this}remove(t){return t===this.first&&t===this.last?(this.first=void 0,this.last=void 0):(t.prev&&(t.prev.next=t.next),t.next&&(t.next.prev=t.prev),t===this.first&&(this.first=t.next),t===this.last&&(this.last=t.prev)),this}isEmpty(){return this.first===void 0}static testInfiniteLoop(t){let e=t,n=t;do{if(e!=t&&e===n)throw T.INFINITE_LOOP;e=e.next,n=n.next.next}while(e!=t)}}const Le={stroke:"black"};class Un{constructor(t=Le){for(const e in t)this[e]=t[e];this.stroke=t.stroke??Le.stroke}toAttributesString(){return Object.keys(this).reduce((t,e)=>t+(this[e]!==void 0?this.toAttrString(e,this[e]):""),"")}toAttrString(t,e){const n=t==="className"?"class":this.convertCamelToKebabCase(t);return e===null?`${n} `:`${n}="${e.toString()}" `}convertCamelToKebabCase(t){return t.match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g).join("-").toLowerCase()}}function lt(r){return new Un(r).toAttributesString()}function ct(r,t){let e=[],[n,s,l]=r.standard,[o,a,u]=t.standard,h=n*a-s*o,f=l*a-s*u,g=n*u-l*o;if(!i.Utils.EQ_0(h)){let _,v;s===0?(_=l/n,v=g/h):a===0?(_=u/o,v=g/h):n===0?(_=f/h,v=l/s):o===0?(_=f/h,v=u/a):(_=f/h,v=g/h),e.push(new i.Point(_,v))}return e}function at(r,t){let e=[],n=t.pc.projectionOn(r),s=t.pc.distanceTo(n)[0];if(i.Utils.EQ(s,t.r))e.push(n);else if(i.Utils.LT(s,t.r)){let l=Math.sqrt(t.r*t.r-s*s),o,a;o=r.norm.rotate90CCW().multiply(l),a=n.translate(o),e.push(a),o=r.norm.rotate90CW().multiply(l),a=n.translate(o),e.push(a)}return e}function dt(r,t){let e=[];for(let n of t.toSegments()){let s=Lt(n,r);for(let l of s)Ve(l,e)||e.push(l)}return e}function zt(r,t){let e=[];if(dt(r,t.box).length===0)return e;let n=new i.Circle(t.pc,t.r),s=at(r,n);for(let l of s)l.on(t)&&e.push(l);return e}function Lt(r,t){let e=[];if(r.ps.on(t)&&e.push(r.ps),r.pe.on(t)&&!r.isZeroLength()&&e.push(r.pe),e.length>0||r.isZeroLength()||r.ps.leftTo(t)&&r.pe.leftTo(t)||!r.ps.leftTo(t)&&!r.pe.leftTo(t))return e;let n=new i.Line(r.ps,r.pe);return ct(n,t)}function Yt(r,t){let e=[];if(r.box.not_intersect(t.box))return e;if(r.isZeroLength())return r.ps.on(t)&&e.push(r.ps),e;if(t.isZeroLength())return t.ps.on(r)&&e.push(t.ps),e;let n=new i.Line(r.ps,r.pe),s=new i.Line(t.ps,t.pe);if(n.incidentTo(s))r.ps.on(t)&&e.push(r.ps),r.pe.on(t)&&e.push(r.pe),t.ps.on(r)&&!t.ps.equalTo(r.ps)&&!t.ps.equalTo(r.pe)&&e.push(t.ps),t.pe.on(r)&&!t.pe.equalTo(r.ps)&&!t.pe.equalTo(r.pe)&&e.push(t.pe);else{let l=ct(n,s);l.length>0&&Oe(l[0],r)&&Oe(l[0],t)&&e.push(l[0])}return e}function Oe(r,t){const e=t.box;return i.Utils.LE(r.x,e.xmax)&&i.Utils.GE(r.x,e.xmin)&&i.Utils.LE(r.y,e.ymax)&&i.Utils.GE(r.y,e.ymin)}function Qt(r,t){let e=[];if(r.box.not_intersect(t.box))return e;if(r.isZeroLength()){let[l,o]=r.ps.distanceTo(t.pc);return i.Utils.EQ(l,t.r)&&e.push(r.ps),e}let n=new i.Line(r.ps,r.pe),s=at(n,t);for(let l of s)l.on(r)&&e.push(l);return e}function gt(r,t){let e=[];if(r.box.not_intersect(t.box))return e;if(r.isZeroLength())return r.ps.on(t)&&e.push(r.ps),e;let n=new i.Line(r.ps,r.pe),s=new i.Circle(t.pc,t.r),l=at(n,s);for(let o of l)o.on(r)&&o.on(t)&&e.push(o);return e}function kn(r,t){let e=[];for(let n of t.toSegments()){let s=Yt(n,r);for(let l of s)e.push(l)}return e}function Ne(r,t){let e=[];if(r.box.not_intersect(t.box))return e;let n=new i.Vector(r.pc,t.pc),s=r.r,l=t.r;if(i.Utils.EQ_0(s)||i.Utils.EQ_0(l))return e;if(i.Utils.EQ_0(n.x)&&i.Utils.EQ_0(n.y)&&i.Utils.EQ(s,l))return e.push(r.pc.translate(-s,0)),e;let o=r.pc.distanceTo(t.pc)[0];if(i.Utils.GT(o,s+l)||i.Utils.LT(o,Math.abs(s-l)))return e;n.x/=o,n.y/=o;let a;if(i.Utils.EQ(o,s+l)||i.Utils.EQ(o,Math.abs(s-l)))return a=r.pc.translate(s*n.x,s*n.y),e.push(a),e;let u=s*s/(2*o)-l*l/(2*o)+o/2,h=r.pc.translate(u*n.x,u*n.y),f=Math.sqrt(s*s-u*u);return a=h.translate(n.rotate90CCW().multiply(f)),e.push(a),a=h.translate(n.rotate90CW().multiply(f)),e.push(a),e}function Fn(r,t){let e=[];for(let n of t.toSegments()){let s=Qt(n,r);for(let l of s)e.push(l)}return e}function Ce(r,t){let e=[];if(r.box.not_intersect(t.box))return e;if(r.pc.equalTo(t.pc)&&i.Utils.EQ(r.r,t.r)){let o;return o=r.start,o.on(t)&&e.push(o),o=r.end,o.on(t)&&e.push(o),o=t.start,o.on(r)&&e.push(o),o=t.end,o.on(r)&&e.push(o),e}let n=new i.Circle(r.pc,r.r),s=new i.Circle(t.pc,t.r),l=n.intersect(s);for(let o of l)o.on(r)&&o.on(t)&&e.push(o);return e}function ne(r,t){let e=[];if(r.box.not_intersect(t.box))return e;if(t.pc.equalTo(r.pc)&&i.Utils.EQ(t.r,r.r))return e.push(r.start),e.push(r.end),e;let n=t,s=new i.Circle(r.pc,r.r),l=Ne(n,s);for(let o of l)o.on(r)&&e.push(o);return e}function Bn(r,t){let e=[];for(let n of t.toSegments()){let s=gt(n,r);for(let l of s)e.push(l)}return e}function Re(r,t){return r.isSegment?Yt(r.shape,t):gt(t,r.shape)}function Me(r,t){return r.isSegment?gt(r.shape,t):Ce(r.shape,t)}function Ue(r,t){return r.isSegment?Lt(r.shape,t):zt(t,r.shape)}function Vn(r,t){return r.isSegment?se(t,r.shape):oe(t,r.shape)}function Hn(r,t){return r.isSegment?Qt(r.shape,t):ne(r.shape,t)}function ie(r,t){let e=[];for(let n of t.edges)for(let s of Re(n,r))e.push(s);return e}function re(r,t){let e=[];for(let n of t.edges)for(let s of Me(n,r))e.push(s);return e}function Ot(r,t){let e=[];if(t.isEmpty())return e;for(let n of t.edges)for(let s of Ue(n,r))Ve(s,e)||e.push(s);return r.sortPoints(e)}function ke(r,t){let e=[];if(t.isEmpty())return e;for(let n of t.edges)for(let s of Hn(n,r))e.push(s);return e}function Fe(r,t){return r.isSegment?Re(t,r.shape):r.isArc?Me(t,r.shape):r.isLine?Ue(t,r.shape):r.isRay?Vn(t,r.shape):[]}function Be(r,t){let e=[];if(t.isEmpty()||r.shape.box.not_intersect(t.box))return e;let n=t.edges.search(r.shape.box);for(let s of n)e=[...e,...Fe(r,s)];return e}function $n(r,t){let e=[];if(t.isEmpty()||r.size===0)return e;for(let n of r)e=[...e,...Be(n,t)];return e}function Gn(r,t){let e=[];if(r.isEmpty()||t.isEmpty()||r.box.not_intersect(t.box))return e;for(let n of r.edges)e=[...e,...Be(n,t)];return e}function qn(r,t){return r instanceof i.Line?Ot(r,t):r instanceof i.Segment?ie(r,t):r instanceof i.Arc?re(r,t):[]}function Ve(r,t){return t.some(e=>e.equalTo(r))}function J(r){return new i.Line(r.start,r.norm)}function se(r,t){return Lt(t,J(r)).filter(e=>r.contains(e))}function oe(r,t){return zt(J(r),t).filter(e=>r.contains(e))}function He(r,t){return at(J(r),t).filter(e=>r.contains(e))}function Dn(r,t){return dt(J(r),t).filter(e=>r.contains(e))}function $e(r,t){return ct(J(r),t).filter(e=>r.contains(e))}function Wn(r,t){return ct(J(r),J(t)).filter(e=>r.contains(e)).filter(e=>t.contains(e))}function Ge(r,t){return Ot(J(r),t).filter(e=>r.contains(e))}function qe(r,t){if(r.intersect&&r.intersect instanceof Function)return r.intersect(t);throw T.UNSUPPORTED_SHAPE_TYPE}function Nt(r,t){let e=[];for(let n of t)e=[...e,...qe(r,n.shape)];return e}function zn(r,t){let e=[];for(let n of r)for(let s of t)e=[...e,...qe(n,s)];return e}let ft=class Gt extends ee{constructor(...t){if(super(),this.isInfinite=!1,t.length===1&&t[0]instanceof Array&&t[0].length>0){let e=!1;const n=t[0],s=n.length,l=u=>u instanceof i.Segment||u instanceof i.Arc||u instanceof i.Ray||u instanceof i.Line,o=u=>u instanceof i.Segment||u instanceof i.Arc||u instanceof i.Ray,a=u=>u instanceof i.Segment||u instanceof i.Arc;if(e=s===1&&l(n[0])||s>1&&o(n[0])&&o(n[s-1])&&n.slice(1,s-1).every(a),e){this.isInfinite=n.some(u=>u instanceof i.Ray||u instanceof i.Line);for(let u of n){let h=new i.Edge(u);this.append(h)}this.setArcLength()}else throw i.Errors.ILLEGAL_PARAMETERS}}get edges(){return[...this]}get box(){return this.edges.reduce((t,e)=>t.merge(e.box),new i.Box)}get vertices(){let t=this.edges.map(e=>e.start);return t.push(this.last.end),t}get length(){if(this.isEmpty())return 0;if(this.isInfinite)return Number.POSITIVE_INFINITY;let t=0;for(let e of this)t+=e.length;return t}clone(){return new Gt(this.toShapes())}setArcLength(){for(let t of this)this.setOneEdgeArcLength(t)}setOneEdgeArcLength(t){t===this.first?t.arc_length=0:t.arc_length=t.prev.arc_length+t.prev.length}pointAtLength(t){if(t>this.length||t<0||this.isInfinite)return null;let e=null;for(let n of this)if(t>=n.arc_length&&(n===this.last||t<n.next.arc_length)){e=n.pointAtLength(t-n.arc_length);break}return e}addVertex(t,e){let n=e.shape.split(t);if(n[0]===null)return e.prev;if(n[1]===null)return e;let s=new i.Edge(n[0]),l=e.prev;return this.insert(s,l),e.shape=n[1],s}getChain(t,e){let n=[];for(let s=t;s!==e.next;s=s.next)n.push(s);return n}split(t){for(let e of t){let n=this.findEdgeByPoint(e);this.addVertex(e,n)}return this}findEdgeByPoint(t){let e;for(let n of this)if(n.shape.contains(t)){e=n;break}return e}distanceTo(t){if(t instanceof Point){const[e,n]=i.Distance.shape2multiline(t,this);return[e,n.reverse()]}if(t instanceof i.Line){const[e,n]=i.Distance.shape2multiline(t,this);return[e,n.reverse()]}if(t instanceof i.Circle){const[e,n]=i.Distance.shape2multiline(t,this);return[e,n.reverse()]}if(t instanceof i.Segment){const[e,n]=i.Distance.shape2multiline(t,this);return[e,n.reverse()]}if(t instanceof i.Arc){const[e,n]=i.Distance.shape2multiline(t,this);return[e,n.reverse()]}if(t instanceof i.Multiline)return i.Distance.multiline2multiline(this,t);throw i.Errors.UNSUPPORTED_SHAPE_TYPE}intersect(t){return t instanceof i.Multiline?zn(this,t):Nt(t,this)}contains(t){if(t instanceof i.Point)return this.edges.some(e=>e.shape.contains(t));throw i.Errors.UNSUPPORTED_SHAPE_TYPE}translate(t){return new Gt(this.edges.map(e=>e.shape.translate(t)))}rotate(t=0,e=new i.Point){return new Gt(this.edges.map(n=>n.shape.rotate(t,e)))}transform(t=new i.Matrix){return new Gt(this.edges.map(e=>e.shape.transform(t)))}toShapes(){return this.edges.map(t=>t.shape.clone())}toJSON(){return this.edges.map(t=>t.toJSON())}svgPoints(){return this.vertices.map(t=>`${t.x},${t.y}`).join(" ")}dpath(){let t=`M${this.first.start.x},${this.first.start.y}`;for(let e of this)t+=e.svg();return t}svg(t={}){let e=`
<path ${lt({fill:"none",...t})} d="`;e+=`
M${this.first.start.x},${this.first.start.y}`;for(let n of this)e+=n.svg();return e+=`" >
</path>`,e}};i.Multiline=ft;const Yn=(...r)=>new i.Multiline(...r);i.multiline=Yn;function pt(r,t,e){let n=e.length,s=r.shape.split(t);if(s.length===0)return;let l=0;s[0]===null?l=0:s[1]===null?l=r.shape.length:l=s[0].length;let o=Jt;ot(l,0)&&(o|=bt),ot(l,r.shape.length)&&(o|=ht);let a;l===1/0?a=s[0].coord(t):a=o&ht&&r.next&&r.next.arc_length===0?0:r.arc_length+l,e.push({id:n,pt:t,arc_length:a,edge_before:r,edge_after:void 0,face:r.face,is_vertex:o})}function Ct(r){r.int_points1_sorted=tt(r.int_points1),r.int_points2_sorted=tt(r.int_points2)}function tt(r){let t=new Map,e=0;for(let s of r)t.has(s.face)||(t.set(s.face,e),e++);for(let s of r)s.faceId=t.get(s.face);return r.slice().sort(Qn)}function Qn(r,t){return r.faceId<t.faceId?-1:r.faceId>t.faceId?1:r.arc_length<t.arc_length?-1:r.arc_length>t.arc_length?1:0}function le(r){if(r.int_points1.length<2)return;let t=!1,e,n,s,l;for(let o=0;o<r.int_points1_sorted.length;o++)if(r.int_points1_sorted[o].id!==-1){e=r.int_points1_sorted[o],n=r.int_points2[e.id];for(let a=o+1;a<r.int_points1_sorted.length&&(s=r.int_points1_sorted[a],!!ot(s.arc_length,e.arc_length));a++)s.id!==-1&&(l=r.int_points2[s.id],l.id!==-1&&s.edge_before===e.edge_before&&s.edge_after===e.edge_after&&l.edge_before===n.edge_before&&l.edge_after===n.edge_after&&(s.id=-1,l.id=-1,t=!0))}n=r.int_points2_sorted[0],e=r.int_points1[n.id];for(let o=1;o<r.int_points2_sorted.length;o++){let a=r.int_points2_sorted[o];if(a.id===-1)continue;if(n.id===-1||!ot(a.arc_length,n.arc_length)){n=a,e=r.int_points1[n.id];continue}let u=r.int_points1[a.id];u.edge_before===e.edge_before&&u.edge_after===e.edge_after&&a.edge_before===n.edge_before&&a.edge_after===n.edge_after&&(u.id=-1,a.id=-1,t=!0)}t&&(r.int_points1=r.int_points1.filter(o=>o.id>=0),r.int_points2=r.int_points2.filter(o=>o.id>=0),r.int_points1.forEach((o,a)=>o.id=a),r.int_points2.forEach((o,a)=>o.id=a))}function ae(r){for(let t of r)t.edge_before&&(t.edge_before.bvStart=void 0,t.edge_before.bvEnd=void 0,t.edge_before.bv=void 0,t.edge_before.overlap=void 0),t.edge_after&&(t.edge_after.bvStart=void 0,t.edge_after.bvEnd=void 0,t.edge_after.bv=void 0,t.edge_after.overlap=void 0);for(let t of r)t.edge_before&&(t.edge_before.bvEnd=M),t.edge_after&&(t.edge_after.bvStart=M)}function fe(r,t){for(let e of r)e.edge_before&&e.edge_before.setInclusion(t),e.edge_after&&e.edge_after.setInclusion(t)}function jn(r){let t,e,n,s=r.int_points1.length;for(let l=0;l<s;l++){let o=r.int_points1_sorted[l];o.face!==t&&(e=l,t=o.face);let a=l,u=_t(r.int_points1_sorted,l,t),h;a+u<s&&r.int_points1_sorted[a+u].face===t?h=a+u:h=e;let f=_t(r.int_points1_sorted,h,t);n=null;for(let E=h;E<h+f;E++){let x=r.int_points1_sorted[E];if(x.face===t&&r.int_points2[x.id].face===r.int_points2[o.id].face){n=x;break}}if(n===null)continue;let g=o.edge_after,_=n.edge_before;if(!(g.bv===M&&_.bv===M)||g!==_)continue;let v=r.int_points2[o.id],S=r.int_points2[n.id],I=v.edge_after,y=S.edge_before;I.bv===M&&y.bv===M&&I===y||(v=r.int_points2[n.id],S=r.int_points2[o.id],I=v.edge_after,y=S.edge_before),I.bv===M&&y.bv===M&&I===y&&g.setOverlap(I)}}function _t(r,t,e){let n,s,l=1;if(r.length===1)return 1;n=r[t];for(let o=t+1;o<r.length&&!(n.face!==e||(s=r[o],!(s.pt.equalTo(n.pt)&&s.edge_before===n.edge_before&&s.edge_after===n.edge_after)));o++)l++;return l}function mt(r,t){if(t){for(let e of t){let n=e.edge_before;if(e.is_vertex=Jt,n.shape.start&&n.shape.start.equalTo(e.pt)&&(e.is_vertex|=bt),n.shape.end&&n.shape.end.equalTo(e.pt)&&(e.is_vertex|=ht),e.is_vertex&bt){e.edge_before=n.prev,n.prev&&(e.is_vertex=ht);continue}if(e.is_vertex&ht)continue;let s=r.addVertex(e.pt,n);e.edge_before=s}for(let e of t)e.edge_before?e.edge_after=e.edge_before.next:r instanceof ft&&e.is_vertex&bt&&(e.edge_after=r.first)}}function De(r,t,e){const n=r.edge_before,s=t.edge_after,l=e.length;n.next=e[0],e[0].prev=n,e[l-1].next=s,s.prev=e[l-1]}const{INSIDE:k,OUTSIDE:F,BOUNDARY:P,OVERLAP_SAME:Zn,OVERLAP_OPPOSITE:Xn}=Wt,{NOT_VERTEX:fr,START_VERTEX:We,END_VERTEX:ze}=Wt,jt=1,Rt=2,ut=3;function Kn(r,t){let[e,n]=Mt(r,t,jt,!0);return e}function ue(r,t){let n=t.clone().reverse(),[s,l]=Mt(r,n,ut,!0);return s}function Ye(r,t){let[e,n]=Mt(r,t,Rt,!0);return e}function Qe(r,t){let[e,n]=Mt(r,t,Rt,!1),s=[];for(let o of e.faces)s=[...s,...[...o.edges].map(a=>a.shape)];let l=[];for(let o of n.faces)l=[...l,...[...o.edges].map(a=>a.shape)];return[s,l]}function he(r,t){let[e,n]=Mt(r,t,ut,!1),s=[];for(let l of e.faces)s=[...s,...[...l.edges].map(o=>o.shape)];return s}function je(r,t){let e=r.clone(),n=t.clone(),s=Ze(e,n);Ct(s),mt(e,s.int_points1_sorted),mt(n,s.int_points2_sorted),le(s),Ct(s);let l=s.int_points1_sorted.map(a=>a.pt),o=s.int_points2_sorted.map(a=>a.pt);return[l,o]}function Jn(r,t,e,n){let s=Xe(r,e.int_points1),l=Xe(t,e.int_points2);for(Ke(s,t),Ke(l,r),ae(e.int_points1),ae(e.int_points2),fe(e.int_points1,t),fe(e.int_points2,r);ei(r,t,e.int_points1,e.int_points1_sorted,e.int_points2,e););jn(e),ce(r,n,e.int_points1_sorted,!0),ce(t,n,e.int_points2_sorted,!1),Je(r,s,n,!0),Je(t,l,n,!1)}function ti(r,t,e,n){ni(r,t,n,e.int_points2),ii(r,t,e),de(r,e.int_points1),de(t,e.int_points2),ge(r,e.int_points1,e.int_points2),ge(r,e.int_points2,e.int_points1)}function Mt(r,t,e,n){let s=r.clone(),l=t.clone(),o=Ze(s,l);return Ct(o),mt(s,o.int_points1_sorted),mt(l,o.int_points2_sorted),le(o),Ct(o),Jn(s,l,o,e),n&&ti(s,l,o,e),[s,l]}function Ze(r,t){let e={int_points1:[],int_points2:[]};for(let n of r.edges){let s=t.edges.search(n.box);for(let l of s){let o=n.shape.intersect(l.shape);for(let a of o)pt(n,a,e.int_points1),pt(l,a,e.int_points2)}}return e}function Xe(r,t){let e=[];for(let n of r.faces)t.find(s=>s.face===n)||e.push(n);return e}function Ke(r,t){for(let e of r)e.first.bv=e.first.bvStart=e.first.bvEnd=void 0,e.first.setInclusion(t)}function ei(r,t,e,n,s,l){let o,a,u,h=n.length,f=!1;for(let g=0;g<h;g++){let _=n[g];_.face!==o&&(a=g,o=_.face);let v=g,S=_t(n,g,o),I;v+S<h&&n[v+S].face===o?I=v+S:I=a;let y=_t(n,I,o);u=null;for(let p=I;p<I+y;p++){let O=n[p];if(O.face===o&&s[O.id].face===s[_.id].face){u=O;break}}if(u===null)continue;let E=_.edge_after,x=u.edge_before;if(E.bv===P&&x.bv!=P){E.bv=x.bv;continue}if(E.bv!=P&&x.bv===P){x.bv=E.bv;continue}if(E.bv===P&&x.bv===P&&E!=x||E.bv===k&&x.bv===F||E.bv===F&&x.bv===k){let p=E.next;for(;p!=x;)p.bvStart=void 0,p.bvEnd=void 0,p.bv=void 0,p.setInclusion(t),p=p.next}if(E.bv===P&&x.bv===P&&E!=x){let p=E.next,O;for(;p!=x;){if(p.bv!=P){if(O===void 0)O=p.bv;else if(p.bv!=O)throw T.UNRESOLVED_BOUNDARY_CONFLICT}p=p.next}O!=null&&(E.bv=O,x.bv=O);continue}if(E.bv===k&&x.bv===F||E.bv===F&&x.bv===k){let p=E;for(;p!=x;){if(p.bvStart===E.bv&&p.bvEnd===x.bv){let[O,Ie]=p.shape.distanceTo(t);if(O<10*i.DP_TOL){pt(p,Ie.ps,e);let rt=e[e.length-1];if(rt.is_vertex&We)rt.edge_after=p,rt.edge_before=p.prev,p.bvStart=P,p.bv=void 0,p.setInclusion(t);else if(rt.is_vertex&ze)rt.edge_after=p.next,p.bvEnd=P,p.bv=void 0,p.setInclusion(t);else{let j=t.addVertex(rt.pt,p);rt.edge_before=j,rt.edge_after=j.next,j.setInclusion(t),j.next.bvStart=P,j.next.bvEnd=void 0,j.next.bv=void 0,j.next.setInclusion(t)}let yt=t.findEdgeByPoint(Ie.pe);pt(yt,Ie.pe,s);let st=s[s.length-1];if(st.is_vertex&We)st.edge_after=yt,st.edge_before=yt.prev;else if(st.is_vertex&ze)st.edge_after=yt.next;else{let j=s.find(or=>or.edge_after===yt),R=t.addVertex(st.pt,yt);st.edge_before=R,st.edge_after=R.next,j&&(j.edge_after=R),R.bvStart=void 0,R.bvEnd=P,R.bv=void 0,R.setInclusion(r),R.next.bvStart=P,R.next.bvEnd=void 0,R.next.bv=void 0,R.next.setInclusion(r)}Ct(l),f=!0;break}}p=p.next}if(f)break;throw T.UNRESOLVED_BOUNDARY_CONFLICT}}return f}function ce(r,t,e,n){if(!e)return;let s,l,o,a;for(let u=0;u<e.length;u++){if(o=e[u],o.face!==s&&(l=u,s=o.face),s.isEmpty())continue;let h=u,f=_t(e,u,s),g;h+f<e.length&&e[h+f].face===o.face?g=h+f:g=l,a=e[g];let _=g,v=_t(e,_,s),S=o.edge_after,I=a.edge_before;if(S.bv===k&&I.bv===k&&t===jt||S.bv===F&&I.bv===F&&t===Rt||(S.bv===F||I.bv===F)&&t===ut&&!n||(S.bv===k||I.bv===k)&&t===ut&&n||S.bv===P&&I.bv===P&&S.overlap&Zn&&n||S.bv===P&&I.bv===P&&S.overlap&Xn){r.removeChain(s,S,I);for(let y=h;y<h+f;y++)e[y].edge_after=void 0;for(let y=_;y<_+v;y++)e[y].edge_before=void 0}u+=f-1}}function ni(r,t,e,n){for(let s of t.faces){for(let l of s)r.edges.add(l);n.find(l=>l.face===s)===void 0&&r.addFace(s.first,s.last)}}function ii(r,t,e){if(e.int_points1.length!==0)for(let n=0;n<e.int_points1.length;n++){let s=e.int_points1[n],l=e.int_points2[n];if(s.edge_before!==void 0&&s.edge_after===void 0&&l.edge_before===void 0&&l.edge_after!==void 0&&(s.edge_before.next=l.edge_after,l.edge_after.prev=s.edge_before,s.edge_after=l.edge_after,l.edge_before=s.edge_before),l.edge_before!==void 0&&l.edge_after===void 0&&s.edge_before===void 0&&s.edge_after!==void 0&&(l.edge_before.next=s.edge_after,s.edge_after.prev=l.edge_before,l.edge_after=s.edge_after,s.edge_before=l.edge_before),s.edge_before!==void 0&&s.edge_after===void 0)for(let o of e.int_points1_sorted)o!==s&&o.edge_before===void 0&&o.edge_after!==void 0&&o.pt.equalTo(s.pt)&&(s.edge_before.next=o.edge_after,o.edge_after.prev=s.edge_before,s.edge_after=o.edge_after,o.edge_before=s.edge_before);if(l.edge_before!==void 0&&l.edge_after===void 0)for(let o of e.int_points2_sorted)o!==l&&o.edge_before===void 0&&o.edge_after!==void 0&&o.pt.equalTo(l.pt)&&(l.edge_before.next=o.edge_after,o.edge_after.prev=l.edge_before,l.edge_after=o.edge_after,o.edge_before=l.edge_before)}}function de(r,t){for(let e of t)r.faces.delete(e.face),e.face=void 0,e.edge_before&&(e.edge_before.face=void 0),e.edge_after&&(e.edge_after.face=void 0)}function ge(r,t,e){for(let n of t){if(n.edge_before===void 0||n.edge_after===void 0||n.face||n.edge_after.face||n.edge_before.face)continue;let s=n.edge_after,l=n.edge_before;try{ee.testInfiniteLoop(s)}catch{throw T.CANNOT_COMPLETE_BOOLEAN_OPERATION}let o=r.addFace(s,l);for(let a of t)a.edge_before&&a.edge_after&&a.edge_before.face===o&&a.edge_after.face===o&&(a.face=o);for(let a of e)a.edge_before&&a.edge_after&&a.edge_before.face===o&&a.edge_after.face===o&&(a.face=o)}}function Je(r,t,e,n){for(let s of t){let l=s.first.bv;(e===jt&&l===k||e===ut&&l===k&&n||e===ut&&l===F&&!n||e===Rt&&l===F)&&r.deleteFace(s)}}var ri=Object.freeze({__proto__:null,BOOLEAN_INTERSECT:Rt,BOOLEAN_SUBTRACT:ut,BOOLEAN_UNION:jt,calculateIntersections:je,innerClip:Qe,intersect:Ye,outerClip:he,removeNotRelevantChains:ce,removeOldFaces:de,restoreFaces:ge,subtract:ue,unify:Kn});const si=RegExp("T.F..FFF.|T.F...F.."),oi=RegExp("T........|.T.......|...T.....|....T...."),li=RegExp("FT.......|F..T.....|F...T...."),ai=RegExp("T.F..F..."),fi=RegExp("T.F..F...|.TF..F...|..FT.F...|..F.TF...");class Et{constructor(){this.m=new Array(9).fill(void 0)}get I2I(){return this.m[0]}set I2I(t){this.m[0]=t}get I2B(){return this.m[1]}set I2B(t){this.m[1]=t}get I2E(){return this.m[2]}set I2E(t){this.m[2]=t}get B2I(){return this.m[3]}set B2I(t){this.m[3]=t}get B2B(){return this.m[4]}set B2B(t){this.m[4]=t}get B2E(){return this.m[5]}set B2E(t){this.m[5]=t}get E2I(){return this.m[6]}set E2I(t){this.m[6]=t}get E2B(){return this.m[7]}set E2B(t){this.m[7]=t}get E2E(){return this.m[8]}set E2E(t){this.m[8]=t}toString(){return this.m.map(t=>t instanceof Array&&t.length>0?"T":t instanceof Array&&t.length===0?"F":"*").join("")}equal(){return si.test(this.toString())}intersect(){return oi.test(this.toString())}touch(){return li.test(this.toString())}inside(){return ai.test(this.toString())}covered(){return fi.test(this.toString())}}function Ut(r,t){let e,n=new i.Ray(t),s=new i.Line(n.pt,n.norm);const l=new i.Box(n.box.xmin-i.DP_TOL,n.box.ymin-i.DP_TOL,n.box.xmax,n.box.ymax+i.DP_TOL);if(r.box.not_intersect(l))return i.OUTSIDE;let o=r.edges.search(l);if(o.length===0)return i.OUTSIDE;for(let f of o)if(f.shape.contains(t))return i.BOUNDARY;let a=[...r.faces],u=[];for(let f of o)for(let g of n.intersect(f.shape)){if(g.equalTo(t))return i.BOUNDARY;u.push({pt:g,edge:f,face_index:a.indexOf(f.face)})}u.sort((f,g)=>be(f.pt.x,g.pt.x)?-1:Ae(f.pt.x,g.pt.x)?1:f.face_index<g.face_index?-1:f.face_index>g.face_index?1:f.edge.arc_length<g.edge.arc_length?-1:f.edge.arc_length>g.edge.arc_length?1:0);let h=0;for(let f=0;f<u.length;f++){let g=u[f];if(g.pt.equalTo(g.edge.shape.start)){if(f>0&&g.pt.equalTo(u[f-1].pt)&&g.face_index===u[f-1].face_index&&g.edge.prev===u[f-1].edge)continue;let _=g.edge.prev;for(;te(_.length);)_=_.prev;let v=_.shape.tangentInEnd(),S=g.pt.translate(v),I=g.edge.shape.tangentInStart(),y=g.pt.translate(I),E=S.leftTo(s),x=y.leftTo(s);(E&&!x||!E&&x)&&h++}else if(g.pt.equalTo(g.edge.shape.end)){if(f>0&&g.pt.equalTo(u[f-1].pt)&&g.face_index===u[f-1].face_index&&g.edge.next===u[f-1].edge)continue;let _=g.edge.next;for(;te(_.length);)_=_.next;let v=_.shape.tangentInStart(),S=g.pt.translate(v),I=g.edge.shape.tangentInEnd(),y=g.pt.translate(I),E=S.leftTo(s),x=y.leftTo(s);(E&&!x||!E&&x)&&h++}else if(g.edge.shape instanceof i.Segment)h++;else{let _=g.edge.shape.box;ot(g.pt.y,_.ymin)||ot(g.pt.y,_.ymax)||h++}}return e=h%2===1?Dt:we,e}function ui(r,t){return xt(r,t).equal()}function tn(r,t){return xt(r,t).intersect()}function hi(r,t){return xt(r,t).touch()}function ci(r,t){return!tn(r,t)}function en(r,t){return xt(r,t).inside()}function nn(r,t){return xt(r,t).covered()}function di(r,t){return en(t,r)}function rn(r,t){return nn(t,r)}function xt(r,t){if(r instanceof i.Line&&t instanceof i.Line)return gi(r,t);if(r instanceof i.Line&&t instanceof i.Circle)return pi(r,t);if(r instanceof i.Line&&t instanceof i.Box)return _i(r,t);if(r instanceof i.Line&&t instanceof i.Polygon)return mi(r,t);if((r instanceof i.Segment||r instanceof i.Arc)&&t instanceof i.Polygon)return sn(r,t);if((r instanceof i.Segment||r instanceof i.Arc)&&(t instanceof i.Circle||t instanceof i.Box))return sn(r,new i.Polygon(t));if(r instanceof i.Polygon&&t instanceof i.Polygon)return Zt(r,t);if((r instanceof i.Circle||r instanceof i.Box)&&(t instanceof i.Circle||t instanceof i.Box))return Zt(new i.Polygon(r),new i.Polygon(t));if((r instanceof i.Circle||r instanceof i.Box)&&t instanceof i.Polygon)return Zt(new i.Polygon(r),t);if(r instanceof i.Polygon&&(t instanceof i.Circle||t instanceof i.Box))return Zt(r,new i.Polygon(t))}function gi(r,t){let e=new Et,n=ct(r,t);return n.length===0?r.contains(t.pt)&&t.contains(r.pt)?(e.I2I=[r],e.I2E=[],e.E2I=[]):(e.I2I=[],e.I2E=[r],e.E2I=[t]):(e.I2I=n,e.I2E=r.split(n),e.E2I=t.split(n)),e}function pi(r,t){let e=new Et,n=at(r,t);if(n.length===0)e.I2I=[],e.I2B=[],e.I2E=[r],e.E2I=[t];else if(n.length===1)e.I2I=[],e.I2B=n,e.I2E=r.split(n),e.E2I=[t];else{let s=new ft([r]),l=r.sortPoints(n);s.split(l);let o=s.toShapes();e.I2I=[o[1]],e.I2B=l,e.I2E=[o[0],o[2]],e.E2I=new i.Polygon([t.toArc()]).cutWithLine(r)}return e}function _i(r,t){let e=new Et,n=dt(r,t);if(n.length===0)e.I2I=[],e.I2B=[],e.I2E=[r],e.E2I=[t];else if(n.length===1)e.I2I=[],e.I2B=n,e.I2E=r.split(n),e.E2I=[t];else{let s=new ft([r]),l=r.sortPoints(n);s.split(l);let o=s.toShapes();t.toSegments().some(a=>a.contains(n[0])&&a.contains(n[1]))?(e.I2I=[],e.I2B=[o[1]],e.I2E=[o[0],o[2]],e.E2I=[t]):(e.I2I=[o[1]],e.I2B=l,e.I2E=[o[0],o[2]],e.E2I=new i.Polygon(t.toSegments()).cutWithLine(r))}return e}function mi(r,t){let e=new Et,n=Ot(r,t),s=new ft([r]),l=n.length>0?n.slice():r.sortPoints(n);return s.split(l),[...s].forEach(o=>o.setInclusion(t)),e.I2I=[...s].filter(o=>o.bv===i.INSIDE).map(o=>o.shape),e.I2B=[...s].slice(1).map(o=>o.bv===i.BOUNDARY?o.shape:o.shape.start),e.I2E=[...s].filter(o=>o.bv===i.OUTSIDE).map(o=>o.shape),e.E2I=t.cutWithLine(r),e}function sn(r,t){let e=new Et,n=qn(r,t),s=n.length>0?n.slice():r.sortPoints(n),l=new ft([r]);l.split(s),[...l].forEach(o=>o.setInclusion(t)),e.I2I=[...l].filter(o=>o.bv===i.INSIDE).map(o=>o.shape),e.I2B=[...l].slice(1).map(o=>o.bv===i.BOUNDARY?o.shape:o.shape.start),e.I2E=[...l].filter(o=>o.bv===i.OUTSIDE).map(o=>o.shape),e.B2I=[],e.B2B=[],e.B2E=[];for(let o of[r.start,r.end])switch(Ut(t,o)){case i.INSIDE:e.B2I.push(o);break;case i.BOUNDARY:e.B2B.push(o);break;case i.OUTSIDE:e.B2E.push(o);break}return e}function Zt(r,t){let e=new Et,[n,s]=je(r,t),l=Ye(r,t),o=ue(r,t),a=ue(t,r),[u,h]=Qe(r,t),f=he(r,t),g=he(t,r);return e.I2I=l.isEmpty()?[]:[l],e.I2B=h,e.I2E=o.isEmpty()?[]:[o],e.B2I=u,e.B2B=n,e.B2E=f,e.E2I=a.isEmpty()?[]:[a],e.E2B=g,e}var Ei=Object.freeze({__proto__:null,contain:di,cover:rn,covered:nn,disjoint:ci,equal:ui,inside:en,intersect:tn,relate:xt,touch:hi});let kt=class Pt{constructor(t=1,e=0,n=0,s=1,l=0,o=0){this.a=t,this.b=e,this.c=n,this.d=s,this.tx=l,this.ty=o}clone(){return new Pt(this.a,this.b,this.c,this.d,this.tx,this.ty)}transform(t){return[t[0]*this.a+t[1]*this.c+this.tx,t[0]*this.b+t[1]*this.d+this.ty]}multiply(t){return new Pt(this.a*t.a+this.c*t.b,this.b*t.a+this.d*t.b,this.a*t.c+this.c*t.d,this.b*t.c+this.d*t.d,this.a*t.tx+this.c*t.ty+this.tx,this.b*t.tx+this.d*t.ty+this.ty)}translate(...t){let e,n;if(t.length==1&&!isNaN(t[0].x)&&!isNaN(t[0].y))e=t[0].x,n=t[0].y;else if(t.length===2&&typeof t[0]=="number"&&typeof t[1]=="number")e=t[0],n=t[1];else throw T.ILLEGAL_PARAMETERS;return this.multiply(new Pt(1,0,0,1,e,n))}rotate(t,e=0,n=0){let s=Math.cos(t),l=Math.sin(t);return this.translate(e,n).multiply(new Pt(s,l,-l,s,0,0)).translate(-e,-n)}scale(t,e){return this.multiply(new Pt(t,0,0,e,0,0))}equalTo(t){return!(!i.Utils.EQ(this.tx,t.tx)||!i.Utils.EQ(this.ty,t.ty)||!i.Utils.EQ(this.a,t.a)||!i.Utils.EQ(this.b,t.b)||!i.Utils.EQ(this.c,t.c)||!i.Utils.EQ(this.d,t.d))}};i.Matrix=kt;const xi=(...r)=>new i.Matrix(...r);i.matrix=xi;const Ti=class Se{constructor(t,e){this.low=t,this.high=e}clone(){return new Se(this.low,this.high)}get max(){return this.clone()}less_than(t){return this.low<t.low||this.low==t.low&&this.high<t.high}equal_to(t){return this.low==t.low&&this.high==t.high}intersect(t){return!this.not_intersect(t)}not_intersect(t){return this.high<t.low||t.high<this.low}merge(t){return new Se(this.low===void 0?t.low:Math.min(this.low,t.low),this.high===void 0?t.high:Math.max(this.high,t.high))}output(){return[this.low,this.high]}static comparable_max(t,e){return t.merge(e)}static comparable_less_than(t,e){return t<e}},b=0,m=1;class Tt{constructor(t=void 0,e=void 0,n=null,s=null,l=null,o=m){this.left=n,this.right=s,this.parent=l,this.color=o,this.item={key:t,value:e},t&&t instanceof Array&&t.length==2&&!Number.isNaN(t[0])&&!Number.isNaN(t[1])&&(this.item.key=new Ti(Math.min(t[0],t[1]),Math.max(t[0],t[1]))),this.max=this.item.key?this.item.key.max:void 0}isNil(){return this.item.key===void 0&&this.item.value===void 0&&this.left===null&&this.right===null&&this.color===m}_value_less_than(t){return this.item.value&&t.item.value&&this.item.value.less_than?this.item.value.less_than(t.item.value):this.item.value<t.item.value}less_than(t){return this.item.value===this.item.key&&t.item.value===t.item.key?this.item.key.less_than(t.item.key):this.item.key.less_than(t.item.key)||this.item.key.equal_to(t.item.key)&&this._value_less_than(t)}_value_equal(t){return this.item.value&&t.item.value&&this.item.value.equal_to?this.item.value.equal_to(t.item.value):this.item.value==t.item.value}equal_to(t){return this.item.value===this.item.key&&t.item.value===t.item.key?this.item.key.equal_to(t.item.key):this.item.key.equal_to(t.item.key)&&this._value_equal(t)}intersect(t){return this.item.key.intersect(t.item.key)}copy_data(t){this.item.key=t.item.key,this.item.value=t.item.value}update_max(){if(this.max=this.item.key?this.item.key.max:void 0,this.right&&this.right.max){const t=this.item.key.constructor.comparable_max;this.max=t(this.max,this.right.max)}if(this.left&&this.left.max){const t=this.item.key.constructor.comparable_max;this.max=t(this.max,this.left.max)}}not_intersect_left_subtree(t){const e=this.item.key.constructor.comparable_less_than;let n=this.left.max.high!==void 0?this.left.max.high:this.left.max;return e(n,t.item.key.low)}not_intersect_right_subtree(t){const e=this.item.key.constructor.comparable_less_than;let n=this.right.max.low!==void 0?this.right.max.low:this.right.item.key.low;return e(t.item.key.high,n)}}class Ft{constructor(){this.root=null,this.nil_node=new Tt}get size(){let t=0;return this.tree_walk(this.root,()=>t++),t}get keys(){let t=[];return this.tree_walk(this.root,e=>t.push(e.item.key.output?e.item.key.output():e.item.key)),t}get values(){let t=[];return this.tree_walk(this.root,e=>t.push(e.item.value)),t}get items(){let t=[];return this.tree_walk(this.root,e=>t.push({key:e.item.key.output?e.item.key.output():e.item.key,value:e.item.value})),t}isEmpty(){return this.root==null||this.root==this.nil_node}clear(){this.root=null}insert(t,e=t){if(t===void 0)return;let n=new Tt(t,e,this.nil_node,this.nil_node,null,b);return this.tree_insert(n),this.recalc_max(n),n}exist(t,e=t){let n=new Tt(t,e);return!!this.tree_search(this.root,n)}remove(t,e=t){let n=new Tt(t,e),s=this.tree_search(this.root,n);return s&&this.tree_delete(s),s}search(t,e=(n,s)=>n===s?s.output():n){let n=new Tt(t),s=[];return this.tree_search_interval(this.root,n,s),s.map(l=>e(l.item.value,l.item.key))}intersect_any(t){let e=new Tt(t);return this.tree_find_any_interval(this.root,e)}forEach(t){this.tree_walk(this.root,e=>t(e.item.key,e.item.value))}map(t){const e=new Ft;return this.tree_walk(this.root,n=>e.insert(n.item.key,t(n.item.value,n.item.key))),e}recalc_max(t){let e=t;for(;e.parent!=null;)e.parent.update_max(),e=e.parent}tree_insert(t){let e=this.root,n=null;if(this.root==null||this.root==this.nil_node)this.root=t;else{for(;e!=this.nil_node;)n=e,t.less_than(e)?e=e.left:e=e.right;t.parent=n,t.less_than(n)?n.left=t:n.right=t}this.insert_fixup(t)}insert_fixup(t){let e,n;for(e=t;e!=this.root&&e.parent.color==b;)e.parent==e.parent.parent.left?(n=e.parent.parent.right,n.color==b?(e.parent.color=m,n.color=m,e.parent.parent.color=b,e=e.parent.parent):(e==e.parent.right&&(e=e.parent,this.rotate_left(e)),e.parent.color=m,e.parent.parent.color=b,this.rotate_right(e.parent.parent))):(n=e.parent.parent.left,n.color==b?(e.parent.color=m,n.color=m,e.parent.parent.color=b,e=e.parent.parent):(e==e.parent.left&&(e=e.parent,this.rotate_right(e)),e.parent.color=m,e.parent.parent.color=b,this.rotate_left(e.parent.parent)));this.root.color=m}tree_delete(t){let e,n;t.left==this.nil_node||t.right==this.nil_node?e=t:e=this.tree_successor(t),e.left!=this.nil_node?n=e.left:n=e.right,n.parent=e.parent,e==this.root?this.root=n:(e==e.parent.left?e.parent.left=n:e.parent.right=n,e.parent.update_max()),this.recalc_max(n),e!=t&&(t.copy_data(e),t.update_max(),this.recalc_max(t)),e.color==m&&this.delete_fixup(n)}delete_fixup(t){let e=t,n;for(;e!=this.root&&e.parent!=null&&e.color==m;)e==e.parent.left?(n=e.parent.right,n.color==b&&(n.color=m,e.parent.color=b,this.rotate_left(e.parent),n=e.parent.right),n.left.color==m&&n.right.color==m?(n.color=b,e=e.parent):(n.right.color==m&&(n.color=b,n.left.color=m,this.rotate_right(n),n=e.parent.right),n.color=e.parent.color,e.parent.color=m,n.right.color=m,this.rotate_left(e.parent),e=this.root)):(n=e.parent.left,n.color==b&&(n.color=m,e.parent.color=b,this.rotate_right(e.parent),n=e.parent.left),n.left.color==m&&n.right.color==m?(n.color=b,e=e.parent):(n.left.color==m&&(n.color=b,n.right.color=m,this.rotate_left(n),n=e.parent.left),n.color=e.parent.color,e.parent.color=m,n.left.color=m,this.rotate_right(e.parent),e=this.root));e.color=m}tree_search(t,e){if(!(t==null||t==this.nil_node))return e.equal_to(t)?t:e.less_than(t)?this.tree_search(t.left,e):this.tree_search(t.right,e)}tree_search_interval(t,e,n){t!=null&&t!=this.nil_node&&(t.left!=this.nil_node&&!t.not_intersect_left_subtree(e)&&this.tree_search_interval(t.left,e,n),t.intersect(e)&&n.push(t),t.right!=this.nil_node&&!t.not_intersect_right_subtree(e)&&this.tree_search_interval(t.right,e,n))}tree_find_any_interval(t,e){let n=!1;return t!=null&&t!=this.nil_node&&(t.left!=this.nil_node&&!t.not_intersect_left_subtree(e)&&(n=this.tree_find_any_interval(t.left,e)),n||(n=t.intersect(e)),!n&&t.right!=this.nil_node&&!t.not_intersect_right_subtree(e)&&(n=this.tree_find_any_interval(t.right,e))),n}local_minimum(t){let e=t;for(;e.left!=null&&e.left!=this.nil_node;)e=e.left;return e}local_maximum(t){let e=t;for(;e.right!=null&&e.right!=this.nil_node;)e=e.right;return e}tree_successor(t){let e,n,s;if(t.right!=this.nil_node)e=this.local_minimum(t.right);else{for(n=t,s=t.parent;s!=null&&s.right==n;)n=s,s=s.parent;e=s}return e}rotate_left(t){let e=t.right;t.right=e.left,e.left!=this.nil_node&&(e.left.parent=t),e.parent=t.parent,t==this.root?this.root=e:t==t.parent.left?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e,t!=null&&t!=this.nil_node&&t.update_max(),e=t.parent,e!=null&&e!=this.nil_node&&e.update_max()}rotate_right(t){let e=t.left;t.left=e.right,e.right!=this.nil_node&&(e.right.parent=t),e.parent=t.parent,t==this.root?this.root=e:t==t.parent.left?t.parent.left=e:t.parent.right=e,e.right=t,t.parent=e,t!=null&&t!=this.nil_node&&t.update_max(),e=t.parent,e!=null&&e!=this.nil_node&&e.update_max()}tree_walk(t,e){t!=null&&t!=this.nil_node&&(this.tree_walk(t.left,e),e(t),this.tree_walk(t.right,e))}testRedBlackProperty(){let t=!0;return this.tree_walk(this.root,function(e){e.color==b&&(e.left.color==m&&e.right.color==m||(t=!1))}),t}testBlackHeightProperty(t){let e=0,n=0,s=0;if(t.color==m&&e++,t.left!=this.nil_node?n=this.testBlackHeightProperty(t.left):n=1,t.right!=this.nil_node?s=this.testBlackHeightProperty(t.right):s=1,n!=s)throw new Error("Red-black height property violated");return e+=n,e}}class Ii extends Set{constructor(t){super(t),this.index=new Ft,this.forEach(e=>this.index.insert(e))}add(t){let e=this.size;const{key:n,value:s}=t,l=n||t.box,o=s||t;return super.add(o),this.size>e&&this.index.insert(l,o),this}delete(t){const{key:e,value:n}=t,s=e||t.box,l=n||t;let o=super.delete(l);return o&&this.index.remove(s,l),o}clear(){super.clear(),this.index=new Ft}search(t){return this.index.search(t)}hit(t){let e=new i.Box(t.x-1,t.y-1,t.x+1,t.y+1);return this.index.search(e).filter(s=>t.on(s))}svg(){return[...this].reduce((e,n)=>e+n.svg(),"")}}i.PlanarSet=Ii;class et{get name(){throw T.CANNOT_INVOKE_ABSTRACT_METHOD}get box(){throw T.CANNOT_INVOKE_ABSTRACT_METHOD}clone(){throw T.CANNOT_INVOKE_ABSTRACT_METHOD}translate(...t){return this.transform(new kt().translate(...t))}rotate(t,e=new i.Point){return this.transform(new kt().rotate(t,e.x,e.y))}scale(t,e){return this.transform(new kt().scale(t,e))}transform(...t){throw T.CANNOT_INVOKE_ABSTRACT_METHOD}toJSON(){return Object.assign({},this,{name:this.name})}svg(t={}){throw T.CANNOT_INVOKE_ABSTRACT_METHOD}}let Si=class wn extends et{constructor(...t){if(super(),this.x=0,this.y=0,t.length!==0){if(t.length===1&&t[0]instanceof Array&&t[0].length===2){let e=t[0];if(typeof e[0]=="number"&&typeof e[1]=="number"){this.x=e[0],this.y=e[1];return}}if(t.length===1&&t[0]instanceof Object&&t[0].name==="point"){let{x:e,y:n}=t[0];this.x=e,this.y=n;return}if(t.length===2&&typeof t[0]=="number"&&typeof t[1]=="number"){this.x=t[0],this.y=t[1];return}throw T.ILLEGAL_PARAMETERS}}get box(){return new i.Box(this.x,this.y,this.x,this.y)}clone(){return new i.Point(this.x,this.y)}get vertices(){return[this.clone()]}equalTo(t){return i.Utils.EQ(this.x,t.x)&&i.Utils.EQ(this.y,t.y)}lessThan(t){return!!(i.Utils.LT(this.y,t.y)||i.Utils.EQ(this.y,t.y)&&i.Utils.LT(this.x,t.x))}transform(t){return new i.Point(t.transform([this.x,this.y]))}projectionOn(t){if(this.equalTo(t.pt))return this.clone();let e=new i.Vector(this,t.pt);if(i.Utils.EQ_0(e.cross(t.norm)))return t.pt.clone();let n=e.dot(t.norm),s=t.norm.multiply(n);return this.translate(s)}leftTo(t){let e=new i.Vector(t.pt,this);return i.Utils.GT(e.dot(t.norm),0)}distanceTo(t){if(t instanceof wn){let e=t.x-this.x,n=t.y-this.y;return[Math.sqrt(e*e+n*n),new i.Segment(this,t)]}if(t instanceof i.Line)return i.Distance.point2line(this,t);if(t instanceof i.Circle)return i.Distance.point2circle(this,t);if(t instanceof i.Segment)return i.Distance.point2segment(this,t);if(t instanceof i.Arc)return i.Distance.point2arc(this,t);if(t instanceof i.Polygon)return i.Distance.point2polygon(this,t);if(t instanceof i.PlanarSet)return i.Distance.shape2planarSet(this,t);if(t instanceof i.Multiline)return i.Distance.shape2multiline(this,t)}on(t){if(t instanceof i.Point)return this.equalTo(t);if(t.contains&&t.contains instanceof Function)return t.contains(this);throw i.Errors.UNSUPPORTED_SHAPE_TYPE}get name(){return"point"}svg(t={}){const e=t.r??3;return`
<circle cx="${this.x}" cy="${this.y}" r="${e}"
            ${lt({fill:"red",...t})} />`}};i.Point=Si;const vi=(...r)=>new i.Point(...r);i.point=vi;let wi=class extends et{constructor(...t){if(super(),this.x=0,this.y=0,t.length!==0){if(t.length===1&&t[0]instanceof Array&&t[0].length===2){let e=t[0];if(typeof e[0]=="number"&&typeof e[1]=="number"){this.x=e[0],this.y=e[1];return}}if(t.length===1&&t[0]instanceof Object&&t[0].name==="vector"){let{x:e,y:n}=t[0];this.x=e,this.y=n;return}if(t.length===2){let e=t[0],n=t[1];if(typeof e=="number"&&typeof n=="number"){this.x=e,this.y=n;return}if(e instanceof i.Point&&n instanceof i.Point){this.x=n.x-e.x,this.y=n.y-e.y;return}}throw T.ILLEGAL_PARAMETERS}}clone(){return new i.Vector(this.x,this.y)}get slope(){let t=Math.atan2(this.y,this.x);return t<0&&(t=2*Math.PI+t),t}get length(){return Math.sqrt(this.dot(this))}equalTo(t){return i.Utils.EQ(this.x,t.x)&&i.Utils.EQ(this.y,t.y)}multiply(t){return new i.Vector(t*this.x,t*this.y)}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}normalize(){if(!i.Utils.EQ_0(this.length))return new i.Vector(this.x/this.length,this.y/this.length);throw T.ZERO_DIVISION}rotate(t,e=new i.Point){if(e.x===0&&e.y===0)return this.transform(new kt().rotate(t));throw T.OPERATION_IS_NOT_SUPPORTED}transform(t){return new i.Vector(t.transform([this.x,this.y]))}rotate90CCW(){return new i.Vector(-this.y,this.x)}rotate90CW(){return new i.Vector(this.y,-this.x)}invert(){return new i.Vector(-this.x,-this.y)}add(t){return new i.Vector(this.x+t.x,this.y+t.y)}subtract(t){return new i.Vector(this.x-t.x,this.y-t.y)}angleTo(t){let e=this.normalize(),n=t.normalize(),s=Math.atan2(e.cross(n),e.dot(n));return s<0&&(s+=2*Math.PI),s}projectionOn(t){let e=t.normalize(),n=this.dot(e);return e.multiply(n)}get name(){return"vector"}};i.Vector=wi;const on=(...r)=>new i.Vector(...r);i.vector=on;let yi=class ve extends et{constructor(...t){if(super(),this.ps=new i.Point,this.pe=new i.Point,t.length!==0){if(t.length===1&&t[0]instanceof Array&&t[0].length===4){let e=t[0];this.ps=new i.Point(e[0],e[1]),this.pe=new i.Point(e[2],e[3]);return}if(t.length===1&&t[0]instanceof Object&&t[0].name==="segment"){let{ps:e,pe:n}=t[0];this.ps=new i.Point(e.x,e.y),this.pe=new i.Point(n.x,n.y);return}if(t.length===1&&t[0]instanceof i.Point){this.ps=t[0].clone();return}if(t.length===2&&t[0]instanceof i.Point&&t[1]instanceof i.Point){this.ps=t[0].clone(),this.pe=t[1].clone();return}if(t.length===4){this.ps=new i.Point(t[0],t[1]),this.pe=new i.Point(t[2],t[3]);return}throw T.ILLEGAL_PARAMETERS}}clone(){return new i.Segment(this.start,this.end)}get start(){return this.ps}get end(){return this.pe}get vertices(){return[this.ps.clone(),this.pe.clone()]}get length(){return this.start.distanceTo(this.end)[0]}get slope(){return new i.Vector(this.start,this.end).slope}get box(){return new i.Box(Math.min(this.start.x,this.end.x),Math.min(this.start.y,this.end.y),Math.max(this.start.x,this.end.x),Math.max(this.start.y,this.end.y))}equalTo(t){return this.ps.equalTo(t.ps)&&this.pe.equalTo(t.pe)}contains(t){return i.Utils.EQ_0(this.distanceToPoint(t))}intersect(t){if(t instanceof i.Point)return this.contains(t)?[t]:[];if(t instanceof i.Line)return Lt(this,t);if(t instanceof i.Ray)return se(t,this);if(t instanceof i.Segment)return Yt(this,t);if(t instanceof i.Circle)return Qt(this,t);if(t instanceof i.Box)return kn(this,t);if(t instanceof i.Arc)return gt(this,t);if(t instanceof i.Polygon)return ie(this,t);if(t instanceof i.Multiline)return Nt(this,t)}distanceTo(t){if(t instanceof i.Point){let[e,n]=i.Distance.point2segment(t,this);return n=n.reverse(),[e,n]}if(t instanceof i.Circle){let[e,n]=i.Distance.segment2circle(this,t);return[e,n]}if(t instanceof i.Line){let[e,n]=i.Distance.segment2line(this,t);return[e,n]}if(t instanceof i.Segment){let[e,n]=i.Distance.segment2segment(this,t);return[e,n]}if(t instanceof i.Arc){let[e,n]=i.Distance.segment2arc(this,t);return[e,n]}if(t instanceof i.Polygon){let[e,n]=i.Distance.shape2polygon(this,t);return[e,n]}if(t instanceof i.PlanarSet){let[e,n]=i.Distance.shape2planarSet(this,t);return[e,n]}if(t instanceof i.Multiline)return i.Distance.shape2multiline(this,t)}tangentInStart(){return new i.Vector(this.start,this.end).normalize()}tangentInEnd(){return new i.Vector(this.end,this.start).normalize()}reverse(){return new ve(this.end,this.start)}split(t){return this.start.equalTo(t)?[null,this.clone()]:this.end.equalTo(t)?[this.clone(),null]:[new i.Segment(this.start,t),new i.Segment(t,this.end)]}middle(){return new i.Point((this.start.x+this.end.x)/2,(this.start.y+this.end.y)/2)}pointAtLength(t){if(t>this.length||t<0)return null;if(t==0)return this.start;if(t==this.length)return this.end;let e=t/this.length;return new i.Point((this.end.x-this.start.x)*e+this.start.x,(this.end.y-this.start.y)*e+this.start.y)}distanceToPoint(t){let[e,...n]=i.Distance.point2segment(t,this);return e}definiteIntegral(t=0){let e=this.end.x-this.start.x,n=this.start.y-t,s=this.end.y-t;return e*(n+s)/2}transform(t=new i.Matrix){return new ve(this.ps.transform(t),this.pe.transform(t))}isZeroLength(){return this.ps.equalTo(this.pe)}sortPoints(t){return new i.Line(this.start,this.end).sortPoints(t)}get name(){return"segment"}svg(t={}){return`
<line x1="${this.start.x}" y1="${this.start.y}" x2="${this.end.x}" y2="${this.end.y}" ${lt(t)} />`}};i.Segment=yi;const Pi=(...r)=>new i.Segment(...r);i.segment=Pi;let{vector:Bt}=i,Ai=class yn extends et{constructor(...t){if(super(),this.pt=new i.Point,this.norm=new i.Vector(0,1),t.length!==0){if(t.length===1&&t[0]instanceof Object&&t[0].name==="line"){let{pt:e,norm:n}=t[0];this.pt=new i.Point(e),this.norm=new i.Vector(n);return}if(t.length===2){let e=t[0],n=t[1];if(e instanceof i.Point&&n instanceof i.Point){this.pt=e,this.norm=yn.points2norm(e,n),this.norm.dot(Bt(this.pt.x,this.pt.y))>=0&&this.norm.invert();return}if(e instanceof i.Point&&n instanceof i.Vector){if(i.Utils.EQ_0(n.x)&&i.Utils.EQ_0(n.y))throw T.ILLEGAL_PARAMETERS;this.pt=e.clone(),this.norm=n.clone(),this.norm=this.norm.normalize(),this.norm.dot(Bt(this.pt.x,this.pt.y))>=0&&this.norm.invert();return}if(e instanceof i.Vector&&n instanceof i.Point){if(i.Utils.EQ_0(e.x)&&i.Utils.EQ_0(e.y))throw T.ILLEGAL_PARAMETERS;this.pt=n.clone(),this.norm=e.clone(),this.norm=this.norm.normalize(),this.norm.dot(Bt(this.pt.x,this.pt.y))>=0&&this.norm.invert();return}}throw T.ILLEGAL_PARAMETERS}}clone(){return new i.Line(this.pt,this.norm)}get start(){}get end(){}get length(){return Number.POSITIVE_INFINITY}get box(){return new i.Box(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)}get middle(){}get slope(){return new i.Vector(this.norm.y,-this.norm.x).slope}get standard(){let t=this.norm.x,e=this.norm.y,n=this.norm.dot(Bt(this.pt.x,this.pt.y));return[t,e,n]}parallelTo(t){return i.Utils.EQ_0(this.norm.cross(t.norm))}incidentTo(t){return this.parallelTo(t)&&this.pt.on(t)}contains(t){if(this.pt.equalTo(t))return!0;let e=new i.Vector(this.pt,t);return i.Utils.EQ_0(this.norm.dot(e))}coord(t){return Bt(t.x,t.y).cross(this.norm)}intersect(t){if(t instanceof i.Point)return this.contains(t)?[t]:[];if(t instanceof i.Line)return ct(this,t);if(t instanceof i.Ray)return $e(t,this);if(t instanceof i.Circle)return at(this,t);if(t instanceof i.Box)return dt(this,t);if(t instanceof i.Segment)return Lt(t,this);if(t instanceof i.Arc)return zt(this,t);if(t instanceof i.Polygon)return Ot(this,t);if(t instanceof i.Multiline)return Nt(this,t)}distanceTo(t){if(t instanceof i.Point){let[e,n]=i.Distance.point2line(t,this);return n=n.reverse(),[e,n]}if(t instanceof i.Circle){let[e,n]=i.Distance.circle2line(t,this);return n=n.reverse(),[e,n]}if(t instanceof i.Segment){let[e,n]=i.Distance.segment2line(t,this);return[e,n.reverse()]}if(t instanceof i.Arc){let[e,n]=i.Distance.arc2line(t,this);return[e,n.reverse()]}if(t instanceof i.Polygon){let[e,n]=i.Distance.shape2polygon(this,t);return[e,n]}}split(t){if(t instanceof i.Point)return[new i.Ray(t,this.norm),new i.Ray(t,this.norm)];{let e=new i.Multiline([this]),n=this.sortPoints(t);return e.split(n),e.toShapes()}}rotate(t,e=new i.Point){return new i.Line(this.pt.rotate(t,e),this.norm.rotate(t))}transform(t){return new i.Line(this.pt.transform(t),this.norm.clone())}sortPoints(t){return t.slice().sort((e,n)=>this.coord(e)<this.coord(n)?-1:this.coord(e)>this.coord(n)?1:0)}get name(){return"line"}svg(t,e={}){let n=dt(this,t);if(n.length===0)return"";let s=n[0],l=n.length===2?n[1]:n.find(a=>!a.equalTo(s));return l===void 0&&(l=s),new i.Segment(s,l).svg(e)}static points2norm(t,e){if(t.equalTo(e))throw T.ILLEGAL_PARAMETERS;return new i.Vector(t,e).normalize().rotate90CCW()}};i.Line=Ai;const bi=(...r)=>new i.Line(...r);i.line=bi;let Li=class extends et{constructor(...t){if(super(),this.pc=new i.Point,this.r=1,t.length===1&&t[0]instanceof Object&&t[0].name==="circle"){let{pc:e,r:n}=t[0];this.pc=new i.Point(e),this.r=n}else{let[e,n]=[...t];e&&e instanceof i.Point&&(this.pc=e.clone()),n!==void 0&&(this.r=n)}}clone(){return new i.Circle(this.pc.clone(),this.r)}get center(){return this.pc}get box(){return new i.Box(this.pc.x-this.r,this.pc.y-this.r,this.pc.x+this.r,this.pc.y+this.r)}contains(t){if(t instanceof i.Point)return i.Utils.LE(t.distanceTo(this.center)[0],this.r);if(t instanceof i.Segment)return i.Utils.LE(t.start.distanceTo(this.center)[0],this.r)&&i.Utils.LE(t.end.distanceTo(this.center)[0],this.r);if(t instanceof i.Arc)return this.intersect(t).length===0&&i.Utils.LE(t.start.distanceTo(this.center)[0],this.r)&&i.Utils.LE(t.end.distanceTo(this.center)[0],this.r);if(t instanceof i.Circle)return this.intersect(t).length===0&&i.Utils.LE(t.r,this.r)&&i.Utils.LE(t.center.distanceTo(this.center)[0],this.r)}toArc(t=!0){return new i.Arc(this.center,this.r,Math.PI,-Math.PI,t)}scale(t,e){if(t!==e||!(this.pc.x===0&&this.pc.y===0))throw T.OPERATION_IS_NOT_SUPPORTED;return new i.Circle(this.pc,this.r*t)}transform(t=new i.Matrix){return new i.Circle(this.pc.transform(t),this.r)}intersect(t){if(t instanceof i.Point)return this.contains(t)?[t]:[];if(t instanceof i.Line)return at(t,this);if(t instanceof i.Ray)return He(t,this);if(t instanceof i.Segment)return Qt(t,this);if(t instanceof i.Circle)return Ne(t,this);if(t instanceof i.Box)return Fn(this,t);if(t instanceof i.Arc)return ne(t,this);if(t instanceof i.Polygon)return ke(this,t);if(t instanceof i.Multiline)return Nt(this,t)}distanceTo(t){if(t instanceof i.Point){let[e,n]=i.Distance.point2circle(t,this);return n=n.reverse(),[e,n]}if(t instanceof i.Circle){let[e,n]=i.Distance.circle2circle(this,t);return[e,n]}if(t instanceof i.Line){let[e,n]=i.Distance.circle2line(this,t);return[e,n]}if(t instanceof i.Segment){let[e,n]=i.Distance.segment2circle(t,this);return n=n.reverse(),[e,n]}if(t instanceof i.Arc){let[e,n]=i.Distance.arc2circle(t,this);return n=n.reverse(),[e,n]}if(t instanceof i.Polygon){let[e,n]=i.Distance.shape2polygon(this,t);return[e,n]}if(t instanceof i.PlanarSet){let[e,n]=i.Distance.shape2planarSet(this,t);return[e,n]}if(t instanceof i.Multiline){let[e,n]=i.Distance.shape2multiline(this,t);return[e,n]}}get name(){return"circle"}svg(t={}){return`
<circle cx="${this.pc.x}" cy="${this.pc.y}" r="${this.r}"
                ${lt({fill:"none",...t})} />`}};i.Circle=Li;const Oi=(...r)=>new i.Circle(...r);i.circle=Oi;class Ni extends et{constructor(...t){if(super(),this.pc=new i.Point,this.r=1,this.startAngle=0,this.endAngle=2*Math.PI,this.counterClockwise=i.CCW,t.length!==0)if(t.length===1&&t[0]instanceof Object&&t[0].name==="arc"){let{pc:e,r:n,startAngle:s,endAngle:l,counterClockwise:o}=t[0];this.pc=new i.Point(e.x,e.y),this.r=n,this.startAngle=s,this.endAngle=l,this.counterClockwise=o}else{let[e,n,s,l,o]=[...t];e&&e instanceof i.Point&&(this.pc=e.clone()),n!==void 0&&(this.r=n),s!==void 0&&(this.startAngle=s),l!==void 0&&(this.endAngle=l),o!==void 0&&(this.counterClockwise=o)}}clone(){return new i.Arc(this.pc.clone(),this.r,this.startAngle,this.endAngle,this.counterClockwise)}get sweep(){if(i.Utils.EQ(this.startAngle,this.endAngle))return 0;if(i.Utils.EQ(Math.abs(this.startAngle-this.endAngle),i.PIx2))return i.PIx2;let t;return this.counterClockwise?t=i.Utils.GT(this.endAngle,this.startAngle)?this.endAngle-this.startAngle:this.endAngle-this.startAngle+i.PIx2:t=i.Utils.GT(this.startAngle,this.endAngle)?this.startAngle-this.endAngle:this.startAngle-this.endAngle+i.PIx2,i.Utils.GT(t,i.PIx2)&&(t-=i.PIx2),i.Utils.LT(t,0)&&(t+=i.PIx2),t}get start(){return new i.Point(this.pc.x+this.r,this.pc.y).rotate(this.startAngle,this.pc)}get end(){return new i.Point(this.pc.x+this.r,this.pc.y).rotate(this.endAngle,this.pc)}get center(){return this.pc.clone()}get vertices(){return[this.start.clone(),this.end.clone()]}get length(){return Math.abs(this.sweep*this.r)}get box(){let e=this.breakToFunctional().reduce((n,s)=>n.merge(s.start.box),new i.Box);return e=e.merge(this.end.box),e}contains(t){if(!i.Utils.EQ(this.pc.distanceTo(t)[0],this.r))return!1;if(t.equalTo(this.start))return!0;let e=new i.Vector(this.pc,t).slope,n=new i.Arc(this.pc,this.r,this.startAngle,e,this.counterClockwise);return i.Utils.LE(n.length,this.length)}split(t){if(this.start.equalTo(t))return[null,this.clone()];if(this.end.equalTo(t))return[this.clone(),null];let e=new i.Vector(this.pc,t).slope;return[new i.Arc(this.pc,this.r,this.startAngle,e,this.counterClockwise),new i.Arc(this.pc,this.r,e,this.endAngle,this.counterClockwise)]}middle(){let t=this.counterClockwise?this.startAngle+this.sweep/2:this.startAngle-this.sweep/2;return new i.Arc(this.pc,this.r,this.startAngle,t,this.counterClockwise).end}pointAtLength(t){if(t>this.length||t<0)return null;if(t===0)return this.start;if(t===this.length)return this.end;let e=t/this.length,n=this.counterClockwise?this.startAngle+this.sweep*e:this.startAngle-this.sweep*e;return new i.Arc(this.pc,this.r,this.startAngle,n,this.counterClockwise).end}chordHeight(){return(1-Math.cos(Math.abs(this.sweep/2)))*this.r}intersect(t){if(t instanceof i.Point)return this.contains(t)?[t]:[];if(t instanceof i.Line)return zt(t,this);if(t instanceof i.Ray)return oe(t,this);if(t instanceof i.Circle)return ne(this,t);if(t instanceof i.Segment)return gt(t,this);if(t instanceof i.Box)return Bn(this,t);if(t instanceof i.Arc)return Ce(this,t);if(t instanceof i.Polygon)return re(this,t);if(t instanceof i.Multiline)return Nt(this,t)}distanceTo(t){if(t instanceof i.Point){let[e,n]=i.Distance.point2arc(t,this);return n=n.reverse(),[e,n]}if(t instanceof i.Circle){let[e,n]=i.Distance.arc2circle(this,t);return[e,n]}if(t instanceof i.Line){let[e,n]=i.Distance.arc2line(this,t);return[e,n]}if(t instanceof i.Segment){let[e,n]=i.Distance.segment2arc(t,this);return n=n.reverse(),[e,n]}if(t instanceof i.Arc){let[e,n]=i.Distance.arc2arc(this,t);return[e,n]}if(t instanceof i.Polygon){let[e,n]=i.Distance.shape2polygon(this,t);return[e,n]}if(t instanceof i.PlanarSet){let[e,n]=i.Distance.shape2planarSet(this,t);return[e,n]}if(t instanceof i.Multiline)return i.Distance.shape2multiline(this,t)}breakToFunctional(){let t=[],e=[0,Math.PI/2,2*Math.PI/2,3*Math.PI/2],n=[this.pc.translate(this.r,0),this.pc.translate(0,this.r),this.pc.translate(-this.r,0),this.pc.translate(0,-this.r)],s=[];for(let l=0;l<4;l++)n[l].on(this)&&s.push(new i.Arc(this.pc,this.r,this.startAngle,e[l],this.counterClockwise));if(s.length===0)t.push(this.clone());else{s.sort((a,u)=>a.length-u.length);for(let a=0;a<s.length;a++){let u=t.length>0?t[t.length-1]:void 0,h;u?h=new i.Arc(this.pc,this.r,u.endAngle,s[a].endAngle,this.counterClockwise):h=new i.Arc(this.pc,this.r,this.startAngle,s[a].endAngle,this.counterClockwise),i.Utils.EQ_0(h.length)||t.push(h.clone())}let l=t.length>0?t[t.length-1]:void 0,o;l?o=new i.Arc(this.pc,this.r,l.endAngle,this.endAngle,this.counterClockwise):o=new i.Arc(this.pc,this.r,this.startAngle,this.endAngle,this.counterClockwise),!i.Utils.EQ_0(o.length)&&!i.Utils.EQ(o.sweep,2*Math.PI)&&t.push(o.clone())}return t}tangentInStart(){let t=new i.Vector(this.pc,this.start),e=this.counterClockwise?Math.PI/2:-Math.PI/2;return t.rotate(e).normalize()}tangentInEnd(){let t=new i.Vector(this.pc,this.end),e=this.counterClockwise?-Math.PI/2:Math.PI/2;return t.rotate(e).normalize()}reverse(){return new i.Arc(this.pc,this.r,this.endAngle,this.startAngle,!this.counterClockwise)}transform(t=new i.Matrix){let e=this.start.transform(t),n=this.end.transform(t),s=this.pc.transform(t),l=this.counterClockwise;return t.a*t.d<0&&(l=!l),i.Arc.arcSE(s,e,n,l)}static arcSE(t,e,n,s){let{vector:l}=i,o=l(t,e).slope,a=l(t,n).slope;i.Utils.EQ(o,a)&&(a+=2*Math.PI,s=!0);let u=l(t,e).length;return new i.Arc(t,u,o,a,s)}definiteIntegral(t=0){return this.breakToFunctional().reduce((s,l)=>s+l.circularSegmentDefiniteIntegral(t),0)}circularSegmentDefiniteIntegral(t){let e=new i.Line(this.start,this.end),n=this.pc.leftTo(e),l=new i.Segment(this.start,this.end).definiteIntegral(t),o=this.circularSegmentArea();return n?l-o:l+o}circularSegmentArea(){return .5*this.r*this.r*(this.sweep-Math.sin(this.sweep))}sortPoints(t){let{vector:e}=i;return t.slice().sort((n,s)=>{let l=e(this.pc,n).slope,o=e(this.pc,s).slope;return l<o?-1:l>o?1:0})}get name(){return"arc"}svg(t={}){let e=this.sweep<=Math.PI?"0":"1",n=this.counterClockwise?"1":"0";return i.Utils.EQ(this.sweep,2*Math.PI)?new i.Circle(this.pc,this.r).svg(t):`
<path d="M${this.start.x},${this.start.y}
                             A${this.r},${this.r} 0 ${e},${n} ${this.end.x},${this.end.y}"
                    ${lt({fill:"none",...t})} />`}}i.Arc=Ni;const Ci=(...r)=>new i.Arc(...r);i.arc=Ci;class Vt extends et{constructor(t=void 0,e=void 0,n=void 0,s=void 0){super(),this.xmin=t,this.ymin=e,this.xmax=n,this.ymax=s}clone(){return new Vt(this.xmin,this.ymin,this.xmax,this.ymax)}get low(){return new i.Point(this.xmin,this.ymin)}get high(){return new i.Point(this.xmax,this.ymax)}get max(){return this.clone()}get center(){return new i.Point((this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2)}get width(){return Math.abs(this.xmax-this.xmin)}get height(){return Math.abs(this.ymax-this.ymin)}get box(){return this.clone()}not_intersect(t){return this.xmax<t.xmin||this.xmin>t.xmax||this.ymax<t.ymin||this.ymin>t.ymax}intersect(t){return!this.not_intersect(t)}merge(t){return new Vt(this.xmin===void 0?t.xmin:Math.min(this.xmin,t.xmin),this.ymin===void 0?t.ymin:Math.min(this.ymin,t.ymin),this.xmax===void 0?t.xmax:Math.max(this.xmax,t.xmax),this.ymax===void 0?t.ymax:Math.max(this.ymax,t.ymax))}less_than(t){return!!(this.low.lessThan(t.low)||this.low.equalTo(t.low)&&this.high.lessThan(t.high))}equal_to(t){return this.low.equalTo(t.low)&&this.high.equalTo(t.high)}output(){return this.clone()}static comparable_max(t,e){return t.merge(e)}static comparable_less_than(t,e){return t.lessThan(e)}set(t,e,n,s){this.xmin=t,this.ymin=e,this.xmax=n,this.ymax=s}toPoints(){return[new i.Point(this.xmin,this.ymin),new i.Point(this.xmax,this.ymin),new i.Point(this.xmax,this.ymax),new i.Point(this.xmin,this.ymax)]}toSegments(){let t=this.toPoints();return[new i.Segment(t[0],t[1]),new i.Segment(t[1],t[2]),new i.Segment(t[2],t[3]),new i.Segment(t[3],t[0])]}rotate(t,e=new i.Point){throw T.OPERATION_IS_NOT_SUPPORTED}transform(t=new i.Matrix){return this.toPoints().map(n=>n.transform(t)).reduce((n,s)=>n.merge(s.box),new Vt)}contains(t){if(t instanceof i.Point)return t.x>=this.xmin&&t.x<=this.xmax&&t.y>=this.ymin&&t.y<=this.ymax;if(t instanceof i.Segment)return t.vertices.every(e=>this.contains(e));if(t instanceof i.Box)return t.toSegments().every(e=>this.contains(e));if(t instanceof i.Circle)return this.contains(t.box);if(t instanceof i.Arc)return t.vertices.every(e=>this.contains(e))&&t.toSegments().every(e=>gt(e,t).length===0);if(t instanceof i.Line||t instanceof i.Ray)return!1;if(t instanceof i.Multiline)return t.toShapes().every(e=>this.contains(e));if(t instanceof i.Polygon)return this.contains(t.box)}distanceTo(t){const e=this.toSegments().map(s=>s.distanceTo(t));let n=[Number.MAX_SAFE_INTEGER,null];return e.forEach(s=>{s[0]<n[0]&&(n=s)}),n}get name(){return"box"}svg(t={}){const e=this.xmax-this.xmin,n=this.ymax-this.ymin;return`
<rect x="${this.xmin}" y="${this.ymin}" width="${e}" height="${n}"
                ${lt({fill:"none",...t})} />`}}i.Box=Vt;const Ri=(...r)=>new i.Box(...r);i.box=Ri;class Mi{constructor(t){this.shape=t,this.next=void 0,this.prev=void 0,this.face=void 0,this.arc_length=0,this.bvStart=void 0,this.bvEnd=void 0,this.bv=void 0,this.overlap=void 0}get start(){return this.shape.start}get end(){return this.shape.end}get length(){return this.shape.length}get box(){return this.shape.box}get isSegment(){return this.shape instanceof i.Segment}get isArc(){return this.shape instanceof i.Arc}get isLine(){return this.shape instanceof i.Line}get isRay(){return this.shape instanceof i.Ray}middle(){return this.shape.middle()}pointAtLength(t){return this.shape.pointAtLength(t)}contains(t){return this.shape.contains(t)}setInclusion(t){if(this.bv!==void 0)return this.bv;if(this.shape instanceof i.Line||this.shape instanceof i.Ray)return this.bv=i.OUTSIDE,this.bv;if(this.bvStart===void 0&&(this.bvStart=Ut(t,this.start)),this.bvEnd===void 0&&(this.bvEnd=Ut(t,this.end)),this.bvStart===i.OUTSIDE||this.bvEnd==i.OUTSIDE)this.bv=i.OUTSIDE;else if(this.bvStart===i.INSIDE||this.bvEnd==i.INSIDE)this.bv=i.INSIDE;else{let e=Ut(t,this.middle());this.bv=e}return this.bv}setOverlap(t){let e,n=this.shape,s=t.shape;n instanceof i.Segment&&s instanceof i.Segment?n.start.equalTo(s.start)&&n.end.equalTo(s.end)?e=i.OVERLAP_SAME:n.start.equalTo(s.end)&&n.end.equalTo(s.start)&&(e=i.OVERLAP_OPPOSITE):(n instanceof i.Arc&&s instanceof i.Arc||n instanceof i.Segment&&s instanceof i.Arc||n instanceof i.Arc&&s instanceof i.Segment)&&(n.start.equalTo(s.start)&&n.end.equalTo(s.end)&&n.middle().equalTo(s.middle())?e=i.OVERLAP_SAME:n.start.equalTo(s.end)&&n.end.equalTo(s.start)&&n.middle().equalTo(s.middle())&&(e=i.OVERLAP_OPPOSITE)),this.overlap===void 0&&(this.overlap=e),t.overlap===void 0&&(t.overlap=e)}svg(){if(this.shape instanceof i.Segment)return` L${this.shape.end.x},${this.shape.end.y}`;if(this.shape instanceof i.Arc){let t=this.shape,e,n=t.counterClockwise?"1":"0";if(i.Utils.EQ(t.sweep,2*Math.PI)){let s=t.counterClockwise?1:-1,l=new i.Arc(t.pc,t.r,t.startAngle,t.startAngle+s*Math.PI,t.counterClockwise),o=new i.Arc(t.pc,t.r,t.startAngle+s*Math.PI,t.endAngle,t.counterClockwise);return e="0",` A${l.r},${l.r} 0 ${e},${n} ${l.end.x},${l.end.y}
                    A${o.r},${o.r} 0 ${e},${n} ${o.end.x},${o.end.y}`}else return e=t.sweep<=Math.PI?"0":"1",` A${t.r},${t.r} 0 ${e},${n} ${t.end.x},${t.end.y}`}}toJSON(){return this.shape.toJSON()}}i.Edge=Mi;class Ui extends ee{constructor(t,e){super(t,e),this.setCircularLinks()}setCircularLinks(){this.isEmpty()||(this.last.next=this.first,this.first.prev=this.last)}[Symbol.iterator](){let t;return{next:()=>{let e=t||this.first,n=this.first?t?t===this.first:!1:!0;return t=e?e.next:void 0,{value:e,done:n}}}}append(t){return super.append(t),this.setCircularLinks(),this}insert(t,e){return super.insert(t,e),this.setCircularLinks(),this}remove(t){return super.remove(t),this}}class It extends Ui{constructor(t,...e){if(super(),this._box=void 0,this._orientation=void 0,e.length!==0){if(e.length===1){if(e[0]instanceof Array){let n=e[0];if(n.length===0)return;if(n.every(s=>s instanceof i.Point)){let s=It.points2segments(n);this.shapes2face(t.edges,s)}else if(n.every(s=>s instanceof Array&&s.length===2)){let s=n.map(o=>new i.Point(o[0],o[1])),l=It.points2segments(s);this.shapes2face(t.edges,l)}else if(n.every(s=>s instanceof i.Segment||s instanceof i.Arc))this.shapes2face(t.edges,n);else if(n.every(s=>s.name==="segment"||s.name==="arc")){let s=[];for(let l of n){let o;l.name==="segment"?o=new i.Segment(l):o=new i.Arc(l),s.push(o)}this.shapes2face(t.edges,s)}}else if(e[0]instanceof It){let n=e[0];this.first=n.first,this.last=n.last;for(let s of n)t.edges.add(s)}else if(e[0]instanceof i.Circle)this.shapes2face(t.edges,[e[0].toArc(!0)]);else if(e[0]instanceof i.Box){let n=e[0];this.shapes2face(t.edges,[new i.Segment(new i.Point(n.xmin,n.ymin),new i.Point(n.xmax,n.ymin)),new i.Segment(new i.Point(n.xmax,n.ymin),new i.Point(n.xmax,n.ymax)),new i.Segment(new i.Point(n.xmax,n.ymax),new i.Point(n.xmin,n.ymax)),new i.Segment(new i.Point(n.xmin,n.ymax),new i.Point(n.xmin,n.ymin))])}}e.length===2&&e[0]instanceof i.Edge&&e[1]instanceof i.Edge&&(this.first=e[0],this.last=e[1],this.last.next=this.first,this.first.prev=this.last,this.setArcLength())}}get edges(){return this.toArray()}get shapes(){return this.edges.map(t=>t.shape.clone())}get box(){if(this._box===void 0){let t=new i.Box;for(let e of this)t=t.merge(e.box);this._box=t}return this._box}get perimeter(){return this.last.arc_length+this.last.length}pointAtLength(t){if(t>this.perimeter||t<0)return null;let e=null;for(let n of this)if(t>=n.arc_length&&(n===this.last||t<n.next.arc_length)){e=n.pointAtLength(t-n.arc_length);break}return e}static points2segments(t){let e=[];for(let n=0;n<t.length;n++)t[n].equalTo(t[(n+1)%t.length])||e.push(new i.Segment(t[n],t[(n+1)%t.length]));return e}shapes2face(t,e){for(let n of e){let s=new i.Edge(n);this.append(s),t.add(s)}}append(t){return super.append(t),this.setOneEdgeArcLength(t),t.face=this,this}insert(t,e){return super.insert(t,e),this.setOneEdgeArcLength(t),t.face=this,this}remove(t){return super.remove(t),this.setArcLength(),this}merge_with_next_edge(t){return t.shape.end.x=t.next.shape.end.x,t.shape.end.y=t.next.shape.end.y,this.remove(t.next),this}reverse(){let t=[],e=this.last;do e.shape=e.shape.reverse(),t.push(e),e=e.prev;while(e!==this.last);this.first=void 0,this.last=void 0;for(let n of t)this.first===void 0?(n.prev=n,n.next=n,this.first=n,this.last=n):(n.prev=this.last,this.last.next=n,this.last=n,this.last.next=this.first,this.first.prev=this.last),this.setOneEdgeArcLength(n);this._orientation!==void 0&&(this._orientation=void 0,this._orientation=this.orientation())}setArcLength(){for(let t of this)this.setOneEdgeArcLength(t),t.face=this}setOneEdgeArcLength(t){t===this.first?t.arc_length=0:t.arc_length=t.prev.arc_length+t.prev.length}area(){return Math.abs(this.signedArea())}signedArea(){let t=0,e=this.box.ymin;for(let n of this)t+=n.shape.definiteIntegral(e);return t}orientation(){if(this._orientation===void 0){let t=this.signedArea();i.Utils.EQ_0(t)?this._orientation=qt.NOT_ORIENTABLE:i.Utils.LT(t,0)?this._orientation=qt.CCW:this._orientation=qt.CW}return this._orientation}isSimple(t){return It.getSelfIntersections(this,t,!0).length===0}static getSelfIntersections(t,e,n=!1){let s=[];for(let l of t){let o=e.search(l.box);for(let a of o){if(l===a||a.face!==t||l.shape instanceof i.Segment&&a.shape instanceof i.Segment&&(l.next===a||l.prev===a))continue;let u=l.shape.intersect(a.shape);for(let h of u)if(!(h.equalTo(l.start)&&h.equalTo(a.end)&&a===l.prev)&&!(h.equalTo(l.end)&&h.equalTo(a.start)&&a===l.next)&&(s.push(h),n))break;if(s.length>0&&n)break}if(s.length>0&&n)break}return s}findEdgeByPoint(t){let e;for(let n of this)if(!t.equalTo(n.shape.start)&&(t.equalTo(n.shape.end)||n.shape.contains(t))){e=n;break}return e}toPolygon(){return new i.Polygon(this.shapes)}toJSON(){return this.edges.map(t=>t.toJSON())}svg(){let t=`M${this.first.start.x},${this.first.start.y}`;for(let e of this)t+=e.svg();return t+=" z",t}}i.Face=It;class pe extends et{constructor(...t){if(super(),this.pt=new i.Point,this.norm=new i.Vector(0,1),t.length!==0&&(t.length>=1&&t[0]instanceof i.Point&&(this.pt=t[0].clone()),t.length!==1)){if(t.length===2&&t[1]instanceof i.Vector){this.norm=t[1].clone();return}throw T.ILLEGAL_PARAMETERS}}clone(){return new pe(this.pt,this.norm)}get slope(){return new i.Vector(this.norm.y,-this.norm.x).slope}get box(){let t=this.slope;return new i.Box(t>Math.PI/2&&t<3*Math.PI/2?Number.NEGATIVE_INFINITY:this.pt.x,t>=0&&t<=Math.PI?this.pt.y:Number.NEGATIVE_INFINITY,t>=Math.PI/2&&t<=3*Math.PI/2?this.pt.x:Number.POSITIVE_INFINITY,t>=Math.PI&&t<=2*Math.PI||t===0?this.pt.y:Number.POSITIVE_INFINITY)}get start(){return this.pt}get end(){}get length(){return Number.POSITIVE_INFINITY}contains(t){if(this.pt.equalTo(t))return!0;let e=new i.Vector(this.pt,t);return i.Utils.EQ_0(this.norm.dot(e))&&i.Utils.GE(e.cross(this.norm),0)}coord(t){return on(t.x,t.y).cross(this.norm)}split(t){return this.contains(t)?this.pt.equalTo(t)?[this]:[new i.Segment(this.pt,t),new i.Ray(t,this.norm)]:[]}intersect(t){if(t instanceof i.Point)return this.contains(t)?[t]:[];if(t instanceof i.Segment)return se(this,t);if(t instanceof i.Arc)return oe(this,t);if(t instanceof i.Line)return $e(this,t);if(t instanceof i.Ray)return Wn(this,t);if(t instanceof i.Circle)return He(this,t);if(t instanceof i.Box)return Dn(this,t);if(t instanceof i.Polygon)return Ge(this,t)}rotate(t,e=new i.Point){return new i.Ray(this.pt.rotate(t,e),this.norm.rotate(t))}transform(t){return new i.Ray(this.pt.transform(t),this.norm.clone())}get name(){return"ray"}svg(t,e={}){let n=new i.Line(this.pt,this.norm),s=dt(n,t);return s=s.filter(o=>this.contains(o)),s.length===0||s.length===2?"":new i.Segment(this.pt,s[0]).svg(e)}}i.Ray=pe;const ki=(...r)=>new i.Ray(...r);i.ray=ki;let Fi=class At{constructor(){this.faces=new i.PlanarSet,this.edges=new i.PlanarSet;let t=[...arguments];if(t.length===1&&(t[0]instanceof Array&&t[0].length>0||t[0]instanceof i.Circle||t[0]instanceof i.Box)){let e=t[0];if(t[0]instanceof Array&&t[0].every(n=>n instanceof Array))if(e.every(n=>n instanceof Array&&n.length===2&&typeof n[0]=="number"&&typeof n[1]=="number"))this.faces.add(new i.Face(this,e));else for(let n of e)if(n instanceof Array&&n[0]instanceof Array&&n[0].every(s=>s instanceof Array&&s.length===2&&typeof s[0]=="number"&&typeof s[1]=="number"))for(let s of n)this.faces.add(new i.Face(this,s));else this.faces.add(new i.Face(this,n));else this.faces.add(new i.Face(this,e))}}get box(){return[...this.faces].reduce((t,e)=>t.merge(e.box),new i.Box)}get vertices(){return[...this.edges].map(t=>t.start)}clone(){let t=new At;for(let e of this.faces)t.addFace(e.shapes);return t}isEmpty(){return this.edges.size===0}isValid(){let t=!0;for(let e of this.faces)if(!e.isSimple(this.edges)){t=!1;break}return t}area(){let t=[...this.faces].reduce((e,n)=>e+n.signedArea(),0);return Math.abs(t)}addFace(...t){let e=new i.Face(this,...t);return this.faces.add(e),e}deleteFace(t){for(let e of t)this.edges.delete(e);return this.faces.delete(t)}recreateFaces(){this.faces.clear();for(let n of this.edges)n.face=null;let t,e=!0;for(;e;){e=!1;for(let n of this.edges)if(n.face===null){t=n,e=!0;break}if(e){let n=t;do n=n.next;while(n.next!==t);this.addFace(t,n)}}}removeChain(t,e,n){if(n.next===e){this.deleteFace(t);return}for(let s=e;s!==n.next;s=s.next)if(t.remove(s),this.edges.delete(s),t.isEmpty()){this.deleteFace(t);break}}addVertex(t,e){let n=e.shape.split(t);if(n[0]===null)return e.prev;if(n[1]===null)return e;let s=new i.Edge(n[0]),l=e.prev;return e.face.insert(s,l),this.edges.delete(e),this.edges.add(s),e.shape=n[1],this.edges.add(e),s}removeEndVertex(t){const e=t.next;e!==t&&(t.face.merge_with_next_edge(t),this.edges.delete(e))}cut(t){let e=this.clone(),n={int_points1:[],int_points2:[],int_points1_sorted:[],int_points2_sorted:[]};for(let o of t.edges)for(let a of e.edges){let u=Fe(o,a);for(let h of u)pt(o,h,n.int_points1),pt(a,h,n.int_points2)}if(n.int_points1.length===0)return e;n.int_points1_sorted=tt(n.int_points1),n.int_points2_sorted=tt(n.int_points2),mt(t,n.int_points1_sorted),mt(e,n.int_points2_sorted),le(n),n.int_points1_sorted=tt(n.int_points1),n.int_points2_sorted=tt(n.int_points2),ae(n.int_points1),fe(n.int_points1,e);for(let o of n.int_points1_sorted)o.edge_before&&o.edge_after&&o.edge_before.bv===o.edge_after.bv&&(n.int_points2[o.id]=-1,o.id=-1);if(n.int_points1=n.int_points1.filter(o=>o.id>=0),n.int_points2=n.int_points2.filter(o=>o.id>=0),n.int_points1.forEach((o,a)=>{o.id=a}),n.int_points2.forEach((o,a)=>{o.id=a}),n.int_points1.length===0)return e;n.int_points1_sorted=tt(n.int_points1),n.int_points2_sorted=tt(n.int_points2);let s,l;for(let o=1;o<n.int_points1_sorted.length;o++)if(l=n.int_points1_sorted[o],s=n.int_points1_sorted[o-1],l.edge_before&&l.edge_before.bv===Dt){let a=s.edge_after,u=l.edge_before,h=t.getChain(a,u);De(n.int_points2[s.id],n.int_points2[l.id],h),h.forEach(f=>e.edges.add(f)),h=h.reverse().map(f=>new i.Edge(f.shape.reverse()));for(let f=0;f<h.length-1;f++)h[f].next=h[f+1],h[f+1].prev=h[f];De(n.int_points2[l.id],n.int_points2[s.id],h),h.forEach(f=>e.edges.add(f))}return e.recreateFaces(),e}cutWithLine(t){let e=new ft([t]);return this.cut(e)}findEdgeByPoint(t){let e;for(let n of this.faces)if(e=n.findEdgeByPoint(t),e!==void 0)break;return e}splitToIslands(){if(this.isEmpty())return[];let t=this.toArray();t.sort((s,l)=>l.area()-s.area());let e=[...t[0].faces][0].orientation(),n=t.filter(s=>[...s.faces][0].orientation()===e);for(let s of t){let l=[...s.faces][0];if(l.orientation()!==e){for(let o of n)if(l.shapes.every(a=>o.contains(a))){o.addFace(l.shapes);break}}}return n}reverse(){for(let t of this.faces)t.reverse();return this}contains(t){if(t instanceof i.Point){let e=Ut(this,t);return e===Dt||e===M}else return rn(this,t)}distanceTo(t){if(t instanceof i.Point){let[e,n]=i.Distance.point2polygon(t,this);return n=n.reverse(),[e,n]}if(t instanceof i.Circle||t instanceof i.Line||t instanceof i.Segment||t instanceof i.Arc){let[e,n]=i.Distance.shape2polygon(t,this);return n=n.reverse(),[e,n]}if(t instanceof i.Polygon){let e=[Number.POSITIVE_INFINITY,new i.Segment],n,s;for(let l of this.edges){let o=e[0];[n,s]=i.Distance.shape2planarSet(l.shape,t.edges,o),i.Utils.LT(n,o)&&(e=[n,s])}return e}}intersect(t){if(t instanceof i.Point)return this.contains(t)?[t]:[];if(t instanceof i.Line)return Ot(t,this);if(t instanceof i.Ray)return Ge(t,this);if(t instanceof i.Circle)return ke(t,this);if(t instanceof i.Segment)return ie(t,this);if(t instanceof i.Arc)return re(t,this);if(t instanceof i.Polygon)return Gn(t,this);if(t instanceof i.Multiline)return $n(t,this)}translate(t){let e=new At;for(let n of this.faces)e.addFace(n.shapes.map(s=>s.translate(t)));return e}rotate(t=0,e=new i.Point){let n=new At;for(let s of this.faces)n.addFace(s.shapes.map(l=>l.rotate(t,e)));return n}scale(t,e){let n=new At;for(let s of this.faces)n.addFace(s.shapes.map(l=>l.scale(t,e)));return n}transform(t=new i.Matrix){let e=new At;for(let n of this.faces)e.addFace(n.shapes.map(s=>s.transform(t)));return e}toJSON(){return[...this.faces].map(t=>t.toJSON())}toArray(){return[...this.faces].map(t=>t.toPolygon())}dpath(){return[...this.faces].reduce((t,e)=>t+e.svg(),"")}svg(t={}){let e=`
<path ${lt({fillRule:"evenodd",fill:"lightcyan",...t})} d="`;for(let n of this.faces)e+=`
${n.svg()}`;return e+=`" >
</path>`,e}};i.Polygon=Fi;const Bi=(...r)=>new i.Polygon(...r);i.polygon=Bi;const{Circle:_e,Line:ln,Point:an,Vector:Xt,Utils:me}=i;class Ht{constructor(t){this.circle=t}get inversion_circle(){return this.circle}static inversePoint(t,e){const n=new Xt(t.pc,e),s=t.r*t.r,l=n.dot(n);return me.EQ_0(l)?new an(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY):t.pc.translate(n.multiply(s/l))}static inverseCircle(t,e){const n=t.pc.distanceTo(e.pc)[0];if(me.EQ(n,e.r)){let s=t.r*t.r/(2*e.r),l=new Xt(t.pc,e.pc);l=l.normalize();let o=t.pc.translate(l.multiply(s));return new ln(o,l)}else{let s=new Xt(t.pc,e.pc),l=t.r*t.r/(s.dot(s)-e.r*e.r),o=t.pc.translate(s.multiply(l)),a=Math.abs(l)*e.r;return new _e(o,a)}}static inverseLine(t,e){const[n,s]=t.pc.distanceTo(e);if(me.EQ_0(n))return e.clone();{let l=t.r*t.r/(2*n),o=new Xt(t.pc,s.end);return o=o.multiply(l/n),new _e(t.pc.translate(o),l)}}inverse(t){if(t instanceof an)return Ht.inversePoint(this.circle,t);if(t instanceof _e)return Ht.inverseCircle(this.circle,t);if(t instanceof ln)return Ht.inverseLine(this.circle,t)}}i.Inversion=Ht;const Vi=r=>new i.Inversion(r);i.inversion=Vi;class d{static point2point(t,e){return t.distanceTo(e)}static point2line(t,e){let n=t.projectionOn(e);return[new i.Vector(t,n).length,new i.Segment(t,n)]}static point2circle(t,e){let[n,s]=t.distanceTo(e.center);if(i.Utils.EQ_0(n))return[e.r,new i.Segment(t,e.toArc().start)];{let l=Math.abs(n-e.r),o=new i.Vector(e.pc,t).normalize().multiply(e.r),a=e.pc.translate(o);return[l,new i.Segment(t,a)]}}static point2segment(t,e){if(e.start.equalTo(e.end))return d.point2point(t,e.start);let n=new i.Vector(e.start,e.end),s=new i.Vector(e.start,t),l=new i.Vector(e.end,t),o=n.dot(s),a=-n.dot(l),u,h;if(i.Utils.GE(o,0)&&i.Utils.GE(a,0)){let f=e.tangentInStart();return u=Math.abs(f.cross(s)),h=e.start.translate(f.multiply(f.dot(s))),[u,new i.Segment(t,h)]}else return o<0?t.distanceTo(e.start):t.distanceTo(e.end)}static point2arc(t,e){let n=new i.Circle(e.pc,e.r),s=[],l,o;return[l,o]=d.point2circle(t,n),o.end.on(e)&&s.push(d.point2circle(t,n)),s.push(d.point2point(t,e.start)),s.push(d.point2point(t,e.end)),d.sort(s),s[0]}static point2edge(t,e){return e.shape instanceof i.Segment?d.point2segment(t,e.shape):d.point2arc(t,e.shape)}static segment2line(t,e){let n=t.intersect(e);if(n.length>0)return[0,new i.Segment(n[0],n[0])];let s=[];return s.push(d.point2line(t.start,e)),s.push(d.point2line(t.end,e)),d.sort(s),s[0]}static segment2segment(t,e){let n=Yt(t,e);if(n.length>0)return[0,new i.Segment(n[0],n[0])];let s=[],l,o;return[l,o]=d.point2segment(e.start,t),s.push([l,o.reverse()]),[l,o]=d.point2segment(e.end,t),s.push([l,o.reverse()]),s.push(d.point2segment(t.start,e)),s.push(d.point2segment(t.end,e)),d.sort(s),s[0]}static segment2circle(t,e){let n=t.intersect(e);if(n.length>0)return[0,new i.Segment(n[0],n[0])];let s=new i.Line(t.ps,t.pe),[l,o]=d.point2line(e.center,s);if(i.Utils.GE(l,e.r)&&o.end.on(t))return d.point2circle(o.end,e);{let[a,u]=d.point2circle(t.start,e),[h,f]=d.point2circle(t.end,e);return i.Utils.LT(a,h)?[a,u]:[h,f]}}static segment2arc(t,e){let n=t.intersect(e);if(n.length>0)return[0,new i.Segment(n[0],n[0])];let s=new i.Line(t.ps,t.pe),l=new i.Circle(e.pc,e.r),[o,a]=d.point2line(l.center,s);if(i.Utils.GE(o,l.r)&&a.end.on(t)){let[g,_]=d.point2circle(a.end,l);if(_.end.on(e))return[g,_]}let u=[];u.push(d.point2arc(t.start,e)),u.push(d.point2arc(t.end,e));let h,f;return[h,f]=d.point2segment(e.start,t),u.push([h,f.reverse()]),[h,f]=d.point2segment(e.end,t),u.push([h,f.reverse()]),d.sort(u),u[0]}static circle2circle(t,e){let n=t.intersect(e);if(n.length>0)return[0,new i.Segment(n[0],n[0])];if(t.center.equalTo(e.center)){let s=t.toArc(),l=e.toArc();return d.point2point(s.start,l.start)}else{let s=new i.Line(t.center,e.center),l=s.intersect(t),o=s.intersect(e),a=[];return a.push(d.point2point(l[0],o[0])),a.push(d.point2point(l[0],o[1])),a.push(d.point2point(l[1],o[0])),a.push(d.point2point(l[1],o[1])),d.sort(a),a[0]}}static circle2line(t,e){let n=t.intersect(e);if(n.length>0)return[0,new i.Segment(n[0],n[0])];let[s,l]=d.point2line(t.center,e),[o,a]=d.point2circle(l.end,t);return a=a.reverse(),[o,a]}static arc2line(t,e){let n=e.intersect(t);if(n.length>0)return[0,new i.Segment(n[0],n[0])];let s=new i.Circle(t.center,t.r),[l,o]=d.point2line(s.center,e);if(i.Utils.GE(l,s.r)){let[a,u]=d.point2circle(o.end,s);if(u.end.on(t))return[a,u]}else{let a=[];return a.push(d.point2line(t.start,e)),a.push(d.point2line(t.end,e)),d.sort(a),a[0]}}static arc2circle(t,e){let n=t.intersect(e);if(n.length>0)return[0,new i.Segment(n[0],n[0])];let s=new i.Circle(t.center,t.r),[l,o]=d.circle2circle(s,e);if(o.start.on(t))return[l,o];{let a=[];return a.push(d.point2circle(t.start,e)),a.push(d.point2circle(t.end,e)),d.sort(a),a[0]}}static arc2arc(t,e){let n=t.intersect(e);if(n.length>0)return[0,new i.Segment(n[0],n[0])];let s=new i.Circle(t.center,t.r),l=new i.Circle(e.center,e.r),[o,a]=d.circle2circle(s,l);if(a.start.on(t)&&a.end.on(e))return[o,a];{let u=[],h,f;return[h,f]=d.point2arc(t.start,e),f.end.on(e)&&u.push([h,f]),[h,f]=d.point2arc(t.end,e),f.end.on(e)&&u.push([h,f]),[h,f]=d.point2arc(e.start,t),f.end.on(t)&&u.push([h,f.reverse()]),[h,f]=d.point2arc(e.end,t),f.end.on(t)&&u.push([h,f.reverse()]),[h,f]=d.point2point(t.start,e.start),u.push([h,f]),[h,f]=d.point2point(t.start,e.end),u.push([h,f]),[h,f]=d.point2point(t.end,e.start),u.push([h,f]),[h,f]=d.point2point(t.end,e.end),u.push([h,f]),d.sort(u),u[0]}}static point2polygon(t,e){let n=[Number.POSITIVE_INFINITY,new i.Segment];for(let s of e.edges){let[l,o]=d.point2edge(t,s);i.Utils.LT(l,n[0])&&(n=[l,o])}return n}static shape2polygon(t,e){let n=[Number.POSITIVE_INFINITY,new i.Segment];for(let s of e.edges){let[l,o]=t.distanceTo(s.shape);i.Utils.LT(l,n[0])&&(n=[l,o])}return n}static polygon2polygon(t,e){let n=[Number.POSITIVE_INFINITY,new i.Segment];for(let s of t.edges)for(let l of e.edges){let[o,a]=s.shape.distanceTo(l.shape);i.Utils.LT(o,n[0])&&(n=[o,a])}return n}static box2box_minmax(t,e){let n=Math.max(Math.max(t.xmin-e.xmax,0),Math.max(e.xmin-t.xmax,0)),s=Math.max(Math.max(t.ymin-e.ymax,0),Math.max(e.ymin-t.ymax,0)),l=n*n+s*s,o=t.merge(e),a=o.xmax-o.xmin,u=o.ymax-o.ymin,h=a*a+u*u;return[l,h]}static minmax_tree_process_level(t,e,n,s){let l,o;for(let f of e)[l,o]=d.box2box_minmax(t.box,f.item.key),f.item.value instanceof i.Edge?s.insert([l,o],f.item.value.shape):s.insert([l,o],f.item.value),i.Utils.LT(o,n)&&(n=o);if(e.length===0)return n;let a=e.map(f=>f.left.isNil()?void 0:f.left).filter(f=>f!==void 0),u=e.map(f=>f.right.isNil()?void 0:f.right).filter(f=>f!==void 0),h=[...a,...u].filter(f=>{let[g,_]=d.box2box_minmax(t.box,f.max);return i.Utils.LE(g,n)});return n=d.minmax_tree_process_level(t,h,n,s),n}static minmax_tree(t,e,n){let s=new Ft,l=[e.index.root],o=n<Number.POSITIVE_INFINITY?n*n:Number.POSITIVE_INFINITY;return o=d.minmax_tree_process_level(t,l,o,s),s}static minmax_tree_calc_distance(t,e,n){let s,l;if(e!=null&&!e.isNil()){if([s,l]=d.minmax_tree_calc_distance(t,e.left,n),l)return[s,l];if(i.Utils.LT(s[0],Math.sqrt(e.item.key.low)))return[s,!0];let[o,a]=d.distance(t,e.item.value);return i.Utils.LT(o,s[0])&&(s=[o,a]),[s,l]=d.minmax_tree_calc_distance(t,e.right,s),[s,l]}return[n,!1]}static shape2planarSet(t,e,n=Number.POSITIVE_INFINITY){let s=[n,new i.Segment],l=!1;if(e instanceof i.PlanarSet){let o=d.minmax_tree(t,e,n);[s,l]=d.minmax_tree_calc_distance(t,o.root,s)}return s}static sort(t){t.sort((e,n)=>i.Utils.LT(e[0],n[0])?-1:i.Utils.GT(e[0],n[0])?1:0)}static distance(t,e){return t.distanceTo(e)}static shape2multiline(t,e){let n=[Number.POSITIVE_INFINITY,new i.Segment];for(let s of e){let[l,o]=d.distance(t,s.shape);i.Utils.LT(l,n[0])&&(n=[l,o])}return n}static multiline2multiline(t,e){let n=[Number.POSITIVE_INFINITY,new i.Segment];for(let s of t)for(let l of e){let[o,a]=d.distance(s.shape,l.shape);i.Utils.LT(o,n[0])&&(n=[o,a])}return n}}i.Distance=d;const{Multiline:Hi,Point:fn,Segment:$i,Polygon:un}=i;function Ee(r){return new fn(r.split(" ").map(Number))}function hn(r){return r.split(", ").map(Ee)}function xe(r){const t=hn(r);let e=[];for(let n=0;n<t.length-1;n++)e.push(new $i(t[n],t[n+1]));return new Hi(e)}function Gi(r){return r.replace(/\(\(/,"").replace(/\)\)$/,"").split("), (").map(xe)}function cn(r){const t=r.replace(/\(\(/,"").replace(/\)\)$/,"").split("), ("),e=new un;let n;return t.forEach((s,l)=>{let o=s.split(", ").map(u=>new fn(u.split(" ").map(Number)));const a=e.addFace(o);l===0?n=a.orientation():a.orientation()===n&&a.reverse()}),e}function qi(r){const e=r.split(/\)\), \(\(/).map(l=>"(("+l+"))").map(cn),n=new un;return e.reduce((l,o)=>[...l,...o==null?void 0:o.faces],[]).forEach(l=>n.addFace([...l==null?void 0:l.shapes])),n}function Di(r){if(r.startsWith("POLYGON")){const t=r.replace(/^POLYGON /,"");return cn(t)}else{const t=r.replace(/^MULTIPOLYGON \(\(\((.*)\)\)\)$/,"$1");return qi(t)}}function Wi(r){return r.split(`
`).map(e=>e.match(/\(([^)]+)\)/)[1]).map(Ee)}function zi(r){return r.split(`
`).map(e=>e.match(/\(([^)]+)\)/)[1]).map(xe).reduce((e,n)=>[...e,...n],[])}function dn(r){if(r.startsWith("POINT")){const t=r.replace(/^POINT \(/,"").replace(/\)$/,"");return Ee(t)}else if(r.startsWith("MULTIPOINT")){const t=r.replace(/^MULTIPOINT \(/,"").replace(/\)$/,"");return hn(t)}else if(r.startsWith("LINESTRING")){const t=r.replace(/^LINESTRING \(/,"").replace(/\)$/,"");return xe(t)}else if(r.startsWith("MULTILINESTRING")){const t=r.replace(/^MULTILINESTRING /,"");return Gi(t)}else{if(r.startsWith("POLYGON")||r.startsWith("MULTIPOLYGON"))return Di(r);if(r.startsWith("GEOMETRYCOLLECTION")){const t=/(?<type>POINT|LINESTRING|POLYGON|MULTIPOINT|MULTILINESTRING|MULTIPOLYGON) \((?:[^\(\)]|\([^\)]*\))*\)/g,e=r.match(t);return e[0].startsWith("GEOMETRYCOLLECTION")&&(e[0]=e[0].replace("GEOMETRYCOLLECTION (","")),e.map(dn).map(s=>s instanceof Array?s:[s]).reduce((s,l)=>[...s,...l],[])}else{if(gn(r))return Wi(r);if(pn(r))return zi(r)}}return[]}function gn(r){var t;return(t=r.split(`
`))==null?void 0:t.every(e=>e.includes("POINT"))}function pn(r){var t;return(t=r.split(`
`))==null?void 0:t.every(e=>e.includes("LINESTRING"))}function Yi(r){return r.startsWith("POINT")||gn(r)||r.startsWith("LINESTRING")||pn(r)||r.startsWith("MULTILINESTRING")||r.startsWith("POLYGON")||r.startsWith("MULTIPOINT")||r.startsWith("MULTIPOLYGON")||r.startsWith("GEOMETRYCOLLECTION")}i.isWktString=Yi,i.parseWKT=dn,i.BooleanOperations=ri,i.Relations=Ei;const _n=i.Matrix,Kt=24,Te=60,A=class A extends w.Path{constructor(t,e){if(super(),w.Util.setOptions(this,e),t==null)throw Error("latLng required");e=e||{},this._latLng=w.latLng(t),this._heading=e.heading,this._course=e.course,this._speed=e.speed,this._shapeOptions=e.shapeOptions||{leaderTime:Te,defaultShapeSet:A.DEFAULT_SHAPE_SET},this._setShapeOptions(e.shapeOptions)}_project(){this._currentShapePoints=this._getProjectedShapePoints(),this._currentLeaderPoints=this._getLeaderShapePoints();const t=new w.Bounds;for(let e=0;e<this._currentShapePoints.length;e++){const n=this._currentShapePoints[e];t.extend(n)}if(this._currentLeaderPoints!==void 0)for(let e=0;e<this._currentLeaderPoints.length;e++){const n=this._currentShapePoints[e];t.extend(n)}this._currentBounds=t,this._currentLatLngBounds=new w.LatLngBounds(this._map.layerPointToLatLng(t.getBottomLeft()),this._map.layerPointToLatLng(t.getTopRight()))}_update(){if(!this._map)return;const t=this.getElement();if(t===void 0)return;const e=[];this._currentShapePoints!==void 0&&e.push(A._toSVGPath(this._currentShapePoints,!0)),this._currentLeaderPoints!==void 0&&e.push(A._toSVGPath(this._currentLeaderPoints,!1));const n=e.join(" ");t.setAttribute("d",n)}_setShapeOptions(t){this._shapeOptions=t||{leaderTime:Te,defaultShapeSet:A.DEFAULT_SHAPE_SET},this._shapeOptions.leaderTime===void 0&&(this._shapeOptions.leaderTime=Te),this._shapeOptions.defaultShapeSet===void 0&&(this._shapeOptions.defaultShapeSet=A.DEFAULT_SHAPE_SET),this._shapeOptions.shapeSetEntries!==void 0&&this._shapeOptions.shapeSetEntries.sort((e,n)=>n.minZoomLevel-e.minZoomLevel)}setLatLng(t){const e=this._latLng;return this._latLng=w.latLng(t),this.fire("move",{oldLatLng:e,latlng:this._latLng}),this.redraw()}setHeading(t){return this._heading=t,this.redraw()}setCourse(t){return this._course=t,this.redraw()}setSpeed(t){return this._speed=t,this.redraw()}setShapeOptions(t){return this._setShapeOptions(t),this.redraw()}getBounds(){return this._currentLatLngBounds}getLatLng(){return this._latLng}getSpeed(){return this._speed}getHeading(){return this._heading}getCourse(){return this._course}static createShape(t,e){return{points:t,length:e,breadth:e,units:"pixels"}}static createShapeSet(t){return{withHeading:A.createShape(A.DEFAULT_HEADING_SHAPE_POINTS,t),withoutHeading:A.createShape(A.DEFAULT_NOHEADING_SHAPE_POINTS,t)}}_getLatSizeOf(t){return t/40075017*360}_getLngSizeOf(t){return t/40075017*360/Math.cos(Math.PI/180*this._latLng.lat)}_getViewAngleFromModel(t){return t-Math.PI/2}_getLeaderShapePoints(){if(this._course===void 0||this._speed===void 0||this._shapeOptions===void 0||this._shapeOptions.leaderTime===void 0)return;const t=this._getViewAngleFromModel(this._course),e=this._speed*this._shapeOptions.leaderTime,n=this._calcRelativeLatLng(this._latLng,e,t);return this._latLngsToLayerPoints(this._latLng,n)}_calcRelativeLatLng(t,e,n){return new w.LatLng(t.lat-this._getLatSizeOf(e*Math.sin(n)),t.lng+this._getLngSizeOf(e*Math.cos(n)))}_latLngsToLayerPoints(...t){return t.map(e=>this._map.latLngToLayerPoint(e))}_getShapeSet(){if(this._shapeOptions.shapeSetEntries===void 0||this._shapeOptions.shapeSetEntries.length==0)return this._shapeOptions.defaultShapeSet?this._shapeOptions.defaultShapeSet:A.DEFAULT_SHAPE_SET;const t=this._map.getZoom(),e=this._shapeOptions.shapeSetEntries.sort((n,s)=>s.minZoomLevel-n.minZoomLevel).filter(n=>t>=n.minZoomLevel);return e.length>0?e[0].shapeSet:this._shapeOptions.defaultShapeSet?this._shapeOptions.defaultShapeSet:A.DEFAULT_SHAPE_SET}_getShape(){const t=this._getShapeSet();return this._heading!==void 0?t.withHeading:t.withoutHeading}_getTransformedShapePoints(){const t=this._getShape();let e=new _n;if(this._heading!==void 0){const s=this._getViewAngleFromModel(this._heading);e=e.rotate(s)}return t.center!==void 0&&(e=e.translate(-t.center[0],-t.center[1])),e=e.scale(t.length,t.breadth),[t.points.map(s=>e.transform(s)),t.units]}_getProjectedShapePoints(){const[t,e]=this._getTransformedShapePoints();switch(e){case"pixels":{const n=this._map.latLngToLayerPoint(this._latLng),s=new _n().translate(n.x,n.y);return t.map(l=>{const o=s.transform(l);return new w.Point(o[0],o[1])})}case"meters":return t.map(n=>this._map.latLngToLayerPoint(new w.LatLng(this._latLng.lat-this._getLatSizeOf(n[1]),this._latLng.lng+this._getLngSizeOf(n[0]))));default:throw`unsupported units: ${e}`}}static _toSVGPath(t,e){let n="";for(let s=0;s<t.length;s++){const l=t[s];n===""?n=`M ${l.x} ${l.y} `:n+=`L ${l.x} ${l.y} `}return e&&(n+="Z"),n}};A.DEFAULT_HEADING_SHAPE_POINTS=[[.75,0],[-.25,.3],[-.25,-.3]],A.DEFAULT_NOHEADING_SHAPE_POINTS=[[.3,0],[0,.3],[-.3,0],[0,-.3]],A.DEFAULT_SHAPE_SET={withHeading:{points:A.DEFAULT_HEADING_SHAPE_POINTS,length:Kt,breadth:Kt,units:"pixels"},withoutHeading:{points:A.DEFAULT_NOHEADING_SHAPE_POINTS,length:Kt,breadth:Kt,units:"pixels"}};let B=A;const Qi=24,ji=14,Zi=60,Xi=1.944,mn=102.3,Ki=360,Ji=360,En="#000000",xn="#d3d3d3",N="#000000",C="#d3d3d3",nt="#8b008b",it="#ff00ff",V="#00008b",H="#ffff00",X="#008b8b",K="#00ffff",$="#00008b",G="#0000ff",q="#006400",D="#90ee90",W="#8b0000",z="#ff0000",Y="#008b8b",Q="#00ffff",Tn={0:c("Not available",N,C),20:c("Wing in ground (WIG), all ships of this type",N,C),21:c("Wing in ground (WIG), Hazardous category A",N,C),22:c("Wing in ground (WIG), Hazardous category B",N,C),23:c("Wing in ground (WIG), Hazardous category C",N,C),24:c("Wing in ground (WIG), Hazardous category D",N,C),25:c("Wing in ground (WIG), Reserved for future use",N,C),26:c("Wing in ground (WIG), Reserved for future use",N,C),27:c("Wing in ground (WIG), Reserved for future use",N,C),28:c("Wing in ground (WIG), Reserved for future use",N,C),29:c("Wing in ground (WIG), Reserved for future use",N,C),30:c("Fishing",nt,it),31:c("Towing",nt,it),32:c("Towing: length exceeds 200m or breadth exceeds 25m",nt,it),33:c("Dredging or underwater ops",nt,it),34:c("Diving ops",nt,it),35:c("Military ops",nt,it),36:c("Sailing",nt,it),37:c("Pleasure Craft",nt,it),40:c("High speed craft (HSC), all ships of this type",V,H),41:c("High speed craft (HSC), Hazardous category A",V,H),42:c("High speed craft (HSC), Hazardous category B",V,H),43:c("High speed craft (HSC), Hazardous category C",V,H),44:c("High speed craft (HSC), Hazardous category D",V,H),45:c("High speed craft (HSC), Reserved for future use",V,H),46:c("High speed craft (HSC), Reserved for future use",V,H),47:c("High speed craft (HSC), Reserved for future use",V,H),48:c("High speed craft (HSC), Reserved for future use",V,H),49:c("High speed craft (HSC), No additional information",V,H),50:c("Pilot Vessel",X,K),51:c("Search and Rescue vessel",X,K),52:c("Tug",X,K),53:c("Port Tender",X,K),54:c("Anti-pollution equipment",X,K),55:c("Law Enforcement",X,K),56:c("Spare - Local Vessel",X,K),57:c("Spare - Local Vessel",X,K),58:c("Medical Transport",X,K),59:c("Noncombatant ship according to RR Resolution No. 18","",""),60:c("Passenger, all ships of this type",$,G),61:c("Passenger, Hazardous category A",$,G),62:c("Passenger, Hazardous category B",$,G),63:c("Passenger, Hazardous category C",$,G),64:c("Passenger, Hazardous category D",$,G),65:c("Passenger, Reserved for future use",$,G),66:c("Passenger, Reserved for future use",$,G),67:c("Passenger, Reserved for future use",$,G),68:c("Passenger, Reserved for future use",$,G),69:c("Passenger, No additional information",$,G),70:c("Cargo, all ships of this type",q,D),71:c("Cargo, Hazardous category A",q,D),72:c("Cargo, Hazardous category B",q,D),73:c("Cargo, Hazardous category C",q,D),74:c("Cargo, Hazardous category D",q,D),75:c("Cargo, Reserved for future use",q,D),76:c("Cargo, Reserved for future use",q,D),77:c("Cargo, Reserved for future use",q,D),78:c("Cargo, Reserved for future use",q,D),79:c("Cargo, No additional information",q,D),80:c("Tanker, all ships of this type",W,z),81:c("Tanker, Hazardous category A",W,z),82:c("Tanker, Hazardous category B",W,z),83:c("Tanker, Hazardous category C",W,z),84:c("Tanker, Hazardous category D",W,z),85:c("Tanker, Reserved for future use",W,z),86:c("Tanker, Reserved for future use",W,z),87:c("Tanker, Reserved for future use",W,z),88:c("Tanker, Reserved for future use",W,z),89:c("Tanker, No additional information",W,z),90:c("Other Type, all ships of this type",Y,Q),91:c("Other Type, Hazardous category A",Y,Q),92:c("Other Type, Hazardous category B",Y,Q),93:c("Other Type, Hazardous category C",Y,Q),94:c("Other Type, Hazardous category D",Y,Q),95:c("Other Type, Reserved for future use",Y,Q),96:c("Other Type, Reserved for future use",Y,Q),97:c("Other Type, Reserved for future use",Y,Q),98:c("Other Type, Reserved for future use",Y,Q),99:c("Other Type, no additional information",Y,Q)},tr=c("Reserved",En,xn),er=c("Unknown",En,xn),wt=class wt extends B{constructor(t,e){super([t.latitude,t.longitude],e),w.Util.setOptions(this,e),e=e||{},this._leaderTime=e.leaderTime||Zi,this._minZoomLevel=e.minZoomLevel||ji,this._size=e.size||Qi,this._positionReport=t,this.setPositionReport(t),this.setShipStaticData(e.shipStaticData)}static etaFromDate(t){if(t!=null)return{month:t.getMonth()+1,day:t.getDate(),hour:t.getHours(),minute:t.getMinutes()}}setPositionReport(t){return this._positionReport=t,this.setLatLng([t.latitude,t.longitude]),t.trueHeading!==null&&t.trueHeading!==void 0&&t.trueHeading<Ji?this.setHeading(In(t.trueHeading)):this.setHeading(void 0),t.cog!==null&&t.cog!==void 0&&t.cog<Ki?this.setCourse(In(t.cog)):this.setCourse(void 0),t.sog!==null&&t.sog!==void 0&&t.sog<mn?this.setSpeed(t.sog/Xi):this.setSpeed(void 0),this.bindPopup(this._getPopupContent(this._positionReport,this._shipStaticData)),this.redraw()}setShipStaticData(t){this._shipStaticData=t;const e=vn(t!=null?t.type:void 0);return this.setStyle({color:e.color,fill:!0,fillOpacity:1,fillColor:e.fillColor}),this.bindPopup(this._getPopupContent(this._positionReport,this._shipStaticData)),this.setShapeOptions(wt._getShapeOptions(this._leaderTime,this._minZoomLevel,this._size,t))}static _getShapeOptions(t,e,n,s){const l={leaderTime:t,defaultShapeSet:B.createShapeSet(n)},o=wt._getShapeSet(n,s);return o!==null&&(l.shapeSetEntries=[{shapeSet:o,minZoomLevel:e}]),l}static _getShapeSet(t,e){return e==null||e.dimension===null||e.dimension===void 0||!Sn(e.dimension)?null:{withHeading:{points:wt.DEFAULT_SILHOUETTE_SHAPE_POINTS,center:[e.dimension.B,e.dimension.D],length:e.dimension.A+e.dimension.B,breadth:e.dimension.C+e.dimension.D,units:"meters"},withoutHeading:B.createShape(B.DEFAULT_NOHEADING_SHAPE_POINTS,t)}}_getPopupContent(t,e){let n="<table>";e!=null&&(n+=L("User ID",e.userId),n+=L("IMO Number",e.imoNumber),n+=L("Call sign",e.callSign),n+=L("Name",e.name)),t!=null&&(n+=L("Location",`${St(t.latitude,5)}, ${St(t.longitude,5)}`),n+=L("SOG",St(t.sog,2,l=>l<mn),"knots"),n+=L("COG",St(t.cog,1),"°"),n+=L("Heading",St(t.trueHeading,1),"°"),n+=L("Navigation status",rr(t.navigationalStatus))),e!=null&&(n+=L("Type",nr(e.type)),e.dimension!==null&&e.dimension!==void 0&&Sn(e.dimension)&&(n+=L("Ship length",e.dimension.A+e.dimension.B,"m"),n+=L("Ship width",e.dimension.C+e.dimension.D,"m")),n+=L("Fix type",ir(e.fixType)),n+=L("ETA",sr(e.eta)),n+=L("Maximum static draught",St(e.maximumStaticDraught,1),"m"),n+=L("Destination",e.destination),n+=L("DTE",e.dte)),n+="</table>";const s=w.DomUtil.create("div");return s.innerHTML=n,s}};wt.DEFAULT_SILHOUETTE_SHAPE_POINTS=[[1,.5],[.75,1],[0,1],[0,0],[.75,0]];let $t=wt;function St(r,t,e){if(r!=null&&!(e&&!e(r)))return r.toFixed(t)}function nr(r){return r==null?void 0:vn(r).name}function ir(r){if(r!=null)switch(r){case 0:return;case 1:return"GPS";case 2:return"GLONASS";case 3:return"combined GPS/GLONASS";case 4:return"Loran-C";case 5:return"Chayka";case 6:return"integrated navigation system";case 7:return"surveyed";case 8:return"Galileo";case 9:case 10:case 11:case 12:case 13:case 14:return`not used (${r})`;case 15:return"internal GNSS";default:return`unknown (${r})`}}function rr(r){if(r!=null)switch(r){case 0:return"Under way using engine";case 1:return"At anchor";case 2:return"Not under command";case 3:return"Restricted manoeuverability";case 4:return"Constrained by her draught";case 5:return"Moored";case 6:return"Aground";case 7:return"Engaged in Fishing";case 8:return"Under way sailing";case 9:return"Reserved for future amendment of Navigational Status for HSC";case 10:return"Reserved for future amendment of Navigational Status for WIG";case 11:return"Reserved for future use";case 12:return"Reserved for future use";case 13:return"Reserved for future use";case 14:return"AIS-SART is active";case 15:return"Not defined (default)";default:return`unknown (${r})`}}function sr(r){if(r==null)return;const t=[];if(!vt(r.month)&&!vt(r.day)&&t.push(`${r.month.toString().padStart(2,"0")}/${r.day.toString().padStart(2,"0")}`),!vt(r.hour)&&!vt(r.minute)&&t.push(`${r.hour.toString().padStart(2,"0")}:${r.minute.toString().padStart(2,"0")}`),t.length!==0)return`${t.join(" ")} UTC`}function In(r){if(r!=null)return r*Math.PI/180}function vt(r){return r==null}function Sn(r){return r!=null&&r.A>0&&r.B>0&&r.C>0&&r.D>0}function L(r,t,e){if(t==null)return"";const n=String(t);return`<tr><td>${r}</td><td>${n} ${vt(e)?"":e}</td></tr>`}function c(r,t,e){return{name:r,color:t,fillColor:e}}function vn(r){if(r==null)return Tn[0];if(r<0||r>99)return er;const t=Tn[r];return vt(t)?tr:t}w.trackSymbol=function(r,t){return new B(r,t)},w.TrackSymbol=B,w.aisTrackSymbol=function(r,t){return new $t(r,t)},w.AISTrackSymbol=$t,Z.AISTrackSymbol=$t,Z.TrackSymbol=B,Z.default=B,Object.defineProperties(Z,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
//# sourceMappingURL=leaflet-tracksymbol2.umd.js.map
