{"version":3,"file":"leaflet-tracksymbol2.es.js","sources":["../node_modules/.pnpm/@flatten-js+core@1.3.5/node_modules/@flatten-js/core/dist/main.esm.js","../src/trackSymbol.ts","../src/ais/aisTrackSymbol.ts","../src/index.ts"],"sourcesContent":["/**\r\n * Global constant CCW defines counter clockwise direction of arc\r\n * @type {boolean}\r\n */\r\nconst CCW = true;\r\n\r\n/**\r\n * Global constant CW defines clockwise direction of arc\r\n * @type {boolean}\r\n */\r\nconst CW = false;\r\n\r\n/**\r\n * Defines orientation for face of the polygon: clockwise, counter clockwise\r\n * or not orientable in the case of self-intersection\r\n * @type {{CW: number, CCW: number, NOT_ORIENTABLE: number}}\r\n */\r\nconst ORIENTATION = {CCW:-1, CW:1, NOT_ORIENTABLE: 0};\r\n\r\nconst PIx2 = 2 * Math.PI;\r\n\r\nconst INSIDE = 1;\r\nconst OUTSIDE = 0;\r\nconst BOUNDARY = 2;\r\nconst CONTAINS = 3;\r\nconst INTERLACE = 4;\r\n\r\nconst OVERLAP_SAME = 1;\r\nconst OVERLAP_OPPOSITE = 2;\r\n\r\nconst NOT_VERTEX = 0;\r\nconst START_VERTEX = 1;\r\nconst END_VERTEX = 2;\r\n\r\nvar Constants = /*#__PURE__*/Object.freeze({\r\n    CCW: CCW,\r\n    CW: CW,\r\n    ORIENTATION: ORIENTATION,\r\n    PIx2: PIx2,\r\n    INSIDE: INSIDE,\r\n    OUTSIDE: OUTSIDE,\r\n    BOUNDARY: BOUNDARY,\r\n    CONTAINS: CONTAINS,\r\n    INTERLACE: INTERLACE,\r\n    OVERLAP_SAME: OVERLAP_SAME,\r\n    OVERLAP_OPPOSITE: OVERLAP_OPPOSITE,\r\n    NOT_VERTEX: NOT_VERTEX,\r\n    START_VERTEX: START_VERTEX,\r\n    END_VERTEX: END_VERTEX\r\n});\r\n\r\n/**\r\n * Created by Alex Bol on 2/18/2017.\r\n */\r\n\r\n/**\r\n * Floating point comparison tolerance.\r\n * Default value is 0.000001 (10e-6)\r\n * @type {number}\r\n */\r\nlet DP_TOL = 0.000001;\r\n\r\n/**\r\n * Set new floating point comparison tolerance\r\n * @param {number} tolerance\r\n */\r\nfunction setTolerance(tolerance) {DP_TOL = tolerance;}\r\n\r\n/**\r\n * Get floating point comparison tolerance\r\n * @returns {number}\r\n */\r\nfunction getTolerance() {return DP_TOL;}\r\n\r\nconst DECIMALS = 3;\r\n\r\n/**\r\n * Returns *true* if value comparable to zero\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nfunction EQ_0(x) {\r\n    return (x < DP_TOL && x > -DP_TOL);\r\n}\r\n\r\n/**\r\n * Returns *true* if two values are equal up to DP_TOL\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nfunction EQ(x, y) {\r\n    return (x - y < DP_TOL && x - y > -DP_TOL);\r\n}\r\n\r\n/**\r\n * Returns *true* if first argument greater than second argument up to DP_TOL\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nfunction GT(x, y) {\r\n    return (x - y > DP_TOL);\r\n}\r\n\r\n/**\r\n * Returns *true* if first argument greater than or equal to second argument up to DP_TOL\r\n * @param {number} x\r\n * @param {number} y\r\n * @returns {boolean}\r\n */\r\nfunction GE(x, y) {\r\n    return (x - y > -DP_TOL);\r\n}\r\n\r\n/**\r\n * Returns *true* if first argument less than second argument up to DP_TOL\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nfunction LT(x, y) {\r\n    return (x - y < -DP_TOL)\r\n}\r\n\r\n/**\r\n * Returns *true* if first argument less than or equal to second argument up to DP_TOL\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nfunction LE(x, y) {\r\n    return (x - y < DP_TOL);\r\n}\r\n\r\nvar Utils = /*#__PURE__*/Object.freeze({\r\n    setTolerance: setTolerance,\r\n    getTolerance: getTolerance,\r\n    DECIMALS: DECIMALS,\r\n    EQ_0: EQ_0,\r\n    EQ: EQ,\r\n    GT: GT,\r\n    GE: GE,\r\n    LT: LT,\r\n    LE: LE\r\n});\r\n\r\n/**\r\n * Created by Alex Bol on 2/19/2017.\r\n */\r\n\r\n/**\r\n * Class of system errors\r\n */\r\nclass Errors {\r\n    /**\r\n     * Throw error ILLEGAL_PARAMETERS when cannot instantiate from given parameter\r\n     * @returns {ReferenceError}\r\n     */\r\n    static get ILLEGAL_PARAMETERS() {\r\n        return new ReferenceError('Illegal Parameters');\r\n    }\r\n\r\n    /**\r\n     * Throw error ZERO_DIVISION to catch situation of zero division\r\n     * @returns {Error}\r\n     */\r\n    static get ZERO_DIVISION() {\r\n        return new Error('Zero division');\r\n    }\r\n\r\n    /**\r\n     * Error to throw from BooleanOperations module in case when fixBoundaryConflicts not capable to fix it\r\n     * @returns {Error}\r\n     */\r\n    static get UNRESOLVED_BOUNDARY_CONFLICT() {\r\n        return new Error('Unresolved boundary conflict in boolean operation');\r\n    }\r\n\r\n    /**\r\n     * Error to throw from LinkedList:testInfiniteLoop static method\r\n     * in case when circular loop detected in linked list\r\n     * @returns {Error}\r\n     */\r\n    static get INFINITE_LOOP() {\r\n        return new Error('Infinite loop');\r\n    }\r\n}\r\n\r\nvar errors = /*#__PURE__*/Object.freeze({\r\n    default: Errors\r\n});\r\n\r\nlet Flatten = {\r\n    Utils: Utils,\r\n    Errors: Errors,\r\n    Matrix: undefined,\r\n    Planar_set: undefined,\r\n    Point: undefined,\r\n    Vector: undefined,\r\n    Line: undefined,\r\n    Circle: undefined,\r\n    Segment: undefined,\r\n    Arc: undefined,\r\n    Box: undefined,\r\n    Edge: undefined,\r\n    Face: undefined,\r\n    Ray: undefined,\r\n    Ray_shooting: undefined,\r\n    Multiline: undefined,\r\n    Polygon: undefined,\r\n    Distance: undefined,\r\n    Inversion: undefined\r\n};\r\n\r\nfor (let c in Constants) {Flatten[c] = Constants[c];}\r\n\r\nObject.defineProperty(Flatten, 'DP_TOL', {\r\n    get:function(){return getTolerance()}, \r\n    set:function(value){setTolerance(value);}\r\n});\r\n\r\n/**\r\n * Class implements bidirectional non-circular linked list. <br/>\r\n * LinkedListElement - object of any type that has properties next and prev.\r\n */\r\nclass LinkedList {\r\n    constructor(first, last) {\r\n        this.first = first;\r\n        this.last = last || this.first;\r\n    }\r\n\r\n    /**\r\n     * Throw an error if circular loop detected in the linked list\r\n     * @param {LinkedListElement} first element to start iteration\r\n     * @throws {Flatten.Errors.INFINITE_LOOP}\r\n     */\r\n    static testInfiniteLoop(first) {\r\n        let edge = first;\r\n        let controlEdge = first;\r\n        do {\r\n            if (edge != first && edge === controlEdge) {\r\n                throw Flatten.Errors.INFINITE_LOOP;  // new Error(\"Infinite loop\")\r\n            }\r\n            edge = edge.next;\r\n            controlEdge = controlEdge.next.next;\r\n        } while (edge != first)\r\n    }\r\n\r\n    /**\r\n     * Return number of elements in the list\r\n     * @returns {number}\r\n     */\r\n    get size() {\r\n        let counter = 0;\r\n        for (let edge of this) {\r\n            counter++;\r\n        }\r\n        return counter;\r\n    }\r\n\r\n    /**\r\n     * Return array of elements from start to end,\r\n     * If start or end not defined, take first as start, last as end\r\n     * @returns {Array}\r\n     */\r\n    toArray(start=undefined, end=undefined) {\r\n        let elements = [];\r\n        let from = start || this.first;\r\n        let to = end || this.last;\r\n        let element = from;\r\n        if (element === undefined) return elements;\r\n        do {\r\n            elements.push(element);\r\n            element = element.next;\r\n        } while (element !== to.next);\r\n        return elements;\r\n    }\r\n\r\n\r\n    /**\r\n     * Append new element to the end of the list\r\n     * @param {LinkedListElement} element\r\n     * @returns {LinkedList}\r\n     */\r\n    append(element) {\r\n        if (this.isEmpty()) {\r\n            this.first = element;\r\n        } else {\r\n            element.prev = this.last;\r\n            this.last.next = element;\r\n        }\r\n\r\n        // update edge to be last\r\n        this.last = element;\r\n\r\n        // nullify non-circular links\r\n        this.last.next = undefined;\r\n        this.first.prev = undefined;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Insert new element to the list after elementBefore\r\n     * @param {LinkedListElement} newElement\r\n     * @param {LinkedListElement} elementBefore\r\n     * @returns {LinkedList}\r\n     */\r\n    insert(newElement, elementBefore) {\r\n        if (this.isEmpty()) {\r\n            this.first = newElement;\r\n            this.last = newElement;\r\n        }\r\n        else if (elementBefore === null || elementBefore === undefined) {\r\n            newElement.next = this.first;\r\n            this.first.prev = newElement;\r\n            this.first = newElement;\r\n        }\r\n        else {\r\n            /* set links to new element */\r\n            let elementAfter = elementBefore.next;\r\n            elementBefore.next = newElement;\r\n            if (elementAfter) elementAfter.prev = newElement;\r\n\r\n            /* set links from new element */\r\n            newElement.prev = elementBefore;\r\n            newElement.next = elementAfter;\r\n\r\n            /* extend list if new element added after the last element */\r\n            if (this.last === elementBefore)\r\n                this.last = newElement;\r\n        }\r\n        // nullify non-circular links\r\n        this.last.next = undefined;\r\n        this.first.prev = undefined;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove element from the list\r\n     * @param {LinkedListElement} element\r\n     * @returns {LinkedList}\r\n     */\r\n    remove(element) {\r\n        // special case if last edge removed\r\n        if (element === this.first && element === this.last) {\r\n            this.first = undefined;\r\n            this.last = undefined;\r\n        } else {\r\n            // update linked list\r\n            if (element.prev) element.prev.next = element.next;\r\n            if (element.next) element.next.prev = element.prev;\r\n            // update first if need\r\n            if (element === this.first) {\r\n                this.first = element.next;\r\n            }\r\n            // update last if need\r\n            if (element === this.last) {\r\n                this.last = element.prev;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Return true if list is empty\r\n     * @returns {boolean}\r\n     */\r\n    isEmpty() {\r\n        return this.first === undefined;\r\n    }\r\n\r\n    [Symbol.iterator]() {\r\n        let value = undefined;\r\n        return {\r\n            next: () => {\r\n                value = value ? value.next : this.first;\r\n                return {value: value, done: value === undefined};\r\n            }\r\n        };\r\n    };\r\n}\r\n\r\n/*\r\n    Smart intersections describe intersection points that refers to the edges they intersect\r\n    This function are supposed for internal usage by morphing and relation methods between\r\n */\r\n\r\nfunction addToIntPoints(edge, pt, int_points)\r\n{\r\n    let id = int_points.length;\r\n    let shapes = edge.shape.split(pt);\r\n\r\n    // if (shapes.length < 2) return;\r\n    if (shapes.length === 0) return;     // Point does not belong to edge ?\r\n\r\n    let len = 0;\r\n    if (shapes[0] === null) {   // point incident to edge start vertex\r\n        len = 0;\r\n    }\r\n    else if (shapes[1] === null) {   // point incident to edge end vertex\r\n        len = edge.shape.length;\r\n    }\r\n    else {                             // Edge was split into to edges\r\n        len = shapes[0].length;\r\n    }\r\n\r\n    let is_vertex = NOT_VERTEX;\r\n    if (EQ(len, 0)) {\r\n        is_vertex |= START_VERTEX;\r\n    }\r\n    if (EQ(len, edge.shape.length)) {\r\n        is_vertex |= END_VERTEX;\r\n    }\r\n    // Fix intersection point which is end point of the last edge\r\n    let arc_length = (is_vertex & END_VERTEX) && edge.next.arc_length === 0 ? 0 : edge.arc_length + len;\r\n\r\n    int_points.push({\r\n        id: id,\r\n        pt: pt,\r\n        arc_length: arc_length,\r\n        edge_before: edge,\r\n        edge_after: undefined,\r\n        face: edge.face,\r\n        is_vertex: is_vertex\r\n    });\r\n}\r\n\r\nfunction sortIntersections(intersections)\r\n{\r\n    // if (intersections.int_points1.length === 0) return;\r\n\r\n    // augment intersections with new sorted arrays\r\n    // intersections.int_points1_sorted = intersections.int_points1.slice().sort(compareFn);\r\n    // intersections.int_points2_sorted = intersections.int_points2.slice().sort(compareFn);\r\n    intersections.int_points1_sorted = getSortedArray(intersections.int_points1);\r\n    intersections.int_points2_sorted = getSortedArray(intersections.int_points2);\r\n}\r\n\r\nfunction getSortedArray(int_points)\r\n{\r\n    let faceMap = new Map;\r\n    let id = 0;\r\n    // Create integer id's for faces\r\n    for (let ip of int_points) {\r\n        if (!faceMap.has(ip.face)) {\r\n            faceMap.set(ip.face, id);\r\n            id++;\r\n        }\r\n    }\r\n    // Augment intersection points with face id's\r\n    for (let ip of int_points) {\r\n        ip.faceId = faceMap.get(ip.face);\r\n    }\r\n    // Clone and sort\r\n    let int_points_sorted = int_points.slice().sort(compareFn);\r\n    return int_points_sorted;\r\n}\r\n\r\nfunction compareFn(ip1, ip2)\r\n{\r\n    // compare face id's\r\n    if (ip1.faceId < ip2.faceId) {\r\n        return -1;\r\n    }\r\n    if (ip1.faceId > ip2.faceId) {\r\n        return 1;\r\n    }\r\n    // same face - compare arc_length\r\n    if (ip1.arc_length < ip2.arc_length) {\r\n        return -1;\r\n    }\r\n    if (ip1.arc_length > ip2.arc_length) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\n\r\nfunction getSortedArrayOnLine(line, int_points) {\r\n    return int_points.slice().sort( (int_point1, int_point2) => {\r\n        if (line.coord(int_point1.pt) < line.coord(int_point2.pt)) {\r\n            return -1;\r\n        }\r\n        if (line.coord(int_point1.pt) > line.coord(int_point2.pt)) {\r\n            return 1;\r\n        }\r\n        return 0;\r\n    })\r\n}\r\n\r\nfunction filterDuplicatedIntersections(intersections)\r\n{\r\n    if (intersections.int_points1.length < 2) return;\r\n\r\n    let do_squeeze = false;\r\n\r\n    let int_point_ref1;\r\n    let int_point_ref2;\r\n    let int_point_cur1;\r\n    let int_point_cur2;\r\n    for (let i = 0; i < intersections.int_points1_sorted.length; i++) {\r\n\r\n        if (intersections.int_points1_sorted[i].id === -1)\r\n            continue;\r\n\r\n        int_point_ref1 = intersections.int_points1_sorted[i];\r\n        int_point_ref2 = intersections.int_points2[int_point_ref1.id];\r\n\r\n        for (let j=i+1; j < intersections.int_points1_sorted.length; j++) {\r\n            int_point_cur1 = intersections.int_points1_sorted[j];\r\n            if (!EQ(int_point_cur1.arc_length, int_point_ref1.arc_length)) {\r\n                break;\r\n            }\r\n            if (int_point_cur1.id === -1)\r\n                continue;\r\n            int_point_cur2 = intersections.int_points2[int_point_cur1.id];\r\n            if (int_point_cur2.id === -1)\r\n                continue;\r\n            if (int_point_cur1.edge_before === int_point_ref1.edge_before &&\r\n                int_point_cur1.edge_after === int_point_ref1.edge_after &&\r\n                int_point_cur2.edge_before === int_point_ref2.edge_before &&\r\n                int_point_cur2.edge_after === int_point_ref2.edge_after) {\r\n                int_point_cur1.id = -1;\r\n                /* to be deleted */\r\n                int_point_cur2.id = -1;\r\n                /* to be deleted */\r\n                do_squeeze = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    int_point_ref2 = intersections.int_points2_sorted[0];\r\n    int_point_ref1 = intersections.int_points1[int_point_ref2.id];\r\n    for (let i = 1; i < intersections.int_points2_sorted.length; i++) {\r\n        let int_point_cur2 = intersections.int_points2_sorted[i];\r\n\r\n        if (int_point_cur2.id == -1) continue;\r\n        /* already deleted */\r\n\r\n        if (int_point_ref2.id == -1 || /* can't be reference if already deleted */\r\n            !(EQ(int_point_cur2.arc_length, int_point_ref2.arc_length))) {\r\n            int_point_ref2 = int_point_cur2;\r\n            int_point_ref1 = intersections.int_points1[int_point_ref2.id];\r\n            continue;\r\n        }\r\n\r\n        let int_point_cur1 = intersections.int_points1[int_point_cur2.id];\r\n        if (int_point_cur1.edge_before === int_point_ref1.edge_before &&\r\n            int_point_cur1.edge_after === int_point_ref1.edge_after &&\r\n            int_point_cur2.edge_before === int_point_ref2.edge_before &&\r\n            int_point_cur2.edge_after === int_point_ref2.edge_after) {\r\n            int_point_cur1.id = -1;\r\n            /* to be deleted */\r\n            int_point_cur2.id = -1;\r\n            /* to be deleted */\r\n            do_squeeze = true;\r\n        }\r\n    }\r\n\r\n    if (do_squeeze) {\r\n        intersections.int_points1 = intersections.int_points1.filter((int_point) => int_point.id >= 0);\r\n        intersections.int_points2 = intersections.int_points2.filter((int_point) => int_point.id >= 0);\r\n\r\n        // update id's\r\n        intersections.int_points1.forEach((int_point, index) => int_point.id = index);\r\n        intersections.int_points2.forEach((int_point, index) => int_point.id = index);\r\n    }\r\n}\r\n\r\nfunction initializeInclusionFlags(int_points)\r\n{\r\n    for (let int_point of int_points) {\r\n        int_point.edge_before.bvStart = undefined;\r\n        int_point.edge_before.bvEnd = undefined;\r\n        int_point.edge_before.bv = undefined;\r\n        int_point.edge_before.overlap = undefined;\r\n\r\n        int_point.edge_after.bvStart = undefined;\r\n        int_point.edge_after.bvEnd = undefined;\r\n        int_point.edge_after.bv = undefined;\r\n        int_point.edge_after.overlap = undefined;\r\n    }\r\n\r\n    for (let int_point of int_points) {\r\n        int_point.edge_before.bvEnd = BOUNDARY;\r\n        int_point.edge_after.bvStart = BOUNDARY;\r\n    }\r\n}\r\n\r\nfunction calculateInclusionFlags(int_points, polygon)\r\n{\r\n    for (let int_point of int_points) {\r\n        int_point.edge_before.setInclusion(polygon);\r\n        int_point.edge_after.setInclusion(polygon);\r\n    }\r\n}\r\n\r\nfunction setOverlappingFlags(intersections)\r\n{\r\n    let cur_face = undefined;\r\n    let first_int_point_in_face_id = undefined;\r\n    let next_int_point1 = undefined;\r\n    let num_int_points = intersections.int_points1.length;\r\n\r\n    for (let i = 0; i < num_int_points; i++) {\r\n        let cur_int_point1 = intersections.int_points1_sorted[i];\r\n\r\n        // Find boundary chain in the polygon1\r\n        if (cur_int_point1.face !== cur_face) {                               // next chain started\r\n            first_int_point_in_face_id = i; // cur_int_point1;\r\n            cur_face = cur_int_point1.face;\r\n        }\r\n\r\n        // Skip duplicated points with same <x,y> in \"cur_int_point1\" pool\r\n        let int_points_cur_pool_start = i;\r\n        let int_points_cur_pool_num = intPointsPoolCount(intersections.int_points1_sorted, i, cur_face);\r\n        let next_int_point_id;\r\n        if (int_points_cur_pool_start + int_points_cur_pool_num < num_int_points &&\r\n            intersections.int_points1_sorted[int_points_cur_pool_start + int_points_cur_pool_num].face === cur_face) {\r\n            next_int_point_id = int_points_cur_pool_start + int_points_cur_pool_num;\r\n        } else {                                         // get first point from the same face\r\n            next_int_point_id = first_int_point_in_face_id;\r\n        }\r\n\r\n        // From all points with same ,x,y. in 'next_int_point1' pool choose one that\r\n        // has same face both in res_poly and in wrk_poly\r\n        let int_points_next_pool_num = intPointsPoolCount(intersections.int_points1_sorted, next_int_point_id, cur_face);\r\n        next_int_point1 = null;\r\n        for (let j=next_int_point_id; j < next_int_point_id + int_points_next_pool_num; j++) {\r\n            let next_int_point1_tmp = intersections.int_points1_sorted[j];\r\n            if (next_int_point1_tmp.face === cur_face &&\r\n                intersections.int_points2[next_int_point1_tmp.id].face === intersections.int_points2[cur_int_point1.id].face) {\r\n                next_int_point1 = next_int_point1_tmp;\r\n                break;\r\n            }\r\n        }\r\n        if (next_int_point1 === null)\r\n            continue;\r\n\r\n        let edge_from1 = cur_int_point1.edge_after;\r\n        let edge_to1 = next_int_point1.edge_before;\r\n\r\n        if (!(edge_from1.bv === BOUNDARY && edge_to1.bv === BOUNDARY))      // not a boundary chain - skip\r\n            continue;\r\n\r\n        if (edge_from1 !== edge_to1)                    //  one edge chain    TODO: support complex case\r\n            continue;\r\n\r\n        /* Find boundary chain in polygon2 between same intersection points */\r\n        let cur_int_point2 = intersections.int_points2[cur_int_point1.id];\r\n        let next_int_point2 = intersections.int_points2[next_int_point1.id];\r\n\r\n        let edge_from2 = cur_int_point2.edge_after;\r\n        let edge_to2 = next_int_point2.edge_before;\r\n\r\n        /* if [edge_from2..edge_to2] is not a boundary chain, invert it */\r\n        /* check also that chain consist of one or two edges */\r\n        if (!(edge_from2.bv === BOUNDARY && edge_to2.bv === BOUNDARY && edge_from2 === edge_to2)) {\r\n            cur_int_point2 = intersections.int_points2[next_int_point1.id];\r\n            next_int_point2 = intersections.int_points2[cur_int_point1.id];\r\n\r\n            edge_from2 = cur_int_point2.edge_after;\r\n            edge_to2 = next_int_point2.edge_before;\r\n        }\r\n\r\n        if (!(edge_from2.bv === BOUNDARY && edge_to2.bv === BOUNDARY && edge_from2 === edge_to2))\r\n            continue;                           // not an overlapping chain - skip   TODO: fix boundary conflict\r\n\r\n        // Set overlapping flag - one-to-one case\r\n        edge_from1.setOverlap(edge_from2);\r\n    }\r\n}\r\n\r\nfunction intPointsPoolCount(int_points, cur_int_point_num, cur_face)\r\n{\r\n    let int_point_current;\r\n    let int_point_next;\r\n\r\n    let int_points_pool_num = 1;\r\n\r\n    if (int_points.length == 1) return 1;\r\n\r\n    int_point_current = int_points[cur_int_point_num];\r\n\r\n    for (let i = cur_int_point_num + 1; i < int_points.length; i++) {\r\n        if (int_point_current.face != cur_face) {      /* next face started */\r\n            break;\r\n        }\r\n\r\n        int_point_next = int_points[i];\r\n\r\n        if (!(int_point_next.pt.equalTo(int_point_current.pt) &&\r\n            int_point_next.edge_before === int_point_current.edge_before &&\r\n            int_point_next.edge_after === int_point_current.edge_after)) {\r\n            break;         /* next point is different - break and exit */\r\n        }\r\n\r\n        int_points_pool_num++;     /* duplicated intersection point - increase counter */\r\n    }\r\n    return int_points_pool_num;\r\n}\r\n\r\nfunction splitByIntersections(polygon, int_points)\r\n{\r\n    if (!int_points) return;\r\n    for (let int_point of int_points) {\r\n        let edge = int_point.edge_before;\r\n\r\n        // recalculate vertex flag: it may be changed after previous split\r\n        int_point.is_vertex = NOT_VERTEX;\r\n        if (edge.shape.start && edge.shape.start.equalTo(int_point.pt)) {\r\n            int_point.is_vertex |= START_VERTEX;\r\n        }\r\n        if (edge.shape.end && edge.shape.end.equalTo(int_point.pt)) {\r\n            int_point.is_vertex |= END_VERTEX;\r\n        }\r\n\r\n        if (int_point.is_vertex & START_VERTEX) {  // nothing to split\r\n            int_point.edge_before = edge.prev;\r\n            int_point.is_vertex = END_VERTEX;\r\n            continue;\r\n        }\r\n        if (int_point.is_vertex & END_VERTEX) {    // nothing to split\r\n            continue;\r\n        }\r\n\r\n        let newEdge = polygon.addVertex(int_point.pt, edge);\r\n        int_point.edge_before = newEdge;\r\n    }\r\n\r\n    for (let int_point of int_points) {\r\n        int_point.edge_after = int_point.edge_before.next;\r\n    }\r\n}\r\n\r\nfunction insertBetweenIntPoints(int_point1, int_point2, new_edge) {\r\n    let edge_before = int_point1.edge_before;\r\n    let edge_after = int_point2.edge_after;\r\n\r\n    edge_before.next = new_edge;\r\n    new_edge.prev = edge_before;\r\n\r\n    new_edge.next = edge_after;\r\n    edge_after.prev = new_edge;\r\n}\r\n\r\n/**\r\n * Created by Alex Bol on 12/02/2018.\r\n */\r\n\r\nconst {INSIDE: INSIDE$1, OUTSIDE: OUTSIDE$1, BOUNDARY: BOUNDARY$1, OVERLAP_SAME: OVERLAP_SAME$1, OVERLAP_OPPOSITE: OVERLAP_OPPOSITE$1} = Constants;\r\nconst {NOT_VERTEX: NOT_VERTEX$1, START_VERTEX: START_VERTEX$1, END_VERTEX: END_VERTEX$1} = Constants;\r\n\r\nconst BOOLEAN_UNION = 1;\r\nconst BOOLEAN_INTERSECT = 2;\r\nconst BOOLEAN_SUBTRACT = 3;\r\n\r\n\r\n/**\r\n * Unify two polygons polygons and returns new polygon. <br/>\r\n * Point belongs to the resulted polygon if it belongs to the first OR to the second polygon\r\n * @param {Polygon} polygon1 - first operand\r\n * @param {Polygon} polygon2 - second operand\r\n * @returns {Polygon}\r\n */\r\nfunction unify(polygon1, polygon2) {\r\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_UNION, true);\r\n    return res_poly;\r\n}\r\n\r\n/**\r\n * Subtract second polygon from the first and returns new polygon\r\n * Point belongs to the resulted polygon if it belongs to the first polygon AND NOT to the second polygon\r\n * @param {Polygon} polygon1 - first operand\r\n * @param {Polygon} polygon2 - second operand\r\n * @returns {Polygon}\r\n */\r\nfunction subtract(polygon1, polygon2) {\r\n    let polygon2_tmp = polygon2.clone();\r\n    let polygon2_reversed = polygon2_tmp.reverse();\r\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2_reversed, BOOLEAN_SUBTRACT, true);\r\n    return res_poly;\r\n}\r\n\r\n/**\r\n * Intersect two polygons and returns new polygon\r\n * Point belongs to the resulted polygon is it belongs to the first AND to the second polygon\r\n * @param {Polygon} polygon1 - first operand\r\n * @param {Polygon} polygon2 - second operand\r\n * @returns {Polygon}\r\n */\r\nfunction intersect(polygon1, polygon2) {\r\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_INTERSECT, true);\r\n    return res_poly;\r\n}\r\n\r\n/**\r\n * Returns boundary of intersection between two polygons as two arrays of shapes (Segments/Arcs) <br/>\r\n * The first array are shapes from the first polygon, the second array are shapes from the second\r\n * @param {Polygon} polygon1 - first operand\r\n * @param {Polygon} polygon2 - second operand\r\n * @returns {Shape[][]}\r\n */\r\nfunction innerClip(polygon1, polygon2) {\r\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_INTERSECT, false);\r\n\r\n    let clip_shapes1 = [];\r\n    for (let face of res_poly.faces) {\r\n        clip_shapes1 = [...clip_shapes1, ...[...face.edges].map(edge => edge.shape)];\r\n    }\r\n    let clip_shapes2 = [];\r\n    for (let face of wrk_poly.faces) {\r\n        clip_shapes2 = [...clip_shapes2, ...[...face.edges].map(edge => edge.shape)];\r\n    }\r\n    return [clip_shapes1, clip_shapes2];\r\n}\r\n\r\n/**\r\n * Returns boundary of subtraction of the second polygon from first polygon as array of shapes\r\n * @param {Polygon} polygon1 - first operand\r\n * @param {Polygon} polygon2 - second operand\r\n * @returns {Shape[]}\r\n */\r\nfunction outerClip(polygon1, polygon2) {\r\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_SUBTRACT, false);\r\n\r\n    let clip_shapes1 = [];\r\n    for (let face of res_poly.faces) {\r\n        clip_shapes1 = [...clip_shapes1, ...[...face.edges].map(edge => edge.shape)];\r\n    }\r\n\r\n    return clip_shapes1;\r\n}\r\n\r\n/**\r\n * Returns intersection points between boundaries of two polygons as two array of points <br/>\r\n * Points in the first array belong to first polygon, points from the second - to the second.\r\n * Points in each array are ordered according to the direction of the correspondent polygon\r\n * @param {Polygon} polygon1 - first operand\r\n * @param {Polygon} polygon2 - second operand\r\n * @returns {Point[][]}\r\n */\r\nfunction calculateIntersections(polygon1, polygon2) {\r\n    let res_poly = polygon1.clone();\r\n    let wrk_poly = polygon2.clone();\r\n\r\n    // get intersection points\r\n    let intersections = getIntersections(res_poly, wrk_poly);\r\n\r\n    // sort intersection points\r\n    sortIntersections(intersections);\r\n\r\n    // split by intersection points\r\n    splitByIntersections(res_poly, intersections.int_points1_sorted);\r\n    splitByIntersections(wrk_poly, intersections.int_points2_sorted);\r\n\r\n    // filter duplicated intersection points\r\n    filterDuplicatedIntersections(intersections);\r\n\r\n    // sort intersection points again after filtering\r\n    sortIntersections(intersections);\r\n\r\n    let ip_sorted1 = intersections.int_points1_sorted.map( int_point => int_point.pt);\r\n    let ip_sorted2 = intersections.int_points2_sorted.map( int_point => int_point.pt);\r\n    return [ip_sorted1, ip_sorted2];\r\n}\r\n\r\nfunction filterNotRelevantEdges(res_poly, wrk_poly, intersections, op) {\r\n    // keep not intersected faces for further remove and merge\r\n    let notIntersectedFacesRes = getNotIntersectedFaces(res_poly, intersections.int_points1);\r\n    let notIntersectedFacesWrk = getNotIntersectedFaces(wrk_poly, intersections.int_points2);\r\n\r\n    // calculate inclusion flag for not intersected faces\r\n    calcInclusionForNotIntersectedFaces(notIntersectedFacesRes, wrk_poly);\r\n    calcInclusionForNotIntersectedFaces(notIntersectedFacesWrk, res_poly);\r\n\r\n    // initialize inclusion flags for edges incident to intersections\r\n    initializeInclusionFlags(intersections.int_points1);\r\n    initializeInclusionFlags(intersections.int_points2);\r\n\r\n    // calculate inclusion flags only for edges incident to intersections\r\n    calculateInclusionFlags(intersections.int_points1, wrk_poly);\r\n    calculateInclusionFlags(intersections.int_points2, res_poly);\r\n\r\n    // fix boundary conflicts\r\n    while (fixBoundaryConflicts(res_poly, wrk_poly, intersections.int_points1, intersections.int_points1_sorted, intersections.int_points2, intersections));\r\n    // while (fixBoundaryConflicts(wrk_poly, res_poly, intersections.int_points2, intersections.int_points2_sorted, intersections.int_points1, intersections));\r\n\r\n    // Set overlapping flags for boundary chains: SAME or OPPOSITE\r\n    setOverlappingFlags(intersections);\r\n\r\n    // remove not relevant chains between intersection points\r\n    removeNotRelevantChains(res_poly, op, intersections.int_points1_sorted, true);\r\n    removeNotRelevantChains(wrk_poly, op, intersections.int_points2_sorted, false);\r\n\r\n    // remove not relevant not intersected faces from res_polygon and wrk_polygon\r\n    // if op == UNION, remove faces that are included in wrk_polygon without intersection\r\n    // if op == INTERSECT, remove faces that are not included into wrk_polygon\r\n    removeNotRelevantNotIntersectedFaces(res_poly, notIntersectedFacesRes, op, true);\r\n    removeNotRelevantNotIntersectedFaces(wrk_poly, notIntersectedFacesWrk, op, false);\r\n}\r\n\r\nfunction swapLinksAndRestore(res_poly, wrk_poly, intersections, op) {\r\n\r\n    // add edges of wrk_poly into the edge container of res_poly\r\n    copyWrkToRes(res_poly, wrk_poly, op, intersections.int_points2);\r\n\r\n    // swap links from res_poly to wrk_poly and vice versa\r\n    swapLinks(res_poly, wrk_poly, intersections);\r\n\r\n    // remove old faces\r\n    removeOldFaces(res_poly, intersections.int_points1);\r\n    removeOldFaces(wrk_poly, intersections.int_points2);\r\n\r\n    // restore faces\r\n    restoreFaces(res_poly, intersections.int_points1, intersections.int_points2);\r\n    restoreFaces(res_poly, intersections.int_points2, intersections.int_points1);\r\n\r\n    // merge relevant not intersected faces from wrk_polygon to res_polygon\r\n    // mergeRelevantNotIntersectedFaces(res_poly, wrk_poly);\r\n}\r\n\r\n\r\nfunction booleanOpBinary(polygon1, polygon2, op, restore)\r\n{\r\n    let res_poly = polygon1.clone();\r\n    let wrk_poly = polygon2.clone();\r\n\r\n    // get intersection points\r\n    let intersections = getIntersections(res_poly, wrk_poly);\r\n\r\n    // sort intersection points\r\n    sortIntersections(intersections);\r\n\r\n    // split by intersection points\r\n    splitByIntersections(res_poly, intersections.int_points1_sorted);\r\n    splitByIntersections(wrk_poly, intersections.int_points2_sorted);\r\n\r\n    // filter duplicated intersection points\r\n    filterDuplicatedIntersections(intersections);\r\n\r\n    // sort intersection points again after filtering\r\n    sortIntersections(intersections);\r\n\r\n    // calculate inclusion and remove not relevant edges\r\n    filterNotRelevantEdges(res_poly, wrk_poly, intersections, op);\r\n\r\n    if (restore) {\r\n        swapLinksAndRestore(res_poly, wrk_poly, intersections, op);\r\n    }\r\n\r\n    return [res_poly, wrk_poly];\r\n}\r\n\r\nfunction getIntersections(polygon1, polygon2)\r\n{\r\n    let intersections = {\r\n        int_points1: [],\r\n        int_points2: []\r\n    };\r\n\r\n    // calculate intersections\r\n    for (let edge1 of polygon1.edges) {\r\n\r\n        // request edges of polygon2 in the box of edge1\r\n        let resp = polygon2.edges.search(edge1.box);\r\n\r\n        // for each edge2 in response\r\n        for (let edge2 of resp) {\r\n\r\n            // calculate intersections between edge1 and edge2\r\n            let ip = edge1.shape.intersect(edge2.shape);\r\n\r\n            // for each intersection point\r\n            for (let pt of ip) {\r\n                addToIntPoints(edge1, pt, intersections.int_points1);\r\n                addToIntPoints(edge2, pt, intersections.int_points2);\r\n            }\r\n        }\r\n    }\r\n    return intersections;\r\n}\r\n\r\nfunction getNotIntersectedFaces(poly, int_points)\r\n{\r\n    let notIntersected = [];\r\n    for (let face of poly.faces) {\r\n        if (!int_points.find((ip) => ip.face === face)) {\r\n            notIntersected.push(face);\r\n        }\r\n    }\r\n    return notIntersected;\r\n}\r\n\r\nfunction calcInclusionForNotIntersectedFaces(notIntersectedFaces, poly2)\r\n{\r\n    for (let face of notIntersectedFaces) {\r\n        face.first.bv = face.first.bvStart = face.first.bvEnd = undefined;\r\n        face.first.setInclusion(poly2);\r\n    }\r\n}\r\n\r\nfunction fixBoundaryConflicts(poly1, poly2, int_points1, int_points1_sorted, int_points2, intersections )\r\n{\r\n    let cur_face;\r\n    let first_int_point_in_face_id;\r\n    let next_int_point1;\r\n    let num_int_points = int_points1_sorted.length;\r\n    let iterate_more = false;\r\n\r\n    for (let i = 0; i < num_int_points; i++) {\r\n        let cur_int_point1 = int_points1_sorted[i];\r\n\r\n        // Find boundary chain in the polygon1\r\n        if (cur_int_point1.face !== cur_face) {                               // next chain started\r\n            first_int_point_in_face_id = i; // cur_int_point1;\r\n            cur_face = cur_int_point1.face;\r\n        }\r\n\r\n        // Skip duplicated points with same <x,y> in \"cur_int_point1\" pool\r\n        let int_points_cur_pool_start = i;\r\n        let int_points_cur_pool_num = intPointsPoolCount(int_points1_sorted, i, cur_face);\r\n        let next_int_point_id;\r\n        if (int_points_cur_pool_start + int_points_cur_pool_num < num_int_points &&\r\n            int_points1_sorted[int_points_cur_pool_start + int_points_cur_pool_num].face === cur_face) {\r\n            next_int_point_id = int_points_cur_pool_start + int_points_cur_pool_num;\r\n        } else {                                         // get first point from the same face\r\n            next_int_point_id = first_int_point_in_face_id;\r\n        }\r\n\r\n        // From all points with same ,x,y. in 'next_int_point1' pool choose one that\r\n        // has same face both in res_poly and in wrk_poly\r\n        let int_points_next_pool_num = intPointsPoolCount(int_points1_sorted, next_int_point_id, cur_face);\r\n        next_int_point1 = null;\r\n        for (let j=next_int_point_id; j < next_int_point_id + int_points_next_pool_num; j++) {\r\n            let next_int_point1_tmp = int_points1_sorted[j];\r\n            if (next_int_point1_tmp.face === cur_face &&\r\n                int_points2[next_int_point1_tmp.id].face === int_points2[cur_int_point1.id].face) {\r\n                next_int_point1 = next_int_point1_tmp;\r\n                break;\r\n            }\r\n        }\r\n        if (next_int_point1 === null)\r\n            continue;\r\n\r\n        let edge_from1 = cur_int_point1.edge_after;\r\n        let edge_to1 = next_int_point1.edge_before;\r\n\r\n        // Case #1. One of the ends is not boundary - probably tiny edge wrongly marked as boundary\r\n        if (edge_from1.bv === BOUNDARY$1 && edge_to1.bv != BOUNDARY$1) {\r\n            edge_from1.bv = edge_to1.bv;\r\n            continue;\r\n        }\r\n\r\n        if (edge_from1.bv != BOUNDARY$1 && edge_to1.bv === BOUNDARY$1) {\r\n            edge_to1.bv = edge_from1.bv;\r\n            continue;\r\n        }\r\n\r\n        // Set up all boundary values for middle edges. Need for cases 2 and 3\r\n        if ( (edge_from1.bv === BOUNDARY$1 && edge_to1.bv === BOUNDARY$1 && edge_from1 != edge_to1) ||\r\n        (edge_from1.bv === INSIDE$1 && edge_to1.bv === OUTSIDE$1  || edge_from1.bv === OUTSIDE$1 && edge_to1.bv === INSIDE$1 ) ) {\r\n            let edge_tmp = edge_from1.next;\r\n            while (edge_tmp != edge_to1) {\r\n                edge_tmp.bvStart = undefined;\r\n                edge_tmp.bvEnd = undefined;\r\n                edge_tmp.bv = undefined;\r\n                edge_tmp.setInclusion(poly2);\r\n                edge_tmp = edge_tmp.next;\r\n            }\r\n        }\r\n\r\n        // Case #2. Both of the ends boundary. Check all the edges in the middle\r\n        // If some edges in the middle are not boundary then update bv of 'from' and 'to' edges\r\n        if (edge_from1.bv === BOUNDARY$1 && edge_to1.bv === BOUNDARY$1 && edge_from1 != edge_to1) {\r\n            let edge_tmp = edge_from1.next;\r\n            let new_bv;\r\n            while (edge_tmp != edge_to1) {\r\n                if (edge_tmp.bv != BOUNDARY$1) {\r\n                    if (new_bv === undefined) {        // first not boundary edge between from and to\r\n                        new_bv = edge_tmp.bv;\r\n                    }\r\n                    else {                            // another not boundary edge between from and to\r\n                        if (edge_tmp.bv != new_bv) {  // and it has different bv - can't resolve conflict\r\n                            throw Errors.UNRESOLVED_BOUNDARY_CONFLICT;\r\n                        }\r\n                    }\r\n                }\r\n                edge_tmp = edge_tmp.next;\r\n            }\r\n\r\n            if (new_bv != undefined) {\r\n                edge_from1.bv = new_bv;\r\n                edge_to1.bv = new_bv;\r\n            }\r\n            continue;         // all middle edges are boundary, proceed with this\r\n        }\r\n\r\n        // Case 3. One of the ends is inner, another is outer\r\n        if (edge_from1.bv === INSIDE$1 && edge_to1.bv === OUTSIDE$1  || edge_from1.bv === OUTSIDE$1 && edge_to1.bv === INSIDE$1 ) {\r\n            let edge_tmp = edge_from1;\r\n            // Find missing intersection point\r\n            while (edge_tmp != edge_to1) {\r\n                if (edge_tmp.bvStart === edge_from1.bv && edge_tmp.bvEnd === edge_to1.bv) {\r\n                    let [dist, segment] = edge_tmp.shape.distanceTo(poly2);\r\n                    if (dist < 10*Flatten.DP_TOL) {  // it should be very close\r\n                        // let pt = edge_tmp.end;\r\n                        // add to the list of intersections of poly1\r\n                        addToIntPoints(edge_tmp, segment.ps, int_points1);\r\n\r\n                        // split edge_tmp in poly1 if need\r\n                        let int_point1 = int_points1[int_points1.length-1];\r\n                        if (int_point1.is_vertex & START_VERTEX$1) {        // nothing to split\r\n                            int_point1.edge_after = edge_tmp;\r\n                            int_point1.edge_before = edge_tmp.prev;\r\n                            edge_tmp.bvStart = BOUNDARY$1;\r\n                            edge_tmp.bv = undefined;\r\n                            edge_tmp.setInclusion(poly2);\r\n                        }\r\n                        else if (int_point1.is_vertex & END_VERTEX$1) {    // nothing to split\r\n                            int_point1.edge_after = edge_tmp.next;\r\n                            edge_tmp.bvEnd = BOUNDARY$1;\r\n                            edge_tmp.bv = undefined;\r\n                            edge_tmp.setInclusion(poly2);\r\n                        }\r\n                        else {        // split edge here\r\n                            let newEdge1 = poly2.addVertex(int_point1.pt, edge_tmp);\r\n                            int_point1.edge_before = newEdge1;\r\n                            int_point1.edge_after = newEdge1.next;\r\n\r\n                            newEdge1.setInclusion(poly2);\r\n\r\n                            newEdge1.next.bvStart = BOUNDARY$1;\r\n                            newEdge1.next.bvEnd = undefined;\r\n                            newEdge1.next.bv = undefined;\r\n                            newEdge1.next.setInclusion(poly2);\r\n                        }\r\n\r\n                        // add to the list of intersections of poly2\r\n                        let edge2 = poly2.findEdgeByPoint(segment.pe);\r\n                        addToIntPoints(edge2, segment.pe, int_points2);\r\n                        // split edge2 in poly2 if need\r\n                        let int_point2 = int_points2[int_points2.length-1];\r\n                        if (int_point2.is_vertex & START_VERTEX$1) {        // nothing to split\r\n                            int_point2.edge_after = edge2;\r\n                            int_point2.edge_before = edge2.prev;\r\n                        }\r\n                        else if (int_point2.is_vertex & END_VERTEX$1) {    // nothing to split\r\n                            int_point2.edge_after = edge2.next;\r\n                        }\r\n                        else {        // split edge here\r\n                            // first locate int_points that may refer to edge2 as edge.after\r\n                            // let int_point2_edge_before = int_points2.find( int_point => int_point.edge_before === edge2)\r\n                            let int_point2_edge_after = int_points2.find( int_point => int_point.edge_after === edge2 );\r\n\r\n                            let newEdge2 = poly2.addVertex(int_point2.pt, edge2);\r\n                            int_point2.edge_before = newEdge2;\r\n                            int_point2.edge_after = newEdge2.next;\r\n\r\n                            if (int_point2_edge_after)\r\n                                int_point2_edge_after.edge_after = newEdge2;\r\n\r\n                            newEdge2.bvStart = undefined;\r\n                            newEdge2.bvEnd = BOUNDARY$1;\r\n                            newEdge2.bv = undefined;\r\n                            newEdge2.setInclusion(poly1);\r\n\r\n                            newEdge2.next.bvStart = BOUNDARY$1;\r\n                            newEdge2.next.bvEnd = undefined;\r\n                            newEdge2.next.bv = undefined;\r\n                            newEdge2.next.setInclusion(poly1);\r\n                        }\r\n\r\n                        sortIntersections(intersections);\r\n\r\n                        iterate_more = true;\r\n                        break;\r\n                    }\r\n                }\r\n                edge_tmp = edge_tmp.next;\r\n            }\r\n\r\n            // we changed intersections inside loop, have to exit and repair again\r\n            if (iterate_more)\r\n                break;\r\n\r\n            throw Errors.UNRESOLVED_BOUNDARY_CONFLICT;\r\n        }\r\n    }\r\n\r\n    return iterate_more;\r\n}\r\n\r\nfunction removeNotRelevantChains(polygon, op, int_points, is_res_polygon)\r\n{\r\n    if (!int_points) return;\r\n    let cur_face = undefined;\r\n    let first_int_point_in_face_num = undefined;\r\n    let int_point_current;\r\n    let int_point_next;\r\n\r\n    for (let i = 0; i < int_points.length; i++) {\r\n        int_point_current = int_points[i];\r\n\r\n        if (int_point_current.face !== cur_face) {   // next face started\r\n            first_int_point_in_face_num = i;\r\n            cur_face = int_point_current.face;\r\n        }\r\n\r\n        if (cur_face.isEmpty())                // ??\r\n            continue;\r\n\r\n        // Get next int point from the same face that current\r\n\r\n        // Count how many duplicated points with same <x,y> in \"points from\" pool ?\r\n        let int_points_from_pull_start = i;\r\n        let int_points_from_pull_num = intPointsPoolCount(int_points, i, cur_face);\r\n        let next_int_point_num;\r\n        if (int_points_from_pull_start + int_points_from_pull_num < int_points.length &&\r\n            int_points[int_points_from_pull_start + int_points_from_pull_num].face === int_point_current.face) {\r\n            next_int_point_num = int_points_from_pull_start + int_points_from_pull_num;\r\n        } else {                                         // get first point from the same face\r\n            next_int_point_num = first_int_point_in_face_num;\r\n        }\r\n        int_point_next = int_points[next_int_point_num];\r\n\r\n        /* Count how many duplicated points with same <x,y> in \"points to\" pull ? */\r\n        let int_points_to_pull_start = next_int_point_num;\r\n        let int_points_to_pull_num = intPointsPoolCount(int_points, int_points_to_pull_start, cur_face);\r\n\r\n\r\n        let edge_from = int_point_current.edge_after;\r\n        let edge_to = int_point_next.edge_before;\r\n\r\n        if ((edge_from.bv === INSIDE$1 && edge_to.bv === INSIDE$1 && op === BOOLEAN_UNION) ||\r\n            (edge_from.bv === OUTSIDE$1 && edge_to.bv === OUTSIDE$1 && op === BOOLEAN_INTERSECT) ||\r\n            ((edge_from.bv === OUTSIDE$1 || edge_to.bv === OUTSIDE$1) && op === BOOLEAN_SUBTRACT && !is_res_polygon) ||\r\n            ((edge_from.bv === INSIDE$1 || edge_to.bv === INSIDE$1) && op === BOOLEAN_SUBTRACT && is_res_polygon) ||\r\n            (edge_from.bv === BOUNDARY$1 && edge_to.bv === BOUNDARY$1 && (edge_from.overlap & OVERLAP_SAME$1) && is_res_polygon) ||\r\n            (edge_from.bv === BOUNDARY$1 && edge_to.bv === BOUNDARY$1 && (edge_from.overlap & OVERLAP_OPPOSITE$1))) {\r\n\r\n            polygon.removeChain(cur_face, edge_from, edge_to);\r\n\r\n            /* update all points in \"points from\" pull */\r\n            for (let k = int_points_from_pull_start; k < int_points_from_pull_start + int_points_from_pull_num; k++) {\r\n                int_points[k].edge_after = undefined;\r\n            }\r\n\r\n            /* update all points in \"points to\" pull */\r\n            for (let k = int_points_to_pull_start; k < int_points_to_pull_start + int_points_to_pull_num; k++) {\r\n                int_points[k].edge_before = undefined;\r\n            }\r\n        }\r\n\r\n        /* skip to the last point in \"points from\" group */\r\n        i += int_points_from_pull_num - 1;\r\n    }\r\n}\r\nfunction copyWrkToRes(res_polygon, wrk_polygon, op, int_points)\r\n{\r\n    for (let face of wrk_polygon.faces) {\r\n        for (let edge of face) {\r\n            res_polygon.edges.add(edge);\r\n        }\r\n        // If union - add face from wrk_polygon that is not intersected with res_polygon\r\n        if ( /*(op === BOOLEAN_UNION || op == BOOLEAN_SUBTRACT) &&*/\r\n            int_points.find((ip) => (ip.face === face)) === undefined) {\r\n            res_polygon.addFace(face.first, face.last);\r\n        }\r\n    }\r\n}\r\n\r\nfunction swapLinks(res_polygon, wrk_polygon, intersections)\r\n{\r\n    if (intersections.int_points1.length === 0) return;\r\n\r\n    for (let i = 0; i < intersections.int_points1.length; i++) {\r\n        let int_point1 = intersections.int_points1[i];\r\n        let int_point2 = intersections.int_points2[i];\r\n\r\n        // Simple case - find continuation on the other polygon\r\n\r\n        // Process edge from res_polygon\r\n        if (int_point1.edge_before !== undefined && int_point1.edge_after === undefined) {    // swap need\r\n            if (int_point2.edge_before === undefined && int_point2.edge_after !== undefined) {  // simple case\r\n                // Connect edges\r\n                int_point1.edge_before.next = int_point2.edge_after;\r\n                int_point2.edge_after.prev = int_point1.edge_before;\r\n\r\n                // Fill in missed links in intersection points\r\n                int_point1.edge_after = int_point2.edge_after;\r\n                int_point2.edge_before = int_point1.edge_before;\r\n            }\r\n        }\r\n        // Process edge from wrk_polygon\r\n        if (int_point2.edge_before !== undefined && int_point2.edge_after === undefined) {    // swap need\r\n            if (int_point1.edge_before === undefined && int_point1.edge_after !== undefined) {  // simple case\r\n                // Connect edges\r\n                int_point2.edge_before.next = int_point1.edge_after;\r\n                int_point1.edge_after.prev = int_point2.edge_before;\r\n\r\n                // Complete missed links\r\n                int_point2.edge_after = int_point1.edge_after;\r\n                int_point1.edge_before = int_point2.edge_before;\r\n            }\r\n        }\r\n\r\n        // Continuation not found - complex case\r\n        // Continuation will be found on the same polygon.\r\n        // It happens when intersection point is actually touching point\r\n        // Polygon1\r\n        if (int_point1.edge_before !== undefined && int_point1.edge_after === undefined) {    // still swap need\r\n            for (let int_point of intersections.int_points1_sorted) {\r\n                if (int_point === int_point1) continue;     // skip same\r\n                if (int_point.edge_before === undefined && int_point.edge_after !== undefined) {\r\n                    if (int_point.pt.equalTo(int_point1.pt)) {\r\n                        // Connect edges\r\n                        int_point1.edge_before.next = int_point.edge_after;\r\n                        int_point.edge_after.prev = int_point1.edge_before;\r\n\r\n                        // Complete missed links\r\n                        int_point1.edge_after = int_point.edge_after;\r\n                        int_point.edge_before = int_point1.edge_before;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Polygon2\r\n        if (int_point2.edge_before !== undefined && int_point2.edge_after === undefined) {    // still swap need\r\n            for (let int_point of intersections.int_points2_sorted) {\r\n                if (int_point === int_point2) continue;     // skip same\r\n                if (int_point.edge_before === undefined && int_point.edge_after !== undefined) {\r\n                    if (int_point.pt.equalTo(int_point2.pt)) {\r\n                        // Connect edges\r\n                        int_point2.edge_before.next = int_point.edge_after;\r\n                        int_point.edge_after.prev = int_point2.edge_before;\r\n\r\n                        // Complete missed links\r\n                        int_point2.edge_after = int_point.edge_after;\r\n                        int_point.edge_before = int_point2.edge_before;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Sanity check that no dead ends left\r\n}\r\n\r\nfunction removeOldFaces(polygon, int_points)\r\n{\r\n    for (let int_point of int_points) {\r\n        polygon.faces.delete(int_point.face);\r\n        int_point.face = undefined;\r\n        if (int_point.edge_before)\r\n            int_point.edge_before.face = undefined;\r\n        if (int_point.edge_after)\r\n            int_point.edge_after.face = undefined;\r\n    }\r\n}\r\n\r\nfunction restoreFaces(polygon, int_points, other_int_points)\r\n{\r\n    // For each intersection point - create new face\r\n    for (let int_point of int_points) {\r\n        if (int_point.edge_before === undefined || int_point.edge_after === undefined)  // completely deleted\r\n            continue;\r\n        if (int_point.face)            // already restored\r\n            continue;\r\n\r\n        if (int_point.edge_after.face || int_point.edge_before.face)        // Face already created. Possible case in duplicated intersection points\r\n            continue;\r\n\r\n        let first = int_point.edge_after;      // face start\r\n        let last = int_point.edge_before;      // face end;\r\n\r\n        LinkedList.testInfiniteLoop(first);    // check and throw error if infinite loop found\r\n\r\n        let face = polygon.addFace(first, last);\r\n\r\n        // Mark intersection points from the newly create face\r\n        // to avoid multiple creation of the same face\r\n        // Face was assigned to each edge of new face in addFace function\r\n        for (let int_point_tmp of int_points) {\r\n            if (int_point_tmp.edge_before && int_point_tmp.edge_after &&\r\n                int_point_tmp.edge_before.face === face && int_point_tmp.edge_after.face === face) {\r\n                int_point_tmp.face = face;\r\n            }\r\n        }\r\n        // Mark other intersection points as well\r\n        for (let int_point_tmp of other_int_points) {\r\n            if (int_point_tmp.edge_before && int_point_tmp.edge_after &&\r\n                int_point_tmp.edge_before.face === face && int_point_tmp.edge_after.face === face) {\r\n                int_point_tmp.face = face;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction removeNotRelevantNotIntersectedFaces(polygon, notIntersectedFaces, op, is_res_polygon)\r\n{\r\n    for (let face of notIntersectedFaces) {\r\n        let rel = face.first.bv;\r\n        if (op === BOOLEAN_UNION && rel === INSIDE$1 ||\r\n            op === BOOLEAN_SUBTRACT && rel === INSIDE$1 && is_res_polygon ||\r\n            op === BOOLEAN_SUBTRACT && rel === OUTSIDE$1 && !is_res_polygon ||\r\n            op === BOOLEAN_INTERSECT && rel === OUTSIDE$1) {\r\n\r\n            polygon.deleteFace(face);\r\n        }\r\n    }\r\n}\r\n\r\nvar BooleanOperations = /*#__PURE__*/Object.freeze({\r\n    BOOLEAN_UNION: BOOLEAN_UNION,\r\n    BOOLEAN_INTERSECT: BOOLEAN_INTERSECT,\r\n    BOOLEAN_SUBTRACT: BOOLEAN_SUBTRACT,\r\n    unify: unify,\r\n    subtract: subtract,\r\n    intersect: intersect,\r\n    innerClip: innerClip,\r\n    outerClip: outerClip,\r\n    calculateIntersections: calculateIntersections,\r\n    removeNotRelevantChains: removeNotRelevantChains,\r\n    removeOldFaces: removeOldFaces,\r\n    restoreFaces: restoreFaces\r\n});\r\n\r\n/*\r\n    Dimensionally extended 9-intersected model\r\n    See https://en.wikipedia.org/wiki/DE-9IM for more details\r\n */\r\n// const DISJOINT = RegExp('FF.FF....');\r\nconst EQUAL = RegExp('T.F..FFF.|T.F...F..');\r\nconst INTERSECT = RegExp('T........|.T.......|...T.....|....T....');\r\nconst TOUCH = RegExp('FT.......|F..T.....|F...T....');\r\nconst INSIDE$2 = RegExp('T.F..F...');\r\nconst COVERED = RegExp('T.F..F...|.TF..F...|..FT.F...|..F.TF...');\r\n\r\nclass DE9IM {\r\n    /**\r\n     * Create new instance of DE9IM matrix\r\n     */\r\n    constructor() {\r\n        /**\r\n         * Array representing 3x3 intersection matrix\r\n         * @type {Shape[]}\r\n         */\r\n        this.m = new Array(9).fill(undefined);\r\n    }\r\n\r\n    /**\r\n     * Get Interior To Interior intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get I2I() {\r\n        return this.m[0];\r\n    }\r\n\r\n    /**\r\n     * Set Interior To Interior intersection\r\n     * @param geom\r\n     */\r\n    set I2I(geom) {\r\n        this.m[0] = geom;\r\n    }\r\n\r\n    /**\r\n     * Get Interior To Boundary intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get I2B() {\r\n        return this.m[1];\r\n    }\r\n\r\n    /**\r\n     * Set Interior to Boundary intersection\r\n     * @param geomc\r\n     */\r\n    set I2B(geom) {\r\n        this.m[1] = geom;\r\n    }\r\n\r\n    /**\r\n     * Get Interior To Exterior intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get I2E() {\r\n        return this.m[2];\r\n    }\r\n\r\n    /**\r\n     * Set Interior to Exterior intersection\r\n     * @param geom\r\n     */\r\n    set I2E(geom) {\r\n        this.m[2] = geom;\r\n    }\r\n\r\n    /**\r\n     * Get Boundary To Interior intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get B2I() {\r\n        return this.m[3];\r\n    }\r\n\r\n    /**\r\n     * Set Boundary to Interior intersection\r\n     * @param geom\r\n     */\r\n    set B2I(geom) {\r\n        this.m[3] = geom;\r\n    }\r\n\r\n    /**\r\n     * Get Boundary To Boundary intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get B2B() {\r\n        return this.m[4];\r\n    }\r\n\r\n    /**\r\n     * Set Boundary to Boundary intersection\r\n     * @param geom\r\n     */\r\n    set B2B(geom) {\r\n        this.m[4] = geom;\r\n    }\r\n\r\n    /**\r\n     * Get Boundary To Exterior intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get B2E() {\r\n        return this.m[5];\r\n    }\r\n\r\n    /**\r\n     * Set Boundary to Exterior intersection\r\n     * @param geom\r\n     */\r\n    set B2E(geom) {\r\n        this.m[5] = geom;\r\n    }\r\n\r\n    /**\r\n     * Get Exterior To Interior intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get E2I() {\r\n        return this.m[6];\r\n    }\r\n\r\n    /**\r\n     * Set Exterior to Interior intersection\r\n     * @param geom\r\n     */\r\n    set E2I(geom) {\r\n        this.m[6] = geom;\r\n    }\r\n\r\n    /**\r\n     * Get Exterior To Boundary intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get E2B() {\r\n        return this.m[7];\r\n    }\r\n\r\n    /**\r\n     * Set Exterior to Boundary intersection\r\n     * @param geom\r\n     */\r\n    set E2B(geom) {\r\n        this.m[7] = geom;\r\n    }\r\n\r\n    /**\r\n     * Get Exterior to Exterior intersection\r\n     * @returns {Shape[] | undefined}\r\n     */\r\n    get E2E() {\r\n        return this.m[8];\r\n    }\r\n\r\n    /**\r\n     * Set Exterior to Exterior intersection\r\n     * @param geom\r\n     */\r\n    set E2E(geom) {\r\n        this.m[8] = geom;\r\n    }\r\n\r\n    /**\r\n     * Return de9im matrix as string where<br/>\r\n     * - intersection is 'T'<br/>\r\n     * - not intersected is 'F'<br/>\r\n     * - not relevant is '*'<br/>\r\n     * For example, string 'FF**FF****' means 'DISJOINT'\r\n     * @returns {string}\r\n     */\r\n    toString() {\r\n        return this.m.map( e => {\r\n            if (e instanceof Array && e.length > 0) {\r\n                return 'T'\r\n            }\r\n            else if (e instanceof Array && e.length === 0) {\r\n                return 'F'\r\n            }\r\n            else {\r\n                return '*'\r\n            }\r\n        }).join(\"\")\r\n    }\r\n\r\n    equal() {\r\n        return EQUAL.test(this.toString());\r\n    }\r\n\r\n    intersect() {\r\n        return INTERSECT.test(this.toString());\r\n    }\r\n\r\n    touch() {\r\n        return TOUCH.test(this.toString());\r\n    }\r\n\r\n    inside() {\r\n        return INSIDE$2.test(this.toString());\r\n    }\r\n\r\n    covered() {\r\n        return COVERED.test(this.toString());\r\n    }\r\n}\r\n\r\n/**\r\n * Intersection\r\n *\r\n * */\r\n\r\nfunction intersectLine2Line(line1, line2) {\r\n    let ip = [];\r\n\r\n    let [A1, B1, C1] = line1.standard;\r\n    let [A2, B2, C2] = line2.standard;\r\n\r\n    /* Cramer's rule */\r\n    let det = A1 * B2 - B1 * A2;\r\n    let detX = C1 * B2 - B1 * C2;\r\n    let detY = A1 * C2 - C1 * A2;\r\n\r\n    if (!Flatten.Utils.EQ_0(det)) {\r\n        let x, y;\r\n\r\n        if (B1 === 0) {        // vertical line x  = C1/A1, where A1 == +1 or -1\r\n            x = C1/A1;\r\n            y = detY / det;\r\n        }\r\n        else if (B2 === 0) {   // vertical line x = C2/A2, where A2 = +1 or -1\r\n            x = C2/A2;\r\n            y = detY / det;\r\n        }\r\n        else if (A1 === 0) {   // horizontal line y = C1/B1, where B1 = +1 or -1\r\n            x = detX / det;\r\n            y = C1/B1;\r\n        }\r\n        else if (A2 === 0) {   // horizontal line y = C2/B2, where B2 = +1 or -1\r\n            x = detX / det;\r\n            y = C2/B2;\r\n        }\r\n        else {\r\n            x = detX / det;\r\n            y = detY / det;\r\n        }\r\n\r\n        ip.push(new Flatten.Point(x, y));\r\n    }\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectLine2Circle(line, circle) {\r\n    let ip = [];\r\n    let prj = circle.pc.projectionOn(line);            // projection of circle center on line\r\n    let dist = circle.pc.distanceTo(prj)[0];           // distance from circle center to projection\r\n\r\n    if (Flatten.Utils.EQ(dist, circle.r)) {            // line tangent to circle - return single intersection point\r\n        ip.push(prj);\r\n    } else if (Flatten.Utils.LT(dist, circle.r)) {       // return two intersection points\r\n        let delta = Math.sqrt(circle.r * circle.r - dist * dist);\r\n        let v_trans, pt;\r\n\r\n        v_trans = line.norm.rotate90CCW().multiply(delta);\r\n        pt = prj.translate(v_trans);\r\n        ip.push(pt);\r\n\r\n        v_trans = line.norm.rotate90CW().multiply(delta);\r\n        pt = prj.translate(v_trans);\r\n        ip.push(pt);\r\n    }\r\n    return ip;\r\n}\r\n\r\nfunction intersectLine2Box(line, box) {\r\n    let ips = [];\r\n    for (let seg of box.toSegments()) {\r\n        let ips_tmp = intersectSegment2Line(seg, line);\r\n        for (let pt of ips_tmp) {\r\n            if (!ptInIntPoints(pt, ips)) {\r\n                ips.push(pt);\r\n            }\r\n        }\r\n    }\r\n    return ips;\r\n}\r\n\r\nfunction intersectLine2Arc(line, arc) {\r\n    let ip = [];\r\n\r\n    if (intersectLine2Box(line, arc.box).length === 0) {\r\n        return ip;\r\n    }\r\n\r\n    let circle = new Flatten.Circle(arc.pc, arc.r);\r\n    let ip_tmp = intersectLine2Circle(line, circle);\r\n    for (let pt of ip_tmp) {\r\n        if (pt.on(arc)) {\r\n            ip.push(pt);\r\n        }\r\n    }\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectSegment2Line(seg, line) {\r\n    let ip = [];\r\n\r\n    // Boundary cases\r\n    if (seg.ps.on(line)) {\r\n        ip.push(seg.ps);\r\n    }\r\n    // If both ends lay on line, return two intersection points\r\n    if (seg.pe.on(line) && !seg.isZeroLength()) {\r\n        ip.push(seg.pe);\r\n    }\r\n\r\n    if (ip.length > 0) {\r\n        return ip;          // done, intersection found\r\n    }\r\n\r\n    // If zero-length segment and nothing found, return no intersections\r\n    if (seg.isZeroLength()) {\r\n        return ip;\r\n    }\r\n\r\n    // Not a boundary case, check if both points are on the same side and\r\n    // hence there is no intersection\r\n    if (seg.ps.leftTo(line) && seg.pe.leftTo(line) ||\r\n        !seg.ps.leftTo(line) && !seg.pe.leftTo(line)) {\r\n        return ip;\r\n    }\r\n\r\n    // Calculate intersection between lines\r\n    let line1 = new Flatten.Line(seg.ps, seg.pe);\r\n    return intersectLine2Line(line1, line);\r\n}\r\n\r\nfunction intersectSegment2Segment(seg1, seg2) {\r\n    let ip = [];\r\n\r\n    // quick reject\r\n    if (seg1.box.not_intersect(seg2.box)) {\r\n        return ip;\r\n    }\r\n\r\n    // Special case of seg1 zero length\r\n    if (seg1.isZeroLength()) {\r\n        if (seg1.ps.on(seg2)) {\r\n            ip.push(seg1.ps);\r\n        }\r\n        return ip;\r\n    }\r\n\r\n    // Special case of seg2 zero length\r\n    if (seg2.isZeroLength()) {\r\n        if (seg2.ps.on(seg1)) {\r\n            ip.push(seg2.ps);\r\n        }\r\n        return ip;\r\n    }\r\n\r\n    // Neither seg1 nor seg2 is zero length\r\n    let line1 = new Flatten.Line(seg1.ps, seg1.pe);\r\n    let line2 = new Flatten.Line(seg2.ps, seg2.pe);\r\n\r\n    // Check overlapping between segments in case of incidence\r\n    // If segments touching, add one point. If overlapping, add two points\r\n    if (line1.incidentTo(line2)) {\r\n        if (seg1.ps.on(seg2)) {\r\n            ip.push(seg1.ps);\r\n        }\r\n        if (seg1.pe.on(seg2)) {\r\n            ip.push(seg1.pe);\r\n        }\r\n        if (seg2.ps.on(seg1) && !seg2.ps.equalTo(seg1.ps) && !seg2.ps.equalTo(seg1.pe)) {\r\n            ip.push(seg2.ps);\r\n        }\r\n        if (seg2.pe.on(seg1) && !seg2.pe.equalTo(seg1.ps) && !seg2.pe.equalTo(seg1.pe)) {\r\n            ip.push(seg2.pe);\r\n        }\r\n    } else {                /* not incident - parallel or intersect */\r\n        // Calculate intersection between lines\r\n        let new_ip = intersectLine2Line(line1, line2);\r\n        if (new_ip.length > 0 && new_ip[0].on(seg1) && new_ip[0].on(seg2)) {\r\n            ip.push(new_ip[0]);\r\n        }\r\n\r\n        // Fix missing intersection\r\n        // const tol = 10*Flatten.DP_TOL;\r\n        // if (ip.length === 0 && new_ip.length > 0 && (new_ip[0].distanceTo(seg1)[0] < tol || new_ip[0].distanceTo(seg2)[0] < tol) ) {\r\n        //     if (seg1.start.distanceTo(seg2)[0] < tol) {\r\n        //         ip.push(new_ip[0]);\r\n        //     }\r\n        //     else if (seg1.end.distanceTo(seg2)[0] < tol) {\r\n        //         ip.push(new_ip[0]);\r\n        //     }\r\n        //     else if (seg2.start.distanceTo(seg1)[0] < tol) {\r\n        //         ip.push(new_ip[0]);\r\n        //     }\r\n        //     else if (seg2.end.distanceTo(seg1)[0] < tol) {\r\n        //         ip.push(new_ip[0]);\r\n        //     }\r\n        // }\r\n    }\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectSegment2Circle(segment, circle) {\r\n    let ips = [];\r\n\r\n    if (segment.box.not_intersect(circle.box)) {\r\n        return ips;\r\n    }\r\n\r\n    // Special case of zero length segment\r\n    if (segment.isZeroLength()) {\r\n        let [dist, shortest_segment] = segment.ps.distanceTo(circle.pc);\r\n        if (Flatten.Utils.EQ(dist, circle.r)) {\r\n            ips.push(segment.ps);\r\n        }\r\n        return ips;\r\n    }\r\n\r\n    // Non zero-length segment\r\n    let line = new Flatten.Line(segment.ps, segment.pe);\r\n\r\n    let ips_tmp = intersectLine2Circle(line, circle);\r\n\r\n    for (let ip of ips_tmp) {\r\n        if (ip.on(segment)) {\r\n            ips.push(ip);\r\n        }\r\n    }\r\n\r\n    return ips;\r\n}\r\n\r\nfunction intersectSegment2Arc(segment, arc) {\r\n    let ip = [];\r\n\r\n    if (segment.box.not_intersect(arc.box)) {\r\n        return ip;\r\n    }\r\n\r\n    // Special case of zero-length segment\r\n    if (segment.isZeroLength()) {\r\n        if (segment.ps.on(arc)) {\r\n            ip.push(segment.ps);\r\n        }\r\n        return ip;\r\n    }\r\n\r\n    // Non-zero length segment\r\n    let line = new Flatten.Line(segment.ps, segment.pe);\r\n    let circle = new Flatten.Circle(arc.pc, arc.r);\r\n\r\n    let ip_tmp = intersectLine2Circle(line, circle);\r\n\r\n    for (let pt of ip_tmp) {\r\n        if (pt.on(segment) && pt.on(arc)) {\r\n            ip.push(pt);\r\n        }\r\n    }\r\n    return ip;\r\n\r\n}\r\n\r\nfunction intersectSegment2Box(segment, box) {\r\n    let ips = [];\r\n    for (let seg of box.toSegments()) {\r\n        let ips_tmp = intersectSegment2Segment(seg, segment);\r\n        for (let ip of ips_tmp) {\r\n            ips.push(ip);\r\n        }\r\n    }\r\n    return ips;\r\n}\r\n\r\nfunction intersectCircle2Circle(circle1, circle2) {\r\n    let ip = [];\r\n\r\n    if (circle1.box.not_intersect(circle2.box)) {\r\n        return ip;\r\n    }\r\n\r\n    let vec = new Flatten.Vector(circle1.pc, circle2.pc);\r\n\r\n    let r1 = circle1.r;\r\n    let r2 = circle2.r;\r\n\r\n    // Degenerated circle\r\n    if (Flatten.Utils.EQ_0(r1) || Flatten.Utils.EQ_0(r2))\r\n        return ip;\r\n\r\n    // In case of equal circles return one leftmost point\r\n    if (Flatten.Utils.EQ_0(vec.x) && Flatten.Utils.EQ_0(vec.y) && Flatten.Utils.EQ(r1, r2)) {\r\n        ip.push(circle1.pc.translate(-r1, 0));\r\n        return ip;\r\n    }\r\n\r\n    let dist = circle1.pc.distanceTo(circle2.pc)[0];\r\n\r\n    if (Flatten.Utils.GT(dist, r1 + r2))               // circles too far, no intersections\r\n        return ip;\r\n\r\n    if (Flatten.Utils.LT(dist, Math.abs(r1 - r2)))     // one circle is contained within another, no intersections\r\n        return ip;\r\n\r\n    // Normalize vector.\r\n    vec.x /= dist;\r\n    vec.y /= dist;\r\n\r\n    let pt;\r\n\r\n    // Case of touching from outside or from inside - single intersection point\r\n    // TODO: check this specifically not sure if correct\r\n    if (Flatten.Utils.EQ(dist, r1 + r2) || Flatten.Utils.EQ(dist, Math.abs(r1 - r2))) {\r\n        pt = circle1.pc.translate(r1 * vec.x, r1 * vec.y);\r\n        ip.push(pt);\r\n        return ip;\r\n    }\r\n\r\n    // Case of two intersection points\r\n\r\n    // Distance from first center to center of common chord:\r\n    //   a = (r1^2 - r2^2 + d^2) / 2d\r\n    // Separate for better accuracy\r\n    let a = (r1 * r1) / (2 * dist) - (r2 * r2) / (2 * dist) + dist / 2;\r\n\r\n    let mid_pt = circle1.pc.translate(a * vec.x, a * vec.y);\r\n    let h = Math.sqrt(r1 * r1 - a * a);\r\n    // let norm;\r\n\r\n    // norm = vec.rotate90CCW().multiply(h);\r\n    pt = mid_pt.translate(vec.rotate90CCW().multiply(h));\r\n    ip.push(pt);\r\n\r\n    // norm = vec.rotate90CW();\r\n    pt = mid_pt.translate(vec.rotate90CW().multiply(h));\r\n    ip.push(pt);\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectCircle2Box(circle, box) {\r\n    let ips = [];\r\n    for (let seg of box.toSegments()) {\r\n        let ips_tmp = intersectSegment2Circle(seg, circle);\r\n        for (let ip of ips_tmp) {\r\n            ips.push(ip);\r\n        }\r\n    }\r\n    return ips;\r\n}\r\n\r\nfunction intersectArc2Arc(arc1, arc2) {\r\n    var ip = [];\r\n\r\n    if (arc1.box.not_intersect(arc2.box)) {\r\n        return ip;\r\n    }\r\n\r\n    // Special case: overlapping arcs\r\n    // May return up to 4 intersection points\r\n    if (arc1.pc.equalTo(arc2.pc) && Flatten.Utils.EQ(arc1.r, arc2.r)) {\r\n        let pt;\r\n\r\n        pt = arc1.start;\r\n        if (pt.on(arc2))\r\n            ip.push(pt);\r\n\r\n        pt = arc1.end;\r\n        if (pt.on(arc2))\r\n            ip.push(pt);\r\n\r\n        pt = arc2.start;\r\n        if (pt.on(arc1)) ip.push(pt);\r\n\r\n        pt = arc2.end;\r\n        if (pt.on(arc1)) ip.push(pt);\r\n\r\n        return ip;\r\n    }\r\n\r\n    // Common case\r\n    let circle1 = new Flatten.Circle(arc1.pc, arc1.r);\r\n    let circle2 = new Flatten.Circle(arc2.pc, arc2.r);\r\n    let ip_tmp = circle1.intersect(circle2);\r\n    for (let pt of ip_tmp) {\r\n        if (pt.on(arc1) && pt.on(arc2)) {\r\n            ip.push(pt);\r\n        }\r\n    }\r\n    return ip;\r\n}\r\n\r\nfunction intersectArc2Circle(arc, circle) {\r\n    let ip = [];\r\n\r\n    if (arc.box.not_intersect(circle.box)) {\r\n        return ip;\r\n    }\r\n\r\n    // Case when arc center incident to circle center\r\n    // Return arc's end points as 2 intersection points\r\n    if (circle.pc.equalTo(arc.pc) && Flatten.Utils.EQ(circle.r, arc.r)) {\r\n        ip.push(arc.start);\r\n        ip.push(arc.end);\r\n        return ip;\r\n    }\r\n\r\n    // Common case\r\n    let circle1 = circle;\r\n    let circle2 = new Flatten.Circle(arc.pc, arc.r);\r\n    let ip_tmp = intersectCircle2Circle(circle1, circle2);\r\n    for (let pt of ip_tmp) {\r\n        if (pt.on(arc)) {\r\n            ip.push(pt);\r\n        }\r\n    }\r\n    return ip;\r\n}\r\n\r\nfunction intersectArc2Box(arc, box) {\r\n    let ips = [];\r\n    for (let seg of box.toSegments()) {\r\n        let ips_tmp = intersectSegment2Arc(seg, arc);\r\n        for (let ip of ips_tmp) {\r\n            ips.push(ip);\r\n        }\r\n    }\r\n    return ips;\r\n}\r\n\r\nfunction intersectEdge2Segment(edge, segment) {\r\n    return edge.isSegment() ? intersectSegment2Segment(edge.shape, segment) : intersectSegment2Arc(segment, edge.shape);\r\n}\r\n\r\nfunction intersectEdge2Arc(edge, arc) {\r\n    return edge.isSegment() ? intersectSegment2Arc(edge.shape, arc) : intersectArc2Arc(edge.shape, arc);\r\n}\r\n\r\nfunction intersectEdge2Line(edge, line) {\r\n    return edge.isSegment() ? intersectSegment2Line(edge.shape, line) : intersectLine2Arc(line, edge.shape);\r\n}\r\n\r\nfunction intersectEdge2Circle(edge, circle) {\r\n    return edge.isSegment() ? intersectSegment2Circle(edge.shape, circle) : intersectArc2Circle(edge.shape, circle);\r\n}\r\n\r\nfunction intersectSegment2Polygon(segment, polygon) {\r\n    let ip = [];\r\n\r\n    for (let edge of polygon.edges) {\r\n        for (let pt of intersectEdge2Segment(edge, segment)) {\r\n            ip.push(pt);\r\n        }\r\n    }\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectArc2Polygon(arc, polygon) {\r\n    let ip = [];\r\n\r\n    for (let edge of polygon.edges) {\r\n        for (let pt of intersectEdge2Arc(edge, arc)) {\r\n            ip.push(pt);\r\n        }\r\n    }\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectLine2Polygon(line, polygon) {\r\n    let ip = [];\r\n\r\n    if (polygon.isEmpty()) {\r\n        return ip;\r\n    }\r\n\r\n    for (let edge of polygon.edges) {\r\n        for (let pt of intersectEdge2Line(edge, line)) {\r\n            if (!ptInIntPoints(pt, ip)) {\r\n                ip.push(pt);\r\n            }\r\n        }\r\n    }\r\n\r\n    return line.sortPoints(ip);\r\n}\r\n\r\nfunction intersectCircle2Polygon(circle, polygon) {\r\n    let ip = [];\r\n\r\n    if (polygon.isEmpty()) {\r\n        return ip;\r\n    }\r\n\r\n    for (let edge of polygon.edges) {\r\n        for (let pt of intersectEdge2Circle(edge, circle)) {\r\n            ip.push(pt);\r\n        }\r\n    }\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectEdge2Edge(edge1, edge2) {\r\n    const shape1 = edge1.shape;\r\n    const shape2 = edge2.shape;\r\n    return edge1.isSegment() ?\r\n        (edge2.isSegment() ? intersectSegment2Segment(shape1, shape2) : intersectSegment2Arc(shape1, shape2)) :\r\n        (edge2.isSegment() ? intersectSegment2Arc(shape2, shape1) : intersectArc2Arc(shape1, shape2));\r\n}\r\n\r\nfunction intersectEdge2Polygon(edge, polygon) {\r\n    let ip = [];\r\n\r\n    if (polygon.isEmpty() || edge.shape.box.not_intersect(polygon.box)) {\r\n        return ip;\r\n    }\r\n\r\n    let resp_edges = polygon.edges.search(edge.shape.box);\r\n\r\n    for (let resp_edge of resp_edges) {\r\n        for (let pt of intersectEdge2Edge(edge, resp_edge)) {\r\n            ip.push(pt);\r\n        }\r\n    }\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectPolygon2Polygon(polygon1, polygon2) {\r\n    let ip = [];\r\n\r\n    if (polygon1.isEmpty() || polygon2.isEmpty()) {\r\n        return ip;\r\n    }\r\n\r\n    if (polygon1.box.not_intersect(polygon2.box)) {\r\n        return ip;\r\n    }\r\n\r\n    for (let edge1 of polygon1.edges) {\r\n        for (let pt of intersectEdge2Polygon(edge1, polygon2)) {\r\n            ip.push(pt);\r\n        }\r\n    }\r\n\r\n    return ip;\r\n}\r\n\r\nfunction intersectShape2Polygon(shape, polygon) {\r\n    if (shape instanceof Flatten.Line) {\r\n        return intersectLine2Polygon(shape, polygon);\r\n    }\r\n    else if (shape instanceof Flatten.Segment) {\r\n        return intersectSegment2Polygon(shape, polygon);\r\n    }\r\n    else if (shape instanceof Flatten.Arc) {\r\n        return intersectArc2Polygon(shape, polygon);\r\n    }\r\n    else {\r\n        return [];\r\n    }\r\n}\r\n\r\nfunction ptInIntPoints(new_pt, ip) {\r\n    return ip.some( pt => pt.equalTo(new_pt) )\r\n}\r\n\r\n/**\r\n * Class Multiline represent connected path of [edges]{@link Flatten.Edge}, where each edge may be\r\n * [segment]{@link Flatten.Segment}, [arc]{@link Flatten.Arc}, [line]{@link Flatten.Line} or [ray]{@link Flatten.Ray}\r\n */\r\nclass Multiline extends LinkedList {\r\n    constructor(...args) {\r\n        super();\r\n\r\n        if (args.length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (args.length == 1) {\r\n            if (args[0] instanceof Array) {\r\n                let shapes = args[0];\r\n                if (shapes.length == 0)\r\n                    return;\r\n\r\n                // TODO: more strict validation:\r\n                // there may be only one line\r\n                // only first and last may be rays\r\n                let validShapes = shapes.every((shape) => {\r\n                    return shape instanceof Flatten.Segment ||\r\n                        shape instanceof Flatten.Arc ||\r\n                        shape instanceof Flatten.Ray ||\r\n                        shape instanceof Flatten.Line\r\n                });\r\n\r\n                for (let shape of shapes) {\r\n                    let edge = new Flatten.Edge(shape);\r\n                    this.append(edge);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * (Getter) Return array of edges\r\n     * @returns {Edge[]}\r\n     */\r\n    get edges() {\r\n        return [...this];\r\n    }\r\n\r\n    /**\r\n     * (Getter) Return bounding box of the multiline\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        return this.edges.reduce( (acc,edge) => acc = acc.merge(edge.box), new Flatten.Box() );\r\n    }\r\n\r\n    /**\r\n     * (Getter) Returns array of vertices\r\n     * @returns {Point[]}\r\n     */\r\n    get vertices() {\r\n        let v = this.edges.map(edge => edge.start);\r\n        v.push(this.last.end);\r\n        return v;\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of Multiline\r\n     * @returns {Multiline}\r\n     */\r\n    clone() {\r\n        return new Multiline(this.toShapes());\r\n    }\r\n\r\n    /**\r\n     * Split edge and add new vertex, return new edge inserted\r\n     * @param {Point} pt - point on edge that will be added as new vertex\r\n     * @param {Edge} edge - edge to split\r\n     * @returns {Edge}\r\n     */\r\n    addVertex(pt, edge) {\r\n        let shapes = edge.shape.split(pt);\r\n        // if (shapes.length < 2) return;\r\n\r\n        if (shapes[0] === null)   // point incident to edge start vertex, return previous edge\r\n           return edge.prev;\r\n\r\n        if (shapes[1] === null)   // point incident to edge end vertex, return edge itself\r\n           return edge;\r\n\r\n        let newEdge = new Flatten.Edge(shapes[0]);\r\n        let edgeBefore = edge.prev;\r\n\r\n        /* Insert first split edge into linked list after edgeBefore */\r\n        this.insert(newEdge, edgeBefore);     // edge.face ?\r\n\r\n        // Update edge shape with second split edge keeping links\r\n        edge.shape = shapes[1];\r\n\r\n        return newEdge;\r\n    }\r\n\r\n    /**\r\n     * Split edges of multiline with intersection points and return mutated multiline\r\n     * @param {Point[]} ip - array of points to be added as new vertices\r\n     * @returns {Multiline}\r\n     */\r\n    split(ip) {\r\n        for (let pt of ip) {\r\n            let edge = this.findEdgeByPoint(pt);\r\n            this.addVertex(pt, edge);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns edge which contains given point\r\n     * @param {Point} pt\r\n     * @returns {Edge}\r\n     */\r\n    findEdgeByPoint(pt) {\r\n        let edgeFound;\r\n        for (let edge of this) {\r\n            if (edge.shape.contains(pt)) {\r\n                edgeFound = edge;\r\n                break;\r\n            }\r\n        }\r\n        return edgeFound;\r\n    }\r\n\r\n    /**\r\n     * Returns new multiline translated by vector vec\r\n     * @param {Vector} vec\r\n     * @returns {Multiline}\r\n     */\r\n    translate(vec) {\r\n        return new Multiline(this.edges.map( edge => edge.shape.translate(vec)));\r\n    }\r\n\r\n    /**\r\n     * Return new multiline rotated by given angle around given point\r\n     * If point omitted, rotate around origin (0,0)\r\n     * Positive value of angle defines rotation counter clockwise, negative - clockwise\r\n     * @param {number} angle - rotation angle in radians\r\n     * @param {Point} center - rotation center, default is (0,0)\r\n     * @returns {Multiline} - new rotated polygon\r\n     */\r\n    rotate(angle = 0, center = new Flatten.Point()) {\r\n        return new Multiline(this.edges.map( edge => edge.shape.rotate(angle, center) ));\r\n    }\r\n\r\n    /**\r\n     * Return new multiline transformed using affine transformation matrix\r\n     * Method does not support unbounded shapes\r\n     * @param {Matrix} matrix - affine transformation matrix\r\n     * @returns {Multiline} - new multiline\r\n     */\r\n    transform(matrix = new Flatten.Matrix()) {\r\n        return new Multiline(this.edges.map( edge => edge.shape.transform(matrix)));\r\n    }\r\n\r\n    /**\r\n     * Transform multiline into array of shapes\r\n     * @returns {Shape[]}\r\n     */\r\n    toShapes() {\r\n        return this.edges.map(edge => edge.shape.clone())\r\n    }\r\n\r\n    /**\r\n     * This method returns an object that defines how data will be\r\n     * serialized when called JSON.stringify() method\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n        return this.edges.map(edge => edge.toJSON());\r\n    }\r\n\r\n    /**\r\n     * Return string to draw multiline in svg\r\n     * @param attrs  - an object with attributes for svg path element,\r\n     * like \"stroke\", \"strokeWidth\", \"fill\", \"fillRule\", \"fillOpacity\"\r\n     * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"lightcyan\", fillRule:\"evenodd\", fillOpacity: \"1\"\r\n     * TODO: support semi-infinite Ray and infinite Line\r\n     * @returns {string}\r\n     */\r\n    svg(attrs = {}) {\r\n        let {stroke, strokeWidth, fill, fillRule, fillOpacity, id, className} = attrs;\r\n        let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n        let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n\r\n        let svgStr = `\\n<path stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"none\"}\" fill-opacity=\"${fillOpacity || 1.0}\" ${id_str} ${class_str} d=\"`;\r\n        svgStr += `\\nM${this.first.start.x},${this.first.start.y}`;\r\n        for (let edge of this) {\r\n            svgStr += edge.svg();\r\n        }\r\n        svgStr += `\" >\\n</path>`;\r\n\r\n        return svgStr;\r\n    }\r\n}\r\n\r\nFlatten.Multiline = Multiline;\r\n\r\n/**\r\n * Shortcut function to create multiline\r\n * @param args\r\n */\r\nconst multiline = (...args) => new Flatten.Multiline(...args);\r\nFlatten.multiline = multiline;\r\n\r\n/**\r\n * @module RayShoot\r\n */\r\n/**\r\n * Implements ray shooting algorithm. Returns relation between point and polygon: inside, outside or boundary\r\n * @param {Polygon} polygon - polygon to test\r\n * @param {Point} point - point to test\r\n * @returns {INSIDE|OUTSIDE|BOUNDARY}\r\n */\r\nfunction ray_shoot(polygon, point) {\r\n    let contains = undefined;\r\n\r\n    // 1. Quick reject\r\n    // if (polygon.box.not_intersect(point.box)) {\r\n    //     return Flatten.OUTSIDE;\r\n    // }\r\n\r\n    let ray = new Flatten.Ray(point);\r\n    let line = new Flatten.Line(ray.pt, ray.norm);\r\n\r\n    // 2. Locate relevant edges of the polygon\r\n    const searchBox = new Flatten.Box(\r\n        ray.box.xmin-Flatten.DP_TOL, ray.box.ymin-Flatten.DP_TOL,\r\n        ray.box.xmax, ray.box.ymax+Flatten.DP_TOL\r\n    );\r\n\r\n    if (polygon.box.not_intersect(searchBox)) {\r\n        return Flatten.OUTSIDE;\r\n    }\r\n\r\n    let resp_edges = polygon.edges.search(searchBox);\r\n\r\n    if (resp_edges.length == 0) {\r\n        return Flatten.OUTSIDE;\r\n    }\r\n\r\n    // 2.5 Check if boundary\r\n    for (let edge of resp_edges) {\r\n        if (edge.shape.contains(point)) {\r\n            return Flatten.BOUNDARY;\r\n        }\r\n    }\r\n\r\n    // 3. Calculate intersections\r\n    let intersections = [];\r\n    for (let edge of resp_edges) {\r\n        for (let ip of ray.intersect(edge.shape)) {\r\n\r\n            // If intersection is equal to query point then point lays on boundary\r\n            if (ip.equalTo(point)) {\r\n                return Flatten.BOUNDARY;\r\n            }\r\n\r\n            intersections.push({\r\n                pt: ip,\r\n                edge: edge\r\n            });\r\n        }\r\n    }\r\n\r\n    // 4. Sort intersection in x-ascending order\r\n    intersections.sort((i1, i2) => {\r\n        if (LT(i1.pt.x, i2.pt.x)) {\r\n            return -1;\r\n        }\r\n        if (GT(i1.pt.x, i2.pt.x)) {\r\n            return 1;\r\n        }\r\n        return 0;\r\n    });\r\n\r\n    // 5. Count real intersections, exclude touching\r\n    let counter = 0;\r\n\r\n    for (let i = 0; i < intersections.length; i++) {\r\n        let intersection = intersections[i];\r\n        if (intersection.pt.equalTo(intersection.edge.shape.start)) {\r\n            /* skip same point between same edges if already counted */\r\n            if (i > 0 && intersection.pt.equalTo(intersections[i - 1].pt) &&\r\n                intersection.edge.prev === intersections[i - 1].edge) {\r\n                continue;\r\n            }\r\n            let prev_edge = intersection.edge.prev;\r\n            while (EQ_0(prev_edge.length)) {\r\n                prev_edge = prev_edge.prev;\r\n            }\r\n            let prev_tangent = prev_edge.shape.tangentInEnd();\r\n            let prev_point = intersection.pt.translate(prev_tangent);\r\n\r\n            let cur_tangent = intersection.edge.shape.tangentInStart();\r\n            let cur_point = intersection.pt.translate(cur_tangent);\r\n\r\n            let prev_on_the_left = prev_point.leftTo(line);\r\n            let cur_on_the_left = cur_point.leftTo(line);\r\n\r\n            if ((prev_on_the_left && !cur_on_the_left) || (!prev_on_the_left && cur_on_the_left)) {\r\n                counter++;\r\n            }\r\n        } else if (intersection.pt.equalTo(intersection.edge.shape.end)) {\r\n            /* skip same point between same edges if already counted */\r\n            if (i > 0 && intersection.pt.equalTo(intersections[i - 1].pt) &&\r\n                intersection.edge.next === intersections[i - 1].edge) {\r\n                continue;\r\n            }\r\n            let next_edge = intersection.edge.next;\r\n            while (EQ_0(next_edge.length)) {\r\n                next_edge = next_edge.next;\r\n            }\r\n            let next_tangent = next_edge.shape.tangentInStart();\r\n            let next_point = intersection.pt.translate(next_tangent);\r\n\r\n            let cur_tangent = intersection.edge.shape.tangentInEnd();\r\n            let cur_point = intersection.pt.translate(cur_tangent);\r\n\r\n            let next_on_the_left = next_point.leftTo(line);\r\n            let cur_on_the_left = cur_point.leftTo(line);\r\n\r\n            if ((next_on_the_left && !cur_on_the_left) || (!next_on_the_left && cur_on_the_left)) {\r\n                counter++;\r\n            }\r\n        } else {        /* intersection point is not a coincident with a vertex */\r\n            if (intersection.edge.shape instanceof Flatten.Segment) {\r\n                counter++;\r\n            } else {\r\n                /* Check if ray does not touch the curve in the extremal (top or bottom) point */\r\n                let box = intersection.edge.shape.box;\r\n                if (!(EQ(intersection.pt.y, box.ymin) ||\r\n                    EQ(intersection.pt.y, box.ymax))) {\r\n                    counter++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // 6. Odd or even?\r\n    contains = counter % 2 == 1 ? INSIDE : OUTSIDE;\r\n\r\n    return contains;\r\n}\r\n\r\n/*\r\n    Calculate relationship between two shapes and return result in the form of\r\n    Dimensionally Extended nine-Intersection Matrix (https://en.wikipedia.org/wiki/DE-9IM)\r\n */\r\n\r\n/**\r\n * Returns true if shapes are topologically equal:  their interiors intersect and\r\n * no part of the interior or boundary of one geometry intersects the exterior of the other\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\r\nfunction equal(shape1, shape2) {\r\n    return relate(shape1, shape2).equal();\r\n}\r\n\r\n/**\r\n * Returns true if shapes have at least one point in common, same as \"not disjoint\"\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\r\nfunction intersect$1(shape1, shape2) {\r\n    return relate(shape1, shape2).intersect();\r\n}\r\n\r\n/**\r\n * Returns true if shapes have at least one point in common, but their interiors do not intersect\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\r\nfunction touch(shape1, shape2) {\r\n    return relate(shape1, shape2).touch();\r\n}\r\n\r\n/**\r\n * Returns true if shapes have no points in common neither in interior nor in boundary\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\r\nfunction disjoint(shape1, shape2) {\r\n    return !intersect$1(shape1, shape2);\r\n}\r\n\r\n/**\r\n * Returns true shape1 lies in the interior of shape2\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\r\nfunction inside(shape1, shape2) {\r\n    return relate(shape1, shape2).inside();\r\n}\r\n\r\n/**\r\n * Returns true if every point in shape1 lies in the interior or on the boundary of shape2\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\r\nfunction covered(shape1, shape2) {\r\n    return  relate(shape1, shape2).covered();\r\n}\r\n\r\n/**\r\n * Returns true shape1's interior contains shape2 <br/>\r\n * Same as inside(shape2, shape1)\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\r\nfunction contain(shape1, shape2) {\r\n    return inside(shape2, shape1);\r\n}\r\n\r\n/**\r\n * Returns true shape1's cover shape2, same as shape2 covered by shape1\r\n * @param shape1\r\n * @param shape2\r\n * @returns {boolean}\r\n */\r\nfunction cover(shape1, shape2) {\r\n    return covered(shape2, shape1);\r\n}\r\n\r\n/**\r\n * Returns relation between two shapes as intersection 3x3 matrix, where each\r\n * element contains relevant intersection as array of shapes.\r\n * If there is no intersection, element contains empty array\r\n * If intersection is irrelevant it left undefined. (For example, intersection\r\n * between two exteriors is usually irrelevant)\r\n * @param shape1\r\n * @param shape2\r\n * @returns {DE9IM}\r\n */\r\nfunction relate(shape1, shape2) {\r\n    if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Line) {\r\n        return relateLine2Line(shape1,  shape2);\r\n    }\r\n    else if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Circle) {\r\n        return relateLine2Circle(shape1, shape2);\r\n    }\r\n    else if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Box) {\r\n        return relateLine2Box(shape1, shape2);\r\n    }\r\n    else if ( shape1 instanceof Flatten.Line  && shape2 instanceof Flatten.Polygon) {\r\n        return relateLine2Polygon(shape1, shape2);\r\n    }\r\n    else if ( (shape1 instanceof Flatten.Segment || shape1 instanceof Flatten.Arc)  && shape2 instanceof Flatten.Polygon) {\r\n        return relateShape2Polygon(shape1, shape2);\r\n    }\r\n    else if ( (shape1 instanceof Flatten.Segment || shape1 instanceof Flatten.Arc)  &&\r\n        (shape2 instanceof Flatten.Circle || shape2 instanceof Flatten.Box) ) {\r\n        return relateShape2Polygon(shape1, new Flatten.Polygon(shape2));\r\n    }\r\n    else if (shape1 instanceof Flatten.Polygon && shape2 instanceof Flatten.Polygon) {\r\n        return relatePolygon2Polygon(shape1, shape2);\r\n    }\r\n    else if ((shape1 instanceof Flatten.Circle || shape1 instanceof Flatten.Box) &&\r\n        (shape2 instanceof  Flatten.Circle || shape2 instanceof Flatten.Box)) {\r\n        return relatePolygon2Polygon(new Flatten.Polygon(shape1), new Flatten.Polygon(shape2));\r\n    }\r\n    else if ((shape1 instanceof Flatten.Circle || shape1 instanceof Flatten.Box) && shape2 instanceof Flatten.Polygon) {\r\n        return relatePolygon2Polygon(new Flatten.Polygon(shape1), shape2);\r\n    }\r\n    else if (shape1 instanceof Flatten.Polygon && (shape2 instanceof Flatten.Circle || shape2 instanceof Flatten.Box)) {\r\n        return relatePolygon2Polygon(shape1, new Flatten.Polygon(shape2));\r\n    }\r\n}\r\n\r\nfunction relateLine2Line(line1, line2) {\r\n    let denim = new DE9IM();\r\n    let ip = intersectLine2Line(line1, line2);\r\n    if (ip.length === 0) {       // parallel or equal ?\r\n        if (line1.contains(line2.pt) && line2.contains(line1.pt)) {\r\n            denim.I2I = [line1];   // equal  'T.F...F..'  - no boundary\r\n            denim.I2E = [];\r\n            denim.E2I = [];\r\n        }\r\n        else {                     // parallel - disjoint 'FFTFF*T**'\r\n            denim.I2I = [];\r\n            denim.I2E = [line1];\r\n            denim.E2I = [line2];\r\n        }\r\n    }\r\n    else {                       // intersect   'T********'\r\n        denim.I2I = ip;\r\n        denim.I2E = line1.split(ip);\r\n        denim.E2I = line2.split(ip);\r\n    }\r\n    return denim;\r\n}\r\n\r\nfunction relateLine2Circle(line,circle) {\r\n    let denim = new DE9IM();\r\n    let ip = intersectLine2Circle(line, circle);\r\n    if (ip.length === 0) {\r\n        denim.I2I = [];\r\n        denim.I2B = [];\r\n        denim.I2E = [line];\r\n        denim.E2I = [circle];\r\n    }\r\n    else if (ip.length === 1) {\r\n        denim.I2I = [];\r\n        denim.I2B = ip;\r\n        denim.I2E = line.split(ip);\r\n\r\n        denim.E2I = [circle];\r\n    }\r\n    else {       // ip.length == 2\r\n        let multiline = new Multiline([line]);\r\n        let ip_sorted = line.sortPoints(ip);\r\n        multiline.split(ip_sorted);\r\n        let splitShapes = multiline.toShapes();\r\n\r\n        denim.I2I = [splitShapes[1]];\r\n        denim.I2B = ip_sorted;\r\n        denim.I2E = [splitShapes[0], splitShapes[2]];\r\n\r\n        denim.E2I = new Flatten.Polygon([circle.toArc()]).cut(multiline);\r\n    }\r\n\r\n    return denim;\r\n}\r\n\r\nfunction relateLine2Box(line, box) {\r\n    let denim = new DE9IM();\r\n    let ip = intersectLine2Box(line, box);\r\n    if (ip.length === 0) {\r\n        denim.I2I = [];\r\n        denim.I2B = [];\r\n        denim.I2E = [line];\r\n\r\n        denim.E2I = [box];\r\n    }\r\n    else if (ip.length === 1) {\r\n        denim.I2I = [];\r\n        denim.I2B = ip;\r\n        denim.I2E = line.split(ip);\r\n\r\n        denim.E2I = [box];\r\n    }\r\n    else {                     // ip.length == 2\r\n        let multiline = new Multiline([line]);\r\n        let ip_sorted = line.sortPoints(ip);\r\n        multiline.split(ip_sorted);\r\n        let splitShapes = multiline.toShapes();\r\n\r\n        /* Are two intersection points on the same segment of the box boundary ? */\r\n        if (box.toSegments().some( segment => segment.contains(ip[0]) && segment.contains(ip[1]) )) {\r\n            denim.I2I = [];                         // case of touching\r\n            denim.I2B = [splitShapes[1]];\r\n            denim.I2E = [splitShapes[0], splitShapes[2]];\r\n\r\n            denim.E2I = [box];\r\n        }\r\n        else {                                       // case of intersection\r\n            denim.I2I = [splitShapes[1]];            // [segment(ip[0], ip[1])];\r\n            denim.I2B = ip_sorted;\r\n            denim.I2E = [splitShapes[0], splitShapes[2]];\r\n\r\n            denim.E2I = new Flatten.Polygon(box.toSegments()).cut(multiline);\r\n        }\r\n    }\r\n    return denim;\r\n}\r\n\r\nfunction relateLine2Polygon(line, polygon) {\r\n    let denim = new DE9IM();\r\n    let ip = intersectLine2Polygon(line, polygon);\r\n    let multiline = new Multiline([line]);\r\n    let ip_sorted = ip.length > 0 ? ip.slice() : line.sortPoints(ip);\r\n\r\n    multiline.split(ip_sorted);\r\n\r\n    [...multiline].forEach(edge => edge.setInclusion(polygon));\r\n\r\n    denim.I2I = [...multiline].filter(edge => edge.bv === Flatten.INSIDE).map(edge => edge.shape);\r\n    denim.I2B = [...multiline].slice(1).map( (edge) => edge.bv === Flatten.BOUNDARY ? edge.shape : edge.shape.start );\r\n    denim.I2E = [...multiline].filter(edge => edge.bv === Flatten.OUTSIDE).map(edge => edge.shape);\r\n\r\n    denim.E2I = polygon.cut(multiline);\r\n\r\n    return denim;\r\n}\r\n\r\nfunction relateShape2Polygon(shape, polygon) {\r\n    let denim = new DE9IM();\r\n    let ip = intersectShape2Polygon(shape, polygon);\r\n    let ip_sorted = ip.length > 0 ? ip.slice() : shape.sortPoints(ip);\r\n\r\n    let multiline = new Multiline([shape]);\r\n    multiline.split(ip_sorted);\r\n\r\n    [...multiline].forEach(edge => edge.setInclusion(polygon));\r\n\r\n    denim.I2I = [...multiline].filter(edge => edge.bv === Flatten.INSIDE).map(edge => edge.shape);\r\n    denim.I2B = [...multiline].slice(1).map( (edge) => edge.bv === Flatten.BOUNDARY ? edge.shape : edge.shape.start );\r\n    denim.I2E = [...multiline].filter(edge => edge.bv === Flatten.OUTSIDE).map(edge => edge.shape);\r\n\r\n\r\n    denim.B2I = [];\r\n    denim.B2B = [];\r\n    denim.B2E = [];\r\n    for (let pt of [shape.start, shape.end]) {\r\n        switch (ray_shoot(polygon, pt)) {\r\n            case Flatten.INSIDE:\r\n                denim.B2I.push(pt);\r\n                break;\r\n            case Flatten.BOUNDARY:\r\n                denim.B2B.push(pt);\r\n                break;\r\n            case Flatten.OUTSIDE:\r\n                denim.B2E.push(pt);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    // denim.E2I  TODO: calculate, not clear what is expected result\r\n\r\n    return denim;\r\n}\r\n\r\nfunction relatePolygon2Polygon(polygon1, polygon2) {\r\n    let denim = new DE9IM();\r\n\r\n    let [ip_sorted1, ip_sorted2] = calculateIntersections(polygon1, polygon2);\r\n    let boolean_intersection = intersect(polygon1, polygon2);\r\n    let boolean_difference1 = subtract(polygon1, polygon2);\r\n    let boolean_difference2 = subtract(polygon2, polygon1);\r\n    let [inner_clip_shapes1, inner_clip_shapes2] = innerClip(polygon1, polygon2);\r\n    let outer_clip_shapes1 = outerClip(polygon1, polygon2);\r\n    let outer_clip_shapes2 = outerClip(polygon2, polygon1);\r\n\r\n    denim.I2I = boolean_intersection.isEmpty() ? [] : [boolean_intersection];\r\n    denim.I2B = inner_clip_shapes2;\r\n    denim.I2E = boolean_difference1.isEmpty() ? [] : [boolean_difference1];\r\n\r\n    denim.B2I = inner_clip_shapes1;\r\n    denim.B2B = ip_sorted1;\r\n    denim.B2E = outer_clip_shapes1;\r\n\r\n    denim.E2I = boolean_difference2.isEmpty() ? [] : [boolean_difference2];\r\n    denim.E2B = outer_clip_shapes2;\r\n    // denim.E2E    not relevant meanwhile\r\n\r\n    return denim;\r\n}\r\n\r\nvar Relations = /*#__PURE__*/Object.freeze({\r\n    equal: equal,\r\n    intersect: intersect$1,\r\n    touch: touch,\r\n    disjoint: disjoint,\r\n    inside: inside,\r\n    covered: covered,\r\n    contain: contain,\r\n    cover: cover,\r\n    relate: relate\r\n});\r\n\r\n/**\r\n * Class representing an affine transformation 3x3 matrix:\r\n * <pre>\r\n *      [ a  c  tx\r\n * A =    b  d  ty\r\n *        0  0  1  ]\r\n * </pre\r\n * @type {Matrix}\r\n */\r\nclass Matrix {\r\n    /**\r\n     * Construct new instance of affine transformation matrix <br/>\r\n     * If parameters omitted, construct identity matrix a = 1, d = 1\r\n     * @param {number} a - position(0,0)   sx*cos(alpha)\r\n     * @param {number} b - position (0,1)  sx*sin(alpha)\r\n     * @param {number} c - position (1,0)  -sy*sin(alpha)\r\n     * @param {number} d - position (1,1)  sy*cos(alpha)\r\n     * @param {number} tx - position (2,0) translation by x\r\n     * @param {number} ty - position (2,1) translation by y\r\n     */\r\n    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\r\n        this.a = a;\r\n        this.b = b;\r\n        this.c = c;\r\n        this.d = d;\r\n        this.tx = tx;\r\n        this.ty = ty;\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of matrix\r\n     * @return {Matrix}\r\n     **/\r\n    clone() {\r\n        return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);\r\n    };\r\n\r\n    /**\r\n     * Transform vector [x,y] using transformation matrix. <br/>\r\n     * Vector [x,y] is an abstract array[2] of numbers and not a FlattenJS object <br/>\r\n     * The result is also an abstract vector [x',y'] = A * [x,y]:\r\n     * <code>\r\n     * [x'       [ ax + by + tx\r\n     *  y'   =     cx + dy + ty\r\n     *  1]                    1 ]\r\n     * </code>\r\n     * @param {number[]} vector - array[2] of numbers\r\n     * @returns {number[]} transformation result - array[2] of numbers\r\n     */\r\n    transform(vector) {\r\n        return [\r\n            vector[0] * this.a + vector[1] * this.c + this.tx,\r\n            vector[0] * this.b + vector[1] * this.d + this.ty\r\n        ]\r\n    };\r\n\r\n    /**\r\n     * Returns result of multiplication of this matrix by other matrix\r\n     * @param {Matrix} other_matrix - matrix to multiply by\r\n     * @returns {Matrix}\r\n     */\r\n    multiply(other_matrix) {\r\n        return new Matrix(\r\n            this.a * other_matrix.a + this.c * other_matrix.b,\r\n            this.b * other_matrix.a + this.d * other_matrix.b,\r\n            this.a * other_matrix.c + this.c * other_matrix.d,\r\n            this.b * other_matrix.c + this.d * other_matrix.d,\r\n            this.a * other_matrix.tx + this.c * other_matrix.ty + this.tx,\r\n            this.b * other_matrix.tx + this.d * other_matrix.ty + this.ty\r\n        )\r\n    };\r\n\r\n    /**\r\n     * Return new matrix as a result of multiplication of the current matrix\r\n     * by the matrix(1,0,0,1,tx,ty)\r\n     * @param {number} tx - translation by x\r\n     * @param {number} ty - translation by y\r\n     * @returns {Matrix}\r\n     */\r\n    translate(...args) {\r\n        let tx, ty;\r\n        if (args.length == 1 && (args[0] instanceof Flatten.Vector)) {\r\n            tx = args[0].x;\r\n            ty = args[0].y;\r\n        } else if (args.length == 2 && typeof (args[0]) == \"number\" && typeof (args[1]) == \"number\") {\r\n            tx = args[0];\r\n            ty = args[1];\r\n        } else {\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n        return this.multiply(new Matrix(1, 0, 0, 1, tx, ty))\r\n    };\r\n\r\n    /**\r\n     * Return new matrix as a result of multiplication of the current matrix\r\n     * by the matrix that defines rotation by given angle (in radians) around\r\n     * point (0,0) in counter clockwise direction\r\n     * @param {number} angle - angle in radians\r\n     * @returns {Matrix}\r\n     */\r\n    rotate(angle) {\r\n        let cos = Math.cos(angle);\r\n        let sin = Math.sin(angle);\r\n        return this.multiply(new Matrix(cos, sin, -sin, cos, 0, 0));\r\n    };\r\n\r\n    /**\r\n     * Return new matrix as a result of multiplication of the current matrix\r\n     * by the matrix (sx,0,0,sy,0,0) that defines scaling\r\n     * @param {number} sx\r\n     * @param {number} sy\r\n     * @returns {Matrix}\r\n     */\r\n    scale(sx, sy) {\r\n        return this.multiply(new Matrix(sx, 0, 0, sy, 0, 0));\r\n    };\r\n\r\n    /**\r\n     * Returns true if two matrix are equal parameter by parameter\r\n     * @param {Matrix} matrix - other matrix\r\n     * @returns {boolean} true if equal, false otherwise\r\n     */\r\n    equalTo(matrix) {\r\n        if (!Flatten.Utils.EQ(this.tx, matrix.tx)) return false;\r\n        if (!Flatten.Utils.EQ(this.ty, matrix.ty)) return false;\r\n        if (!Flatten.Utils.EQ(this.a, matrix.a)) return false;\r\n        if (!Flatten.Utils.EQ(this.b, matrix.b)) return false;\r\n        if (!Flatten.Utils.EQ(this.c, matrix.c)) return false;\r\n        if (!Flatten.Utils.EQ(this.d, matrix.d)) return false;\r\n        return true;\r\n    };\r\n}\r\nFlatten.Matrix = Matrix;\r\n/**\r\n * Function to create matrix equivalent to \"new\" constructor\r\n * @param args\r\n */\r\nconst matrix = (...args) => new Flatten.Matrix(...args);\r\nFlatten.matrix = matrix;\r\n\r\n/**\r\n * Created by Alex Bol on 4/1/2017.\r\n */\r\n\r\n/**\r\n * Interval is a pair of numbers or a pair of any comparable objects on which may be defined predicates\r\n * *equal*, *less* and method *max(p1, p1)* that returns maximum in a pair.\r\n * When interval is an object rather than pair of numbers, this object should have properties *low*, *high*, *max*\r\n * and implement methods *less_than(), equal_to(), intersect(), not_intersect(), clone(), output()*.\r\n * Two static methods *comparable_max(), comparable_less_than()* define how to compare values in pair. <br/>\r\n * This interface is described in typescript definition file *index.d.ts*\r\n *\r\n * Axis aligned rectangle is an example of such interval.\r\n * We may look at rectangle as an interval between its low left and top right corners.\r\n * See **Box** class in [flatten-js](https://github.com/alexbol99/flatten-js) library as the example\r\n * of Interval interface implementation\r\n * @type {Interval}\r\n */\r\nconst Interval = class Interval {\r\n    /**\r\n     * Accept two comparable values and creates new instance of interval\r\n     * Predicate Interval.comparable_less(low, high) supposed to return true on these values\r\n     * @param low\r\n     * @param high\r\n     */\r\n    constructor(low, high) {\r\n        this.low = low;\r\n        this.high = high;\r\n    }\r\n\r\n    /**\r\n     * Clone interval\r\n     * @returns {Interval}\r\n     */\r\n    clone() {\r\n        return new Interval(this.low, this.high);\r\n    }\r\n\r\n    /**\r\n     * Propery max returns clone of this interval\r\n     * @returns {Interval}\r\n     */\r\n    get max() {\r\n        return this.clone();   // this.high;\r\n    }\r\n\r\n    /**\r\n     * Predicate returns true is this interval less than other interval\r\n     * @param other_interval\r\n     * @returns {boolean}\r\n     */\r\n    less_than(other_interval) {\r\n        return this.low < other_interval.low ||\r\n            this.low == other_interval.low && this.high < other_interval.high;\r\n    }\r\n\r\n    /**\r\n     * Predicate returns true is this interval equals to other interval\r\n     * @param other_interval\r\n     * @returns {boolean}\r\n     */\r\n    equal_to(other_interval) {\r\n        return this.low == other_interval.low && this.high == other_interval.high;\r\n    }\r\n\r\n    /**\r\n     * Predicate returns true if this interval intersects other interval\r\n     * @param other_interval\r\n     * @returns {boolean}\r\n     */\r\n    intersect(other_interval) {\r\n        return !this.not_intersect(other_interval);\r\n    }\r\n\r\n    /**\r\n     * Predicate returns true if this interval does not intersect other interval\r\n     * @param other_interval\r\n     * @returns {boolean}\r\n     */\r\n    not_intersect(other_interval) {\r\n        return (this.high < other_interval.low || other_interval.high < this.low);\r\n    }\r\n\r\n    /**\r\n     * Returns new interval merged with other interval\r\n     * @param {Interval} interval - Other interval to merge with\r\n     * @returns {Interval}\r\n     */\r\n    merge(other_interval) {\r\n        return new Interval(\r\n            this.low === undefined ? other_interval.low : Math.min(this.low, other_interval.low),\r\n            this.high === undefined ? other_interval.high : Math.max(this.high, other_interval.high)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns how key should return\r\n     */\r\n    output() {\r\n        return [this.low, this.high];\r\n    }\r\n\r\n    /**\r\n     * Function returns maximum between two comparable values\r\n     * @param interval1\r\n     * @param interval2\r\n     * @returns {Interval}\r\n     */\r\n    static comparable_max(interval1, interval2) {\r\n        return interval1.merge(interval2);\r\n    }\r\n\r\n    /**\r\n     * Predicate returns true if first value less than second value\r\n     * @param val1\r\n     * @param val2\r\n     * @returns {boolean}\r\n     */\r\n    static comparable_less_than(val1, val2 ) {\r\n        return val1 < val2;\r\n    }\r\n};\r\n\r\n/**\r\n * Created by Alex Bol on 3/28/2017.\r\n */\r\n\r\n// module.exports = {\r\n//     RB_TREE_COLOR_RED: 0,\r\n//     RB_TREE_COLOR_BLACK: 1\r\n// };\r\n\r\nconst RB_TREE_COLOR_RED = 0;\r\nconst RB_TREE_COLOR_BLACK = 1;\r\n\r\n/**\r\n * Created by Alex Bol on 4/1/2017.\r\n */\r\n\r\nclass Node {\r\n    constructor(key = undefined, value = undefined,\r\n                left = null, right = null, parent = null, color = RB_TREE_COLOR_BLACK) {\r\n        this.left = left;                     // reference to left child node\r\n        this.right = right;                   // reference to right child node\r\n        this.parent = parent;                 // reference to parent node\r\n        this.color = color;\r\n\r\n        this.item = {key: key, value: value};   // key is supposed to be instance of Interval\r\n\r\n        /* If not, this should by an array of two numbers */\r\n        if (key && key instanceof Array && key.length == 2) {\r\n            if (!Number.isNaN(key[0]) && !Number.isNaN(key[1])) {\r\n                this.item.key = new Interval(Math.min(key[0], key[1]), Math.max(key[0], key[1]));\r\n            }\r\n        }\r\n\r\n        this.max = this.item.key ? this.item.key.max : undefined;\r\n    }\r\n\r\n    isNil() {\r\n        return (this.item.key === undefined && this.item.value === undefined &&\r\n            this.left === null && this.right === null && this.color === RB_TREE_COLOR_BLACK);\r\n    }\r\n\r\n    less_than(other_node) {\r\n        // if tree stores only keys\r\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\r\n            return this.item.key.less_than(other_node.item.key);\r\n        }\r\n        else {    // if tree stores keys and values\r\n            let value_less_than = this.item.value && other_node.item.value && this.item.value.less_than ? this.item.value.less_than(other_node.item.value) :\r\n                this.item.value < other_node.item.value;\r\n            return this.item.key.less_than(other_node.item.key) ||\r\n                this.item.key.equal_to((other_node.item.key)) && value_less_than;\r\n        }\r\n\r\n        // if (this.item.value && other_node.item.value) {\r\n        //     let item_less_than = this.item.value.less_than ? this.item.value.less_than(other_node.item.value) :\r\n        //         this.item.value < other_node.item.value;\r\n        //     return this.item.key.less_than(other_node.item.key) ||\r\n        //         this.item.key.equal_to((other_node.item.key)) && item_less_than;\r\n        // }\r\n        // else {\r\n        //     return this.item.key.less_than(other_node.item.key);\r\n        // }\r\n    }\r\n\r\n    equal_to(other_node) {\r\n        // if tree stores only keys\r\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\r\n            return this.item.key.equal_to(other_node.item.key);\r\n        }\r\n        else {    // if tree stores keys and values\r\n            let value_equal = this.item.value && other_node.item.value && this.item.value.equal_to ? this.item.value.equal_to(other_node.item.value) :\r\n                this.item.value == other_node.item.value;\r\n            return this.item.key.equal_to(other_node.item.key) && value_equal;\r\n        }\r\n\r\n        // let value_equal = true;\r\n        // if (this.item.value && other_node.item.value) {\r\n        //     value_equal = this.item.value.equal_to ? this.item.value.equal_to(other_node.item.value) :\r\n        //         this.item.value == other_node.item.value;\r\n        // }\r\n        // return this.item.key.equal_to(other_node.item.key) && value_equal;\r\n    }\r\n\r\n    intersect(other_node) {\r\n        return this.item.key.intersect(other_node.item.key);\r\n    }\r\n\r\n    copy_data(other_node) {\r\n        this.item.key = other_node.item.key;\r\n        this.item.value = other_node.item.value;\r\n    }\r\n\r\n    update_max() {\r\n        // use key (Interval) max property instead of key.high\r\n        this.max = this.item.key ? this.item.key.max : undefined;\r\n        if (this.right && this.right.max) {\r\n            const comparable_max = this.item.key.constructor.comparable_max;  // static method\r\n            this.max = comparable_max(this.max, this.right.max);\r\n        }\r\n        if (this.left && this.left.max) {\r\n            const comparable_max = this.item.key.constructor.comparable_max;  // static method\r\n            this.max = comparable_max(this.max, this.left.max);\r\n        }\r\n    }\r\n\r\n    // Other_node does not intersect any node of left subtree, if this.left.max < other_node.item.key.low\r\n    not_intersect_left_subtree(search_node) {\r\n        const comparable_less_than = this.item.key.constructor.comparable_less_than;  // static method\r\n        let high = this.left.max.high !== undefined ? this.left.max.high : this.left.max;\r\n        return comparable_less_than(high, search_node.item.key.low);\r\n    }\r\n\r\n    // Other_node does not intersect right subtree if other_node.item.key.high < this.right.key.low\r\n    not_intersect_right_subtree(search_node) {\r\n        const comparable_less_than = this.item.key.constructor.comparable_less_than;  // static method\r\n        let low = this.right.max.low !== undefined ? this.right.max.low : this.right.item.key.low;\r\n        return comparable_less_than(search_node.item.key.high, low);\r\n    }\r\n}\r\n\r\n/**\r\n * Created by Alex Bol on 3/31/2017.\r\n */\r\n\r\n// const nil_node = new Node();\r\n\r\n/**\r\n * Implementation of interval binary search tree <br/>\r\n * Interval tree stores items which are couples of {key:interval, value: value} <br/>\r\n * Interval is an object with high and low properties or simply pair [low,high] of numeric values <br />\r\n * @type {IntervalTree}\r\n */\r\nclass IntervalTree {\r\n    /**\r\n     * Construct new empty instance of IntervalTree\r\n     */\r\n    constructor() {\r\n        this.root = null;\r\n        this.nil_node = new Node();\r\n    }\r\n\r\n    /**\r\n     * Returns number of items stored in the interval tree\r\n     * @returns {number}\r\n     */\r\n    get size() {\r\n        let count = 0;\r\n        this.tree_walk(this.root, () => count++);\r\n        return count;\r\n    }\r\n\r\n    /**\r\n     * Returns array of sorted keys in the ascending order\r\n     * @returns {Array}\r\n     */\r\n    get keys() {\r\n        let res = [];\r\n        this.tree_walk(this.root, (node) => res.push(\r\n            node.item.key.output ? node.item.key.output() : node.item.key\r\n        ));\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Return array of values in the ascending keys order\r\n     * @returns {Array}\r\n     */\r\n    get values() {\r\n        let res = [];\r\n        this.tree_walk(this.root, (node) => res.push(node.item.value));\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Returns array of items (<key,value> pairs) in the ascended keys order\r\n     * @returns {Array}\r\n     */\r\n    get items() {\r\n        let res = [];\r\n        this.tree_walk(this.root, (node) => res.push({\r\n            key: node.item.key.output ? node.item.key.output() : node.item.key,\r\n            value: node.item.value\r\n        }));\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Returns true if tree is empty\r\n     * @returns {boolean}\r\n     */\r\n    isEmpty() {\r\n        return (this.root == null || this.root == this.nil_node);\r\n    }\r\n\r\n    /**\r\n     * Clear tree\r\n     */\r\n    clear() {\r\n        this.root = null;\r\n    }\r\n\r\n    /**\r\n     * Insert new item into interval tree\r\n     * @param {Interval} key - interval object or array of two numbers [low, high]\r\n     * @param {any} value - value representing any object (optional)\r\n     * @returns {Node} returns reference to inserted node as an object {key:interval, value: value}\r\n     */\r\n    insert(key, value = key) {\r\n        if (key === undefined) return;\r\n        let insert_node = new Node(key, value, this.nil_node, this.nil_node, null, RB_TREE_COLOR_RED);\r\n        this.tree_insert(insert_node);\r\n        this.recalc_max(insert_node);\r\n        return insert_node;\r\n    }\r\n\r\n    /**\r\n     * Returns true if item {key,value} exist in the tree\r\n     * @param {Interval} key - interval correspondent to keys stored in the tree\r\n     * @param {any} value - value object to be checked\r\n     * @returns {boolean} true if item {key, value} exist in the tree, false otherwise\r\n     */\r\n    exist(key, value = key) {\r\n        let search_node = new Node(key, value);\r\n        return this.tree_search(this.root, search_node) ? true : false;\r\n    }\r\n\r\n    /**\r\n     * Remove entry {key, value} from the tree\r\n     * @param {Interval} key - interval correspondent to keys stored in the tree\r\n     * @param {any} value - value object\r\n     * @returns {boolean} true if item {key, value} deleted, false if not found\r\n     */\r\n    remove(key, value = key) {\r\n        let search_node = new Node(key, value);\r\n        let delete_node = this.tree_search(this.root, search_node);\r\n        if (delete_node) {\r\n            this.tree_delete(delete_node);\r\n        }\r\n        return delete_node;\r\n    }\r\n\r\n    /**\r\n     * Returns array of entry values which keys intersect with given interval <br/>\r\n     * If no values stored in the tree, returns array of keys which intersect given interval\r\n     * @param {Interval} interval - search interval, or tuple [low, high]\r\n     * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output\r\n     * @returns {Array}\r\n     */\r\n    search(interval, outputMapperFn = (value, key) => value === key ? key.output() : value) {\r\n        let search_node = new Node(interval);\r\n        let resp_nodes = [];\r\n        this.tree_search_interval(this.root, search_node, resp_nodes);\r\n        return resp_nodes.map(node => outputMapperFn(node.item.value, node.item.key))\r\n    }\r\n\r\n    /**\r\n     * Returns true if intersection between given and any interval stored in the tree found\r\n     * @param {Interval} interval - search interval or tuple [low, high]\r\n     * @returns {boolean}\r\n     */\r\n    intersect_any(interval) {\r\n        let search_node = new Node(interval);\r\n        let found = this.tree_find_any_interval(this.root, search_node);\r\n        return found;\r\n    }\r\n\r\n    /**\r\n     * Tree visitor. For each node implement a callback function. <br/>\r\n     * Method calls a callback function with two parameters (key, value)\r\n     * @param visitor(key,value) - function to be called for each tree item\r\n     */\r\n    forEach(visitor) {\r\n        this.tree_walk(this.root, (node) => visitor(node.item.key, node.item.value));\r\n    }\r\n\r\n    /** Value Mapper. Walk through every node and map node value to another value\r\n    * @param callback(value,key) - function to be called for each tree item\r\n    */\r\n    map(callback) {\r\n        const tree = new IntervalTree();\r\n        this.tree_walk(this.root, (node) => tree.insert(node.item.key, callback(node.item.value, node.item.key)));\r\n        return tree;\r\n    }\r\n\r\n    recalc_max(node) {\r\n        let node_current = node;\r\n        while (node_current.parent != null) {\r\n            node_current.parent.update_max();\r\n            node_current = node_current.parent;\r\n        }\r\n    }\r\n\r\n    tree_insert(insert_node) {\r\n        let current_node = this.root;\r\n        let parent_node = null;\r\n\r\n        if (this.root == null || this.root == this.nil_node) {\r\n            this.root = insert_node;\r\n        }\r\n        else {\r\n            while (current_node != this.nil_node) {\r\n                parent_node = current_node;\r\n                if (insert_node.less_than(current_node)) {\r\n                    current_node = current_node.left;\r\n                }\r\n                else {\r\n                    current_node = current_node.right;\r\n                }\r\n            }\r\n\r\n            insert_node.parent = parent_node;\r\n\r\n            if (insert_node.less_than(parent_node)) {\r\n                parent_node.left = insert_node;\r\n            }\r\n            else {\r\n                parent_node.right = insert_node;\r\n            }\r\n        }\r\n\r\n        this.insert_fixup(insert_node);\r\n    }\r\n\r\n// After insertion insert_node may have red-colored parent, and this is a single possible violation\r\n// Go upwords to the root and re-color until violation will be resolved\r\n    insert_fixup(insert_node) {\r\n        let current_node;\r\n        let uncle_node;\r\n\r\n        current_node = insert_node;\r\n        while (current_node != this.root && current_node.parent.color == RB_TREE_COLOR_RED) {\r\n            if (current_node.parent == current_node.parent.parent.left) {   // parent is left child of grandfather\r\n                uncle_node = current_node.parent.parent.right;              // right brother of parent\r\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 1. Uncle is red\r\n                    // re-color father and uncle into black\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    current_node = current_node.parent.parent;\r\n                }\r\n                else {                                                    // Case 2 & 3. Uncle is black\r\n                    if (current_node == current_node.parent.right) {     // Case 2. Current if right child\r\n                        // This case is transformed into Case 3.\r\n                        current_node = current_node.parent;\r\n                        this.rotate_left(current_node);\r\n                    }\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 3. Current is left child.\r\n                    // Re-color father and grandfather, rotate grandfather right\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    this.rotate_right(current_node.parent.parent);\r\n                }\r\n            }\r\n            else {                                                         // parent is right child of grandfather\r\n                uncle_node = current_node.parent.parent.left;              // left brother of parent\r\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 4. Uncle is red\r\n                    // re-color father and uncle into black\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    current_node = current_node.parent.parent;\r\n                }\r\n                else {\r\n                    if (current_node == current_node.parent.left) {             // Case 5. Current is left child\r\n                        // Transform into case 6\r\n                        current_node = current_node.parent;\r\n                        this.rotate_right(current_node);\r\n                    }\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 6. Current is right child.\r\n                    // Re-color father and grandfather, rotate grandfather left\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    this.rotate_left(current_node.parent.parent);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.root.color = RB_TREE_COLOR_BLACK;\r\n    }\r\n\r\n    tree_delete(delete_node) {\r\n        let cut_node;   // node to be cut - either delete_node or successor_node  (\"y\" from 14.4)\r\n        let fix_node;   // node to fix rb tree property   (\"x\" from 14.4)\r\n\r\n        if (delete_node.left == this.nil_node || delete_node.right == this.nil_node) {  // delete_node has less then 2 children\r\n            cut_node = delete_node;\r\n        }\r\n        else {                                                    // delete_node has 2 children\r\n            cut_node = this.tree_successor(delete_node);\r\n        }\r\n\r\n        // fix_node if single child of cut_node\r\n        if (cut_node.left != this.nil_node) {\r\n            fix_node = cut_node.left;\r\n        }\r\n        else {\r\n            fix_node = cut_node.right;\r\n        }\r\n\r\n        // remove cut_node from parent\r\n        /*if (fix_node != this.nil_node) {*/\r\n            fix_node.parent = cut_node.parent;\r\n        /*}*/\r\n\r\n        if (cut_node == this.root) {\r\n            this.root = fix_node;\r\n        }\r\n        else {\r\n            if (cut_node == cut_node.parent.left) {\r\n                cut_node.parent.left = fix_node;\r\n            }\r\n            else {\r\n                cut_node.parent.right = fix_node;\r\n            }\r\n            cut_node.parent.update_max();        // update max property of the parent\r\n        }\r\n\r\n        this.recalc_max(fix_node);              // update max property upward from fix_node to root\r\n\r\n        // COPY DATA !!!\r\n        // Delete_node becomes cut_node, it means that we cannot hold reference\r\n        // to node in outer structure and we will have to delete by key, additional search need\r\n        if (cut_node != delete_node) {\r\n            delete_node.copy_data(cut_node);\r\n            delete_node.update_max();           // update max property of the cut node at the new place\r\n            this.recalc_max(delete_node);       // update max property upward from delete_node to root\r\n        }\r\n\r\n        if (/*fix_node != this.nil_node && */cut_node.color == RB_TREE_COLOR_BLACK) {\r\n            this.delete_fixup(fix_node);\r\n        }\r\n    }\r\n\r\n    delete_fixup(fix_node) {\r\n        let current_node = fix_node;\r\n        let brother_node;\r\n\r\n        while (current_node != this.root && current_node.parent != null && current_node.color == RB_TREE_COLOR_BLACK) {\r\n            if (current_node == current_node.parent.left) {          // fix node is left child\r\n                brother_node = current_node.parent.right;\r\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\r\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\r\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\r\n                    this.rotate_left(current_node.parent);\r\n                    brother_node = current_node.parent.right;                      // update brother\r\n                }\r\n                // Derive to cases 2..4: brother is black\r\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\r\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {  // case 2: both nephews black\r\n                    brother_node.color = RB_TREE_COLOR_RED;              // re-color brother\r\n                    current_node = current_node.parent;                  // continue iteration\r\n                }\r\n                else {\r\n                    if (brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 3: left nephew red, right nephew black\r\n                        brother_node.color = RB_TREE_COLOR_RED;          // re-color brother\r\n                        brother_node.left.color = RB_TREE_COLOR_BLACK;   // re-color nephew\r\n                        this.rotate_right(brother_node);\r\n                        brother_node = current_node.parent.right;                     // update brother\r\n                        // Derive to case 4: left nephew black, right nephew red\r\n                    }\r\n                    // case 4: left nephew black, right nephew red\r\n                    brother_node.color = current_node.parent.color;\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    brother_node.right.color = RB_TREE_COLOR_BLACK;\r\n                    this.rotate_left(current_node.parent);\r\n                    current_node = this.root;                         // exit from loop\r\n                }\r\n            }\r\n            else {                                             // fix node is right child\r\n                brother_node = current_node.parent.left;\r\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\r\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\r\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\r\n                    this.rotate_right(current_node.parent);\r\n                    brother_node = current_node.parent.left;                        // update brother\r\n                }\r\n                // Go to cases 2..4\r\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\r\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 2\r\n                    brother_node.color = RB_TREE_COLOR_RED;             // re-color brother\r\n                    current_node = current_node.parent;                              // continue iteration\r\n                }\r\n                else {\r\n                    if (brother_node.left.color == RB_TREE_COLOR_BLACK) {  // case 3: right nephew red, left nephew black\r\n                        brother_node.color = RB_TREE_COLOR_RED;            // re-color brother\r\n                        brother_node.right.color = RB_TREE_COLOR_BLACK;    // re-color nephew\r\n                        this.rotate_left(brother_node);\r\n                        brother_node = current_node.parent.left;                        // update brother\r\n                        // Derive to case 4: right nephew black, left nephew red\r\n                    }\r\n                    // case 4: right nephew black, left nephew red\r\n                    brother_node.color = current_node.parent.color;\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    brother_node.left.color = RB_TREE_COLOR_BLACK;\r\n                    this.rotate_right(current_node.parent);\r\n                    current_node = this.root;                               // force exit from loop\r\n                }\r\n            }\r\n        }\r\n\r\n        current_node.color = RB_TREE_COLOR_BLACK;\r\n    }\r\n\r\n    tree_search(node, search_node) {\r\n        if (node == null || node == this.nil_node)\r\n            return undefined;\r\n\r\n        if (search_node.equal_to(node)) {\r\n            return node;\r\n        }\r\n        if (search_node.less_than(node)) {\r\n            return this.tree_search(node.left, search_node);\r\n        }\r\n        else {\r\n            return this.tree_search(node.right, search_node);\r\n        }\r\n    }\r\n\r\n    // Original search_interval method; container res support push() insertion\r\n    // Search all intervals intersecting given one\r\n    tree_search_interval(node, search_node, res) {\r\n        if (node != null && node != this.nil_node) {\r\n            // if (node->left != this.nil_node && node->left->max >= low) {\r\n            if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) {\r\n                this.tree_search_interval(node.left, search_node, res);\r\n            }\r\n            // if (low <= node->high && node->low <= high) {\r\n            if (node.intersect(search_node)) {\r\n                res.push(node);\r\n            }\r\n            // if (node->right != this.nil_node && node->low <= high) {\r\n            if (node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) {\r\n                this.tree_search_interval(node.right, search_node, res);\r\n            }\r\n        }\r\n    }\r\n\r\n    tree_find_any_interval(node, search_node) {\r\n        let found = false;\r\n        if (node != null && node != this.nil_node) {\r\n            // if (node->left != this.nil_node && node->left->max >= low) {\r\n            if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) {\r\n                found = this.tree_find_any_interval(node.left, search_node);\r\n            }\r\n            // if (low <= node->high && node->low <= high) {\r\n            if (!found) {\r\n                found = node.intersect(search_node);\r\n            }\r\n            // if (node->right != this.nil_node && node->low <= high) {\r\n            if (!found && node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) {\r\n                found = this.tree_find_any_interval(node.right, search_node);\r\n            }\r\n        }\r\n        return found;\r\n    }\r\n\r\n    local_minimum(node) {\r\n        let node_min = node;\r\n        while (node_min.left != null && node_min.left != this.nil_node) {\r\n            node_min = node_min.left;\r\n        }\r\n        return node_min;\r\n    }\r\n\r\n    // not in use\r\n    local_maximum(node) {\r\n        let node_max = node;\r\n        while (node_max.right != null && node_max.right != this.nil_node) {\r\n            node_max = node_max.right;\r\n        }\r\n        return node_max;\r\n    }\r\n\r\n    tree_successor(node) {\r\n        let node_successor;\r\n        let current_node;\r\n        let parent_node;\r\n\r\n        if (node.right != this.nil_node) {\r\n            node_successor = this.local_minimum(node.right);\r\n        }\r\n        else {\r\n            current_node = node;\r\n            parent_node = node.parent;\r\n            while (parent_node != null && parent_node.right == current_node) {\r\n                current_node = parent_node;\r\n                parent_node = parent_node.parent;\r\n            }\r\n            node_successor = parent_node;\r\n        }\r\n        return node_successor;\r\n    }\r\n\r\n    //           |            right-rotate(T,y)       |\r\n    //           y            ---------------.       x\r\n    //          / \\                                  / \\\r\n    //         x   c          left-rotate(T,x)      a   y\r\n    //        / \\             <---------------         / \\\r\n    //       a   b                                    b   c\r\n\r\n    rotate_left(x) {\r\n        let y = x.right;\r\n\r\n        x.right = y.left;           // b goes to x.right\r\n\r\n        if (y.left != this.nil_node) {\r\n            y.left.parent = x;     // x becomes parent of b\r\n        }\r\n        y.parent = x.parent;       // move parent\r\n\r\n        if (x == this.root) {\r\n            this.root = y;           // y becomes root\r\n        }\r\n        else {                        // y becomes child of x.parent\r\n            if (x == x.parent.left) {\r\n                x.parent.left = y;\r\n            }\r\n            else {\r\n                x.parent.right = y;\r\n            }\r\n        }\r\n        y.left = x;                 // x becomes left child of y\r\n        x.parent = y;               // and y becomes parent of x\r\n\r\n        if (x != null && x != this.nil_node) {\r\n            x.update_max();\r\n        }\r\n\r\n        y = x.parent;\r\n        if (y != null && y != this.nil_node) {\r\n            y.update_max();\r\n        }\r\n    }\r\n\r\n    rotate_right(y) {\r\n        let x = y.left;\r\n\r\n        y.left = x.right;           // b goes to y.left\r\n\r\n        if (x.right != this.nil_node) {\r\n            x.right.parent = y;        // y becomes parent of b\r\n        }\r\n        x.parent = y.parent;          // move parent\r\n\r\n        if (y == this.root) {        // x becomes root\r\n            this.root = x;\r\n        }\r\n        else {                        // y becomes child of x.parent\r\n            if (y == y.parent.left) {\r\n                y.parent.left = x;\r\n            }\r\n            else {\r\n                y.parent.right = x;\r\n            }\r\n        }\r\n        x.right = y;                 // y becomes right child of x\r\n        y.parent = x;               // and x becomes parent of y\r\n\r\n        if (y != null && y != this.nil_node) {\r\n            y.update_max();\r\n        }\r\n\r\n        x = y.parent;\r\n        if (x != null && x != this.nil_node) {\r\n            x.update_max();\r\n        }\r\n    }\r\n\r\n    tree_walk(node, action) {\r\n        if (node != null && node != this.nil_node) {\r\n            this.tree_walk(node.left, action);\r\n            // arr.push(node.toArray());\r\n            action(node);\r\n            this.tree_walk(node.right, action);\r\n        }\r\n    }\r\n\r\n    /* Return true if all red nodes have exactly two black child nodes */\r\n    testRedBlackProperty() {\r\n        let res = true;\r\n        this.tree_walk(this.root, function (node) {\r\n            if (node.color == RB_TREE_COLOR_RED) {\r\n                if (!(node.left.color == RB_TREE_COLOR_BLACK && node.right.color == RB_TREE_COLOR_BLACK)) {\r\n                    res = false;\r\n                }\r\n            }\r\n        });\r\n        return res;\r\n    }\r\n\r\n    /* Throw error if not every path from root to bottom has same black height */\r\n    testBlackHeightProperty(node) {\r\n        let height = 0;\r\n        let heightLeft = 0;\r\n        let heightRight = 0;\r\n        if (node.color == RB_TREE_COLOR_BLACK) {\r\n            height++;\r\n        }\r\n        if (node.left != this.nil_node) {\r\n            heightLeft = this.testBlackHeightProperty(node.left);\r\n        }\r\n        else {\r\n            heightLeft = 1;\r\n        }\r\n        if (node.right != this.nil_node) {\r\n            heightRight = this.testBlackHeightProperty(node.right);\r\n        }\r\n        else {\r\n            heightRight = 1;\r\n        }\r\n        if (heightLeft != heightRight) {\r\n            throw new Error('Red-black height property violated');\r\n        }\r\n        height += heightLeft;\r\n        return height;\r\n    };\r\n}\r\n\r\n/**\r\n * Created by Alex Bol on 3/12/2017.\r\n */\r\n\r\n/**\r\n * Class representing a planar set - a generic container with ability to keep and retrieve shapes and\r\n * perform spatial queries. Planar set is an extension of Set container, so it supports\r\n * Set properties and methods\r\n */\r\nclass PlanarSet extends Set {\r\n    /**\r\n     * Create new instance of PlanarSet\r\n     * @param shapes - array or set of geometric objects to store in planar set\r\n     * Each object should have a <b>box</b> property\r\n     */\r\n    constructor(shapes) {\r\n        super(shapes);\r\n        this.index = new IntervalTree();\r\n        this.forEach(shape => this.index.insert(shape));\r\n    }\r\n\r\n    /**\r\n     * Add new shape to planar set and to its spatial index.<br/>\r\n     * If shape already exist, it will not be added again.\r\n     * This happens with no error, it is possible to use <i>size</i> property to check if\r\n     * a shape was actually added.<br/>\r\n     * Method returns planar set object updated and may be chained\r\n     * @param {Shape} shape - shape to be added, should have valid <i>box</i> property\r\n     * @returns {PlanarSet}\r\n     */\r\n    add(shape) {\r\n        let size = this.size;\r\n        super.add(shape);\r\n        // size not changed - item not added, probably trying to add same item twice\r\n        if (this.size > size) {\r\n            let node = this.index.insert(shape.box, shape);\r\n        }\r\n        return this;         // in accordance to Set.add interface\r\n    }\r\n\r\n    /**\r\n     * Delete shape from planar set. Returns true if shape was actually deleted, false otherwise\r\n     * @param {Shape} shape - shape to be deleted\r\n     * @returns {boolean}\r\n     */\r\n    delete(shape) {\r\n        let deleted = super.delete(shape);\r\n        if (deleted) {\r\n            this.index.remove(shape.box, shape);\r\n        }\r\n        return deleted;\r\n    }\r\n\r\n    /**\r\n     * Clear planar set\r\n     */\r\n    clear() {\r\n        super.clear();\r\n        this.index = new IntervalTree();\r\n    }\r\n\r\n    /**\r\n     * 2d range search in planar set.<br/>\r\n     * Returns array of all shapes in planar set which bounding box is intersected with query box\r\n     * @param {Box} box - query box\r\n     * @returns {Shapes[]}\r\n     */\r\n    search(box) {\r\n        let resp = this.index.search(box);\r\n        return resp;\r\n    }\r\n\r\n    /**\r\n     * Point location test. Returns array of shapes which contains given point\r\n     * @param {Point} point - query point\r\n     * @returns {Array}\r\n     */\r\n    hit(point) {\r\n        let box = new Flatten.Box(point.x - 1, point.y - 1, point.x + 1, point.y + 1);\r\n        let resp = this.index.search(box);\r\n        return resp.filter((shape) => point.on(shape));\r\n    }\r\n\r\n    /**\r\n     * Returns svg string to draw all shapes in planar set\r\n     * @returns {String}\r\n     */\r\n    svg() {\r\n        let svgcontent = [...this].reduce((acc, shape) => acc + shape.svg(), \"\");\r\n        return svgcontent;\r\n    }\r\n}\r\n\r\nFlatten.PlanarSet = PlanarSet;\r\n\r\n/**\r\n * Created by Alex Bol on 2/18/2017.\r\n */\r\n\r\n/**\r\n *\r\n * Class representing a point\r\n * @type {Point}\r\n */\r\nclass Point {\r\n    /**\r\n     * Point may be constructed by two numbers, or by array of two numbers\r\n     * @param {number} x - x-coordinate (float number)\r\n     * @param {number} y - y-coordinate (float number)\r\n     */\r\n    constructor(...args) {\r\n        /**\r\n         * x-coordinate (float number)\r\n         * @type {number}\r\n         */\r\n        this.x = 0;\r\n        /**\r\n         * y-coordinate (float number)\r\n         * @type {number}\r\n         */\r\n        this.y = 0;\r\n\r\n        if (args.length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (args.length === 1 && args[0] instanceof Array && args[0].length === 2) {\r\n            let arr = args[0];\r\n            if (typeof (arr[0]) == \"number\" && typeof (arr[1]) == \"number\") {\r\n                this.x = arr[0];\r\n                this.y = arr[1];\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"point\") {\r\n            let {x, y} = args[0];\r\n            this.x = x;\r\n            this.y = y;\r\n            return;\r\n        }\r\n\r\n        if (args.length === 2) {\r\n            if (typeof (args[0]) == \"number\" && typeof (args[1]) == \"number\") {\r\n                this.x = args[0];\r\n                this.y = args[1];\r\n                return;\r\n            }\r\n        }\r\n\r\n        throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n\r\n    }\r\n\r\n    /**\r\n     * Returns bounding box of a point\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        return new Flatten.Box(this.x, this.y, this.x, this.y);\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of point\r\n     * @returns {Point}\r\n     */\r\n    clone() {\r\n        return new Flatten.Point(this.x, this.y);\r\n    }\r\n\r\n    get vertices() {\r\n        return [this.clone()];\r\n    }\r\n\r\n    /**\r\n     * Returns true if points are equal up to [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\r\n     * @param {Point} pt Query point\r\n     * @returns {boolean}\r\n     */\r\n    equalTo(pt) {\r\n        return Flatten.Utils.EQ(this.x, pt.x) && Flatten.Utils.EQ(this.y, pt.y);\r\n    }\r\n\r\n    /**\r\n     * Defines predicate \"less than\" between points. Returns true if the point is less than query points, false otherwise <br/>\r\n     * By definition point1 < point2 if {point1.y < point2.y || point1.y == point2.y && point1.x < point2.x <br/>\r\n     * Numeric values compared with [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\r\n     * @param {Point} pt Query point\r\n     * @returns {boolean}\r\n     */\r\n    lessThan(pt) {\r\n        if (Flatten.Utils.LT(this.y, pt.y))\r\n            return true;\r\n        if (Flatten.Utils.EQ(this.y, pt.y) && Flatten.Utils.LT(this.x, pt.x))\r\n            return true;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns new point rotated by given angle around given center point.\r\n     * If center point is omitted, rotates around zero point (0,0).\r\n     * Positive value of angle defines rotation in counter clockwise direction,\r\n     * negative angle defines rotation in clockwise clockwise direction\r\n     * @param {number} angle - angle in radians\r\n     * @param {Point} [center=(0,0)] center\r\n     * @returns {Point}\r\n     */\r\n    rotate(angle, center = {x: 0, y: 0}) {\r\n        var x_rot = center.x + (this.x - center.x) * Math.cos(angle) - (this.y - center.y) * Math.sin(angle);\r\n        var y_rot = center.y + (this.x - center.x) * Math.sin(angle) + (this.y - center.y) * Math.cos(angle);\r\n\r\n        return new Flatten.Point(x_rot, y_rot);\r\n    }\r\n\r\n    /**\r\n     * Returns new point translated by given vector.\r\n     * Translation vector may by also defined by a pair of numbers.\r\n     * @param {Vector} vector - Translation vector defined as Flatten.Vector or\r\n     * @param {number|number} - Translation vector defined as pair of numbers\r\n     * @returns {Point}\r\n     */\r\n    translate(...args) {\r\n        if (args.length == 1 &&\r\n            (args[0] instanceof Flatten.Vector || !isNaN(args[0].x) && !isNaN(args[0].y))) {\r\n            return new Flatten.Point(this.x + args[0].x, this.y + args[0].y);\r\n        }\r\n\r\n        if (args.length == 2 && typeof (args[0]) == \"number\" && typeof (args[1]) == \"number\") {\r\n            return new Flatten.Point(this.x + args[0], this.y + args[1]);\r\n        }\r\n\r\n        throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n    }\r\n\r\n    /**\r\n     * Return new point transformed by affine transformation matrix m\r\n     * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\r\n     * @returns {Point}\r\n     */\r\n    transform(m) {\r\n        // let [x,y] = m.transform([this.x,this.y]);\r\n        return new Flatten.Point(m.transform([this.x, this.y]))\r\n    }\r\n\r\n    /**\r\n     * Returns projection point on given line\r\n     * @param {Line} line Line this point be projected on\r\n     * @returns {Point}\r\n     */\r\n    projectionOn(line) {\r\n        if (this.equalTo(line.pt))                   // this point equal to line anchor point\r\n            return this.clone();\r\n\r\n        let vec = new Flatten.Vector(this, line.pt);\r\n        if (Flatten.Utils.EQ_0(vec.cross(line.norm)))    // vector to point from anchor point collinear to normal vector\r\n            return line.pt.clone();\r\n\r\n        let dist = vec.dot(line.norm);             // signed distance\r\n        let proj_vec = line.norm.multiply(dist);\r\n        return this.translate(proj_vec);\r\n    }\r\n\r\n    /**\r\n     * Returns true if point belongs to the \"left\" semi-plane, which means, point belongs to the same semi plane where line normal vector points to\r\n     * Return false if point belongs to the \"right\" semi-plane or to the line itself\r\n     * @param {Line} line Query line\r\n     * @returns {boolean}\r\n     */\r\n    leftTo(line) {\r\n        let vec = new Flatten.Vector(line.pt, this);\r\n        let onLeftSemiPlane = Flatten.Utils.GT(vec.dot(line.norm), 0);\r\n        return onLeftSemiPlane;\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment from point to shape and return as array [distance, shortest segment]\r\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n     * @returns {number} distance from point to shape\r\n     * @returns {Segment} shortest segment between point and shape (started at point, ended at shape)\r\n     */\r\n    distanceTo(shape) {\r\n        if (shape instanceof Point) {\r\n            let dx = shape.x - this.x;\r\n            let dy = shape.y - this.y;\r\n            return [Math.sqrt(dx * dx + dy * dy), new Flatten.Segment(this, shape)];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Line) {\r\n            return Flatten.Distance.point2line(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            return Flatten.Distance.point2circle(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            return Flatten.Distance.point2segment(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            // let [dist, ...rest] = Distance.point2arc(this, shape);\r\n            // return dist;\r\n            return Flatten.Distance.point2arc(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            // let [dist, ...rest] = Distance.point2polygon(this, shape);\r\n            // return dist;\r\n            return Flatten.Distance.point2polygon(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.PlanarSet) {\r\n            return Flatten.Distance.shape2planarSet(this, shape);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if point is on a shape, false otherwise\r\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon\r\n     * @returns {boolean}\r\n     */\r\n    on(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            return this.equalTo(shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Line) {\r\n            return shape.contains(this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            return shape.contains(this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            return shape.contains(this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            return shape.contains(this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            return shape.contains(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method returns an object that defines how data will be\r\n     * serialized when called JSON.stringify() method\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n        return Object.assign({}, this, {name: \"point\"});\r\n    }\r\n\r\n    /**\r\n     * Return string to draw point in svg as circle with radius \"r\" <br/>\r\n     * Accept any valid attributes of svg elements as svg object\r\n     * Defaults attribues are: <br/>\r\n     * {\r\n     *    r:\"3\",\r\n     *    stroke:\"black\",\r\n     *    strokeWidth:\"1\",\r\n     *    fill:\"red\"\r\n     * }\r\n     * @param {Object} attrs - Any valid attributes of svg circle element, like \"r\", \"stroke\", \"strokeWidth\", \"fill\"\r\n     * @returns {String}\r\n     */\r\n    svg(attrs = {}) {\r\n        let {r, stroke, strokeWidth, fill, id, className} = attrs;\r\n        // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n        let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n        let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n        return `\\n<circle cx=\"${this.x}\" cy=\"${this.y}\" r=\"${r || 3}\" stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"red\"}\" ${id_str} ${class_str} />`;\r\n    }\r\n\r\n}\r\nFlatten.Point = Point;\r\n/**\r\n * Function to create point equivalent to \"new\" constructor\r\n * @param args\r\n */\r\nconst point = (...args) => new Flatten.Point(...args);\r\nFlatten.point = point;\r\n\r\n// export {Point};\r\n\r\n/**\r\n * Created by Alex Bol on 2/19/2017.\r\n */\r\n\r\n/**\r\n * Class representing a vector\r\n * @type {Vector}\r\n */\r\nclass Vector {\r\n    /**\r\n     * Vector may be constructed by two points, or by two float numbers,\r\n     * or by array of two numbers\r\n     * @param {Point} ps - start point\r\n     * @param {Point} pe - end point\r\n     */\r\n    constructor(...args) {\r\n        /**\r\n         * x-coordinate of a vector (float number)\r\n         * @type {number}\r\n         */\r\n        this.x = 0;\r\n        /**\r\n         * y-coordinate of a vector (float number)\r\n         * @type {number}\r\n         */\r\n        this.y = 0;\r\n\r\n        /* return zero vector */\r\n        if (args.length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (args.length === 1 && args[0] instanceof Array && args[0].length === 2) {\r\n            let arr = args[0];\r\n            if (typeof (arr[0]) == \"number\" && typeof (arr[1]) == \"number\") {\r\n                this.x = arr[0];\r\n                this.y = arr[1];\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"vector\") {\r\n            let {x, y} = args[0];\r\n            this.x = x;\r\n            this.y = y;\r\n            return;\r\n        }\r\n\r\n        if (args.length === 2) {\r\n            let a1 = args[0];\r\n            let a2 = args[1];\r\n\r\n            if (typeof (a1) == \"number\" && typeof (a2) == \"number\") {\r\n                this.x = a1;\r\n                this.y = a2;\r\n                return;\r\n            }\r\n\r\n            if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\r\n                this.x = a2.x - a1.x;\r\n                this.y = a2.y - a1.y;\r\n                return;\r\n            }\r\n\r\n        }\r\n\r\n        throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n    }\r\n\r\n    /**\r\n     * Method clone returns new instance of Vector\r\n     * @returns {Vector}\r\n     */\r\n    clone() {\r\n        return new Flatten.Vector(this.x, this.y);\r\n    }\r\n\r\n    /**\r\n     * Slope of the vector in radians from 0 to 2PI\r\n     * @returns {number}\r\n     */\r\n    get slope() {\r\n        let angle = Math.atan2(this.y, this.x);\r\n        if (angle < 0) angle = 2 * Math.PI + angle;\r\n        return angle;\r\n    }\r\n\r\n    /**\r\n     * Length of vector\r\n     * @returns {number}\r\n     */\r\n    get length() {\r\n        return Math.sqrt(this.dot(this));\r\n    }\r\n\r\n    /**\r\n     * Returns true if vectors are equal up to [DP_TOL]{@link http://localhost:63342/flatten-js/docs/global.html#DP_TOL}\r\n     * tolerance\r\n     * @param {Vector} v\r\n     * @returns {boolean}\r\n     */\r\n    equalTo(v) {\r\n        return Flatten.Utils.EQ(this.x, v.x) && Flatten.Utils.EQ(this.y, v.y);\r\n    }\r\n\r\n    /**\r\n     * Returns new vector multiplied by scalar\r\n     * @param {number} scalar\r\n     * @returns {Vector}\r\n     */\r\n    multiply(scalar) {\r\n        return (new Flatten.Vector(scalar * this.x, scalar * this.y));\r\n    }\r\n\r\n    /**\r\n     * Returns scalar product (dot product) of two vectors <br/>\r\n     * <code>dot_product = (this * v)</code>\r\n     * @param {Vector} v Other vector\r\n     * @returns {number}\r\n     */\r\n    dot(v) {\r\n        return (this.x * v.x + this.y * v.y);\r\n    }\r\n\r\n    /**\r\n     * Returns vector product (cross product) of two vectors <br/>\r\n     * <code>cross_product = (this x v)</code>\r\n     * @param {Vector} v Other vector\r\n     * @returns {number}\r\n     */\r\n    cross(v) {\r\n        return (this.x * v.y - this.y * v.x);\r\n    }\r\n\r\n    /**\r\n     * Returns unit vector.<br/>\r\n     * Throw error if given vector has zero length\r\n     * @returns {Vector}\r\n     */\r\n    normalize() {\r\n        if (!Flatten.Utils.EQ_0(this.length)) {\r\n            return (new Flatten.Vector(this.x / this.length, this.y / this.length));\r\n        }\r\n        throw Flatten.Errors.ZERO_DIVISION;\r\n    }\r\n\r\n    /**\r\n     * Returns new vector rotated by given angle,\r\n     * positive angle defines rotation in counter clockwise direction,\r\n     * negative - in clockwise direction\r\n     * @param {number} angle - Angle in radians\r\n     * @returns {Vector}\r\n     */\r\n    rotate(angle) {\r\n        let point = new Flatten.Point(this.x, this.y);\r\n        let rpoint = point.rotate(angle);\r\n        return new Flatten.Vector(rpoint.x, rpoint.y);\r\n    }\r\n\r\n    /**\r\n     * Returns vector rotated 90 degrees counter clockwise\r\n     * @returns {Vector}\r\n     */\r\n    rotate90CCW() {\r\n        return new Flatten.Vector(-this.y, this.x);\r\n    };\r\n\r\n    /**\r\n     * Returns vector rotated 90 degrees clockwise\r\n     * @returns {Vector}\r\n     */\r\n    rotate90CW() {\r\n        return new Flatten.Vector(this.y, -this.x);\r\n    };\r\n\r\n    /**\r\n     * Return inverted vector\r\n     * @returns {Vector}\r\n     */\r\n    invert() {\r\n        return new Flatten.Vector(-this.x, -this.y);\r\n    }\r\n\r\n    /**\r\n     * Return result of addition of other vector to this vector as a new vector\r\n     * @param {Vector} v Other vector\r\n     * @returns {Vector}\r\n     */\r\n    add(v) {\r\n        return new Flatten.Vector(this.x + v.x, this.y + v.y);\r\n    }\r\n\r\n    /**\r\n     * Return result of subtraction of other vector from current vector as a new vector\r\n     * @param {Vector} v Another vector\r\n     * @returns {Vector}\r\n     */\r\n    subtract(v) {\r\n        return new Flatten.Vector(this.x - v.x, this.y - v.y);\r\n    }\r\n\r\n    /**\r\n     * Return angle between this vector and other vector. <br/>\r\n     * Angle is measured from 0 to 2*PI in the counter clockwise direction\r\n     * from current vector to other.\r\n     * @param {Vector} v Another vector\r\n     * @returns {number}\r\n     */\r\n    angleTo(v) {\r\n        let norm1 = this.normalize();\r\n        let norm2 = v.normalize();\r\n        let angle = Math.atan2(norm1.cross(norm2), norm1.dot(norm2));\r\n        if (angle < 0) angle += 2 * Math.PI;\r\n        return angle;\r\n    }\r\n\r\n    /**\r\n     * Return vector projection of the current vector on another vector\r\n     * @param {Vector} v Another vector\r\n     * @returns {Vector}\r\n     */\r\n    projectionOn(v) {\r\n        let n = v.normalize();\r\n        let d = this.dot(n);\r\n        return n.multiply(d);\r\n    }\r\n\r\n    /**\r\n     * This method returns an object that defines how data will be\r\n     * serialized when called JSON.stringify() method\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n        return Object.assign({}, this, {name: \"vector\"});\r\n    }\r\n}\r\nFlatten.Vector = Vector;\r\n\r\n/**\r\n * Function to create vector equivalent to \"new\" constructor\r\n * @param args\r\n */\r\nconst vector = (...args) => new Flatten.Vector(...args);\r\nFlatten.vector = vector;\r\n\r\n/**\r\n * Created by Alex Bol on 3/10/2017.\r\n */\r\n\r\n/**\r\n * Class representing a segment\r\n * @type {Segment}\r\n */\r\nclass Segment {\r\n    /**\r\n     *\r\n     * @param {Point} ps - start point\r\n     * @param {Point} pe - end point\r\n     */\r\n    constructor(...args) {\r\n        /**\r\n         * Start point\r\n         * @type {Point}\r\n         */\r\n        this.ps = new Flatten.Point();\r\n        /**\r\n         * End Point\r\n         * @type {Point}\r\n         */\r\n        this.pe = new Flatten.Point();\r\n\r\n        if (args.length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (args.length === 1 && args[0] instanceof Array && args[0].length === 4) {\r\n            let coords = args[0];\r\n            this.ps = new Flatten.Point(coords[0], coords[1]);\r\n            this.pe = new Flatten.Point(coords[2], coords[3]);\r\n            return;\r\n        }\r\n\r\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"segment\") {\r\n            let {ps, pe} = args[0];\r\n            this.ps = new Flatten.Point(ps.x, ps.y);\r\n            this.pe = new Flatten.Point(pe.x, pe.y);\r\n            return;\r\n        }\r\n\r\n        // second point omitted issue #84\r\n        if (args.length === 1 && args[0] instanceof Flatten.Point) {\r\n            this.ps = args[0].clone();\r\n            return;\r\n        }\r\n\r\n        if (args.length === 2 && args[0] instanceof Flatten.Point && args[1] instanceof Flatten.Point) {\r\n            this.ps = args[0].clone();\r\n            this.pe = args[1].clone();\r\n            return;\r\n        }\r\n\r\n        if (args.length === 4) {\r\n            this.ps = new Flatten.Point(args[0], args[1]);\r\n            this.pe = new Flatten.Point(args[2], args[3]);\r\n            return;\r\n        }\r\n\r\n        throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of segment\r\n     * @returns {Segment}\r\n     */\r\n    clone() {\r\n        return new Flatten.Segment(this.start, this.end);\r\n    }\r\n\r\n    /**\r\n     * Start point\r\n     * @returns {Point}\r\n     */\r\n    get start() {\r\n        return this.ps;\r\n    }\r\n\r\n    /**\r\n     * End point\r\n     * @returns {Point}\r\n     */\r\n    get end() {\r\n        return this.pe;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns array of start and end point\r\n     * @returns [Point,Point]\r\n     */\r\n    get vertices() {\r\n        return [this.ps.clone(), this.pe.clone()];\r\n    }\r\n\r\n    /**\r\n     * Length of a segment\r\n     * @returns {number}\r\n     */\r\n    get length() {\r\n        return this.start.distanceTo(this.end)[0];\r\n    }\r\n\r\n    /**\r\n     * Slope of the line - angle to axe x in radians from 0 to 2PI\r\n     * @returns {number}\r\n     */\r\n    get slope() {\r\n        let vec = new Flatten.Vector(this.start, this.end);\r\n        return vec.slope;\r\n    }\r\n\r\n    /**\r\n     * Bounding box\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        return new Flatten.Box(\r\n            Math.min(this.start.x, this.end.x),\r\n            Math.min(this.start.y, this.end.y),\r\n            Math.max(this.start.x, this.end.x),\r\n            Math.max(this.start.y, this.end.y)\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Returns true if equals to query segment, false otherwise\r\n     * @param {Seg} seg - query segment\r\n     * @returns {boolean}\r\n     */\r\n    equalTo(seg) {\r\n        return this.ps.equalTo(seg.ps) && this.pe.equalTo(seg.pe);\r\n    }\r\n\r\n    /**\r\n     * Returns true if segment contains point\r\n     * @param {Point} pt Query point\r\n     * @returns {boolean}\r\n     */\r\n    contains(pt) {\r\n        return Flatten.Utils.EQ_0(this.distanceToPoint(pt));\r\n    }\r\n\r\n    /**\r\n     * Returns array of intersection points between segment and other shape\r\n     * @param {Shape} shape - Shape of the one of supported types <br/>\r\n     * @returns {Point[]}\r\n     */\r\n    intersect(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            return this.contains(shape) ? [shape] : [];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Line) {\r\n            return intersectSegment2Line(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            return  intersectSegment2Segment(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            return intersectSegment2Circle(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Box) {\r\n            return intersectSegment2Box(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            return intersectSegment2Arc(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            return  intersectSegment2Polygon(this, shape);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment from segment to shape and return as array [distance, shortest segment]\r\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n     * @returns {number} distance from segment to shape\r\n     * @returns {Segment} shortest segment between segment and shape (started at segment, ended at shape)\r\n     */\r\n    distanceTo(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            let [dist, shortest_segment] = Flatten.Distance.point2segment(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            let [dist, shortest_segment] = Flatten.Distance.segment2circle(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Line) {\r\n            let [dist, shortest_segment] = Flatten.Distance.segment2line(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            let [dist, shortest_segment] = Flatten.Distance.segment2segment(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            let [dist, shortest_segment] = Flatten.Distance.segment2arc(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            let [dist, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.PlanarSet) {\r\n            let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns unit vector in the direction from start to end\r\n     * @returns {Vector}\r\n     */\r\n    tangentInStart() {\r\n        let vec = new Flatten.Vector(this.start, this.end);\r\n        return vec.normalize();\r\n    }\r\n\r\n    /**\r\n     * Return unit vector in the direction from end to start\r\n     * @returns {Vector}\r\n     */\r\n    tangentInEnd() {\r\n        let vec = new Flatten.Vector(this.end, this.start);\r\n        return vec.normalize();\r\n    }\r\n\r\n    /**\r\n     * Returns new segment with swapped start and end points\r\n     * @returns {Segment}\r\n     */\r\n    reverse() {\r\n        return new Segment(this.end, this.start);\r\n    }\r\n\r\n    /**\r\n     * When point belongs to segment, return array of two segments split by given point,\r\n     * if point is inside segment. Returns clone of this segment if query point is incident\r\n     * to start or end point of the segment. Returns empty array if point does not belong to segment\r\n     * @param {Point} pt Query point\r\n     * @returns {Segment[]}\r\n     */\r\n    split(pt) {\r\n        if (this.start.equalTo(pt))\r\n            return [null, this.clone()];\r\n\r\n        if (this.end.equalTo(pt))\r\n            return [this.clone(), null];\r\n\r\n        return [\r\n            new Flatten.Segment(this.start, pt),\r\n            new Flatten.Segment(pt, this.end)\r\n        ]\r\n    }\r\n\r\n    /**\r\n     * Return middle point of the segment\r\n     * @returns {Point}\r\n     */\r\n    middle() {\r\n        return new Flatten.Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);\r\n    }\r\n\r\n    /**\r\n     * Get point at given length\r\n     * @param {number} length - The length along the segment\r\n     * @returns {Point}\r\n     */\r\n    pointAtLength(length) {\r\n        if (length > this.length || length < 0) return null;\r\n        if (length == 0) return this.start;\r\n        if (length == this.length) return this.end;\r\n        let factor = length / this.length;\r\n        return new Flatten.Point(\r\n            (this.end.x - this.start.x) * factor + this.start.x,\r\n            (this.end.y - this.start.y) * factor + this.start.y\r\n        );\r\n    }\r\n\r\n    distanceToPoint(pt) {\r\n        let [dist, ...rest] = Flatten.Distance.point2segment(pt, this);\r\n        return dist;\r\n    };\r\n\r\n    definiteIntegral(ymin = 0.0) {\r\n        let dx = this.end.x - this.start.x;\r\n        let dy1 = this.start.y - ymin;\r\n        let dy2 = this.end.y - ymin;\r\n        return (dx * (dy1 + dy2) / 2);\r\n    }\r\n\r\n    /**\r\n     * Returns new segment translated by vector vec\r\n     * @param {Vector} vec\r\n     * @returns {Segment}\r\n     */\r\n    translate(...args) {\r\n        return new Segment(this.ps.translate(...args), this.pe.translate(...args));\r\n    }\r\n\r\n    /**\r\n     * Return new segment rotated by given angle around given point\r\n     * If point omitted, rotate around origin (0,0)\r\n     * Positive value of angle defines rotation counter clockwise, negative - clockwise\r\n     * @param {number} angle - rotation angle in radians\r\n     * @param {Point} center - center point, default is (0,0)\r\n     * @returns {Segment}\r\n     */\r\n    rotate(angle = 0, center = new Flatten.Point()) {\r\n        let m = new Flatten.Matrix();\r\n        m = m.translate(center.x, center.y).rotate(angle).translate(-center.x, -center.y);\r\n        return this.transform(m);\r\n    }\r\n\r\n    /**\r\n     * Return new segment transformed using affine transformation matrix\r\n     * @param {Matrix} matrix - affine transformation matrix\r\n     * @returns {Segment} - transformed segment\r\n     */\r\n    transform(matrix = new Flatten.Matrix()) {\r\n        return new Segment(this.ps.transform(matrix), this.pe.transform(matrix))\r\n    }\r\n\r\n    /**\r\n     * Returns true if segment start is equal to segment end up to DP_TOL\r\n     * @returns {boolean}\r\n     */\r\n    isZeroLength() {\r\n        return this.ps.equalTo(this.pe)\r\n    }\r\n\r\n    /**\r\n     * Sort given array of points from segment start to end, assuming all points lay on the segment\r\n     * @param {Point[]} - array of points\r\n     * @returns {Point[]} new array sorted\r\n     */\r\n    sortPoints(pts) {\r\n        let line = new Flatten.Line(this.start, this.end);\r\n        return line.sortPoints(pts);\r\n    }\r\n\r\n    /**\r\n     * This method returns an object that defines how data will be\r\n     * serialized when called JSON.stringify() method\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n        return Object.assign({}, this, {name: \"segment\"});\r\n    }\r\n\r\n    /**\r\n     * Return string to draw segment in svg\r\n     * @param {Object} attrs - an object with attributes for svg path element,\r\n     * like \"stroke\", \"strokeWidth\" <br/>\r\n     * Defaults are stroke:\"black\", strokeWidth:\"1\"\r\n     * @returns {string}\r\n     */\r\n    svg(attrs = {}) {\r\n        let {stroke, strokeWidth, id, className} = attrs;\r\n        // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n        let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n        let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n\r\n        return `\\n<line x1=\"${this.start.x}\" y1=\"${this.start.y}\" x2=\"${this.end.x}\" y2=\"${this.end.y}\" stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" ${id_str} ${class_str} />`;\r\n\r\n    }\r\n\r\n}\r\nFlatten.Segment = Segment;\r\n/**\r\n * Shortcut method to create new segment\r\n */\r\nconst segment = (...args) => new Flatten.Segment(...args);\r\nFlatten.segment = segment;\r\n\r\n/**\r\n * Created by Alex Bol on 2/20/2017.\r\n */\r\n\r\nlet {vector: vector$1} = Flatten;\r\n\r\n/**\r\n * Class representing a line\r\n * @type {Line}\r\n */\r\nclass Line {\r\n    /**\r\n     * Line may be constructed by point and normal vector or by two points that a line passes through\r\n     * @param {Point} pt - point that a line passes through\r\n     * @param {Vector|Point} norm - normal vector to a line or second point a line passes through\r\n     */\r\n    constructor(...args) {\r\n        /**\r\n         * Point a line passes through\r\n         * @type {Point}\r\n         */\r\n        this.pt = new Flatten.Point();\r\n        /**\r\n         * Normal vector to a line <br/>\r\n         * Vector is normalized (length == 1)<br/>\r\n         * Direction of the vector is chosen to satisfy inequality norm * p >= 0\r\n         * @type {Vector}\r\n         */\r\n        this.norm = new Flatten.Vector(0, 1);\r\n\r\n        if (args.length == 0) {\r\n            return;\r\n        }\r\n\r\n        if (args.length == 1 && args[0] instanceof Object && args[0].name === \"line\") {\r\n            let {pt, norm} = args[0];\r\n            this.pt = new Flatten.Point(pt);\r\n            this.norm = new Flatten.Vector(norm);\r\n            return;\r\n        }\r\n\r\n        if (args.length == 2) {\r\n            let a1 = args[0];\r\n            let a2 = args[1];\r\n\r\n            if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\r\n                this.pt = a1;\r\n                this.norm = Line.points2norm(a1, a2);\r\n                if (this.norm.dot(vector$1(this.pt.x,this.pt.y)) >= 0) {\r\n                    this.norm.invert();\r\n                }\r\n                return;\r\n            }\r\n\r\n            if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Vector) {\r\n                if (Flatten.Utils.EQ_0(a2.x) && Flatten.Utils.EQ_0(a2.y)) {\r\n                    throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n                }\r\n                this.pt = a1.clone();\r\n                this.norm = a2.clone();\r\n                this.norm = this.norm.normalize();\r\n                if (this.norm.dot(vector$1(this.pt.x,this.pt.y)) >= 0) {\r\n                    this.norm.invert();\r\n                }\r\n                return;\r\n            }\r\n\r\n            if (a1 instanceof Flatten.Vector && a2 instanceof Flatten.Point) {\r\n                if (Flatten.Utils.EQ_0(a1.x) && Flatten.Utils.EQ_0(a1.y)) {\r\n                    throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n                }\r\n                this.pt = a2.clone();\r\n                this.norm = a1.clone();\r\n                this.norm = this.norm.normalize();\r\n                if (this.norm.dot(vector$1(this.pt.x,this.pt.y)) >= 0) {\r\n                    this.norm.invert();\r\n                }\r\n                return;\r\n            }\r\n        }\r\n\r\n        throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of line\r\n     * @returns {Line}\r\n     */\r\n    clone() {\r\n        return new Flatten.Line(this.pt, this.norm);\r\n    }\r\n\r\n    /* The following methods need for implementation of Edge interface\r\n    /**\r\n     * Line has no start point\r\n     * @returns {undefined}\r\n     */\r\n    get start() {return undefined;}\r\n\r\n    /**\r\n     * Line has no end point\r\n     */\r\n    get end() {return undefined;}\r\n\r\n    /**\r\n     * Return positive infinity number as length\r\n     * @returns {number}\r\n     */\r\n    get length() {return Number.POSITIVE_INFINITY;}\r\n\r\n    /**\r\n     * Returns infinite box\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        return new Flatten.Box(\r\n            Number.NEGATIVE_INFINITY,\r\n            Number.NEGATIVE_INFINITY,\r\n            Number.POSITIVE_INFINITY,\r\n            Number.POSITIVE_INFINITY\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Middle point is undefined\r\n     * @returns {undefined}\r\n     */\r\n    get middle() {return undefined}\r\n\r\n    /**\r\n     * Slope of the line - angle in radians between line and axe x from 0 to 2PI\r\n     * @returns {number} - slope of the line\r\n     */\r\n    get slope() {\r\n        let vec = new Flatten.Vector(this.norm.y, -this.norm.x);\r\n        return vec.slope;\r\n    }\r\n\r\n    /**\r\n     * Get coefficients [A,B,C] of a standard line equation in the form Ax + By = C\r\n     * @code [A, B, C] = line.standard\r\n     * @returns {number[]} - array of coefficients\r\n     */\r\n    get standard() {\r\n        let A = this.norm.x;\r\n        let B = this.norm.y;\r\n        let C = this.norm.dot(this.pt);\r\n\r\n        return [A, B, C];\r\n    }\r\n\r\n    /**\r\n     * Return true if parallel or incident to other line\r\n     * @param {Line} other_line - line to check\r\n     * @returns {boolean}\r\n     */\r\n    parallelTo(other_line) {\r\n        return Flatten.Utils.EQ_0(this.norm.cross(other_line.norm));\r\n    }\r\n\r\n    /**\r\n     * Returns true if incident to other line\r\n     * @param {Line} other_line - line to check\r\n     * @returns {boolean}\r\n     */\r\n    incidentTo(other_line) {\r\n        return this.parallelTo(other_line) && this.pt.on(other_line);\r\n    }\r\n\r\n    /**\r\n     * Returns true if point belongs to line\r\n     * @param {Point} pt Query point\r\n     * @returns {boolean}\r\n     */\r\n    contains(pt) {\r\n        if (this.pt.equalTo(pt)) {\r\n            return true;\r\n        }\r\n        /* Line contains point if vector to point is orthogonal to the line normal vector */\r\n        let vec = new Flatten.Vector(this.pt, pt);\r\n        return Flatten.Utils.EQ_0(this.norm.dot(vec));\r\n    }\r\n\r\n    /**\r\n     * Return coordinate of the point that lays on the line in the transformed\r\n     * coordinate system where center is the projection of the point(0,0) to\r\n     * the line and axe y is collinear to the normal vector. <br/>\r\n     * This method assumes that point lays on the line and does not check it\r\n     * @param {Point} pt - point on line\r\n     * @returns {number}\r\n     */\r\n    coord(pt) {\r\n        return vector$1(pt.x, pt.y).cross(this.norm);\r\n    }\r\n\r\n    /**\r\n     * Returns array of intersection points\r\n     * @param {Shape} shape - shape to intersect with\r\n     * @returns {Point[]}\r\n     */\r\n    intersect(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            return this.contains(shape) ? [shape] : [];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Line) {\r\n            return intersectLine2Line(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            return intersectLine2Circle(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Box) {\r\n            return intersectLine2Box(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            return intersectSegment2Line(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            return intersectLine2Arc(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            return  intersectLine2Polygon(this, shape);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment from line to shape and returns array [distance, shortest_segment]\r\n     * @param {Shape} shape Shape of the one of the types Point, Circle, Segment, Arc, Polygon\r\n     * @returns {Number}\r\n     * @returns {Segment}\r\n     */\r\n    distanceTo(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            let [distance, shortest_segment] = Flatten.Distance.point2line(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [distance, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            let [distance, shortest_segment] = Flatten.Distance.circle2line(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [distance, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            let [distance, shortest_segment] = Flatten.Distance.segment2line(shape, this);\r\n            return [distance, shortest_segment.reverse()];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            let [distance, shortest_segment] = Flatten.Distance.arc2line(shape, this);\r\n            return [distance, shortest_segment.reverse()];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            let [distance, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\r\n            return [distance, shortest_segment];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Split line with array of points and return array of shapes\r\n     * Assumed that all points lay on the line\r\n     * @param {Point[]}\r\n     * @returns {Shape[]}\r\n     */\r\n    split(pt) {\r\n        if (pt instanceof Flatten.Point) {\r\n            return [new Flatten.Ray(pt, this.norm.invert()), new Flatten.Ray(pt, this.norm)]\r\n        }\r\n        else {\r\n            let multiline = new Flatten.Multiline([this]);\r\n            let sorted_points = this.sortPoints(pt);\r\n            multiline.split(sorted_points);\r\n            return multiline.toShapes();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sort given array of points that lay on line with respect to coordinate on a line\r\n     * The method assumes that points lay on the line and does not check this\r\n     * @param {Point[]} pts - array of points\r\n     * @returns {Point[]} new array sorted\r\n     */\r\n    sortPoints(pts) {\r\n        return pts.slice().sort( (pt1, pt2) => {\r\n            if (this.coord(pt1) < this.coord(pt2)) {\r\n                return -1;\r\n            }\r\n            if (this.coord(pt1) > this.coord(pt2)) {\r\n                return 1;\r\n            }\r\n            return 0;\r\n        })\r\n    }\r\n\r\n    /**\r\n     * This method returns an object that defines how data will be\r\n     * serialized when called JSON.stringify() method\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n        return Object.assign({}, this, {name: \"line\"});\r\n    }\r\n\r\n    /**\r\n     * Return string to draw svg segment representing line inside given box\r\n     * @param {Box} box Box representing drawing area\r\n     * @param {Object} attrs - an object with attributes of svg circle element\r\n     */\r\n    svg(box, attrs = {}) {\r\n        let ip = intersectLine2Box(this, box);\r\n        if (ip.length === 0)\r\n            return \"\";\r\n        let ps = ip[0];\r\n        let pe = ip.length == 2 ? ip[1] : ip.find(pt => !pt.equalTo(ps));\r\n        if (pe === undefined) pe = ps;\r\n        let segment = new Flatten.Segment(ps, pe);\r\n        return segment.svg(attrs);\r\n    }\r\n\r\n    static points2norm(pt1, pt2) {\r\n        if (pt1.equalTo(pt2)) {\r\n            throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n        }\r\n        let vec = new Flatten.Vector(pt1, pt2);\r\n        let unit = vec.normalize();\r\n        return unit.rotate90CCW();\r\n    }\r\n}\r\nFlatten.Line = Line;\r\n/**\r\n * Function to create line equivalent to \"new\" constructor\r\n * @param args\r\n */\r\nconst line = (...args) => new Flatten.Line(...args);\r\nFlatten.line = line;\r\n\r\n/**\r\n * Created by Alex Bol on 3/6/2017.\r\n */\r\n\r\n/**\r\n * Class representing a circle\r\n * @type {Circle}\r\n */\r\nclass Circle {\r\n    /**\r\n     *\r\n     * @param {Point} pc - circle center point\r\n     * @param {number} r - circle radius\r\n     */\r\n    constructor(...args) {\r\n        /**\r\n         * Circle center\r\n         * @type {Point}\r\n         */\r\n        this.pc = new Flatten.Point();\r\n        /**\r\n         * Circle radius\r\n         * @type {number}\r\n         */\r\n        this.r = 1;\r\n\r\n        if (args.length == 1 && args[0] instanceof Object && args[0].name === \"circle\") {\r\n            let {pc, r} = args[0];\r\n            this.pc = new Flatten.Point(pc);\r\n            this.r = r;\r\n            return;\r\n        } else {\r\n            let [pc, r] = [...args];\r\n            if (pc && pc instanceof Flatten.Point) this.pc = pc.clone();\r\n            if (r !== undefined) this.r = r;\r\n            return;\r\n        }\r\n\r\n        throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of circle\r\n     * @returns {Circle}\r\n     */\r\n    clone() {\r\n        return new Flatten.Circle(this.pc.clone(), this.r);\r\n    }\r\n\r\n    /**\r\n     * Circle center\r\n     * @returns {Point}\r\n     */\r\n    get center() {\r\n        return this.pc;\r\n    }\r\n\r\n    /**\r\n     * Circle bounding box\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        return new Flatten.Box(\r\n            this.pc.x - this.r,\r\n            this.pc.y - this.r,\r\n            this.pc.x + this.r,\r\n            this.pc.y + this.r\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Return true if circle contains shape: no point of shape lies outside of the circle\r\n     * @param {Shape} shape - test shape\r\n     * @returns {boolean}\r\n     */\r\n    contains(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            return Flatten.Utils.LE(shape.distanceTo(this.center)[0], this.r);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            return Flatten.Utils.LE(shape.start.distanceTo(this.center)[0], this.r) &&\r\n                Flatten.Utils.LE(shape.end.distanceTo(this.center)[0], this.r);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            return this.intersect(shape).length === 0 &&\r\n                Flatten.Utils.LE(shape.start.distanceTo(this.center)[0], this.r) &&\r\n                Flatten.Utils.LE(shape.end.distanceTo(this.center)[0], this.r);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            return this.intersect(shape).length === 0 &&\r\n                Flatten.Utils.LE(shape.r, this.r) &&\r\n                Flatten.Utils.LE(shape.center.distanceTo(this.center)[0], this.r);\r\n        }\r\n\r\n        /* TODO: box, polygon */\r\n    }\r\n\r\n    /**\r\n     * Transform circle to closed arc\r\n     * @param {boolean} counterclockwise\r\n     * @returns {Arc}\r\n     */\r\n    toArc(counterclockwise = true) {\r\n        return new Flatten.Arc(this.center, this.r, Math.PI, -Math.PI, counterclockwise);\r\n    }\r\n\r\n    /**\r\n     * Returns array of intersection points between circle and other shape\r\n     * @param {Shape} shape Shape of the one of supported types\r\n     * @returns {Point[]}\r\n     */\r\n    intersect(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            return this.contains(shape) ? [shape] : [];\r\n        }\r\n        if (shape instanceof Flatten.Line) {\r\n            return intersectLine2Circle(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            return intersectSegment2Circle(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            return intersectCircle2Circle(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Box) {\r\n            return intersectCircle2Box(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            return intersectArc2Circle(shape, this);\r\n        }\r\n        if (shape instanceof Flatten.Polygon) {\r\n            return intersectCircle2Polygon(this, shape);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment from circle to shape and return array [distance, shortest segment]\r\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n     * @returns {number} distance from circle to shape\r\n     * @returns {Segment} shortest segment between circle and shape (started at circle, ended at shape)\r\n\r\n     */\r\n    distanceTo(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            let [distance, shortest_segment] = Flatten.Distance.point2circle(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [distance, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            let [distance, shortest_segment] = Flatten.Distance.circle2circle(this, shape);\r\n            return [distance, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Line) {\r\n            let [distance, shortest_segment] = Flatten.Distance.circle2line(this, shape);\r\n            return [distance, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            let [distance, shortest_segment] = Flatten.Distance.segment2circle(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [distance, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            let [distance, shortest_segment] = Flatten.Distance.arc2circle(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [distance, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            let [distance, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\r\n            return [distance, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.PlanarSet) {\r\n            let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method returns an object that defines how data will be\r\n     * serialized when called JSON.stringify() method\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n        return Object.assign({}, this, {name: \"circle\"});\r\n    }\r\n\r\n    /**\r\n     * Return string to draw circle in svg\r\n     * @param {Object} attrs - an object with attributes of svg circle element,\r\n     * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\r\n     * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\r\n     * @returns {string}\r\n     */\r\n    svg(attrs = {}) {\r\n        let {stroke, strokeWidth, fill, fillOpacity, id, className} = attrs;\r\n        // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n        let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n        let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n\r\n        return `\\n<circle cx=\"${this.pc.x}\" cy=\"${this.pc.y}\" r=\"${this.r}\" stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"none\"}\" fill-opacity=\"${fillOpacity || 1.0}\" ${id_str} ${class_str} />`;\r\n    }\r\n\r\n}\r\nFlatten.Circle = Circle;\r\n/**\r\n * Shortcut to create new circle\r\n * @param args\r\n */\r\nconst circle = (...args) => new Flatten.Circle(...args);\r\nFlatten.circle = circle;\r\n\r\n/**\r\n * Created by Alex Bol on 3/10/2017.\r\n */\r\n\r\n/**\r\n * Class representing a circular arc\r\n * @type {Arc}\r\n */\r\nclass Arc {\r\n    /**\r\n     *\r\n     * @param {Point} pc - arc center\r\n     * @param {number} r - arc radius\r\n     * @param {number} startAngle - start angle in radians from 0 to 2*PI\r\n     * @param {number} endAngle - end angle in radians from 0 to 2*PI\r\n     * @param {boolean} counterClockwise - arc direction, true - clockwise, false - counter clockwise\r\n     */\r\n    constructor(...args) {\r\n        /**\r\n         * Arc center\r\n         * @type {Point}\r\n         */\r\n        this.pc = new Flatten.Point();\r\n        /**\r\n         * Arc radius\r\n         * @type {number}\r\n         */\r\n        this.r = 1;\r\n        /**\r\n         * Arc start angle in radians\r\n         * @type {number}\r\n         */\r\n        this.startAngle = 0;\r\n        /**\r\n         * Arc end angle in radians\r\n         * @type {number}\r\n         */\r\n        this.endAngle = 2 * Math.PI;\r\n        /**\r\n         * Arc orientation\r\n         * @type {boolean}\r\n         */\r\n        this.counterClockwise = Flatten.CCW;\r\n\r\n        if (args.length == 0)\r\n            return;\r\n\r\n        if (args.length == 1 && args[0] instanceof Object && args[0].name === \"arc\") {\r\n            let {pc, r, startAngle, endAngle, counterClockwise} = args[0];\r\n            this.pc = new Flatten.Point(pc.x, pc.y);\r\n            this.r = r;\r\n            this.startAngle = startAngle;\r\n            this.endAngle = endAngle;\r\n            this.counterClockwise = counterClockwise;\r\n            return;\r\n        } else {\r\n            let [pc, r, startAngle, endAngle, counterClockwise] = [...args];\r\n            if (pc && pc instanceof Flatten.Point) this.pc = pc.clone();\r\n            if (r !== undefined) this.r = r;\r\n            if (startAngle !== undefined) this.startAngle = startAngle;\r\n            if (endAngle !== undefined) this.endAngle = endAngle;\r\n            if (counterClockwise !== undefined) this.counterClockwise = counterClockwise;\r\n            return;\r\n        }\r\n\r\n        throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of arc\r\n     * @returns {Arc}\r\n     */\r\n    clone() {\r\n        return new Flatten.Arc(this.pc.clone(), this.r, this.startAngle, this.endAngle, this.counterClockwise);\r\n    }\r\n\r\n    /**\r\n     * Get sweep angle in radians. Sweep angle is non-negative number from 0 to 2*PI\r\n     * @returns {number}\r\n     */\r\n    get sweep() {\r\n        if (Flatten.Utils.EQ(this.startAngle, this.endAngle))\r\n            return 0.0;\r\n        if (Flatten.Utils.EQ(Math.abs(this.startAngle - this.endAngle), Flatten.PIx2)) {\r\n            return Flatten.PIx2;\r\n        }\r\n        let sweep;\r\n        if (this.counterClockwise) {\r\n            sweep = Flatten.Utils.GT(this.endAngle, this.startAngle) ?\r\n                this.endAngle - this.startAngle : this.endAngle - this.startAngle + Flatten.PIx2;\r\n        } else {\r\n            sweep = Flatten.Utils.GT(this.startAngle, this.endAngle) ?\r\n                this.startAngle - this.endAngle : this.startAngle - this.endAngle + Flatten.PIx2;\r\n        }\r\n\r\n        if (Flatten.Utils.GT(sweep, Flatten.PIx2)) {\r\n            sweep -= Flatten.PIx2;\r\n        }\r\n        if (Flatten.Utils.LT(sweep, 0)) {\r\n            sweep += Flatten.PIx2;\r\n        }\r\n        return sweep;\r\n    }\r\n\r\n    /**\r\n     * Get start point of arc\r\n     * @returns {Point}\r\n     */\r\n    get start() {\r\n        let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);\r\n        return p0.rotate(this.startAngle, this.pc);\r\n    }\r\n\r\n    /**\r\n     * Get end point of arc\r\n     * @returns {Point}\r\n     */\r\n    get end() {\r\n        let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);\r\n        return p0.rotate(this.endAngle, this.pc);\r\n    }\r\n\r\n    /**\r\n     * Get center of arc\r\n     * @returns {Point}\r\n     */\r\n    get center() {\r\n        return this.pc.clone();\r\n    }\r\n\r\n    get vertices() {\r\n        return [this.start.clone(), this.end.clone()];\r\n    }\r\n\r\n    /**\r\n     * Get arc length\r\n     * @returns {number}\r\n     */\r\n    get length() {\r\n        return Math.abs(this.sweep * this.r);\r\n    }\r\n\r\n    /**\r\n     * Get bounding box of the arc\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        let func_arcs = this.breakToFunctional();\r\n        let box = func_arcs.reduce((acc, arc) => acc.merge(arc.start.box), new Flatten.Box());\r\n        box = box.merge(this.end.box);\r\n        return box;\r\n    }\r\n\r\n    /**\r\n     * Returns true if arc contains point, false otherwise\r\n     * @param {Point} pt - point to test\r\n     * @returns {boolean}\r\n     */\r\n    contains(pt) {\r\n        // first check if  point on circle (pc,r)\r\n        if (!Flatten.Utils.EQ(this.pc.distanceTo(pt)[0], this.r))\r\n            return false;\r\n\r\n        // point on circle\r\n\r\n        if (pt.equalTo(this.start))\r\n            return true;\r\n\r\n        let angle = new Flatten.Vector(this.pc, pt).slope;\r\n        let test_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise);\r\n        return Flatten.Utils.LE(test_arc.length, this.length);\r\n    }\r\n\r\n    /**\r\n     * When given point belongs to arc, return array of two arcs split by this point. If points is incident\r\n     * to start or end point of the arc, return clone of the arc. If point does not belong to the arcs, return\r\n     * empty array.\r\n     * @param {Point} pt Query point\r\n     * @returns {Arc[]}\r\n     */\r\n    split(pt) {\r\n        if (this.start.equalTo(pt))\r\n            return [null, this.clone()];\r\n\r\n        if (this.end.equalTo(pt))\r\n            return [this.clone(), null];\r\n\r\n        let angle = new Flatten.Vector(this.pc, pt).slope;\r\n\r\n        return [\r\n            new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise),\r\n            new Flatten.Arc(this.pc, this.r, angle, this.endAngle, this.counterClockwise)\r\n        ]\r\n    }\r\n\r\n    /**\r\n     * Return middle point of the arc\r\n     * @returns {Point}\r\n     */\r\n    middle() {\r\n        let endAngle = this.counterClockwise ? this.startAngle + this.sweep / 2 : this.startAngle - this.sweep / 2;\r\n        let arc = new Flatten.Arc(this.pc, this.r, this.startAngle, endAngle, this.counterClockwise);\r\n        return arc.end;\r\n    }\r\n\r\n    /**\r\n     * Get point at given length\r\n     * @param {number} length - The length along the arc\r\n     * @returns {Point}\r\n     */\r\n    pointAtLength(length) {\r\n        if (length > this.length || length < 0) return null;\r\n        if (length == 0) return this.start;\r\n        if (length == this.length) return this.end;\r\n        let factor = length / this.length;\r\n        let endAngle = this.counterClockwise ? this.startAngle + this.sweep * factor : this.startAngle - this.sweep * factor;\r\n        let arc = new Flatten.Arc(this.pc, this.r, this.startAngle, endAngle, this.counterClockwise);\r\n        return arc.end;\r\n    }\r\n\r\n    /**\r\n     * Returns chord height (\"sagitta\") of the arc\r\n     * @returns {number}\r\n     */\r\n    chordHeight() {\r\n        return (1.0 - Math.cos(Math.abs(this.sweep / 2.0))) * this.r;\r\n    }\r\n\r\n    /**\r\n     * Returns array of intersection points between arc and other shape\r\n     * @param {Shape} shape Shape of the one of supported types <br/>\r\n     * @returns {Points[]}\r\n     */\r\n    intersect(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            return this.contains(shape) ? [shape] : [];\r\n        }\r\n        if (shape instanceof Flatten.Line) {\r\n            return intersectLine2Arc(shape, this);\r\n        }\r\n        if (shape instanceof Flatten.Circle) {\r\n            return intersectArc2Circle(this, shape);\r\n        }\r\n        if (shape instanceof Flatten.Segment) {\r\n            return intersectSegment2Arc(shape, this);\r\n        }\r\n        if (shape instanceof Flatten.Box) {\r\n            return intersectArc2Box(this, shape);\r\n        }\r\n        if (shape instanceof Flatten.Arc) {\r\n            return intersectArc2Arc(this, shape);\r\n        }\r\n        if (shape instanceof Flatten.Polygon) {\r\n            return intersectArc2Polygon(this, shape);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment from arc to shape and return array [distance, shortest segment]\r\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\r\n     * @returns {number} distance from arc to shape\r\n     * @returns {Segment} shortest segment between arc and shape (started at arc, ended at shape)\r\n\r\n     */\r\n    distanceTo(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            let [dist, shortest_segment] = Flatten.Distance.point2arc(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            let [dist, shortest_segment] = Flatten.Distance.arc2circle(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Line) {\r\n            let [dist, shortest_segment] = Flatten.Distance.arc2line(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            let [dist, shortest_segment] = Flatten.Distance.segment2arc(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            let [dist, shortest_segment] = Flatten.Distance.arc2arc(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            let [dist, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.PlanarSet) {\r\n            let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);\r\n            return [dist, shortest_segment];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Breaks arc in extreme point 0, pi/2, pi, 3*pi/2 and returns array of sub-arcs\r\n     * @returns {Arcs[]}\r\n     */\r\n    breakToFunctional() {\r\n        let func_arcs_array = [];\r\n        let angles = [0, Math.PI / 2, 2 * Math.PI / 2, 3 * Math.PI / 2];\r\n        let pts = [\r\n            this.pc.translate(this.r, 0),\r\n            this.pc.translate(0, this.r),\r\n            this.pc.translate(-this.r, 0),\r\n            this.pc.translate(0, -this.r)\r\n        ];\r\n\r\n        // If arc contains extreme point,\r\n        // create test arc started at start point and ended at this extreme point\r\n        let test_arcs = [];\r\n        for (let i = 0; i < 4; i++) {\r\n            if (pts[i].on(this)) {\r\n                test_arcs.push(new Flatten.Arc(this.pc, this.r, this.startAngle, angles[i], this.counterClockwise));\r\n            }\r\n        }\r\n\r\n        if (test_arcs.length == 0) {                  // arc does contain any extreme point\r\n            func_arcs_array.push(this.clone());\r\n        } else {                                        // arc passes extreme point\r\n            // sort these arcs by length\r\n            test_arcs.sort((arc1, arc2) => arc1.length - arc2.length);\r\n\r\n            for (let i = 0; i < test_arcs.length; i++) {\r\n                let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\r\n                let new_arc;\r\n                if (prev_arc) {\r\n                    new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, test_arcs[i].endAngle, this.counterClockwise);\r\n                } else {\r\n                    new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, test_arcs[i].endAngle, this.counterClockwise);\r\n                }\r\n                if (!Flatten.Utils.EQ_0(new_arc.length)) {\r\n                    func_arcs_array.push(new_arc.clone());\r\n                }\r\n            }\r\n\r\n            // add last sub arc\r\n            let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\r\n            let new_arc;\r\n            if (prev_arc) {\r\n                new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, this.endAngle, this.counterClockwise);\r\n            } else {\r\n                new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, this.endAngle, this.counterClockwise);\r\n            }\r\n            // It could be 2*PI when occasionally start = 0 and end = 2*PI but this is not valid for breakToFunctional\r\n            if (!Flatten.Utils.EQ_0(new_arc.length) && !Flatten.Utils.EQ(new_arc.sweep, 2*Math.PI)) {\r\n                func_arcs_array.push(new_arc.clone());\r\n            }\r\n        }\r\n        return func_arcs_array;\r\n    }\r\n\r\n    /**\r\n     * Return tangent unit vector in the start point in the direction from start to end\r\n     * @returns {Vector}\r\n     */\r\n    tangentInStart() {\r\n        let vec = new Flatten.Vector(this.pc, this.start);\r\n        let angle = this.counterClockwise ? Math.PI / 2. : -Math.PI / 2.;\r\n        let tangent = vec.rotate(angle).normalize();\r\n        return tangent;\r\n    }\r\n\r\n    /**\r\n     * Return tangent unit vector in the end point in the direction from end to start\r\n     * @returns {Vector}\r\n     */\r\n    tangentInEnd() {\r\n        let vec = new Flatten.Vector(this.pc, this.end);\r\n        let angle = this.counterClockwise ? -Math.PI / 2. : Math.PI / 2.;\r\n        let tangent = vec.rotate(angle).normalize();\r\n        return tangent;\r\n    }\r\n\r\n    /**\r\n     * Returns new arc with swapped start and end angles and reversed direction\r\n     * @returns {Arc}\r\n     */\r\n    reverse() {\r\n        return new Flatten.Arc(this.pc, this.r, this.endAngle, this.startAngle, !this.counterClockwise);\r\n    }\r\n\r\n    /**\r\n     * Returns new arc translated by vector vec\r\n     * @param {Vector} vec\r\n     * @returns {Segment}\r\n     */\r\n    translate(...args) {\r\n        let arc = this.clone();\r\n        arc.pc = this.pc.translate(...args);\r\n        return arc;\r\n    }\r\n\r\n    /**\r\n     * Return new segment rotated by given angle around given point\r\n     * If point omitted, rotate around origin (0,0)\r\n     * Positive value of angle defines rotation counter clockwise, negative - clockwise\r\n     * @param {number} angle - rotation angle in radians\r\n     * @param {Point} center - center point, default is (0,0)\r\n     * @returns {Arc}\r\n     */\r\n    rotate(angle = 0, center = new Flatten.Point()) {\r\n        let m = new Flatten.Matrix();\r\n        m = m.translate(center.x, center.y).rotate(angle).translate(-center.x, -center.y);\r\n        return this.transform(m);\r\n    }\r\n\r\n    /**\r\n     * Return new arc scaled by scaleX, scaleY.\r\n     * @param {number} scaleX - scale value by X\r\n     * @param {number} scaleY - scale value by Y\r\n     * @returns {Arc}\r\n     */\r\n    scale(scaleX = 1, scaleY = 1) {\r\n        let m = new Flatten.Matrix();\r\n        m = m.scale(scaleX, scaleY);\r\n        return this.transform(m);\r\n    }\r\n\r\n    /**\r\n     * Return new arc transformed using affine transformation matrix <br/>\r\n     * Note 1. Non-equal scaling by x and y (abs(matrix[0]) != abs(matrix[3])) produce illegal result because\r\n     * it should create elliptic arc but this package does not support ellipses\r\n     * Note 2. Mirror transformation (matrix[0] * matrix[3] < 0) change direction of the arc to the opposite\r\n     * TODO: support non-equal scaling arc to ellipse or throw exception ?\r\n     * @param {Matrix} matrix - affine transformation matrix\r\n     * @returns {Arc}\r\n     */\r\n    transform(matrix = new Flatten.Matrix()) {\r\n        let newStart = this.start.transform(matrix);\r\n        let newEnd = this.end.transform(matrix);\r\n        let newCenter = this.pc.transform(matrix);\r\n        let newDirection = this.counterClockwise;\r\n        if (matrix.a * matrix.d < 0) {\r\n          newDirection = !newDirection;\r\n        }\r\n        let arc = Flatten.Arc.arcSE(newCenter, newStart, newEnd, newDirection);\r\n        return arc;\r\n    }\r\n\r\n    static arcSE(center, start, end, counterClockwise) {\r\n        let {vector} = Flatten;\r\n        let startAngle = vector(center, start).slope;\r\n        let endAngle = vector(center, end).slope;\r\n        if (Flatten.Utils.EQ(startAngle, endAngle)) {\r\n            endAngle += 2 * Math.PI;\r\n            counterClockwise = true;\r\n        }\r\n        let r = vector(center, start).length;\r\n\r\n        return new Flatten.Arc(center, r, startAngle, endAngle, counterClockwise);\r\n    }\r\n\r\n    definiteIntegral(ymin = 0) {\r\n        let f_arcs = this.breakToFunctional();\r\n        let area = f_arcs.reduce((acc, arc) => acc + arc.circularSegmentDefiniteIntegral(ymin), 0.0);\r\n        return area;\r\n    }\r\n\r\n    circularSegmentDefiniteIntegral(ymin) {\r\n        let line = new Flatten.Line(this.start, this.end);\r\n        let onLeftSide = this.pc.leftTo(line);\r\n        let segment = new Flatten.Segment(this.start, this.end);\r\n        let areaTrapez = segment.definiteIntegral(ymin);\r\n        let areaCircularSegment = this.circularSegmentArea();\r\n        let area = onLeftSide ? areaTrapez - areaCircularSegment : areaTrapez + areaCircularSegment;\r\n        return area;\r\n    }\r\n\r\n    circularSegmentArea() {\r\n        return (0.5 * this.r * this.r * (this.sweep - Math.sin(this.sweep)))\r\n    }\r\n\r\n    /**\r\n     * Sort given array of points from arc start to end, assuming all points lay on the arc\r\n     * @param {Point[]} array of points\r\n     * @returns {Point[]} new array sorted\r\n     */\r\n    sortPoints(pts) {\r\n        let {vector} = Flatten;\r\n        return pts.slice().sort( (pt1, pt2) => {\r\n            let slope1 = vector(this.pc, pt1).slope;\r\n            let slope2 = vector(this.pc, pt2).slope;\r\n            if (slope1 < slope2) {\r\n                return -1;\r\n            }\r\n            if (slope1 > slope2) {\r\n                return 1;\r\n            }\r\n            return 0;\r\n        })\r\n    }\r\n\r\n    /**\r\n     * This method returns an object that defines how data will be\r\n     * serialized when called JSON.stringify() method\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n        return Object.assign({}, this, {name: \"arc\"});\r\n    }\r\n\r\n    /**\r\n     * Return string to draw arc in svg\r\n     * @param {Object} attrs - an object with attributes of svg path element,\r\n     * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\r\n     * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\r\n     * @returns {string}\r\n     */\r\n    svg(attrs = {}) {\r\n        let largeArcFlag = this.sweep <= Math.PI ? \"0\" : \"1\";\r\n        let sweepFlag = this.counterClockwise ? \"1\" : \"0\";\r\n        let {stroke, strokeWidth, fill, id, className} = attrs;\r\n        // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n        let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n        let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n\r\n        if (Flatten.Utils.EQ(this.sweep, 2 * Math.PI)) {\r\n            let circle = new Flatten.Circle(this.pc, this.r);\r\n            return circle.svg(attrs);\r\n        } else {\r\n            return `\\n<path d=\"M${this.start.x},${this.start.y}\r\n                             A${this.r},${this.r} 0 ${largeArcFlag},${sweepFlag} ${this.end.x},${this.end.y}\"\r\n                    stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"none\"}\" ${id_str} ${class_str} />`\r\n        }\r\n    }\r\n\r\n}\r\nFlatten.Arc = Arc;\r\n/**\r\n * Function to create arc equivalent to \"new\" constructor\r\n * @param args\r\n */\r\nconst arc = (...args) => new Flatten.Arc(...args);\r\nFlatten.arc = arc;\r\n\r\n/**\r\n * Created by Alex Bol on 3/7/2017.\r\n */\r\n\r\n/**\r\n * Class Box represent bounding box of the shape\r\n * @type {Box}\r\n */\r\nclass Box {\r\n    /**\r\n     *\r\n     * @param {number} xmin - minimal x coordinate\r\n     * @param {number} ymin - minimal y coordinate\r\n     * @param {number} xmax - maximal x coordinate\r\n     * @param {number} ymax - maximal y coordinate\r\n     */\r\n    constructor(xmin = undefined, ymin = undefined, xmax = undefined, ymax = undefined) {\r\n        /**\r\n         * Minimal x coordinate\r\n         * @type {number}\r\n         */\r\n        this.xmin = xmin;\r\n        /**\r\n         * Minimal y coordinate\r\n         * @type {number}\r\n         */\r\n        this.ymin = ymin;\r\n        /**\r\n         * Maximal x coordinate\r\n         * @type {number}\r\n         */\r\n        this.xmax = xmax;\r\n        /**\r\n         * Maximal y coordinate\r\n         * @type {number}\r\n         */\r\n        this.ymax = ymax;\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of box\r\n     * @returns {Box}\r\n     */\r\n    clone() {\r\n        return new Box(this.xmin, this.ymin, this.xmax, this.ymax);\r\n    }\r\n\r\n    /**\r\n     * Property low need for interval tree interface\r\n     * @returns {Point}\r\n     */\r\n    get low() {\r\n        return new Flatten.Point(this.xmin, this.ymin);\r\n    }\r\n\r\n    /**\r\n     * Property high need for interval tree interface\r\n     * @returns {Point}\r\n     */\r\n    get high() {\r\n        return new Flatten.Point(this.xmax, this.ymax);\r\n    }\r\n\r\n    /**\r\n     * Property max returns the box itself !\r\n     * @returns {Box}\r\n     */\r\n    get max() {\r\n        return this.clone();\r\n    }\r\n    \r\n    /**\r\n     * Return center of the box\r\n     * @returns {Point}\r\n     */\r\n    get center() {\r\n        return new Flatten.Point((this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2);\r\n    }\r\n\r\n    /**\r\n     * Return the width of the box\r\n     * @returns {number}\r\n     */\r\n    get width() {\r\n        return Math.abs(this.xmax - this.xmin);\r\n    }\r\n\r\n    /**\r\n     * Return the height of the box\r\n     * @returns {number}\r\n     */\r\n    get height() {\r\n        return Math.abs(this.ymax - this.ymin);\r\n    }\r\n    \r\n    /**\r\n     * Return property box like all other shapes\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        return this.clone();\r\n    }\r\n\r\n    /**\r\n     * Returns true if not intersected with other box\r\n     * @param {Box} other_box - other box to test\r\n     * @returns {boolean}\r\n     */\r\n    not_intersect(other_box) {\r\n        return (\r\n            this.xmax < other_box.xmin ||\r\n            this.xmin > other_box.xmax ||\r\n            this.ymax < other_box.ymin ||\r\n            this.ymin > other_box.ymax\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns true if intersected with other box\r\n     * @param {Box} other_box - Query box\r\n     * @returns {boolean}\r\n     */\r\n    intersect(other_box) {\r\n        return !this.not_intersect(other_box);\r\n    }\r\n\r\n    /**\r\n     * Returns new box merged with other box\r\n     * @param {Box} other_box - Other box to merge with\r\n     * @returns {Box}\r\n     */\r\n    merge(other_box) {\r\n        return new Box(\r\n            this.xmin === undefined ? other_box.xmin : Math.min(this.xmin, other_box.xmin),\r\n            this.ymin === undefined ? other_box.ymin : Math.min(this.ymin, other_box.ymin),\r\n            this.xmax === undefined ? other_box.xmax : Math.max(this.xmax, other_box.xmax),\r\n            this.ymax === undefined ? other_box.ymax : Math.max(this.ymax, other_box.ymax)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Defines predicate \"less than\" between two boxes. Need for interval index\r\n     * @param {Box} other_box - other box\r\n     * @returns {boolean} - true if this box less than other box, false otherwise\r\n     */\r\n    less_than(other_box) {\r\n        if (this.low.lessThan(other_box.low))\r\n            return true;\r\n        if (this.low.equalTo(other_box.low) && this.high.lessThan(other_box.high))\r\n            return true;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if this box is equal to other box, false otherwise\r\n     * @param {Box} other_box - query box\r\n     * @returns {boolean}\r\n     */\r\n    equal_to(other_box) {\r\n        return (this.low.equalTo(other_box.low) && this.high.equalTo(other_box.high));\r\n    }\r\n\r\n    output() {\r\n        return this.clone();\r\n    }\r\n\r\n    static comparable_max(box1, box2) {\r\n        // return pt1.lessThan(pt2) ? pt2.clone() : pt1.clone();\r\n        return box1.merge(box2);\r\n    }\r\n\r\n    static comparable_less_than(pt1, pt2) {\r\n        return pt1.lessThan(pt2);\r\n    }\r\n\r\n    /**\r\n     * Set new values to the box object\r\n     * @param {number} xmin - miminal x coordinate\r\n     * @param {number} ymin - minimal y coordinate\r\n     * @param {number} xmax - maximal x coordinate\r\n     * @param {number} ymax - maximal y coordinate\r\n     */\r\n    set(xmin, ymin, xmax, ymax) {\r\n        this.xmin = xmin;\r\n        this.ymin = ymin;\r\n        this.xmax = xmax;\r\n        this.ymax = ymax;\r\n    }\r\n\r\n    /**\r\n     * Transform box into array of points from low left corner in counter clockwise\r\n     * @returns {Point[]}\r\n     */\r\n    toPoints() {\r\n        return [\r\n            new Flatten.Point(this.xmin, this.ymin),\r\n            new Flatten.Point(this.xmax, this.ymin),\r\n            new Flatten.Point(this.xmax, this.ymax),\r\n            new Flatten.Point(this.xmin, this.ymax)\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * Transform box into array of segments from low left corner in counter clockwise\r\n     * @returns {Segment[]}\r\n     */\r\n    toSegments() {\r\n        let pts = this.toPoints();\r\n        return [\r\n            new Flatten.Segment(pts[0], pts[1]),\r\n            new Flatten.Segment(pts[1], pts[2]),\r\n            new Flatten.Segment(pts[2], pts[3]),\r\n            new Flatten.Segment(pts[3], pts[0])\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * Return string to draw circle in svg\r\n     * @param {Object} attrs - an object with attributes of svg rectangle element,\r\n     * like \"stroke\", \"strokeWidth\", \"fill\" <br/>\r\n     * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"none\"\r\n     * @returns {string}\r\n     */\r\n    svg(attrs = {}) {\r\n        let {stroke, strokeWidth, fill, id, className} = attrs;\r\n        // let rest_str = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n        let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n        let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n        let width = this.xmax - this.xmin;\r\n        let height = this.ymax - this.ymin;\r\n\r\n        return `\\n<rect x=\"${this.xmin}\" y=\"${this.ymin}\" width=${width} height=${height} stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"none\"}\" ${id_str} ${class_str} />`;\r\n    };\r\n}\r\nFlatten.Box = Box;\r\n/**\r\n * Shortcut to create new box\r\n * @param args\r\n * @returns {Box}\r\n */\r\nconst box = (...args) => new Flatten.Box(...args);\r\nFlatten.box = box;\r\n\r\n/**\r\n * Created by Alex Bol on 3/17/2017.\r\n */\r\n\r\n/**\r\n * Class representing an edge of polygon. Edge shape may be Segment or Arc.\r\n * Each edge contains references to the next and previous edges in the face of the polygon.\r\n *\r\n * @type {Edge}\r\n */\r\nclass Edge {\r\n    /**\r\n     * Construct new instance of edge\r\n     * @param {Shape} shape Shape of type Segment or Arc\r\n     */\r\n    constructor(shape) {\r\n        /**\r\n         * Shape of the edge: Segment or Arc\r\n         * @type {Segment|Arc}\r\n         */\r\n        this.shape = shape;\r\n        /**\r\n         * Pointer to the next edge in the face\r\n         * @type {Edge}\r\n         */\r\n        this.next = undefined;\r\n        /**\r\n         * Pointer to the previous edge in the face\r\n         * @type {Edge}\r\n         */\r\n        this.prev = undefined;\r\n        /**\r\n         * Pointer to the face containing this edge\r\n         * @type {Face}\r\n         */\r\n        this.face = undefined;\r\n        /**\r\n         * \"Arc distance\" from the face start\r\n         * @type {number}\r\n         */\r\n        this.arc_length = 0;\r\n        /**\r\n         * Start inclusion flag (inside/outside/boundary)\r\n         * @type {*}\r\n         */\r\n        this.bvStart = undefined;\r\n        /**\r\n         * End inclusion flag (inside/outside/boundary)\r\n         * @type {*}\r\n         */\r\n        this.bvEnd = undefined;\r\n        /**\r\n         * Edge inclusion flag (Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY)\r\n         * @type {*}\r\n         */\r\n        this.bv = undefined;\r\n        /**\r\n         * Overlap flag for boundary edge (Flatten.OVERLAP_SAME/Flatten.OVERLAP_OPPOSITE)\r\n         * @type {*}\r\n         */\r\n        this.overlap = undefined;\r\n    }\r\n\r\n    /**\r\n     * Get edge start point\r\n     */\r\n    get start() {\r\n        return this.shape.start;\r\n    }\r\n\r\n    /**\r\n     * Get edge end point\r\n     */\r\n    get end() {\r\n        return this.shape.end;\r\n    }\r\n\r\n    /**\r\n     * Get edge length\r\n     */\r\n    get length() {\r\n        return this.shape.length;\r\n    }\r\n\r\n    /**\r\n     * Get bounding box of the edge\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        return this.shape.box;\r\n    }\r\n\r\n    isSegment() {\r\n        return this.shape instanceof Flatten.Segment;\r\n    }\r\n\r\n    isArc() {\r\n        return this.shape instanceof Flatten.Arc;\r\n    }\r\n\r\n    /**\r\n     * Get middle point of the edge\r\n     * @returns {Point}\r\n     */\r\n    middle() {\r\n        return this.shape.middle();\r\n    }\r\n\r\n    /**\r\n     * Get point at given length\r\n     * @param {number} length - The length along the edge\r\n     * @returns {Point}\r\n     */\r\n    pointAtLength(length) {\r\n        return this.shape.pointAtLength(length);\r\n    }\r\n\r\n    /**\r\n     * Returns true if point belongs to the edge, false otherwise\r\n     * @param {Point} pt - test point\r\n     */\r\n    contains(pt) {\r\n        return this.shape.contains(pt);\r\n    }\r\n\r\n    /**\r\n     * Set inclusion flag of the edge with respect to another polygon\r\n     * Inclusion flag is one of Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY\r\n     * @param polygon\r\n     */\r\n    setInclusion(polygon) {\r\n        if (this.bv !== undefined) return this.bv;\r\n\r\n        if (this.shape instanceof Flatten.Line || this.shape instanceof Flatten.Ray) {\r\n            this.bv = Flatten.OUTSIDE;\r\n            return this.bv;\r\n        }\r\n\r\n        if (this.bvStart === undefined) {\r\n            this.bvStart = ray_shoot(polygon, this.start);\r\n        }\r\n        if (this.bvEnd === undefined) {\r\n            this.bvEnd = ray_shoot(polygon, this.end);\r\n        }\r\n        /* At least one end outside - the whole edge outside */\r\n        if (this.bvStart === Flatten.OUTSIDE || this.bvEnd == Flatten.OUTSIDE) {\r\n            this.bv = Flatten.OUTSIDE;\r\n        }\r\n        /* At least one end inside - the whole edge inside */\r\n        else if (this.bvStart === Flatten.INSIDE || this.bvEnd == Flatten.INSIDE) {\r\n            this.bv = Flatten.INSIDE;\r\n        }\r\n        /* Both are boundary - check the middle point */\r\n        else {\r\n            let bvMiddle = ray_shoot(polygon, this.middle());\r\n            // let boundary = this.middle().distanceTo(polygon)[0] < 10*Flatten.DP_TOL;\r\n            // let bvMiddle = boundary ? Flatten.BOUNDARY : ray_shoot(polygon, this.middle());\r\n            this.bv = bvMiddle;\r\n        }\r\n        return this.bv;\r\n    }\r\n\r\n    /**\r\n     * Set overlapping between two coincident boundary edges\r\n     * Overlapping flag is one of Flatten.OVERLAP_SAME or Flatten.OVERLAP_OPPOSITE\r\n     * @param edge\r\n     */\r\n    setOverlap(edge) {\r\n        let flag = undefined;\r\n        let shape1 = this.shape;\r\n        let shape2 = edge.shape;\r\n\r\n        if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Segment) {\r\n            if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end)) {\r\n                flag = Flatten.OVERLAP_SAME;\r\n            } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start)) {\r\n                flag = Flatten.OVERLAP_OPPOSITE;\r\n            }\r\n        } else if (shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Arc) {\r\n            if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && /*shape1.counterClockwise === shape2.counterClockwise &&*/\r\n                shape1.middle().equalTo(shape2.middle())) {\r\n                flag = Flatten.OVERLAP_SAME;\r\n            } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && /*shape1.counterClockwise !== shape2.counterClockwise &&*/\r\n                shape1.middle().equalTo(shape2.middle())) {\r\n                flag = Flatten.OVERLAP_OPPOSITE;\r\n            }\r\n        } else if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Arc ||\r\n            shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Segment) {\r\n            if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && shape1.middle().equalTo(shape2.middle())) {\r\n                flag = Flatten.OVERLAP_SAME;\r\n            } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && shape1.middle().equalTo(shape2.middle())) {\r\n                flag = Flatten.OVERLAP_OPPOSITE;\r\n            }\r\n        }\r\n\r\n        /* Do not update overlap flag if already set on previous chain */\r\n        if (this.overlap === undefined) this.overlap = flag;\r\n        if (edge.overlap === undefined) edge.overlap = flag;\r\n    }\r\n\r\n    svg() {\r\n        if (this.shape instanceof Flatten.Segment) {\r\n            return ` L${this.shape.end.x},${this.shape.end.y}`;\r\n        } else if (this.shape instanceof Flatten.Arc) {\r\n            let arc = this.shape;\r\n            let largeArcFlag;\r\n            let sweepFlag = arc.counterClockwise ? \"1\" : \"0\";\r\n\r\n            // Draw full circe arc as special case: split it into two half-circles\r\n            if (Flatten.Utils.EQ(arc.sweep, 2 * Math.PI)) {\r\n                let sign = arc.counterClockwise ? 1 : -1;\r\n                let halfArc1 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle, arc.startAngle + sign * Math.PI, arc.counterClockwise);\r\n                let halfArc2 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle + sign * Math.PI, arc.endAngle, arc.counterClockwise);\r\n\r\n                largeArcFlag = \"0\";\r\n\r\n                return ` A${halfArc1.r},${halfArc1.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc1.end.x},${halfArc1.end.y}\r\n                    A${halfArc2.r},${halfArc2.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc2.end.x},${halfArc2.end.y}`\r\n            } else {\r\n                largeArcFlag = arc.sweep <= Math.PI ? \"0\" : \"1\";\r\n\r\n                return ` A${arc.r},${arc.r} 0 ${largeArcFlag},${sweepFlag} ${arc.end.x},${arc.end.y}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    toJSON() {\r\n        return this.shape.toJSON();\r\n    }\r\n}\r\nFlatten.Edge = Edge;\r\n\r\n/**\r\n * Class implements circular bidirectional linked list <br/>\r\n * LinkedListElement - object of any type that has properties next and prev.\r\n */\r\nclass CircularLinkedList extends LinkedList {\r\n    constructor(first, last) {\r\n        super(first, last);\r\n        this.setCircularLinks();\r\n    }\r\n\r\n    setCircularLinks() {\r\n        if (this.isEmpty()) return;\r\n        this.last.next = this.first;\r\n        this.first.prev = this.last;\r\n    }\r\n\r\n    [Symbol.iterator]() {\r\n        let element = undefined;\r\n        return {\r\n            next: () => {\r\n                let value = element ? element : this.first;\r\n                let done = this.first ? (element ? element === this.first : false) : true;\r\n                element = value ? value.next : undefined;\r\n                return {value: value, done: done};\r\n            }\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Append new element to the end of the list\r\n     * @param {LinkedListElement} element - new element to be appended\r\n     * @returns {CircularLinkedList}\r\n     */\r\n    append(element) {\r\n        super.append(element);\r\n        this.setCircularLinks();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Insert new element to the list after elementBefore\r\n     * @param {LinkedListElement} newElement - new element to be inserted\r\n     * @param {LinkedListElement} elementBefore - element in the list to insert after it\r\n     * @returns {CircularLinkedList}\r\n     */\r\n    insert(newElement, elementBefore) {\r\n        super.insert(newElement, elementBefore);\r\n        this.setCircularLinks();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove element from the list\r\n     * @param {LinkedListElement} element - element to be removed from the list\r\n     * @returns {CircularLinkedList}\r\n     */\r\n    remove(element) {\r\n        super.remove(element);\r\n        // this.setCircularLinks();\r\n        return this;\r\n    }\r\n}\r\n\r\n/**\r\n * Created by Alex Bol on 3/17/2017.\r\n */\r\n\r\n/**\r\n * Class representing a face (closed loop) in a [polygon]{@link Flatten.Polygon} object.\r\n * Face is a circular bidirectional linked list of [edges]{@link Flatten.Edge}.\r\n * Face object cannot be instantiated with a constructor.\r\n * Instead, use [polygon.addFace()]{@link Flatten.Polygon#addFace} method.\r\n * <br/>\r\n * Note, that face only set entry point to the linked list of edges but does not contain edges by itself.\r\n * Container of edges is a property of the polygon object. <br/>\r\n *\r\n * @example\r\n * // Face implements \"next\" iterator which enables to iterate edges in for loop:\r\n * for (let edge of face) {\r\n *      console.log(edge.shape.length)     // do something\r\n * }\r\n *\r\n * // Instead, it is possible to iterate edges as linked list, starting from face.first:\r\n * let edge = face.first;\r\n * do {\r\n *   console.log(edge.shape.length);   // do something\r\n *   edge = edge.next;\r\n * } while (edge != face.first)\r\n */\r\nclass Face extends CircularLinkedList {\r\n    constructor(polygon, ...args) {\r\n        super();            // construct empty list of edges\r\n        /**\r\n         * Reference to the first edge in face\r\n         */\r\n        // this.first;\r\n        /**\r\n         * Reference to the last edge in face\r\n         */\r\n        // this.last;\r\n\r\n        this._box = undefined;  // new Box();\r\n        this._orientation = undefined;\r\n\r\n        if (args.length == 0) {\r\n            return;\r\n        }\r\n\r\n        /* If passed an array it supposed to be:\r\n         1) array of shapes that performs close loop or\r\n         2) array of points that performs set of vertices\r\n         */\r\n        if (args.length == 1) {\r\n            if (args[0] instanceof Array) {\r\n                // let argsArray = args[0];\r\n                let shapes = args[0];  // argsArray[0];\r\n                if (shapes.length == 0)\r\n                    return;\r\n\r\n                /* array of Flatten.Points */\r\n                if (shapes.every((shape) => {return shape instanceof Flatten.Point})) {\r\n                    let segments = Face.points2segments(shapes);\r\n                    this.shapes2face(polygon.edges, segments);\r\n                }\r\n                /* array of points as pairs of numbers */\r\n                else if (shapes.every((shape) => {return shape instanceof Array && shape.length === 2})) {\r\n                    let points = shapes.map((shape) => new Flatten.Point(shape[0],shape[1]));\r\n                    let segments = Face.points2segments(points);\r\n                    this.shapes2face(polygon.edges, segments);\r\n                }\r\n                /* array of segments ot arcs */\r\n                else if (shapes.every((shape) => {\r\n                    return (shape instanceof Flatten.Segment || shape instanceof Flatten.Arc)\r\n                })) {\r\n                    this.shapes2face(polygon.edges, shapes);\r\n                }\r\n                // this is from JSON.parse object\r\n                else if (shapes.every((shape) => {\r\n                    return (shape.name === \"segment\" || shape.name === \"arc\")\r\n                })) {\r\n                    let flattenShapes = [];\r\n                    for (let shape of shapes) {\r\n                        let flattenShape;\r\n                        if (shape.name === \"segment\") {\r\n                            flattenShape = new Flatten.Segment(shape);\r\n                        } else {\r\n                            flattenShape = new Flatten.Arc(shape);\r\n                        }\r\n                        flattenShapes.push(flattenShape);\r\n                    }\r\n                    this.shapes2face(polygon.edges, flattenShapes);\r\n                }\r\n            }\r\n            /* Create new face and copy edges into polygon.edges set */\r\n            else if (args[0] instanceof Face) {\r\n                let face = args[0];\r\n                this.first = face.first;\r\n                this.last = face.last;\r\n                for (let edge of face) {\r\n                    polygon.edges.add(edge);\r\n                }\r\n            }\r\n            /* Instantiate face from a circle in CCW orientation */\r\n            else if (args[0] instanceof Flatten.Circle) {\r\n                this.shapes2face(polygon.edges, [args[0].toArc(Flatten.CCW)]);\r\n            }\r\n            /* Instantiate face from a box in CCW orientation */\r\n            else if (args[0] instanceof Flatten.Box) {\r\n                let box = args[0];\r\n                this.shapes2face(polygon.edges, [\r\n                    new Flatten.Segment(new Flatten.Point(box.xmin, box.ymin), new Flatten.Point(box.xmax, box.ymin)),\r\n                    new Flatten.Segment(new Flatten.Point(box.xmax, box.ymin), new Flatten.Point(box.xmax, box.ymax)),\r\n                    new Flatten.Segment(new Flatten.Point(box.xmax, box.ymax), new Flatten.Point(box.xmin, box.ymax)),\r\n                    new Flatten.Segment(new Flatten.Point(box.xmin, box.ymax), new Flatten.Point(box.xmin, box.ymin))\r\n                ]);\r\n            }\r\n        }\r\n        /* If passed two edges, consider them as start and end of the face loop */\r\n        /* THIS METHOD WILL BE USED BY BOOLEAN OPERATIONS */\r\n        /* Assume that edges already copied to polygon.edges set in the clip algorithm !!! */\r\n        if (args.length == 2 && args[0] instanceof Flatten.Edge && args[1] instanceof Flatten.Edge) {\r\n            this.first = args[0];                          // first edge in face or undefined\r\n            this.last = args[1];                           // last edge in face or undefined\r\n            this.last.next = this.first;\r\n            this.first.prev = this.last;\r\n\r\n            // set arc length\r\n            this.setArcLength();\r\n\r\n            // this.box = this.getBox();\r\n            // this.orientation = this.getOrientation();      // face direction cw or ccw\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return array of edges from first to last\r\n     * @returns {Array}\r\n     */\r\n    get edges() {\r\n        return this.toArray();\r\n    }\r\n\r\n    /**\r\n     * Return array of shapes which comprise face\r\n     * @returns {Array}\r\n     */\r\n    get shapes() {\r\n        return this.edges.map(edge => edge.shape.clone());\r\n    }\r\n\r\n    /**\r\n     * Return bounding box of the face\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        if (this._box === undefined) {\r\n            let box = new Flatten.Box();\r\n            for (let edge of this) {\r\n                box = box.merge(edge.box);\r\n            }\r\n            this._box = box;\r\n        }\r\n        return this._box;\r\n    }\r\n\r\n    /**\r\n     * Get all edges length\r\n     * @returns {number}\r\n     */\r\n    get perimeter() {\r\n        return this.last.arc_length + this.last.length\r\n    }\r\n\r\n    /**\r\n     * Get point on face boundary at given length\r\n     * @param {number} length - The length along the face boundary\r\n     * @returns {Point}\r\n     */\r\n    pointAtLength(length) {\r\n        if (length > this.perimeter || length < 0) return null;\r\n        let point = null;\r\n        for (let edge of this) {\r\n            if (length >= edge.arc_length &&\r\n                (edge === this.last || length < edge.next.arc_length)) {\r\n                point = edge.pointAtLength(length - edge.arc_length);\r\n                break;\r\n            }\r\n        }\r\n        return point;\r\n    }\r\n\r\n    static points2segments(points) {\r\n        let segments = [];\r\n        for (let i = 0; i < points.length; i++) {\r\n            // skip zero length segment\r\n            if (points[i].equalTo(points[(i + 1) % points.length]))\r\n                continue;\r\n            segments.push(new Flatten.Segment(points[i], points[(i + 1) % points.length]));\r\n        }\r\n        return segments;\r\n    }\r\n\r\n    shapes2face(edges, shapes) {\r\n        for (let shape of shapes) {\r\n            let edge = new Flatten.Edge(shape);\r\n            this.append(edge);\r\n            // this.box = this.box.merge(shape.box);\r\n            edges.add(edge);\r\n        }\r\n        // this.orientation = this.getOrientation();              // face direction cw or ccw\r\n    }\r\n\r\n    /**\r\n     * Append edge after the last edge of the face (and before the first edge). <br/>\r\n     * @param {Edge} edge - Edge to be appended to the linked list\r\n     * @returns {Face}\r\n     */\r\n    append(edge) {\r\n        super.append(edge);\r\n        // set arc length\r\n        this.setOneEdgeArcLength(edge);\r\n        edge.face = this;\r\n        // edges.add(edge);      // Add new edges into edges container\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Insert edge newEdge into the linked list after the edge edgeBefore <br/>\r\n     * @param {Edge} newEdge - Edge to be inserted into linked list\r\n     * @param {Edge} edgeBefore - Edge to insert newEdge after it\r\n     * @returns {Face}\r\n     */\r\n    insert(newEdge, edgeBefore) {\r\n        super.insert(newEdge, edgeBefore);\r\n        // set arc length\r\n        this.setOneEdgeArcLength(newEdge);\r\n        newEdge.face = this;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove the given edge from the linked list of the face <br/>\r\n     * @param {Edge} edge - Edge to be removed\r\n     * @returns {Face}\r\n     */\r\n    remove(edge) {\r\n        super.remove(edge);\r\n        // Recalculate arc length\r\n        this.setArcLength();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reverse orientation of the face: first edge become last and vice a verse,\r\n     * all edges starts and ends swapped, direction of arcs inverted. If face was oriented\r\n     * clockwise, it becomes counter clockwise and vice versa\r\n     */\r\n    reverse() {\r\n        // collect edges in revert order with reverted shapes\r\n        let edges = [];\r\n        let edge_tmp = this.last;\r\n        do {\r\n            // reverse shape\r\n            edge_tmp.shape = edge_tmp.shape.reverse();\r\n            edges.push(edge_tmp);\r\n            edge_tmp = edge_tmp.prev;\r\n        } while (edge_tmp !== this.last);\r\n\r\n        // restore linked list\r\n        this.first = undefined;\r\n        this.last = undefined;\r\n        for (let edge of edges) {\r\n            if (this.first === undefined) {\r\n                edge.prev = edge;\r\n                edge.next = edge;\r\n                this.first = edge;\r\n                this.last = edge;\r\n            } else {\r\n                // append to end\r\n                edge.prev = this.last;\r\n                this.last.next = edge;\r\n\r\n                // update edge to be last\r\n                this.last = edge;\r\n\r\n                // restore circular links\r\n                this.last.next = this.first;\r\n                this.first.prev = this.last;\r\n\r\n            }\r\n            // set arc length\r\n            this.setOneEdgeArcLength(edge);\r\n        }\r\n\r\n        // Recalculate orientation, if set\r\n        if (this._orientation !== undefined) {\r\n            this._orientation = undefined;\r\n            this._orientation = this.orientation();\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Set arc_length property for each of the edges in the face.\r\n     * Arc_length of the edge it the arc length from the first edge of the face\r\n     */\r\n    setArcLength() {\r\n        for (let edge of this) {\r\n            this.setOneEdgeArcLength(edge);\r\n            edge.face = this;\r\n        }\r\n    }\r\n\r\n    setOneEdgeArcLength(edge) {\r\n        if (edge === this.first) {\r\n            edge.arc_length = 0.0;\r\n        } else {\r\n            edge.arc_length = edge.prev.arc_length + edge.prev.length;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the absolute value of the area of the face\r\n     * @returns {number}\r\n     */\r\n    area() {\r\n        return Math.abs(this.signedArea());\r\n    }\r\n\r\n    /**\r\n     * Returns signed area of the simple face.\r\n     * Face is simple if it has no self intersections that change its orientation.\r\n     * Then the area will be positive if the orientation of the face is clockwise,\r\n     * and negative if orientation is counterclockwise.\r\n     * It may be zero if polygon is degenerated.\r\n     * @returns {number}\r\n     */\r\n    signedArea() {\r\n        let sArea = 0;\r\n        let ymin = this.box.ymin;\r\n        for (let edge of this) {\r\n            sArea += edge.shape.definiteIntegral(ymin);\r\n        }\r\n        return sArea;\r\n    }\r\n\r\n    /**\r\n     * Return face orientation: one of Flatten.ORIENTATION.CCW, Flatten.ORIENTATION.CW, Flatten.ORIENTATION.NOT_ORIENTABLE <br/>\r\n     * According to Green theorem the area of a closed curve may be calculated as double integral,\r\n     * and the sign of the integral will be defined by the direction of the curve.\r\n     * When the integral (\"signed area\") will be negative, direction is counter clockwise,\r\n     * when positive - clockwise and when it is zero, polygon is not orientable.\r\n     * See {@link https://mathinsight.org/greens_theorem_find_area}\r\n     * @returns {number}\r\n     */\r\n    orientation() {\r\n        if (this._orientation === undefined) {\r\n            let area = this.signedArea();\r\n            if (Flatten.Utils.EQ_0(area)) {\r\n                this._orientation = Flatten.ORIENTATION.NOT_ORIENTABLE;\r\n            } else if (Flatten.Utils.LT(area, 0)) {\r\n                this._orientation = Flatten.ORIENTATION.CCW;\r\n            } else {\r\n                this._orientation = Flatten.ORIENTATION.CW;\r\n            }\r\n        }\r\n        return this._orientation;\r\n    }\r\n\r\n    /**\r\n     * Returns true if face of the polygon is simple (no self-intersection points found)\r\n     * NOTE: this method is incomplete because it does not exclude touching points.\r\n     * Self intersection test should check if polygon change orientation in the test point.\r\n     * @param {Edges} edges - reference to polygon.edges to provide search index\r\n     * @returns {boolean}\r\n     */\r\n    isSimple(edges) {\r\n        let ip = Face.getSelfIntersections(this, edges, true);\r\n        return ip.length == 0;\r\n    }\r\n\r\n    static getSelfIntersections(face, edges, exitOnFirst = false) {\r\n        let int_points = [];\r\n\r\n        // calculate intersections\r\n        for (let edge1 of face) {\r\n\r\n            // request edges of polygon in the box of edge1\r\n            let resp = edges.search(edge1.box);\r\n\r\n            // for each edge2 in response\r\n            for (let edge2 of resp) {\r\n\r\n                // Skip itself\r\n                if (edge1 === edge2)\r\n                    continue;\r\n\r\n                // Skip is edge2 belongs to another face\r\n                if (edge2.face !== face)\r\n                    continue;\r\n\r\n                // Skip next and previous edge if both are segment (if one of them arc - calc intersection)\r\n                if (edge1.shape instanceof Flatten.Segment && edge2.shape instanceof Flatten.Segment &&\r\n                    (edge1.next === edge2 || edge1.prev === edge2))\r\n                    continue;\r\n\r\n                // calculate intersections between edge1 and edge2\r\n                let ip = edge1.shape.intersect(edge2.shape);\r\n\r\n                // for each intersection point\r\n                for (let pt of ip) {\r\n\r\n                    // skip start-end connections\r\n                    if (pt.equalTo(edge1.start) && pt.equalTo(edge2.end) && edge2 === edge1.prev)\r\n                        continue;\r\n                    if (pt.equalTo(edge1.end) && pt.equalTo(edge2.start) && edge2 === edge1.next)\r\n                        continue;\r\n\r\n                    int_points.push(pt);\r\n\r\n                    if (exitOnFirst)\r\n                        break;\r\n                }\r\n\r\n                if (int_points.length > 0 && exitOnFirst)\r\n                    break;\r\n            }\r\n\r\n            if (int_points.length > 0 && exitOnFirst)\r\n                break;\r\n\r\n        }\r\n        return int_points;\r\n    }\r\n\r\n    /**\r\n     * Returns edge which contains given point\r\n     * @param {Point} pt - test point\r\n     * @returns {Edge}\r\n     */\r\n    findEdgeByPoint(pt) {\r\n        let edgeFound;\r\n        for (let edge of this) {\r\n            if (edge.shape.contains(pt)) {\r\n                edgeFound = edge;\r\n                break;\r\n            }\r\n        }\r\n        return edgeFound;\r\n    }\r\n\r\n    /**\r\n     * Returns new polygon created from one face\r\n     * @returns {Polygon}\r\n     */\r\n    toPolygon() {\r\n        return new Flatten.Polygon(this.shapes);\r\n    }\r\n\r\n    toJSON() {\r\n        return this.edges.map(edge => edge.toJSON());\r\n    }\r\n\r\n    /**\r\n     * Returns string to be assigned to \"d\" attribute inside defined \"path\"\r\n     * @returns {string}\r\n     */\r\n    svg() {\r\n        let svgStr = `\\nM${this.first.start.x},${this.first.start.y}`;\r\n        for (let edge of this) {\r\n            svgStr += edge.svg();\r\n        }\r\n        svgStr += ` z`;\r\n        return svgStr;\r\n    }\r\n\r\n}\r\nFlatten.Face = Face;\r\n\r\n/**\r\n * Class representing a ray (a half-infinite line).\r\n * @type {Ray}\r\n */\r\nclass Ray {\r\n    /**\r\n     * Ray may be constructed by setting an <b>origin</b> point and a <b>normal</b> vector, so that any point <b>x</b>\r\n     * on a ray fit an equation: <br />\r\n     *  (<b>x</b> - <b>origin</b>) * <b>vector</b> = 0 <br />\r\n     * Ray defined by constructor is a right semi-infinite line with respect to the normal vector <br/>\r\n     * If normal vector is omitted ray is considered horizontal (normal vector is (0,1)). <br/>\r\n     * Don't be confused: direction of the normal vector is orthogonal to the ray <br/>\r\n     * @param {Point} pt - start point\r\n     * @param {Vector} norm - normal vector\r\n     */\r\n    constructor(...args) {\r\n        this.pt = new Flatten.Point();\r\n        this.norm = new Flatten.Vector(0,1);\r\n\r\n        if (args.length == 0) {\r\n            return;\r\n        }\r\n\r\n        if (args.length >= 1 && args[0] instanceof Flatten.Point) {\r\n            this.pt = args[0].clone();\r\n        }\r\n\r\n        if (args.length === 1) {\r\n            return;\r\n        }\r\n\r\n        if (args.length === 2 && args[1] instanceof Flatten.Vector) {\r\n            this.norm = args[1].clone();\r\n            return;\r\n        }\r\n\r\n        // if (args.length == 2 && typeof (args[0]) == \"number\" && typeof (args[1]) == \"number\") {\r\n        //     this.pt = new Flatten.Point(args[0], args[1]);\r\n        //     return;\r\n        // }\r\n\r\n        throw Flatten.Errors.ILLEGAL_PARAMETERS;\r\n    }\r\n\r\n    /**\r\n     * Return new cloned instance of ray\r\n     * @returns {Ray}\r\n     */\r\n    clone() {\r\n        return new Ray(this.pt, this.norm);\r\n    }\r\n\r\n    /**\r\n     * Slope of the ray - angle in radians between ray and axe x from 0 to 2PI\r\n     * @returns {number} - slope of the line\r\n     */\r\n    get slope() {\r\n        let vec = new Flatten.Vector(this.norm.y, -this.norm.x);\r\n        return vec.slope;\r\n    }\r\n\r\n    /**\r\n     * Returns half-infinite bounding box of the ray\r\n     * @returns {Box} - bounding box\r\n     */\r\n    get box() {\r\n        let slope = this.slope;\r\n        return new Flatten.Box(\r\n            slope > Math.PI/2 && slope < 3*Math.PI/2 ? Number.NEGATIVE_INFINITY : this.pt.x,\r\n            slope >= 0 && slope <= Math.PI ? this.pt.y : Number.NEGATIVE_INFINITY,\r\n            slope >= Math.PI/2 && slope <= 3*Math.PI/2 ? this.pt.x : Number.POSITIVE_INFINITY,\r\n            slope >= Math.PI && slope <= 2*Math.PI || slope == 0 ? this.pt.y : Number.POSITIVE_INFINITY\r\n        )\r\n    }\r\n\r\n    /**\r\n     * Return ray start point\r\n     * @returns {Point} - ray start point\r\n     */\r\n    get start() {\r\n        return this.pt;\r\n    }\r\n\r\n    /**\r\n     * Ray has no end point?\r\n     * @returns {undefined}\r\n     */\r\n    get end() {return undefined;}\r\n\r\n    /**\r\n     * Return positive infinity number as length\r\n     * @returns {number}\r\n     */\r\n    get length() {return Number.POSITIVE_INFINITY;}\r\n\r\n    /**\r\n     * Returns true if point belongs to ray\r\n     * @param {Point} pt Query point\r\n     * @returns {boolean}\r\n     */\r\n    contains(pt) {\r\n        if (this.pt.equalTo(pt)) {\r\n            return true;\r\n        }\r\n        /* Ray contains point if vector to point is orthogonal to the ray normal vector\r\n            and cross product from vector to point is positive */\r\n        let vec = new Flatten.Vector(this.pt, pt);\r\n        return Flatten.Utils.EQ_0(this.norm.dot(vec)) && Flatten.Utils.GE(vec.cross(this.norm),0);\r\n    }\r\n\r\n    /**\r\n     * Split ray with point and return array of segment and new ray\r\n     * @param {Point} pt\r\n     * @returns [Segment,Ray]\r\n     */\r\n    split(pt) {\r\n        if (!this.contains(pt))\r\n            return [];\r\n\r\n        if (this.pt.equalTo(pt)) {\r\n            return [this]\r\n        }\r\n\r\n        return [\r\n            new Flatten.Segment(this.pt, pt),\r\n            new Flatten.Ray(pt, this.norm)\r\n        ]\r\n    }\r\n\r\n    /**\r\n     * Returns array of intersection points between ray and segment or arc\r\n     * @param {Segment|Arc} - Shape to intersect with ray\r\n     * @returns {Array} array of intersection points\r\n     */\r\n    intersect(shape) {\r\n        if (shape instanceof Flatten.Segment) {\r\n            return this.intersectRay2Segment(this, shape);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            return this.intersectRay2Arc(this, shape);\r\n        }\r\n    }\r\n\r\n    intersectRay2Segment(ray, segment) {\r\n        let ip = [];\r\n\r\n        // if (ray.box.not_intersect(segment.box)) {\r\n        //     return ip;\r\n        // }\r\n\r\n        let line = new Flatten.Line(ray.start, ray.norm);\r\n        let ip_tmp = line.intersect(segment);\r\n\r\n        for (let pt of ip_tmp) {\r\n            // if (Flatten.Utils.GE(pt.x, ray.start.x)) {\r\n            if (ray.contains(pt)) {\r\n                ip.push(pt);\r\n            }\r\n        }\r\n\r\n        /* If there were two intersection points between line and ray,\r\n        and now there is exactly one left, it means ray starts between these points\r\n        and there is another intersection point - start of the ray */\r\n        if (ip_tmp.length == 2 && ip.length == 1 && ray.start.on(line)) {\r\n            ip.push(ray.start);\r\n        }\r\n\r\n        return ip;\r\n    }\r\n\r\n    intersectRay2Arc(ray, arc) {\r\n        let ip = [];\r\n\r\n        // if (ray.box.not_intersect(arc.box)) {\r\n        //     return ip;\r\n        // }\r\n\r\n        let line = new Flatten.Line(ray.start, ray.norm);\r\n        let ip_tmp = line.intersect(arc);\r\n\r\n        for (let pt of ip_tmp) {\r\n            // if (Flatten.Utils.GE(pt.x, ray.start.x)) {\r\n            if (ray.contains(pt)) {\r\n                ip.push(pt);\r\n            }\r\n        }\r\n        return ip;\r\n    }\r\n\r\n    /**\r\n     * Return string to draw svg segment representing ray inside given box\r\n     * @param {Box} box Box representing drawing area\r\n     * @param {Object} attrs - an object with attributes of svg segment element\r\n     */\r\n    svg(box, attrs = {}) {\r\n        let line = new Flatten.Line(this.pt, this.norm);\r\n        let ip = intersectLine2Box(line, box);\r\n        ip = ip.filter( pt => this.contains(pt) );\r\n        if (ip.length === 0 || ip.length === 2)\r\n            return \"\";\r\n        let segment = new Flatten.Segment(this.pt, ip[0]);\r\n        return segment.svg(attrs);\r\n    }\r\n\r\n}\r\nFlatten.Ray = Ray;\r\n\r\nconst ray = (...args) => new Flatten.Ray(...args);\r\nFlatten.ray = ray;\r\n\r\n/**\r\n * Created by Alex Bol on 3/15/2017.\r\n */\r\n\r\n/**\r\n * Class representing a polygon.<br/>\r\n * Polygon in FlattenJS is a multipolygon comprised from a set of [faces]{@link Flatten.Face}. <br/>\r\n * Face, in turn, is a closed loop of [edges]{@link Flatten.Edge}, where edge may be segment or circular arc<br/>\r\n * @type {Polygon}\r\n */\r\nclass Polygon {\r\n    /**\r\n     * Constructor creates new instance of polygon. With no arguments new polygon is empty.<br/>\r\n     * Constructor accepts as argument array that define loop of shapes\r\n     * or array of arrays in case of multi polygon <br/>\r\n     * Loop may be defined in different ways: <br/>\r\n     * - array of shapes of type Segment or Arc <br/>\r\n     * - array of points (Flatten.Point) <br/>\r\n     * - array of numeric pairs which represent points <br/>\r\n     * - box or circle object <br/>\r\n     * Alternatively, it is possible to use polygon.addFace method\r\n     * @param {args} - array of shapes or array of arrays\r\n     */\r\n    constructor() {\r\n        /**\r\n         * Container of faces (closed loops), may be empty\r\n         * @type {PlanarSet}\r\n         */\r\n        this.faces = new Flatten.PlanarSet();\r\n        /**\r\n         * Container of edges\r\n         * @type {PlanarSet}\r\n         */\r\n        this.edges = new Flatten.PlanarSet();\r\n\r\n        /* It may be array of something that may represent one loop (face) or\r\n         array of arrays that represent multiple loops\r\n         */\r\n        let args = [...arguments];\r\n        if (args.length === 1 &&\r\n            ((args[0] instanceof Array && args[0].length > 0) ||\r\n                args[0] instanceof Flatten.Circle || args[0] instanceof Flatten.Box)) {\r\n            let argsArray = args[0];\r\n            if (args[0] instanceof Array && args[0].every((loop) => {\r\n                return loop instanceof Array\r\n            })) {\r\n                if (argsArray.every(el => {\r\n                    return el instanceof Array && el.length === 2 && typeof (el[0]) === \"number\" && typeof (el[1]) === \"number\"\r\n                })) {\r\n                    this.faces.add(new Flatten.Face(this, argsArray));    // one-loop polygon as array of pairs of numbers\r\n                } else {\r\n                    for (let loop of argsArray) {   // multi-loop polygon\r\n                        /* Check extra level of nesting for GeoJSON-style multi polygons */\r\n                        if (loop instanceof Array && loop[0] instanceof Array &&\r\n                            loop[0].every(el => {\r\n                                return el instanceof Array && el.length === 2 && typeof (el[0]) === \"number\" && typeof (el[1]) === \"number\"\r\n                            })) {\r\n                            for (let loop1 of loop) {\r\n                                this.faces.add(new Flatten.Face(this, loop1));\r\n                            }\r\n                        } else {\r\n                            this.faces.add(new Flatten.Face(this, loop));\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                this.faces.add(new Flatten.Face(this, argsArray));    // one-loop polygon\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * (Getter) Returns bounding box of the polygon\r\n     * @returns {Box}\r\n     */\r\n    get box() {\r\n        return [...this.faces].reduce((acc, face) => acc.merge(face.box), new Flatten.Box());\r\n    }\r\n\r\n    /**\r\n     * (Getter) Returns array of vertices\r\n     * @returns {Array}\r\n     */\r\n    get vertices() {\r\n        return [...this.edges].map(edge => edge.start);\r\n    }\r\n\r\n    /**\r\n     * Create new cloned instance of the polygon\r\n     * @returns {Polygon}\r\n     */\r\n    clone() {\r\n        let polygon = new Polygon();\r\n        for (let face of this.faces) {\r\n            polygon.addFace(face.shapes);\r\n        }\r\n        return polygon;\r\n    }\r\n\r\n    /**\r\n     * Return true is polygon has no edges\r\n     * @returns {boolean}\r\n     */\r\n    isEmpty() {\r\n        return this.edges.size === 0;\r\n    }\r\n\r\n    /**\r\n     * Return true if polygon is valid for boolean operations\r\n     * Polygon is valid if <br/>\r\n     * 1. All faces are simple polygons (there are no self-intersected polygons) <br/>\r\n     * 2. All faces are orientable and there is no island inside island or hole inside hole - TODO <br/>\r\n     * 3. There is no intersections between faces (excluding touching) - TODO <br/>\r\n     * @returns {boolean}\r\n     */\r\n    isValid() {\r\n        let valid = true;\r\n        // 1. Polygon is invalid if at least one face is not simple\r\n        for (let face of this.faces) {\r\n            if (!face.isSimple(this.edges)) {\r\n                valid = false;\r\n                break;\r\n            }\r\n        }\r\n        // 2. TODO: check if no island inside island and no hole inside hole\r\n        // 3. TODO: check the there is no intersection between faces\r\n        return valid;\r\n    }\r\n\r\n    /**\r\n     * Returns area of the polygon. Area of an island will be added, area of a hole will be subtracted\r\n     * @returns {number}\r\n     */\r\n    area() {\r\n        let signedArea = [...this.faces].reduce((acc, face) => acc + face.signedArea(), 0);\r\n        return Math.abs(signedArea);\r\n    }\r\n\r\n    /**\r\n     * Add new face to polygon. Returns added face\r\n     * @param {Points[]|Segments[]|Arcs[]|Circle|Box} args -  new face may be create with one of the following ways: <br/>\r\n     * 1) array of points that describe closed path (edges are segments) <br/>\r\n     * 2) array of shapes (segments and arcs) which describe closed path <br/>\r\n     * 3) circle - will be added as counterclockwise arc <br/>\r\n     * 4) box - will be added as counterclockwise rectangle <br/>\r\n     * You can chain method face.reverse() is you need to change direction of the creates face\r\n     * @returns {Face}\r\n     */\r\n    addFace(...args) {\r\n        let face = new Flatten.Face(this, ...args);\r\n        this.faces.add(face);\r\n        return face;\r\n    }\r\n\r\n    /**\r\n     * Delete existing face from polygon\r\n     * @param {Face} face Face to be deleted\r\n     * @returns {boolean}\r\n     */\r\n    deleteFace(face) {\r\n        for (let edge of face) {\r\n            this.edges.delete(edge);\r\n        }\r\n        return this.faces.delete(face);\r\n    }\r\n\r\n    /**\r\n     * Clear all faces and create new faces from edges\r\n     */\r\n    recreateFaces() {\r\n        // Remove all faces\r\n        this.faces.clear();\r\n        for (let edge of this.edges) {\r\n            edge.face = null;\r\n        }\r\n\r\n        // Restore faces\r\n        let first;\r\n        let unassignedEdgeFound = true;\r\n        while (unassignedEdgeFound) {\r\n            unassignedEdgeFound = false;\r\n            for (let edge of this.edges) {\r\n                if (edge.face === null) {\r\n                    first = edge;\r\n                    unassignedEdgeFound = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (unassignedEdgeFound) {\r\n                let last = first;\r\n                do {\r\n                    last = last.next;\r\n                } while (last.next !== first)\r\n\r\n                this.addFace(first, last);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete chain of edges from the face.\r\n     * @param {Face} face Face to remove chain\r\n     * @param {Edge} edgeFrom Start of the chain of edges to be removed\r\n     * @param {Edge} edgeTo End of the chain of edges to be removed\r\n     */\r\n    removeChain(face, edgeFrom, edgeTo) {\r\n        // Special case: all edges removed\r\n        if (edgeTo.next === edgeFrom) {\r\n            this.deleteFace(face);\r\n            return;\r\n        }\r\n        for (let edge = edgeFrom; edge !== edgeTo.next; edge = edge.next) {\r\n            face.remove(edge);\r\n            this.edges.delete(edge);      // delete from PlanarSet of edges and update index\r\n            if (face.isEmpty()) {\r\n                this.deleteFace(face);    // delete from PlanarSet of faces and update index\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add point as a new vertex and split edge. Point supposed to belong to an edge.\r\n     * When edge is split, new edge created from the start of the edge to the new vertex\r\n     * and inserted before current edge.\r\n     * Current edge is trimmed and updated.\r\n     * Method returns new edge added. If no edge added, it returns edge before vertex\r\n     * @param {Point} pt Point to be added as a new vertex\r\n     * @param {Edge} edge Edge to be split with new vertex and then trimmed from start\r\n     * @returns {Edge}\r\n     */\r\n    addVertex(pt, edge) {\r\n        let shapes = edge.shape.split(pt);\r\n        // if (shapes.length < 2) return;\r\n\r\n        if (shapes[0] === null)   // point incident to edge start vertex, return previous edge\r\n            return edge.prev;\r\n\r\n        if (shapes[1] === null)   // point incident to edge end vertex, return edge itself\r\n            return edge;\r\n\r\n        let newEdge = new Flatten.Edge(shapes[0]);\r\n        let edgeBefore = edge.prev;\r\n\r\n        /* Insert first split edge into linked list after edgeBefore */\r\n        edge.face.insert(newEdge, edgeBefore);\r\n\r\n        // Remove old edge from edges container and 2d index\r\n        this.edges.delete(edge);\r\n\r\n        // Insert new edge to the edges container and 2d index\r\n        this.edges.add(newEdge);\r\n\r\n        // Update edge shape with second split edge keeping links\r\n        edge.shape = shapes[1];\r\n\r\n        // Add updated edge to the edges container and 2d index\r\n        this.edges.add(edge);\r\n\r\n        return newEdge;\r\n    }\r\n\r\n    /**\r\n     * Cut polygon with multiline and return array of new polygons\r\n     * Multiline should be constructed from a line with intersection point, see notebook:\r\n     * https://next.observablehq.com/@alexbol99/cut-polygon-with-line\r\n     * @param {Multiline} multiline\r\n     * @returns {Polygon[]}\r\n     */\r\n    cut(multiline) {\r\n        let cutPolygons = [this.clone()];\r\n        for (let edge of multiline) {\r\n            if (edge.setInclusion(this) !== INSIDE)\r\n                continue;\r\n\r\n            let cut_edge_start = edge.shape.start;\r\n            let cut_edge_end = edge.shape.end;\r\n\r\n            let newCutPolygons = [];\r\n            for (let polygon of cutPolygons) {\r\n                if (polygon.findEdgeByPoint(cut_edge_start) === undefined) {\r\n                    newCutPolygons.push(polygon);\r\n                } else {\r\n                    let [cutPoly1, cutPoly2] = polygon.cutFace(cut_edge_start, cut_edge_end);\r\n                    newCutPolygons.push(cutPoly1, cutPoly2);\r\n                }\r\n            }\r\n            cutPolygons = newCutPolygons;\r\n        }\r\n        return cutPolygons;\r\n    }\r\n\r\n    /**\r\n     * Cut face of polygon with a segment between two points and create two new polygons\r\n     * Supposed that a segments between points does not intersect any other edge\r\n     * @param {Point} pt1\r\n     * @param {Point} pt2\r\n     * @returns {Polygon[]}\r\n     */\r\n    cutFace(pt1, pt2) {\r\n        let edge1 = this.findEdgeByPoint(pt1);\r\n        let edge2 = this.findEdgeByPoint(pt2);\r\n        if (edge1.face !== edge2.face)\r\n            return [];\r\n\r\n        // Cut face into two and create new polygon with two faces\r\n        let edgeBefore1 = this.addVertex(pt1, edge1);\r\n        edge2 = this.findEdgeByPoint(pt2);\r\n        let edgeBefore2 = this.addVertex(pt2, edge2);\r\n\r\n        let face = edgeBefore1.face;\r\n        let newEdge1 = new Flatten.Edge(\r\n            new Flatten.Segment(edgeBefore1.end, edgeBefore2.end)\r\n        );\r\n        let newEdge2 = new Flatten.Edge(\r\n            new Flatten.Segment(edgeBefore2.end, edgeBefore1.end)\r\n        );\r\n\r\n        // Swap links\r\n        edgeBefore1.next.prev = newEdge2;\r\n        newEdge2.next = edgeBefore1.next;\r\n\r\n        edgeBefore1.next = newEdge1;\r\n        newEdge1.prev = edgeBefore1;\r\n\r\n        edgeBefore2.next.prev = newEdge1;\r\n        newEdge1.next = edgeBefore2.next;\r\n\r\n        edgeBefore2.next = newEdge2;\r\n        newEdge2.prev = edgeBefore2;\r\n\r\n        // Insert new edge to the edges container and 2d index\r\n        this.edges.add(newEdge1);\r\n        this.edges.add(newEdge2);\r\n\r\n        // Add two new faces\r\n        let face1 = this.addFace(newEdge1, edgeBefore1);\r\n        let face2 = this.addFace(newEdge2, edgeBefore2);\r\n\r\n        // Remove old face\r\n        this.faces.delete(face);\r\n\r\n        return [face1.toPolygon(), face2.toPolygon()];\r\n    }\r\n\r\n    /**\r\n     * Return a result of cutting polygon with line\r\n     * @param {Line} line - cutting line\r\n     * @returns {Polygon} newPoly - resulted polygon\r\n     */\r\n    cutWithLine(line) {\r\n        let newPoly = this.clone();\r\n\r\n        let multiline = new Multiline([line]);\r\n\r\n        // smart intersections\r\n        let intersections = {\r\n            int_points1: [],\r\n            int_points2: [],\r\n            int_points1_sorted: [],\r\n            int_points2_sorted: []\r\n        };\r\n\r\n        // intersect line with each edge of the polygon\r\n        // and create smart intersections\r\n        for (let edge of newPoly.edges) {\r\n            let ip = intersectEdge2Line(edge, line);\r\n            // for each intersection point\r\n            for (let pt of ip) {\r\n                addToIntPoints(multiline.first, pt, intersections.int_points1);\r\n                addToIntPoints(edge, pt, intersections.int_points2);\r\n            }\r\n        }\r\n\r\n        // No intersections - return a copy of the original polygon\r\n        if (intersections.int_points1.length === 0)\r\n            return newPoly;\r\n\r\n        // sort smart intersections\r\n        intersections.int_points1_sorted = getSortedArrayOnLine(line, intersections.int_points1);\r\n        intersections.int_points2_sorted = getSortedArray(intersections.int_points2);\r\n\r\n        // split by intersection points\r\n        splitByIntersections(multiline, intersections.int_points1_sorted);\r\n        splitByIntersections(newPoly, intersections.int_points2_sorted);\r\n\r\n        // filter duplicated intersection points\r\n        filterDuplicatedIntersections(intersections);\r\n\r\n        // sort intersection points again after filtering\r\n        intersections.int_points1_sorted = getSortedArrayOnLine(line, intersections.int_points1);\r\n        intersections.int_points2_sorted = getSortedArray(intersections.int_points2);\r\n\r\n        // initialize inclusion flags for edges of multiline incident to intersections\r\n        initializeInclusionFlags(intersections.int_points1);\r\n\r\n        // calculate inclusion flag for edges of multiline incident to intersections\r\n        calculateInclusionFlags(intersections.int_points1, newPoly);\r\n\r\n        // filter intersections between two edges that got same inclusion flag\r\n        for (let int_point1 of intersections.int_points1_sorted) {\r\n            if (int_point1.edge_before.bv === int_point1.edge_after.bv) {\r\n                intersections.int_points2[int_point1.id] = -1;   // to be filtered out\r\n                int_point1.id = -1;                              // to be filtered out\r\n            }\r\n        }\r\n        intersections.int_points1 = intersections.int_points1.filter( int_point => int_point.id >= 0);\r\n        intersections.int_points2 = intersections.int_points2.filter( int_point => int_point.id >= 0);\r\n\r\n        // No intersections left after filtering - return a copy of the original polygon\r\n        if (intersections.int_points1.length === 0)\r\n            return newPoly;\r\n\r\n        // sort intersection points 3d time after filtering\r\n        intersections.int_points1_sorted = getSortedArrayOnLine(line, intersections.int_points1);\r\n        intersections.int_points2_sorted = getSortedArray(intersections.int_points2);\r\n\r\n        // Add 2 new inner edges between intersection points\r\n        let int_point1_prev = intersections.int_points1[0];\r\n        let new_edge;\r\n        for (let int_point1_curr of intersections.int_points1_sorted) {\r\n            if (int_point1_curr.edge_before.bv === INSIDE) {\r\n                new_edge = new Flatten.Edge(new Flatten.Segment(int_point1_prev.pt, int_point1_curr.pt));    // (int_point1_curr.edge_before.shape);\r\n                insertBetweenIntPoints(intersections.int_points2[int_point1_prev.id], intersections.int_points2[int_point1_curr.id], new_edge);\r\n                newPoly.edges.add(new_edge);\r\n\r\n                new_edge = new Flatten.Edge(new Flatten.Segment(int_point1_curr.pt, int_point1_prev.pt));    // (int_point1_curr.edge_before.shape.reverse());\r\n                insertBetweenIntPoints(intersections.int_points2[int_point1_curr.id], intersections.int_points2[int_point1_prev.id], new_edge);\r\n                newPoly.edges.add(new_edge);\r\n            }\r\n            int_point1_prev = int_point1_curr;\r\n        }\r\n\r\n        // Recreate faces\r\n        newPoly.recreateFaces();\r\n        return newPoly;\r\n    }\r\n\r\n    /**\r\n     * Returns the first founded edge of polygon that contains given point\r\n     * @param {Point} pt\r\n     * @returns {Edge}\r\n     */\r\n    findEdgeByPoint(pt) {\r\n        let edge;\r\n        for (let face of this.faces) {\r\n            edge = face.findEdgeByPoint(pt);\r\n            if (edge !== undefined)\r\n                break;\r\n        }\r\n        return edge;\r\n    }\r\n\r\n    /**\r\n     * Split polygon into array of polygons, where each polygon is an island with all\r\n     * hole that it contains\r\n     * @returns {Flatten.Polygon[]}\r\n     */\r\n    splitToIslands() {\r\n        if (this.isEmpty()) return [];      // return empty array if polygon is empty\r\n        let polygons = this.toArray();      // split into array of one-loop polygons\r\n        /* Sort polygons by area in descending order */\r\n        polygons.sort((polygon1, polygon2) => polygon2.area() - polygon1.area());\r\n        /* define orientation of the island by orientation of the first polygon in array */\r\n        let orientation = [...polygons[0].faces][0].orientation();\r\n        /* Create output array from polygons with same orientation as a first polygon (array of islands) */\r\n        let newPolygons = polygons.filter(polygon => [...polygon.faces][0].orientation() === orientation);\r\n        for (let polygon of polygons) {\r\n            let face = [...polygon.faces][0];\r\n            if (face.orientation() === orientation) continue;  // skip same orientation\r\n            /* Proceed with opposite orientation */\r\n            /* Look if any of island polygons contains tested polygon as a hole */\r\n            for (let islandPolygon of newPolygons) {\r\n                if (face.shapes.every(shape => islandPolygon.contains(shape))) {\r\n                    islandPolygon.addFace(face.shapes);      // add polygon as a hole in islandPolygon\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // TODO: assert if not all polygons added into output\r\n        return newPolygons;\r\n    }\r\n\r\n    /**\r\n     * Reverse orientation of all faces to opposite\r\n     * @returns {Polygon}\r\n     */\r\n    reverse() {\r\n        for (let face of this.faces) {\r\n            face.reverse();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns true if polygon contains shape: no point of shape lay outside of the polygon,\r\n     * false otherwise\r\n     * @param {Shape} shape - test shape\r\n     * @returns {boolean}\r\n     */\r\n    contains(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            let rel = ray_shoot(this, shape);\r\n            return rel === INSIDE || rel === BOUNDARY;\r\n        } else {\r\n            return cover(this, shape);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return distance and shortest segment between polygon and other shape as array [distance, shortest_segment]\r\n     * @param {Shape} shape Shape of one of the types Point, Circle, Line, Segment, Arc or Polygon\r\n     * @returns {Number | Segment}\r\n     */\r\n    distanceTo(shape) {\r\n        // let {Distance} = Flatten;\r\n\r\n        if (shape instanceof Flatten.Point) {\r\n            let [dist, shortest_segment] = Flatten.Distance.point2polygon(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle ||\r\n            shape instanceof Flatten.Line ||\r\n            shape instanceof Flatten.Segment ||\r\n            shape instanceof Flatten.Arc) {\r\n            let [dist, shortest_segment] = Flatten.Distance.shape2polygon(shape, this);\r\n            shortest_segment = shortest_segment.reverse();\r\n            return [dist, shortest_segment];\r\n        }\r\n\r\n        /* this method is bit faster */\r\n        if (shape instanceof Flatten.Polygon) {\r\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\r\n            let dist, shortest_segment;\r\n\r\n            for (let edge of this.edges) {\r\n                // let [dist, shortest_segment] = Distance.shape2polygon(edge.shape, shape);\r\n                let min_stop = min_dist_and_segment[0];\r\n                [dist, shortest_segment] = Flatten.Distance.shape2planarSet(edge.shape, shape.edges, min_stop);\r\n                if (Flatten.Utils.LT(dist, min_stop)) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n            return min_dist_and_segment;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return array of intersection points between polygon and other shape\r\n     * @param shape Shape of the one of supported types <br/>\r\n     * @returns {Point[]}\r\n     */\r\n    intersect(shape) {\r\n        if (shape instanceof Flatten.Point) {\r\n            return this.contains(shape) ? [shape] : [];\r\n        }\r\n\r\n        if (shape instanceof Flatten.Line) {\r\n            return intersectLine2Polygon(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Circle) {\r\n            return intersectCircle2Polygon(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Segment) {\r\n            return intersectSegment2Polygon(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Arc) {\r\n            return intersectArc2Polygon(shape, this);\r\n        }\r\n\r\n        if (shape instanceof Flatten.Polygon) {\r\n            return intersectPolygon2Polygon(shape, this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns new polygon translated by vector vec\r\n     * @param {Vector} vec\r\n     * @returns {Polygon}\r\n     */\r\n    translate(vec) {\r\n        let newPolygon = new Polygon();\r\n        for (let face of this.faces) {\r\n            newPolygon.addFace(face.shapes.map(shape => shape.translate(vec)));\r\n        }\r\n        return newPolygon;\r\n    }\r\n\r\n    /**\r\n     * Return new polygon rotated by given angle around given point\r\n     * If point omitted, rotate around origin (0,0)\r\n     * Positive value of angle defines rotation counter clockwise, negative - clockwise\r\n     * @param {number} angle - rotation angle in radians\r\n     * @param {Point} center - rotation center, default is (0,0)\r\n     * @returns {Polygon} - new rotated polygon\r\n     */\r\n    rotate(angle = 0, center = new Flatten.Point()) {\r\n        let newPolygon = new Polygon();\r\n        for (let face of this.faces) {\r\n            newPolygon.addFace(face.shapes.map(shape => shape.rotate(angle, center)));\r\n        }\r\n        return newPolygon;\r\n    }\r\n\r\n    /**\r\n     * Return new polygon transformed using affine transformation matrix\r\n     * @param {Matrix} matrix - affine transformation matrix\r\n     * @returns {Polygon} - new polygon\r\n     */\r\n    transform(matrix = new Flatten.Matrix()) {\r\n        let newPolygon = new Polygon();\r\n        for (let face of this.faces) {\r\n            newPolygon.addFace(face.shapes.map(shape => shape.transform(matrix)));\r\n        }\r\n        return newPolygon;\r\n    }\r\n\r\n    /**\r\n     * This method returns an object that defines how data will be\r\n     * serialized when called JSON.stringify() method\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n        return [...this.faces].map(face => face.toJSON());\r\n    }\r\n\r\n    /**\r\n     * Transform all faces into array of polygons\r\n     * @returns {Flatten.Polygon[]}\r\n     */\r\n    toArray() {\r\n        return [...this.faces].map(face => face.toPolygon());\r\n    }\r\n\r\n    /**\r\n     * Return string to draw polygon in svg\r\n     * @param attrs  - an object with attributes for svg path element,\r\n     * like \"stroke\", \"strokeWidth\", \"fill\", \"fillRule\", \"fillOpacity\"\r\n     * Defaults are stroke:\"black\", strokeWidth:\"1\", fill:\"lightcyan\", fillRule:\"evenodd\", fillOpacity: \"1\"\r\n     * @returns {string}\r\n     */\r\n    svg(attrs = {}) {\r\n        let {stroke, strokeWidth, fill, fillRule, fillOpacity, id, className} = attrs;\r\n        // let restStr = Object.keys(rest).reduce( (acc, key) => acc += ` ${key}=\"${rest[key]}\"`, \"\");\r\n        let id_str = (id && id.length > 0) ? `id=\"${id}\"` : \"\";\r\n        let class_str = (className && className.length > 0) ? `class=\"${className}\"` : \"\";\r\n\r\n        let svgStr = `\\n<path stroke=\"${stroke || \"black\"}\" stroke-width=\"${strokeWidth || 1}\" fill=\"${fill || \"lightcyan\"}\" fill-rule=\"${fillRule || \"evenodd\"}\" fill-opacity=\"${fillOpacity || 1.0}\" ${id_str} ${class_str} d=\"`;\r\n        for (let face of this.faces) {\r\n            svgStr += face.svg();\r\n        }\r\n        svgStr += `\" >\\n</path>`;\r\n        return svgStr;\r\n    }\r\n}\r\n\r\nFlatten.Polygon = Polygon;\r\n\r\n/**\r\n * Shortcut method to create new polygon\r\n */\r\nconst polygon = (...args) => new Flatten.Polygon(...args);\r\nFlatten.polygon = polygon;\r\n\r\nconst {Circle: Circle$1, Line: Line$1, Point: Point$1, Vector: Vector$1, Utils: Utils$1} = Flatten;\r\n/**\r\n * Class Inversion represent operator of inversion in circle\r\n * Inversion is a transformation of the Euclidean plane that maps generalized circles\r\n * (where line is considered as a circle with infinite radius) into generalized circles\r\n * See also https://en.wikipedia.org/wiki/Inversive_geometry and\r\n * http://mathworld.wolfram.com/Inversion.html <br/>\r\n * @type {Inversion}\r\n */\r\nclass Inversion {\r\n    /**\r\n     * Inversion constructor\r\n     * @param {Circle} inversion_circle inversion circle\r\n     */\r\n    constructor(inversion_circle) {\r\n        this.circle = inversion_circle;\r\n    }\r\n\r\n\r\n    get inversion_circle() {\r\n        return this.circle;\r\n    }\r\n\r\n    static inversePoint(inversion_circle, point) {\r\n        const v = new Vector$1(inversion_circle.pc, point);\r\n        const k2 = inversion_circle.r * inversion_circle.r;\r\n        const len2 = v.dot(v);\r\n        const reflected_point = Utils$1.EQ_0(len2) ?\r\n            new Point$1(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY) :\r\n            inversion_circle.pc.translate(v.multiply(k2 / len2));\r\n        return reflected_point;\r\n    }\r\n\r\n    static inverseCircle(inversion_circle, circle) {\r\n        const dist = inversion_circle.pc.distanceTo(circle.pc)[0];\r\n        if (Utils$1.EQ(dist, circle.r)) {     // Circle passing through inversion center mapped into line\r\n            let d = (inversion_circle.r * inversion_circle.r) / (2 * circle.r);\r\n            let v = new Vector$1(inversion_circle.pc, circle.pc);\r\n            v = v.normalize();\r\n            let pt = inversion_circle.pc.translate(v.multiply(d));\r\n\r\n            return new Line$1(pt, v);\r\n        } else {                           // Circle not passing through inversion center - map into another circle */\r\n            /* Taken from http://mathworld.wolfram.com */\r\n            let v = new Vector$1(inversion_circle.pc, circle.pc);\r\n            let s = inversion_circle.r * inversion_circle.r / (v.dot(v) - circle.r * circle.r);\r\n            let pc = inversion_circle.pc.translate(v.multiply(s));\r\n            let r = Math.abs(s) * circle.r;\r\n\r\n            return new Circle$1(pc, r);\r\n        }\r\n    }\r\n\r\n    static inverseLine(inversion_circle, line) {\r\n        const [dist, shortest_segment] = inversion_circle.pc.distanceTo(line);\r\n        if (Utils$1.EQ_0(dist)) {            // Line passing through inversion center, is mapping to itself\r\n            return line.clone();\r\n        } else {                           // Line not passing through inversion center is mapping into circle\r\n            let r = inversion_circle.r * inversion_circle.r / (2 * dist);\r\n            let v = new Vector$1(inversion_circle.pc, shortest_segment.end);\r\n            v = v.multiply(r / dist);\r\n            return new Circle$1(inversion_circle.pc.translate(v), r);\r\n        }\r\n    }\r\n\r\n    inverse(shape) {\r\n        if (shape instanceof Point$1) {\r\n            return Inversion.inversePoint(this.circle, shape);\r\n        }\r\n        else if (shape instanceof Circle$1) {\r\n            return Inversion.inverseCircle(this.circle, shape);\r\n        }\r\n        else if (shape instanceof Line$1) {\r\n            return Inversion.inverseLine(this.circle, shape);\r\n        }\r\n    }\r\n}\r\nFlatten.Inversion = Inversion;\r\n\r\n/**\r\n * Shortcut to create inversion operator\r\n * @param circle\r\n * @returns {Inversion}\r\n */\r\nconst inversion = (circle) => new Flatten.Inversion(circle);\r\nFlatten.inversion = inversion;\r\n\r\nclass Distance {\r\n    /**\r\n     * Calculate distance and shortest segment between points\r\n     * @param pt1\r\n     * @param pt2\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static point2point(pt1, pt2) {\r\n        return pt1.distanceTo(pt2);\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between point and line\r\n     * @param pt\r\n     * @param line\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static point2line(pt, line) {\r\n        let closest_point = pt.projectionOn(line);\r\n        let vec = new Flatten.Vector(pt, closest_point);\r\n        return [vec.length, new Flatten.Segment(pt, closest_point)];\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between point and circle\r\n     * @param pt\r\n     * @param circle\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static point2circle(pt, circle) {\r\n        let [dist2center, shortest_dist] = pt.distanceTo(circle.center);\r\n        if (Flatten.Utils.EQ_0(dist2center)) {\r\n            return [circle.r, new Flatten.Segment(pt, circle.toArc().start)];\r\n        } else {\r\n            let dist = Math.abs(dist2center - circle.r);\r\n            let v = new Flatten.Vector(circle.pc, pt).normalize().multiply(circle.r);\r\n            let closest_point = circle.pc.translate(v);\r\n            return [dist, new Flatten.Segment(pt, closest_point)];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between point and segment\r\n     * @param pt\r\n     * @param segment\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static point2segment(pt, segment) {\r\n        /* Degenerated case of zero-length segment */\r\n        if (segment.start.equalTo(segment.end)) {\r\n            return Distance.point2point(pt, segment.start);\r\n        }\r\n\r\n        let v_seg = new Flatten.Vector(segment.start, segment.end);\r\n        let v_ps2pt = new Flatten.Vector(segment.start, pt);\r\n        let v_pe2pt = new Flatten.Vector(segment.end, pt);\r\n        let start_sp = v_seg.dot(v_ps2pt);\r\n        /* dot product v_seg * v_ps2pt */\r\n        let end_sp = -v_seg.dot(v_pe2pt);\r\n        /* minus dot product v_seg * v_pe2pt */\r\n\r\n        let dist;\r\n        let closest_point;\r\n        if (Flatten.Utils.GE(start_sp, 0) && Flatten.Utils.GE(end_sp, 0)) {    /* point inside segment scope */\r\n            let v_unit = segment.tangentInStart(); // new Flatten.Vector(v_seg.x / this.length, v_seg.y / this.length);\r\n            /* unit vector ||v_unit|| = 1 */\r\n            dist = Math.abs(v_unit.cross(v_ps2pt));\r\n            /* dist = abs(v_unit x v_ps2pt) */\r\n            closest_point = segment.start.translate(v_unit.multiply(v_unit.dot(v_ps2pt)));\r\n            return [dist, new Flatten.Segment(pt, closest_point)];\r\n        } else if (start_sp < 0) {                             /* point is out of scope closer to ps */\r\n            return pt.distanceTo(segment.start);\r\n        } else {                                               /* point is out of scope closer to pe */\r\n            return pt.distanceTo(segment.end);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between point and arc\r\n     * @param pt\r\n     * @param arc\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static point2arc(pt, arc) {\r\n        let circle = new Flatten.Circle(arc.pc, arc.r);\r\n        let dist_and_segment = [];\r\n        let dist, shortest_segment;\r\n        [dist, shortest_segment] = Distance.point2circle(pt, circle);\r\n        if (shortest_segment.end.on(arc)) {\r\n            dist_and_segment.push(Distance.point2circle(pt, circle));\r\n        }\r\n        dist_and_segment.push(Distance.point2point(pt, arc.start));\r\n        dist_and_segment.push(Distance.point2point(pt, arc.end));\r\n\r\n        Distance.sort(dist_and_segment);\r\n\r\n        return dist_and_segment[0];\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between segment and line\r\n     * @param seg\r\n     * @param line\r\n     * @returns {Number | Segment}\r\n     */\r\n    static segment2line(seg, line) {\r\n        let ip = seg.intersect(line);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];   // distance = 0, closest point is the first point\r\n        }\r\n        let dist_and_segment = [];\r\n        dist_and_segment.push(Distance.point2line(seg.start, line));\r\n        dist_and_segment.push(Distance.point2line(seg.end, line));\r\n\r\n        Distance.sort(dist_and_segment);\r\n        return dist_and_segment[0];\r\n\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between two segments\r\n     * @param seg1\r\n     * @param seg2\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static segment2segment(seg1, seg2) {\r\n        let ip = intersectSegment2Segment(seg1, seg2);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];   // distance = 0, closest point is the first point\r\n        }\r\n\r\n        // Seg1 and seg2 not intersected\r\n        let dist_and_segment = [];\r\n        let dist_tmp, shortest_segment_tmp;\r\n        [dist_tmp, shortest_segment_tmp] = Distance.point2segment(seg2.start, seg1);\r\n        dist_and_segment.push([dist_tmp, shortest_segment_tmp.reverse()]);\r\n        [dist_tmp, shortest_segment_tmp] = Distance.point2segment(seg2.end, seg1);\r\n        dist_and_segment.push([dist_tmp, shortest_segment_tmp.reverse()]);\r\n        dist_and_segment.push(Distance.point2segment(seg1.start, seg2));\r\n        dist_and_segment.push(Distance.point2segment(seg1.end, seg2));\r\n\r\n        Distance.sort(dist_and_segment);\r\n        return dist_and_segment[0];\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between segment and circle\r\n     * @param seg\r\n     * @param circle\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static segment2circle(seg, circle) {\r\n        /* Case 1 Segment and circle intersected. Return the first point and zero distance */\r\n        let ip = seg.intersect(circle);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];\r\n        }\r\n\r\n        // No intersection between segment and circle\r\n\r\n        /* Case 2. Distance to projection of center point to line bigger than radius\r\n         * And projection point belong to segment\r\n          * Then measure again distance from projection to circle and return it */\r\n        let line = new Flatten.Line(seg.ps, seg.pe);\r\n        let [dist, shortest_segment] = Distance.point2line(circle.center, line);\r\n        if (Flatten.Utils.GE(dist, circle.r) && shortest_segment.end.on(seg)) {\r\n            return Distance.point2circle(shortest_segment.end, circle);\r\n        }\r\n        /* Case 3. Otherwise closest point is one of the end points of the segment */\r\n        else {\r\n            let [dist_from_start, shortest_segment_from_start] = Distance.point2circle(seg.start, circle);\r\n            let [dist_from_end, shortest_segment_from_end] = Distance.point2circle(seg.end, circle);\r\n            return Flatten.Utils.LT(dist_from_start, dist_from_end) ?\r\n                [dist_from_start, shortest_segment_from_start] :\r\n                [dist_from_end, shortest_segment_from_end];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between segment and arc\r\n     * @param seg\r\n     * @param arc\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static segment2arc(seg, arc) {\r\n        /* Case 1 Segment and arc intersected. Return the first point and zero distance */\r\n        let ip = seg.intersect(arc);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];\r\n        }\r\n\r\n        // No intersection between segment and arc\r\n        let line = new Flatten.Line(seg.ps, seg.pe);\r\n        let circle = new Flatten.Circle(arc.pc, arc.r);\r\n\r\n        /* Case 2. Distance to projection of center point to line bigger than radius AND\r\n         * projection point belongs to segment AND\r\n           * distance from projection point to circle belongs to arc  =>\r\n           * return this distance from projection to circle */\r\n        let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\r\n        if (Flatten.Utils.GE(dist_from_center, circle.r) && shortest_segment_from_center.end.on(seg)) {\r\n            let [dist_from_projection, shortest_segment_from_projection] =\r\n                Distance.point2circle(shortest_segment_from_center.end, circle);\r\n            if (shortest_segment_from_projection.end.on(arc)) {\r\n                return [dist_from_projection, shortest_segment_from_projection];\r\n            }\r\n        }\r\n        /* Case 3. Otherwise closest point is one of the end points of the segment */\r\n        let dist_and_segment = [];\r\n        dist_and_segment.push(Distance.point2arc(seg.start, arc));\r\n        dist_and_segment.push(Distance.point2arc(seg.end, arc));\r\n\r\n        let dist_tmp, segment_tmp;\r\n        [dist_tmp, segment_tmp] = Distance.point2segment(arc.start, seg);\r\n        dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n\r\n        [dist_tmp, segment_tmp] = Distance.point2segment(arc.end, seg);\r\n        dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n\r\n        Distance.sort(dist_and_segment);\r\n        return dist_and_segment[0];\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between two circles\r\n     * @param circle1\r\n     * @param circle2\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static circle2circle(circle1, circle2) {\r\n        let ip = circle1.intersect(circle2);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];\r\n        }\r\n\r\n        // Case 1. Concentric circles. Convert to arcs and take distance between two arc starts\r\n        if (circle1.center.equalTo(circle2.center)) {\r\n            let arc1 = circle1.toArc();\r\n            let arc2 = circle2.toArc();\r\n            return Distance.point2point(arc1.start, arc2.start);\r\n        } else {\r\n            // Case 2. Not concentric circles\r\n            let line = new Flatten.Line(circle1.center, circle2.center);\r\n            let ip1 = line.intersect(circle1);\r\n            let ip2 = line.intersect(circle2);\r\n\r\n            let dist_and_segment = [];\r\n\r\n            dist_and_segment.push(Distance.point2point(ip1[0], ip2[0]));\r\n            dist_and_segment.push(Distance.point2point(ip1[0], ip2[1]));\r\n            dist_and_segment.push(Distance.point2point(ip1[1], ip2[0]));\r\n            dist_and_segment.push(Distance.point2point(ip1[1], ip2[1]));\r\n\r\n            Distance.sort(dist_and_segment);\r\n            return dist_and_segment[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between two circles\r\n     * @param circle\r\n     * @param line\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static circle2line(circle, line) {\r\n        let ip = circle.intersect(line);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];\r\n        }\r\n\r\n        let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\r\n        let [dist, shortest_segment] = Distance.point2circle(shortest_segment_from_center.end, circle);\r\n        shortest_segment = shortest_segment.reverse();\r\n        return [dist, shortest_segment];\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between arc and line\r\n     * @param arc\r\n     * @param line\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static arc2line(arc, line) {\r\n        /* Case 1 Line and arc intersected. Return the first point and zero distance */\r\n        let ip = line.intersect(arc);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];\r\n        }\r\n\r\n        let circle = new Flatten.Circle(arc.center, arc.r);\r\n\r\n        /* Case 2. Distance to projection of center point to line bigger than radius AND\r\n         * projection point belongs to segment AND\r\n           * distance from projection point to circle belongs to arc  =>\r\n           * return this distance from projection to circle */\r\n        let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\r\n        if (Flatten.Utils.GE(dist_from_center, circle.r)) {\r\n            let [dist_from_projection, shortest_segment_from_projection] =\r\n                Distance.point2circle(shortest_segment_from_center.end, circle);\r\n            if (shortest_segment_from_projection.end.on(arc)) {\r\n                return [dist_from_projection, shortest_segment_from_projection];\r\n            }\r\n        } else {\r\n            let dist_and_segment = [];\r\n            dist_and_segment.push(Distance.point2line(arc.start, line));\r\n            dist_and_segment.push(Distance.point2line(arc.end, line));\r\n\r\n            Distance.sort(dist_and_segment);\r\n            return dist_and_segment[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between arc and circle\r\n     * @param arc\r\n     * @param circle2\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static arc2circle(arc, circle2) {\r\n        let ip = arc.intersect(circle2);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];\r\n        }\r\n\r\n        let circle1 = new Flatten.Circle(arc.center, arc.r);\r\n\r\n        let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);\r\n        if (shortest_segment.start.on(arc)) {\r\n            return [dist, shortest_segment];\r\n        } else {\r\n            let dist_and_segment = [];\r\n\r\n            dist_and_segment.push(Distance.point2circle(arc.start, circle2));\r\n            dist_and_segment.push(Distance.point2circle(arc.end, circle2));\r\n\r\n            Distance.sort(dist_and_segment);\r\n\r\n            return dist_and_segment[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between two arcs\r\n     * @param arc1\r\n     * @param arc2\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static arc2arc(arc1, arc2) {\r\n        let ip = arc1.intersect(arc2);\r\n        if (ip.length > 0) {\r\n            return [0, new Flatten.Segment(ip[0], ip[0])];\r\n        }\r\n\r\n        let circle1 = new Flatten.Circle(arc1.center, arc1.r);\r\n        let circle2 = new Flatten.Circle(arc2.center, arc2.r);\r\n\r\n        let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);\r\n        if (shortest_segment.start.on(arc1) && shortest_segment.end.on(arc2)) {\r\n            return [dist, shortest_segment];\r\n        } else {\r\n            let dist_and_segment = [];\r\n\r\n            let dist_tmp, segment_tmp;\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc1.start, arc2);\r\n            if (segment_tmp.end.on(arc2)) {\r\n                dist_and_segment.push([dist_tmp, segment_tmp]);\r\n            }\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc1.end, arc2);\r\n            if (segment_tmp.end.on(arc2)) {\r\n                dist_and_segment.push([dist_tmp, segment_tmp]);\r\n            }\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc2.start, arc1);\r\n            if (segment_tmp.end.on(arc1)) {\r\n                dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n            }\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc2.end, arc1);\r\n            if (segment_tmp.end.on(arc1)) {\r\n                dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\r\n            }\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.start);\r\n            dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.end);\r\n            dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.start);\r\n            dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.end);\r\n            dist_and_segment.push([dist_tmp, segment_tmp]);\r\n\r\n            Distance.sort(dist_and_segment);\r\n\r\n            return dist_and_segment[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between point and polygon\r\n     * @param point\r\n     * @param polygon\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static point2polygon(point, polygon) {\r\n        let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\r\n        for (let edge of polygon.edges) {\r\n            let [dist, shortest_segment] = (edge.shape instanceof Flatten.Segment) ?\r\n                Distance.point2segment(point, edge.shape) : Distance.point2arc(point, edge.shape);\r\n            if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                min_dist_and_segment = [dist, shortest_segment];\r\n            }\r\n        }\r\n        return min_dist_and_segment;\r\n    }\r\n\r\n    static shape2polygon(shape, polygon) {\r\n        let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\r\n        for (let edge of polygon.edges) {\r\n            let [dist, shortest_segment] = shape.distanceTo(edge.shape);\r\n            if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                min_dist_and_segment = [dist, shortest_segment];\r\n            }\r\n        }\r\n        return min_dist_and_segment;\r\n    }\r\n\r\n    /**\r\n     * Calculate distance and shortest segment between two polygons\r\n     * @param polygon1\r\n     * @param polygon2\r\n     * @returns {Number | Segment} - distance and shortest segment\r\n     */\r\n    static polygon2polygon(polygon1, polygon2) {\r\n        let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\r\n        for (let edge1 of polygon1.edges) {\r\n            for (let edge2 of polygon2.edges) {\r\n                let [dist, shortest_segment] = edge1.shape.distanceTo(edge2.shape);\r\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\r\n                    min_dist_and_segment = [dist, shortest_segment];\r\n                }\r\n            }\r\n        }\r\n        return min_dist_and_segment;\r\n    }\r\n\r\n    /**\r\n     * Returns [mindist, maxdist] array of squared minimal and maximal distance between boxes\r\n     * Minimal distance by x is\r\n     *    (box2.xmin - box1.xmax), if box1 is left to box2\r\n     *    (box1.xmin - box2.xmax), if box2 is left to box1\r\n     *    0,                       if box1 and box2 are intersected by x\r\n     * Minimal distance by y is defined in the same way\r\n     *\r\n     * Maximal distance is estimated as a sum of squared dimensions of the merged box\r\n     *\r\n     * @param box1\r\n     * @param box2\r\n     * @returns {Number | Number} - minimal and maximal distance\r\n     */\r\n    static box2box_minmax(box1, box2) {\r\n        let mindist_x = Math.max(Math.max(box1.xmin - box2.xmax, 0), Math.max(box2.xmin - box1.xmax, 0));\r\n        let mindist_y = Math.max(Math.max(box1.ymin - box2.ymax, 0), Math.max(box2.ymin - box1.ymax, 0));\r\n        let mindist = mindist_x * mindist_x + mindist_y * mindist_y;\r\n\r\n        let box = box1.merge(box2);\r\n        let dx = box.xmax - box.xmin;\r\n        let dy = box.ymax - box.ymin;\r\n        let maxdist = dx * dx + dy * dy;\r\n\r\n        return [mindist, maxdist];\r\n    }\r\n\r\n    static minmax_tree_process_level(shape, level, min_stop, tree) {\r\n        // Calculate minmax distance to each shape in current level\r\n        // Insert result into the interval tree for further processing\r\n        // update min_stop with maxdist, it will be the new stop distance\r\n        let mindist, maxdist;\r\n        for (let node of level) {\r\n\r\n            // [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\r\n            // if (Flatten.Utils.GT(mindist, min_stop))\r\n            //     continue;\r\n\r\n            // Estimate min-max dist to the shape stored in the node.item, using node.item.key which is shape's box\r\n            [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.item.key);\r\n            if (node.item.value instanceof Flatten.Edge) {\r\n                tree.insert([mindist, maxdist], node.item.value.shape);\r\n            } else {\r\n                tree.insert([mindist, maxdist], node.item.value);\r\n            }\r\n            if (Flatten.Utils.LT(maxdist, min_stop)) {\r\n                min_stop = maxdist;                       // this will be the new distance estimation\r\n            }\r\n        }\r\n\r\n        if (level.length === 0)\r\n            return min_stop;\r\n\r\n        // Calculate new level from left and right children of the current\r\n        let new_level_left = level.map(node => node.left.isNil() ? undefined : node.left).filter(node => node !== undefined);\r\n        let new_level_right = level.map(node => node.right.isNil() ? undefined : node.right).filter(node => node !== undefined);\r\n        // Merge left and right subtrees and leave only relevant subtrees\r\n        let new_level = [...new_level_left, ...new_level_right].filter(node => {\r\n            // Node subtree quick reject, node.max is a subtree box\r\n            let [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\r\n            return (Flatten.Utils.LE(mindist, min_stop));\r\n        });\r\n\r\n        min_stop = Distance.minmax_tree_process_level(shape, new_level, min_stop, tree);\r\n        return min_stop;\r\n    }\r\n\r\n    /**\r\n     * Calculates sorted tree of [mindist, maxdist] intervals between query shape\r\n     * and shapes of the planar set.\r\n     * @param shape\r\n     * @param set\r\n     */\r\n    static minmax_tree(shape, set, min_stop) {\r\n        let tree = new IntervalTree();\r\n        let level = [set.index.root];\r\n        let squared_min_stop = min_stop < Number.POSITIVE_INFINITY ? min_stop * min_stop : Number.POSITIVE_INFINITY;\r\n        squared_min_stop = Distance.minmax_tree_process_level(shape, level, squared_min_stop, tree);\r\n        return tree;\r\n    }\r\n\r\n    static minmax_tree_calc_distance(shape, node, min_dist_and_segment) {\r\n        let min_dist_and_segment_new, stop;\r\n        if (node != null && !node.isNil()) {\r\n            [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.left, min_dist_and_segment);\r\n\r\n            if (stop) {\r\n                return [min_dist_and_segment_new, stop];\r\n            }\r\n\r\n            if (Flatten.Utils.LT(min_dist_and_segment_new[0], Math.sqrt(node.item.key.low))) {\r\n                return [min_dist_and_segment_new, true];   // stop condition\r\n            }\r\n\r\n            let [dist, shortest_segment] = Distance.distance(shape, node.item.value);\r\n            // console.log(dist)\r\n            if (Flatten.Utils.LT(dist, min_dist_and_segment_new[0])) {\r\n                min_dist_and_segment_new = [dist, shortest_segment];\r\n            }\r\n\r\n            [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.right, min_dist_and_segment_new);\r\n\r\n            return [min_dist_and_segment_new, stop];\r\n        }\r\n\r\n        return [min_dist_and_segment, false];\r\n    }\r\n\r\n    /**\r\n     * Calculates distance between shape and Planar Set of shapes\r\n     * @param shape\r\n     * @param {PlanarSet} set\r\n     * @param {Number} min_stop\r\n     * @returns {*}\r\n     */\r\n    static shape2planarSet(shape, set, min_stop = Number.POSITIVE_INFINITY) {\r\n        let min_dist_and_segment = [min_stop, new Flatten.Segment()];\r\n        let stop = false;\r\n        if (set instanceof Flatten.PlanarSet) {\r\n            let tree = Distance.minmax_tree(shape, set, min_stop);\r\n            [min_dist_and_segment, stop] = Distance.minmax_tree_calc_distance(shape, tree.root, min_dist_and_segment);\r\n        }\r\n        return min_dist_and_segment;\r\n    }\r\n\r\n    static sort(dist_and_segment) {\r\n        dist_and_segment.sort((d1, d2) => {\r\n            if (Flatten.Utils.LT(d1[0], d2[0])) {\r\n                return -1;\r\n            }\r\n            if (Flatten.Utils.GT(d1[0], d2[0])) {\r\n                return 1;\r\n            }\r\n            return 0;\r\n        });\r\n    }\r\n\r\n    static distance(shape1, shape2) {\r\n        return shape1.distanceTo(shape2);\r\n    }\r\n}\r\n\r\nFlatten.Distance = Distance;\r\n\r\n/**\r\n * Created by Alex Bol on 2/18/2017.\r\n */\r\n\r\nFlatten.BooleanOperations = BooleanOperations;\r\nFlatten.Relations = Relations;\r\n\r\nexport default Flatten;\r\nexport { Arc, BOUNDARY, BooleanOperations, Box, CCW, CW, Circle, Distance, Edge, errors as Errors, Face, INSIDE, Inversion, Line, Matrix, Multiline, ORIENTATION, OUTSIDE, PlanarSet, Point, Polygon, Ray, Relations, Segment, Utils, Vector, arc, box, circle, inversion, line, matrix, multiline, point, polygon, ray, ray_shoot, segment, vector };\r\n","import type {LatLngExpression} from 'leaflet';\nimport L, {Bounds, LatLng, LatLngBounds, Path, Point, Util} from 'leaflet';\nimport Flatten from '@flatten-js/core';\nimport Matrix = Flatten.Matrix;\nimport type {Points, Shape, ShapeSet, Units} from './types';\nimport type {ShapeOptions, TrackSymbolOptions} from './options';\n\nconst DEFAULT_SIZE = 24;\nconst DEFAULT_LEADER_TIME = 60;\n\n/**\n * Track symbol.\n */\nexport class TrackSymbol\n    extends Path {\n\n    /** Default 'withHeading' shape points. */\n    public static DEFAULT_HEADING_SHAPE_POINTS: Points = [[0.75, 0], [-0.25, 0.3], [-0.25, -0.3]];\n\n    /** Default 'withoutHeading' shape points. */\n    public static DEFAULT_NOHEADING_SHAPE_POINTS: Points = [[0.3, 0], [0, 0.3], [-0.3, 0], [0, -0.3]];\n\n    /** Default shape set. */\n    private static DEFAULT_SHAPE_SET: ShapeSet = {\n        withHeading: {\n            points: TrackSymbol.DEFAULT_HEADING_SHAPE_POINTS,\n            length: DEFAULT_SIZE,\n            breadth: DEFAULT_SIZE,\n            units: \"pixels\",\n        },\n        withoutHeading: {\n            points: TrackSymbol.DEFAULT_NOHEADING_SHAPE_POINTS,\n            length: DEFAULT_SIZE,\n            breadth: DEFAULT_SIZE,\n            units: \"pixels\",\n        },\n    };\n\n    /** Location. */\n    private _latLng: LatLng;\n    /** Heading (radians, from north, clockwise. */\n    private _heading?: number;\n    /** Course (radians, from north, clockwise. */\n    private _course?: number;\n    /** Speed (m/s). */\n    private _speed?: number;\n     /** Shape options. */\n    private _shapeOptions: ShapeOptions;\n\n    /** Current shape points. */\n    private _currentShapePoints: Point[] | undefined;\n    /** Current leader points. */\n    private _currentLeaderPoints: Point[] | undefined;\n    /** Current bounds. */\n    private _currentBounds: Bounds | undefined;\n    /** Current lat/lng bounds. */\n    private _currentLatLngBounds: LatLngBounds | undefined;\n\n    /**\n     * TrackSymbol constructor.\n     *\n     * @param latLng - Initial location.\n     * @param options - Options.\n     */\n    constructor(latLng: LatLngExpression, options?: TrackSymbolOptions) {\n        super();\n\n        Util.setOptions(this, options);\n        if (latLng == undefined) {\n            throw Error(\"latLng required\");\n        }\n        options = options || {};\n        this._latLng = L.latLng(latLng);\n        this._heading = options.heading;\n        this._course = options.course;\n        this._speed = options.speed;\n        this._setShapeOptions(options.shapeOptions);\n    }\n\n    // ---- Leaflet\n\n    /**\n     * Project to layer.\n     *\n     * [Leaflet internal]\n     */\n    protected _project() {\n        this._currentShapePoints = this._getProjectedShapePoints();\n        this._currentLeaderPoints = this._getLeaderShapePoints();\n\n        const bounds = new Bounds();\n        for (let i = 0; i < this._currentShapePoints.length; i++) {\n            const point = this._currentShapePoints[i];\n            bounds.extend(point);\n        }\n        if (this._currentLeaderPoints !== undefined) {\n            for (let i = 0; i < this._currentLeaderPoints.length; i++) {\n                const point = this._currentShapePoints[i];\n                bounds.extend(point);\n            }\n        }\n        this._currentBounds = bounds;\n        this._currentLatLngBounds = new LatLngBounds(\n            this._map.layerPointToLatLng(bounds.getBottomLeft()),\n            this._map.layerPointToLatLng(bounds.getTopRight())\n        );\n    }\n\n    /**\n     * Update element.\n     *\n     * [Leaflet internal]\n     */\n    protected _update() {\n        if (!this._map) {\n            return;\n        }\n        let viewPath = TrackSymbol._toSVGPath(this._currentShapePoints, true);\n        if (this._currentLeaderPoints !== undefined) {\n            viewPath += ' ' + TrackSymbol._toSVGPath(this._currentLeaderPoints, false);\n        }\n        this.getElement().setAttribute('d', viewPath);\n    }\n\n    // ----\n\n    /**\n     * Set shape options.\n     *\n     * @param shapeOptions Shape options.\n     */\n    private _setShapeOptions(shapeOptions: ShapeOptions | undefined) {\n        this._shapeOptions = shapeOptions || {\n            leaderTime: DEFAULT_LEADER_TIME,\n            defaultShapeSet: TrackSymbol.DEFAULT_SHAPE_SET,\n        };\n        if (this._shapeOptions.leaderTime === undefined) {\n            this._shapeOptions.leaderTime = DEFAULT_LEADER_TIME;\n        }\n        if (this._shapeOptions.defaultShapeSet === undefined) {\n            this._shapeOptions.defaultShapeSet = TrackSymbol.DEFAULT_SHAPE_SET;\n        }\n        if (this._shapeOptions.shapeSetEntries !== undefined) {\n            this._shapeOptions.shapeSetEntries\n                .sort((a, b) => b.minZoomLevel - a.minZoomLevel);\n        }\n    }\n\n    // ---\n\n    /**\n     * Sets the location.\n     *\n     * @param latLng - Location.\n     * @returns this\n     */\n    public setLatLng(latLng: LatLngExpression): this {\n        const oldLatLng = this._latLng;\n        this._latLng = L.latLng(latLng);\n        this.fire('move', {\n            oldLatLng: oldLatLng,\n            latlng: this._latLng,\n        });\n        return this.redraw();\n    }\n\n    /**\n     * Sets the heading.\n     *\n     * @param heading - Heading (unit: radians, from north, clockwise).\n     * @returns this\n     */\n    public setHeading(heading: number | undefined): this {\n        this._heading = heading;\n        return this.redraw();\n    }\n\n    /**\n     * Sets the course over ground.\n     *\n     * @param course - Course over ground (unit: radians, from north, clockwise).\n     * @returns this\n     */\n    public setCourse(course: number | undefined): this {\n        this._course = course;\n        return this.redraw();\n    }\n\n    /**\n     * Sets the speed.\n     *\n     * @param speed - Speed (unit: m/s).\n     * @returns this\n     */\n    public setSpeed(speed: number | undefined): this {\n        this._speed = speed;\n        return this.redraw();\n    }\n\n    /**\n     * Sets the shape options.\n     *\n     * @param shapeOptions - Shape options.\n     * @returns this\n     */\n    public setShapeOptions(shapeOptions: ShapeOptions): this {\n        this._setShapeOptions(shapeOptions);\n        return this.redraw();\n    }\n\n    /**\n     * Returns the bounding box.\n     *\n     * @returns The bounding box.\n     */\n    public getBounds(): LatLngBounds {\n        return this._currentLatLngBounds;\n    }\n\n    /**\n     * Returns the location.\n     *\n     * @returns The location.\n     */\n    public getLatLng(): LatLng {\n        return this._latLng;\n    }\n\n    /**\n     * Returns the speed.\n     *\n     * @returns The speed (m/s).\n     */\n    public getSpeed(): number | undefined {\n        return this._speed;\n    }\n\n    /**\n     * Returns the heading.\n     *\n     * @returns The heading (radians, from north, clockwise).\n     */\n    public getHeading(): number | undefined {\n        return this._heading;\n    }\n\n    /**\n     * Returns the course.\n     *\n     * @returns The course (radians, from north, clockwise).\n     */\n    public getCourse(): number | undefined {\n        return this._course;\n    }\n\n    /**\n     * Creates a shape.\n     *\n     * @param points - Points.\n     * @param size - Size (units: pixels).\n     * @returns The new shape.\n     */\n    public static createShape(points: Points, size: number): Shape {\n        return {\n            points: points,\n            length: size,\n            breadth: size,\n            units: \"pixels\",\n        };\n    }\n\n    /**\n     * Creates a shape set.\n     *\n     * @param size - Size (units: pixels).\n     * @returns The new shape set.\n     */\n    public static createShapeSet(size: number): ShapeSet {\n        return {\n            withHeading: TrackSymbol.createShape(TrackSymbol.DEFAULT_HEADING_SHAPE_POINTS, size),\n            withoutHeading: TrackSymbol.createShape(TrackSymbol.DEFAULT_NOHEADING_SHAPE_POINTS, size),\n        };\n    }\n\n    /**\n     * Get latitude size of y-distance.\n     *\n     * @param value Y distance (m).\n     * @returns dLat\n     */\n    private _getLatSizeOf(value): number {\n        return (value / 40075017) * 360;\n    }\n\n    /**\n     * Get longitude size of x-distance.\n     *\n     * @param value X distance (m).\n     * @returns dLng\n     */\n    private _getLngSizeOf(value): number {\n        return ((value / 40075017) * 360) / Math.cos((Math.PI / 180) * this._latLng.lat);\n    }\n\n    /**\n     * Get view angle from model.\n     *\n     * @param modelAngle Model angle (radians).\n     * @returns View angle from model (radians).\n     */\n    private _getViewAngleFromModel(modelAngle: number): number {\n        return modelAngle - Math.PI / 2.0;\n    }\n\n    /**\n     * Get leader shape points.\n     *\n     * @returns Points.\n     */\n    private _getLeaderShapePoints(): Point[] | undefined {\n        if ((this._course === undefined) || (this._speed === undefined)) {\n            return undefined;\n        }\n        const angle = this._getViewAngleFromModel(this._course);\n        const leaderLength = this._speed * this._shapeOptions.leaderTime;\n        const leaderEndLatLng = this._calcRelativeLatLng(this._latLng, leaderLength, angle);\n        return this._latLngsToLayerPoints(this._latLng, leaderEndLatLng);\n    }\n\n    /**\n     * Calculate relative lat/lng.\n     *\n     * @param latLng LatLng.\n     * @param distance Distance (meters).\n     * @param angle Angle (radians).\n     * @private Calculated LatLng.\n     */\n    private _calcRelativeLatLng(latLng: LatLng, distance: number, angle: number): LatLng {\n        return new LatLng(\n            latLng.lat - this._getLatSizeOf(distance * Math.sin(angle)),\n            latLng.lng + this._getLngSizeOf(distance * Math.cos(angle))\n        );\n    }\n\n    /**\n     * Convert LatLngs to map layer points.\n     *\n     * @param latLngs LatLngs.\n     * @returns Points.\n     */\n    private _latLngsToLayerPoints(...latLngs: LatLng[]): Point[] {\n        return latLngs.map(latLng => this._map.latLngToLayerPoint(latLng));\n    }\n\n    /**\n     * Gets the shape set.\n     *\n     * @returns The shape set.\n     */\n    private _getShapeSet(): ShapeSet {\n        if ((this._shapeOptions.shapeSetEntries === undefined)\n            || (this._shapeOptions.shapeSetEntries.length == 0)) {\n            return this._shapeOptions.defaultShapeSet;\n        }\n        const zoomLevel = this._map.getZoom();\n        const shapeSetEntriesFiltered = this._shapeOptions.shapeSetEntries\n            .sort((a, b) => b.minZoomLevel - a.minZoomLevel)\n            .filter(shapeSetEntry => zoomLevel >= shapeSetEntry.minZoomLevel);\n        if (shapeSetEntriesFiltered.length > 0) {\n            return shapeSetEntriesFiltered[0].shapeSet;\n        } else {\n            return this._shapeOptions.defaultShapeSet;\n        }\n    }\n\n    /**\n     * Gets the shape.\n     *\n     * @returns The shape.\n     */\n    private _getShape(): Shape {\n        const shapeSet = this._getShapeSet();\n        return (this._heading !== undefined) ? shapeSet.withHeading : shapeSet.withoutHeading;\n    }\n\n    /**\n     * Get transformed shape points.\n     *\n     * @returns Transformed points and units.\n     */\n    private _getTransformedShapePoints(): [Points, Units] {\n        const shape = this._getShape();\n        let m = new Matrix();\n        if (this._heading !== undefined) {\n            const headingAngle = this._getViewAngleFromModel(this._heading);\n            m = m.rotate(headingAngle);\n        }\n        if (shape.center !== undefined) {\n            m = m.translate(-shape.center[0], -shape.center[1]);\n        }\n        m = m.scale(shape.length, shape.breadth);\n        const points = shape.points.map(point => m.transform(point));\n        return [points, shape.units];\n    }\n\n    /**\n     * Get projected shape points.\n     *\n     * @returns Points projected to map layer.\n     */\n    private _getProjectedShapePoints(): Point[] {\n        const [points, units] = this._getTransformedShapePoints();\n        switch (units) {\n            case \"pixels\": {\n                const p = this._map.latLngToLayerPoint(this._latLng);\n                const m = new Matrix().translate(p.x, p.y);\n                return points.map(point => {\n                    const p1 = m.transform(point);\n                    return new Point(p1[0], p1[1]);\n                });\n            }\n            case \"meters\": {\n                return points.map(point => this._map.latLngToLayerPoint(\n                    new LatLng(\n                        this._latLng.lat - this._getLatSizeOf(point[1]),\n                        this._latLng.lng + this._getLngSizeOf(point[0])\n                    )\n                ));\n            }\n            default:\n                break;\n        }\n    }\n\n    /**\n     * Converts points to an SVG path string.\n     *\n     * @param points Points.\n     * @param close Close path.\n     * @private SVG path string.\n     */\n    private static _toSVGPath(points: Point[], close: boolean): string {\n        let result = '';\n        for (let i = 0; i < points.length; i++) {\n            const point = points[i];\n            if (result === '') {\n                result = `M ${point.x} ${point.y} `;\n            } else {\n                result += `L ${point.x} ${point.y} `;\n            }\n        }\n        if (close) {\n            result += 'Z';\n        }\n        return result;\n    }\n}\n","import {TrackSymbol} from '../trackSymbol';\nimport type {ShapeOptions} from '../options';\nimport type {Points, ShapeSet} from '../types';\nimport type {AISTrackSymbolOptions} from './options';\nimport type {Dimension, ETA, PositionReport, ShipStaticData} from './types';\nimport {DomUtil, Util} from 'leaflet';\n\nconst DEFAULT_SIZE = 24;\nconst DEFAULT_MIN_ZOOM_LEVEL = 14;\nconst DEFAULT_LEADER_TIME = 60;\nconst KNOTS_PER_METER_PER_SECOND = 1.944;\n\ninterface ShipType {\n    name: string;\n    color: string;\n    fillColor: string;\n}\n\nconst RESERVED_COLOR = \"#000000\";\nconst RESERVED_FILL_COLOR = \"#d3d3d3\";\nconst WIG_COLOR = \"#000000\";\nconst WIG_FILL_COLOR = \"#d3d3d3\";\nconst TYPE_3X_COLOR = \"#8b008b\";\nconst TYPE_3X_FILL_COLOR = \"#ff00ff\";\nconst HSC_COLOR = \"#00008b\";\nconst HSC_FILL_COLOR = \"#ffff00\";\nconst TYPE_5X_COLOR = \"#008b8b\";\nconst TYPE_5X_FILL_COLOR = \"#00ffff\";\nconst PASSENGER_COLOR = \"#00008b\";\nconst PASSENGER_FILL_COLOR = \"#0000ff\";\nconst CARGO_COLOR = \"#006400\";\nconst CARGO_FILL_COLOR = \"#90ee90\";\nconst TANKER_COLOR = \"#8b0000\";\nconst TANKER_FILL_COLOR = \"#ff0000\";\nconst OTHER_COLOR = \"#008b8b\";\nconst OTHER_FILL_COLOR = \"#00ffff\";\n\nconst TYPES = {\n    0: newShipType('Not available', WIG_COLOR, WIG_FILL_COLOR),\n    20: newShipType('Wing in ground (WIG), all ships of this type', WIG_COLOR, WIG_FILL_COLOR),\n    21: newShipType('Wing in ground (WIG), Hazardous category A', WIG_COLOR, WIG_FILL_COLOR),\n    22: newShipType('Wing in ground (WIG), Hazardous category B', WIG_COLOR, WIG_FILL_COLOR),\n    23: newShipType('Wing in ground (WIG), Hazardous category C', WIG_COLOR, WIG_FILL_COLOR),\n    24: newShipType('Wing in ground (WIG), Hazardous category D', WIG_COLOR, WIG_FILL_COLOR),\n    25: newShipType('Wing in ground (WIG), Reserved for future use', WIG_COLOR, WIG_FILL_COLOR),\n    26: newShipType('Wing in ground (WIG), Reserved for future use', WIG_COLOR, WIG_FILL_COLOR),\n    27: newShipType('Wing in ground (WIG), Reserved for future use', WIG_COLOR, WIG_FILL_COLOR),\n    28: newShipType('Wing in ground (WIG), Reserved for future use', WIG_COLOR, WIG_FILL_COLOR),\n    29: newShipType('Wing in ground (WIG), Reserved for future use', WIG_COLOR, WIG_FILL_COLOR),\n    30: newShipType('Fishing', TYPE_3X_COLOR, TYPE_3X_FILL_COLOR),\n    31: newShipType('Towing', TYPE_3X_COLOR, TYPE_3X_FILL_COLOR),\n    32: newShipType('Towing: length exceeds 200m or breadth exceeds 25m', TYPE_3X_COLOR, TYPE_3X_FILL_COLOR),\n    33: newShipType('Dredging or underwater ops', TYPE_3X_COLOR, TYPE_3X_FILL_COLOR),\n    34: newShipType('Diving ops', TYPE_3X_COLOR, TYPE_3X_FILL_COLOR),\n    35: newShipType('Military ops', TYPE_3X_COLOR, TYPE_3X_FILL_COLOR),\n    36: newShipType('Sailing', TYPE_3X_COLOR, TYPE_3X_FILL_COLOR),\n    37: newShipType('Pleasure Craft', TYPE_3X_COLOR, TYPE_3X_FILL_COLOR),\n    40: newShipType('High speed craft (HSC), all ships of this type', HSC_COLOR, HSC_FILL_COLOR),\n    41: newShipType('High speed craft (HSC), Hazardous category A', HSC_COLOR, HSC_FILL_COLOR),\n    42: newShipType('High speed craft (HSC), Hazardous category B', HSC_COLOR, HSC_FILL_COLOR),\n    43: newShipType('High speed craft (HSC), Hazardous category C', HSC_COLOR, HSC_FILL_COLOR),\n    44: newShipType('High speed craft (HSC), Hazardous category D', HSC_COLOR, HSC_FILL_COLOR),\n    45: newShipType('High speed craft (HSC), Reserved for future use', HSC_COLOR, HSC_FILL_COLOR),\n    46: newShipType('High speed craft (HSC), Reserved for future use', HSC_COLOR, HSC_FILL_COLOR),\n    47: newShipType('High speed craft (HSC), Reserved for future use', HSC_COLOR, HSC_FILL_COLOR),\n    48: newShipType('High speed craft (HSC), Reserved for future use', HSC_COLOR, HSC_FILL_COLOR),\n    49: newShipType('High speed craft (HSC), No additional information', HSC_COLOR, HSC_FILL_COLOR),\n    50: newShipType('Pilot Vessel', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    51: newShipType('Search and Rescue vessel', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    52: newShipType('Tug', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    53: newShipType('Port Tender', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    54: newShipType('Anti-pollution equipment', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    55: newShipType('Law Enforcement', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    56: newShipType('Spare - Local Vessel', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    57: newShipType('Spare - Local Vessel', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    58: newShipType('Medical Transport', TYPE_5X_COLOR, TYPE_5X_FILL_COLOR),\n    59: newShipType('Noncombatant ship according to RR Resolution No. 18', '', ''),\n    60: newShipType('Passenger, all ships of this type', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    61: newShipType('Passenger, Hazardous category A', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    62: newShipType('Passenger, Hazardous category B', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    63: newShipType('Passenger, Hazardous category C', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    64: newShipType('Passenger, Hazardous category D', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    65: newShipType('Passenger, Reserved for future use', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    66: newShipType('Passenger, Reserved for future use', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    67: newShipType('Passenger, Reserved for future use', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    68: newShipType('Passenger, Reserved for future use', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    69: newShipType('Passenger, No additional information', PASSENGER_COLOR, PASSENGER_FILL_COLOR),\n    70: newShipType('Cargo, all ships of this type', CARGO_COLOR, CARGO_FILL_COLOR),\n    71: newShipType('Cargo, Hazardous category A', CARGO_COLOR, CARGO_FILL_COLOR),\n    72: newShipType('Cargo, Hazardous category B', CARGO_COLOR, CARGO_FILL_COLOR),\n    73: newShipType('Cargo, Hazardous category C', CARGO_COLOR, CARGO_FILL_COLOR),\n    74: newShipType('Cargo, Hazardous category D', CARGO_COLOR, CARGO_FILL_COLOR),\n    75: newShipType('Cargo, Reserved for future use', CARGO_COLOR, CARGO_FILL_COLOR),\n    76: newShipType('Cargo, Reserved for future use', CARGO_COLOR, CARGO_FILL_COLOR),\n    77: newShipType('Cargo, Reserved for future use', CARGO_COLOR, CARGO_FILL_COLOR),\n    78: newShipType('Cargo, Reserved for future use', CARGO_COLOR, CARGO_FILL_COLOR),\n    79: newShipType('Cargo, No additional information', CARGO_COLOR, CARGO_FILL_COLOR),\n    80: newShipType('Tanker, all ships of this type', TANKER_COLOR, TANKER_FILL_COLOR),\n    81: newShipType('Tanker, Hazardous category A', TANKER_COLOR, TANKER_FILL_COLOR),\n    82: newShipType('Tanker, Hazardous category B', TANKER_COLOR, TANKER_FILL_COLOR),\n    83: newShipType('Tanker, Hazardous category C', TANKER_COLOR, TANKER_FILL_COLOR),\n    84: newShipType('Tanker, Hazardous category D', TANKER_COLOR, TANKER_FILL_COLOR),\n    85: newShipType('Tanker, Reserved for future use', TANKER_COLOR, TANKER_FILL_COLOR),\n    86: newShipType('Tanker, Reserved for future use', TANKER_COLOR, TANKER_FILL_COLOR),\n    87: newShipType('Tanker, Reserved for future use', TANKER_COLOR, TANKER_FILL_COLOR),\n    88: newShipType('Tanker, Reserved for future use', TANKER_COLOR, TANKER_FILL_COLOR),\n    89: newShipType('Tanker, No additional information', TANKER_COLOR, TANKER_FILL_COLOR),\n    90: newShipType('Other Type, all ships of this type', OTHER_COLOR, OTHER_FILL_COLOR),\n    91: newShipType('Other Type, Hazardous category A', OTHER_COLOR, OTHER_FILL_COLOR),\n    92: newShipType('Other Type, Hazardous category B', OTHER_COLOR, OTHER_FILL_COLOR),\n    93: newShipType('Other Type, Hazardous category C', OTHER_COLOR, OTHER_FILL_COLOR),\n    94: newShipType('Other Type, Hazardous category D', OTHER_COLOR, OTHER_FILL_COLOR),\n    95: newShipType('Other Type, Reserved for future use', OTHER_COLOR, OTHER_FILL_COLOR),\n    96: newShipType('Other Type, Reserved for future use', OTHER_COLOR, OTHER_FILL_COLOR),\n    97: newShipType('Other Type, Reserved for future use', OTHER_COLOR, OTHER_FILL_COLOR),\n    98: newShipType('Other Type, Reserved for future use', OTHER_COLOR, OTHER_FILL_COLOR),\n    99: newShipType('Other Type, no additional information', OTHER_COLOR, OTHER_FILL_COLOR),\n};\nconst RESERVED_TYPE = newShipType('Reserved', RESERVED_COLOR, RESERVED_FILL_COLOR);\nconst UNKNOWN_TYPE = newShipType('Unknown', RESERVED_COLOR, RESERVED_FILL_COLOR);\n\nexport class AISTrackSymbol\n    extends TrackSymbol {\n\n    /** Default silhouette shape points. */\n    public static DEFAULT_SILHOUETTE_SHAPE_POINTS: Points = [[1, 0.5], [0.75, 1], [0, 1], [0, 0], [0.75, 0]];\n\n    private readonly _leaderTime: number;\n    private readonly _minZoomLevel: number;\n    private readonly _size: number;\n    private _positionReport: PositionReport;\n    private _shipStaticData?: ShipStaticData;\n\n    /**\n     * AISTrackSymbol constructor.\n     *\n     * @param positionReport - Position report.\n     * @param options - Options.\n     */\n    constructor(positionReport: PositionReport, options?: AISTrackSymbolOptions) {\n        super([positionReport.latitude, positionReport.longitude], options);\n\n        Util.setOptions(this, options);\n        options = options || {};\n        this._leaderTime = options.leaderTime || DEFAULT_LEADER_TIME;\n        this._minZoomLevel = options.minZoomLevel || DEFAULT_MIN_ZOOM_LEVEL;\n        this._size = options.size || DEFAULT_SIZE;\n        this.setPositionReport(positionReport);\n        this.setShipStaticData(options.shipStaticData);\n    }\n\n    /**\n     * Sets the position report.\n     *\n     * @param positionReport - Position report.\n     * @returns this\n     */\n    public setPositionReport(positionReport: PositionReport): this {\n        this._positionReport = positionReport;\n        this.setLatLng([positionReport.latitude, positionReport.longitude]);\n        if (!isNullOrUndefined(positionReport.trueHeading) && (positionReport.trueHeading != 511)) {\n            this.setHeading(toRadians(positionReport.trueHeading));\n        } else {\n            this.setHeading(undefined);\n        }\n        if (!isNullOrUndefined(positionReport.cog) && (positionReport.cog < 360)) {\n            this.setCourse(toRadians(positionReport.cog));\n        } else {\n            this.setCourse(undefined);\n        }\n        if (!isNullOrUndefined(positionReport.sog) && (positionReport.sog < 102.3)) {\n            this.setSpeed(positionReport.sog / KNOTS_PER_METER_PER_SECOND);\n        } else {\n            this.setSpeed(undefined);\n        }\n        return this.redraw();\n    }\n\n    /**\n     * Sets the ship static data.\n     *\n     * @param shipStaticData - Ship static data.\n     * @returns this\n     */\n    public setShipStaticData(shipStaticData?: ShipStaticData): this {\n        this._shipStaticData = shipStaticData;\n        const shipType = !isNullOrUndefined(shipStaticData) && !isNullOrUndefined(shipStaticData.type)\n            ? getShipType(shipStaticData.type) : TYPES[0];\n        this.setStyle({\n            color: shipType.color,\n            fill: true,\n            fillOpacity: 1.0,\n            fillColor: shipType.fillColor,\n        });\n        this.bindPopup(this._getPopupContent(this._positionReport, shipStaticData));\n        return this.setShapeOptions(AISTrackSymbol._getShapeOptions(this._leaderTime, this._minZoomLevel, this._size,\n            shipStaticData));\n    }\n\n    private static _getShapeOptions(leaderTime: number, minZoomLevel: number, size: number,\n                                    shipStaticData?: ShipStaticData): ShapeOptions {\n        const shapeOptions: ShapeOptions = {\n            leaderTime: leaderTime,\n            defaultShapeSet: TrackSymbol.createShapeSet(size),\n        };\n        const shapeSet = AISTrackSymbol._getShapeSet(size, shipStaticData);\n        if (shapeSet !== null) {\n            shapeOptions.shapeSetEntries = [{\n                shapeSet: shapeSet,\n                minZoomLevel: minZoomLevel,\n            }];\n        }\n        return shapeOptions;\n    }\n\n    private static _getShapeSet(size: number, shipStaticData?: ShipStaticData): ShapeSet | null {\n        if (isNullOrUndefined(shipStaticData) || isNullOrUndefined(shipStaticData.dimension)\n            || !isDimensionValid(shipStaticData.dimension)) {\n            return null;\n        }\n        return {\n            withHeading: {\n                points: AISTrackSymbol.DEFAULT_SILHOUETTE_SHAPE_POINTS,\n                center: [shipStaticData.dimension.B, shipStaticData.dimension.D],\n                length: shipStaticData.dimension.A + shipStaticData.dimension.B,\n                breadth: shipStaticData.dimension.C + shipStaticData.dimension.D,\n                units: \"meters\",\n            },\n            withoutHeading: TrackSymbol.createShape(TrackSymbol.DEFAULT_NOHEADING_SHAPE_POINTS, size),\n        };\n    }\n\n    private _getPopupContent(positionReport?: PositionReport, shipStaticData?: ShipStaticData): HTMLElement {\n        let content = \"<table>\";\n        if (!isNullOrUndefined(shipStaticData)) {\n            content += createTableRow(\"User ID\", shipStaticData.userId);\n            content += createTableRow(\"IMO Number\", shipStaticData.imoNumber);\n            content += createTableRow(\"Call sign\", shipStaticData.callSign);\n            content += createTableRow(\"Name\", shipStaticData.name);\n        }\n        if (!isNullOrUndefined(positionReport)) {\n            content += createTableRow(\"Location\", `${positionReport.latitude}, ${positionReport.longitude}`)\n            content += createTableRow(\"SOG\", !isNullOrUndefined(positionReport.sog)\n                ? positionReport.sog.toFixed(2) : undefined, \"knots\");\n            content += createTableRow(\"COG\", !isNullOrUndefined(positionReport.cog)\n                ? positionReport.cog.toFixed(1) : undefined, \"°\");\n            content += createTableRow(\"Heading\", !isNullOrUndefined(positionReport.trueHeading)\n                ? positionReport.trueHeading.toFixed(1) : undefined, \"°\");\n            content += createTableRow(\"Navigation status\",\n                toNavigationStatusString(positionReport.navigationalStatus));\n        }\n        if (!isNullOrUndefined(shipStaticData)) {\n            content += createTableRow(\"Type\", toTypeString(shipStaticData.type));\n            if (!isNullOrUndefined(shipStaticData.dimension) && isDimensionValid(shipStaticData.dimension)) {\n                content += createTableRow(\"Ship length\",\n                    shipStaticData.dimension.A + shipStaticData.dimension.B, \"m\");\n                content += createTableRow(\"Ship width\",\n                    shipStaticData.dimension.C + shipStaticData.dimension.D, \"m\");\n            }\n            content += createTableRow(\"Fix type\", toFixTypeString(shipStaticData.fixType));\n            content += createTableRow(\"ETA\", toETAString(shipStaticData.eta));\n            content += createTableRow(\"Maximum static draught\",\n                !isNullOrUndefined(shipStaticData.maximumStaticDraught)\n                    ? shipStaticData.maximumStaticDraught.toFixed(1) : undefined, \"m\");\n            content += createTableRow(\"Destination\", shipStaticData.destination);\n            content += createTableRow(\"DTE\", shipStaticData.dte);\n        }\n        content += \"</table>\";\n        const popupContent = DomUtil.create(\"div\");\n        popupContent.innerHTML = content;\n        return popupContent;\n    }\n}\n\nfunction toTypeString(type: number): string | undefined {\n    if (isNullOrUndefined(type)) {\n        return undefined;\n    }\n    const shipType = getShipType(type);\n    return shipType.name;\n}\n\nfunction toFixTypeString(fixType: number): string | undefined {\n    if (isNullOrUndefined(fixType)) {\n        return undefined;\n    }\n    switch (fixType) {\n        case 0:\n            return undefined;\n        case 1:\n            return 'GPS';\n        case 2:\n            return 'GLONASS';\n        case 3:\n            return 'combined GPS/GLONASS';\n        case 4:\n            return 'Loran-C';\n        case 5:\n            return 'Chayka';\n        case 6:\n            return 'integrated navigation system';\n        case 7:\n            return 'surveyed';\n        case 8:\n            return 'Galileo';\n        case 9:\n        case 10:\n        case 11:\n        case 12:\n        case 13:\n        case 14:\n            return `not used (${fixType})`;\n        case 15:\n            return \"internal GNSS\";\n        default:\n            return `unknown (${fixType})`;\n    }\n}\n\nfunction toNavigationStatusString(navigationStatus: number): string | undefined {\n    if (isNullOrUndefined(navigationStatus)) {\n        return undefined;\n    }\n    switch (navigationStatus) {\n        case 0:\n            return 'Under way using engine';\n        case 1:\n            return 'At anchor';\n        case 2:\n            return 'Not under command';\n        case 3:\n            return 'Restricted manoeuverability';\n        case 4:\n            return 'Constrained by her draught';\n        case 5:\n            return 'Moored';\n        case 6:\n            return 'Aground';\n        case 7:\n            return 'Engaged in Fishing';\n        case 8:\n            return 'Under way sailing';\n        case 9:\n            return 'Reserved for future amendment of Navigational Status for HSC';\n        case 10:\n            return 'Reserved for future amendment of Navigational Status for WIG';\n        case 11:\n            return 'Reserved for future use';\n        case 12:\n            return 'Reserved for future use';\n        case 13:\n            return 'Reserved for future use';\n        case 14:\n            return 'AIS-SART is active';\n        case 15:\n            return 'Not defined (default)';\n        default:\n            return `unknown (${navigationStatus})`;\n    }\n}\n\nfunction toETAString(eta: ETA): string | undefined {\n    if (isNullOrUndefined(eta)) {\n        return undefined;\n    }\n    return `${eta.month.toString().padStart(2, '0')}/${eta.day.toString().padStart(2, '0')} ${eta.hour.toString().padStart(2, '0')}:${eta.minute.toString().padStart(2, '0')} UTC`;\n}\n\nfunction toRadians(degs: number | null | undefined): number | undefined {\n    if ((degs === null) || (degs === undefined)) {\n        return undefined;\n    }\n    return degs * Math.PI / 180;\n}\n\nfunction isNullOrUndefined(v: any): boolean {\n    return (v === null) || (v === undefined);\n}\n\nfunction isDimensionValid(dimension?: Dimension): boolean {\n    return !isNullOrUndefined(dimension)\n        && (dimension.A > 0) && (dimension.B > 0) && (dimension.C > 0) && (dimension.D > 0);\n}\n\nfunction createTableRow(name: string, value: any, unit?: string): string {\n    if (isNullOrUndefined(value)) {\n        return '';\n    }\n    return `<tr><td>${name}</td><td>${value} ${isNullOrUndefined(unit) ? \"\" : unit}</td></tr>`;\n}\n\nfunction toDegrees(rads: number | null | undefined): number | undefined {\n    if ((rads === null) || (rads === undefined)) {\n        return undefined;\n    }\n    return rads * 180 / Math.PI;\n}\n\nfunction newShipType(name: string, color: string, fillColor): ShipType {\n    return {\n        name: name,\n        color: color,\n        fillColor: fillColor,\n    }\n}\n\nfunction getShipType(type: number): ShipType {\n    if ((type < 0) || (type > 99)) {\n        return UNKNOWN_TYPE;\n    }\n    const shipType = TYPES[type];\n    if (!isNullOrUndefined(shipType)) {\n        return shipType;\n    }\n    return RESERVED_TYPE;\n}\n","import L from 'leaflet';\nimport type {LatLngExpression} from 'leaflet';\nimport {TrackSymbol} from './trackSymbol';\nimport type {ShapeSetEntry, ShapeOptions, TrackSymbolOptions} from './options';\nimport type {Points, Shape, ShapeSet, Units} from './types';\nimport {AISTrackSymbol} from './ais/aisTrackSymbol';\nimport type {AISTrackSymbolOptions} from './ais/options';\nimport type {AISMessage, Dimension, ETA, PositionReport, ShipStaticData} from './ais/types';\n\nexport {\n    Points,\n    Shape,\n    ShapeOptions,\n    ShapeSet,\n    ShapeSetEntry,\n    TrackSymbol,\n    TrackSymbolOptions,\n    Units,\n};\n\nexport {\n    AISMessage,\n    AISTrackSymbol,\n    AISTrackSymbolOptions,\n    Dimension,\n    ETA,\n    PositionReport,\n    ShipStaticData,\n};\n\nL['trackSymbol'] = function(latLng: LatLngExpression, options?: TrackSymbolOptions): TrackSymbol {\n    return new TrackSymbol(latLng, options);\n}\nL['TrackSymbol'] = TrackSymbol;\n\nL['aisTrackSymbol'] = function(positionReport: PositionReport, options?: AISTrackSymbolOptions): AISTrackSymbol {\n    return new AISTrackSymbol(positionReport, options);\n}\nL['AISTrackSymbol'] = AISTrackSymbol;\n\nexport default TrackSymbol;\n"],"names":["CCW","CW","ORIENTATION","PIx2","INSIDE","OUTSIDE","BOUNDARY","CONTAINS","INTERLACE","OVERLAP_SAME","OVERLAP_OPPOSITE","NOT_VERTEX","START_VERTEX","END_VERTEX","Constants","DP_TOL","setTolerance","tolerance","getTolerance","DECIMALS","EQ_0","x","EQ","y","GT","GE","LT","LE","Utils","Errors","Flatten","c","value","LinkedList","first","last","edge","controlEdge","counter","start","end","elements","from","to","element","newElement","elementBefore","elementAfter","addToIntPoints","pt","int_points","id","shapes","len","is_vertex","arc_length","sortIntersections","intersections","getSortedArray","faceMap","ip","compareFn","ip1","ip2","getSortedArrayOnLine","line","int_point1","int_point2","filterDuplicatedIntersections","do_squeeze","int_point_ref1","int_point_ref2","int_point_cur1","int_point_cur2","i","j","int_point","index","initializeInclusionFlags","calculateInclusionFlags","polygon","setOverlappingFlags","cur_face","first_int_point_in_face_id","next_int_point1","num_int_points","cur_int_point1","int_points_cur_pool_start","int_points_cur_pool_num","intPointsPoolCount","next_int_point_id","int_points_next_pool_num","next_int_point1_tmp","edge_from1","edge_to1","cur_int_point2","next_int_point2","edge_from2","edge_to2","cur_int_point_num","int_point_current","int_point_next","int_points_pool_num","splitByIntersections","newEdge","insertBetweenIntPoints","new_edge","edge_before","edge_after","INSIDE$1","OUTSIDE$1","BOUNDARY$1","OVERLAP_SAME$1","OVERLAP_OPPOSITE$1","NOT_VERTEX$1","START_VERTEX$1","END_VERTEX$1","BOOLEAN_UNION","BOOLEAN_INTERSECT","BOOLEAN_SUBTRACT","unify","polygon1","polygon2","res_poly","wrk_poly","booleanOpBinary","subtract","polygon2_reversed","intersect","innerClip","clip_shapes1","face","clip_shapes2","outerClip","calculateIntersections","getIntersections","ip_sorted1","ip_sorted2","filterNotRelevantEdges","op","notIntersectedFacesRes","getNotIntersectedFaces","notIntersectedFacesWrk","calcInclusionForNotIntersectedFaces","fixBoundaryConflicts","removeNotRelevantChains","removeNotRelevantNotIntersectedFaces","swapLinksAndRestore","copyWrkToRes","swapLinks","removeOldFaces","restoreFaces","restore","edge1","resp","edge2","poly","notIntersected","notIntersectedFaces","poly2","poly1","int_points1","int_points1_sorted","int_points2","iterate_more","edge_tmp","new_bv","dist","segment","newEdge1","int_point2_edge_after","newEdge2","is_res_polygon","first_int_point_in_face_num","int_points_from_pull_start","int_points_from_pull_num","next_int_point_num","int_points_to_pull_start","int_points_to_pull_num","edge_from","edge_to","k","res_polygon","wrk_polygon","other_int_points","int_point_tmp","rel","BooleanOperations","EQUAL","INTERSECT","TOUCH","INSIDE$2","COVERED","DE9IM","geom","e","intersectLine2Line","line1","line2","A1","B1","C1","A2","B2","C2","det","detX","detY","intersectLine2Circle","circle","prj","delta","v_trans","intersectLine2Box","box","ips","seg","ips_tmp","intersectSegment2Line","ptInIntPoints","intersectLine2Arc","arc","ip_tmp","intersectSegment2Segment","seg1","seg2","new_ip","intersectSegment2Circle","shortest_segment","intersectSegment2Arc","intersectSegment2Box","intersectCircle2Circle","circle1","circle2","vec","r1","r2","a","mid_pt","h","intersectCircle2Box","intersectArc2Arc","arc1","arc2","intersectArc2Circle","intersectArc2Box","intersectEdge2Segment","intersectEdge2Arc","intersectEdge2Line","intersectEdge2Circle","intersectSegment2Polygon","intersectArc2Polygon","intersectLine2Polygon","intersectCircle2Polygon","intersectEdge2Edge","shape1","shape2","intersectEdge2Polygon","resp_edges","resp_edge","intersectPolygon2Polygon","intersectShape2Polygon","shape","new_pt","Multiline","args","acc","v","edgeBefore","edgeFound","angle","center","matrix","attrs","stroke","strokeWidth","fill","fillRule","fillOpacity","className","id_str","class_str","svgStr","multiline","ray_shoot","point","contains","ray","searchBox","i1","i2","intersection","prev_edge","prev_tangent","prev_point","cur_tangent","cur_point","prev_on_the_left","cur_on_the_left","next_edge","next_tangent","next_point","next_on_the_left","equal","relate","intersect$1","touch","disjoint","inside","covered","contain","cover","relateLine2Line","relateLine2Circle","relateLine2Box","relateLine2Polygon","relateShape2Polygon","relatePolygon2Polygon","denim","ip_sorted","splitShapes","boolean_intersection","boolean_difference1","boolean_difference2","inner_clip_shapes1","inner_clip_shapes2","outer_clip_shapes1","outer_clip_shapes2","Relations","Matrix$1","b","d","tx","ty","Matrix","vector","other_matrix","cos","sin","sx","sy","Interval","low","high","other_interval","interval1","interval2","val1","val2","RB_TREE_COLOR_RED","RB_TREE_COLOR_BLACK","Node","key","left","right","parent","color","other_node","value_less_than","value_equal","comparable_max","search_node","comparable_less_than","IntervalTree","count","res","node","insert_node","delete_node","interval","outputMapperFn","resp_nodes","visitor","callback","tree","node_current","current_node","parent_node","uncle_node","cut_node","fix_node","brother_node","found","node_min","node_max","node_successor","action","height","heightLeft","heightRight","PlanarSet","size","deleted","Point","arr","x_rot","y_rot","m","proj_vec","dx","dy","r","Vector","a1","a2","scalar","rpoint","norm1","norm2","n","Segment","coords","ps","pe","length","factor","rest","ymin","dy1","dy2","pts","vector$1","Line","norm","A","B","C","other_line","distance","sorted_points","pt1","pt2","Circle","pc","counterclockwise","Arc","startAngle","endAngle","counterClockwise","sweep","test_arc","func_arcs_array","angles","test_arcs","prev_arc","new_arc","scaleX","scaleY","newStart","newEnd","newCenter","newDirection","onLeftSide","areaTrapez","areaCircularSegment","slope1","slope2","largeArcFlag","sweepFlag","Box","xmin","xmax","ymax","other_box","box1","box2","width","Edge","bvMiddle","flag","sign","halfArc1","halfArc2","CircularLinkedList","done","Face","segments","points","flattenShapes","flattenShape","edges","sArea","area","exitOnFirst","Ray","slope","Polygon","argsArray","loop","el","loop1","valid","signedArea","unassignedEdgeFound","edgeFrom","edgeTo","cutPolygons","cut_edge_start","cut_edge_end","newCutPolygons","cutPoly1","cutPoly2","edgeBefore1","edgeBefore2","face1","face2","newPoly","int_point1_prev","int_point1_curr","polygons","orientation","newPolygons","islandPolygon","min_dist_and_segment","min_stop","newPolygon","Circle$1","Line$1","Point$1","Vector$1","Utils$1","Inversion","inversion_circle","k2","len2","s","inversion","Distance","closest_point","dist2center","shortest_dist","v_seg","v_ps2pt","v_pe2pt","start_sp","end_sp","v_unit","dist_and_segment","dist_tmp","shortest_segment_tmp","dist_from_start","shortest_segment_from_start","dist_from_end","shortest_segment_from_end","dist_from_center","shortest_segment_from_center","dist_from_projection","shortest_segment_from_projection","segment_tmp","mindist_x","mindist_y","mindist","maxdist","level","new_level_left","new_level_right","new_level","set","squared_min_stop","min_dist_and_segment_new","stop","d1","d2","DEFAULT_SIZE","DEFAULT_LEADER_TIME","_TrackSymbol","Path","latLng","options","Util","L","bounds","Bounds","LatLngBounds","viewPath","shapeOptions","oldLatLng","heading","course","speed","modelAngle","leaderLength","leaderEndLatLng","LatLng","latLngs","zoomLevel","shapeSetEntriesFiltered","shapeSetEntry","shapeSet","headingAngle","units","p","p1","close","result","TrackSymbol","DEFAULT_MIN_ZOOM_LEVEL","KNOTS_PER_METER_PER_SECOND","RESERVED_COLOR","RESERVED_FILL_COLOR","WIG_COLOR","WIG_FILL_COLOR","TYPE_3X_COLOR","TYPE_3X_FILL_COLOR","HSC_COLOR","HSC_FILL_COLOR","TYPE_5X_COLOR","TYPE_5X_FILL_COLOR","PASSENGER_COLOR","PASSENGER_FILL_COLOR","CARGO_COLOR","CARGO_FILL_COLOR","TANKER_COLOR","TANKER_FILL_COLOR","OTHER_COLOR","OTHER_FILL_COLOR","TYPES","newShipType","RESERVED_TYPE","UNKNOWN_TYPE","_AISTrackSymbol","positionReport","isNullOrUndefined","toRadians","shipStaticData","shipType","getShipType","leaderTime","minZoomLevel","isDimensionValid","content","createTableRow","toNavigationStatusString","toTypeString","toFixTypeString","toETAString","popupContent","DomUtil","AISTrackSymbol","type","fixType","navigationStatus","eta","degs","dimension","name","unit","fillColor"],"mappings":";AAIA,MAAMA,KAAM,IAMNC,KAAK,IAOLC,KAAc,EAAC,KAAI,IAAI,IAAG,GAAG,gBAAgB,EAAC,GAE9CC,KAAO,IAAI,KAAK,IAEhBC,KAAS,GACTC,KAAU,GACVC,IAAW,GACXC,KAAW,GACXC,KAAY,GAEZC,KAAe,GACfC,KAAmB,GAEnBC,KAAa,GACbC,KAAe,GACfC,KAAa;AAEnB,IAAIC,KAAyB,uBAAO,OAAO;AAAA,EACvC,KAAKd;AAAA,EACL,IAAIC;AAAA,EACJ,aAAaC;AAAA,EACb,MAAMC;AAAA,EACN,QAAQC;AAAA,EACR,SAASC;AAAA,EACT,UAAUC;AAAA,EACV,UAAUC;AAAA,EACV,WAAWC;AAAA,EACX,cAAcC;AAAA,EACd,kBAAkBC;AAAA,EAClB,YAAYC;AAAA,EACZ,cAAcC;AAAA,EACd,YAAYC;AAChB,CAAC;AAWD,IAAIE,IAAS;AAMb,SAASC,GAAaC,GAAW;AAAC,EAAAF,IAASE;AAAU;AAMrD,SAASC,KAAe;AAAC,SAAOH;AAAO;AAEvC,MAAMI,KAAW;AAQjB,SAASC,GAAKC,GAAG;AACb,SAAQA,IAAIN,KAAUM,IAAI,CAACN;AAC/B;AAQA,SAASO,GAAGD,GAAGE,GAAG;AACd,SAAQF,IAAIE,IAAIR,KAAUM,IAAIE,IAAI,CAACR;AACvC;AAQA,SAASS,GAAGH,GAAGE,GAAG;AACd,SAAQF,IAAIE,IAAIR;AACpB;AAQA,SAASU,GAAGJ,GAAGE,GAAG;AACd,SAAQF,IAAIE,IAAI,CAACR;AACrB;AAQA,SAASW,GAAGL,GAAGE,GAAG;AACd,SAAQF,IAAIE,IAAI,CAACR;AACrB;AAQA,SAASY,GAAGN,GAAGE,GAAG;AACd,SAAQF,IAAIE,IAAIR;AACpB;AAEA,IAAIa,KAAqB,uBAAO,OAAO;AAAA,EACnC,cAAcZ;AAAA,EACd,cAAcE;AAAA,EACd,UAAUC;AAAA,EACV,MAAMC;AAAA,EACN,IAAIE;AAAA,EACJ,IAAIE;AAAA,EACJ,IAAIC;AAAA,EACJ,IAAIC;AAAA,EACJ,IAAIC;AACR,CAAC;AASD,MAAME,GAAO;AAAA,EAKT,WAAW,qBAAqB;AAC5B,WAAO,IAAI,eAAe,oBAAoB;AAAA,EACjD;AAAA,EAMD,WAAW,gBAAgB;AACvB,WAAO,IAAI,MAAM,eAAe;AAAA,EACnC;AAAA,EAMD,WAAW,+BAA+B;AACtC,WAAO,IAAI,MAAM,mDAAmD;AAAA,EACvE;AAAA,EAOD,WAAW,gBAAgB;AACvB,WAAO,IAAI,MAAM,eAAe;AAAA,EACnC;AACL;AAMA,IAAIC,IAAU;AAAA,EACV,OAAOF;AAAA,EACP,QAAQC;AAAA,EACR,QAAQ;AAAA,EACR,YAAY;AAAA,EACZ,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,KAAK;AAAA,EACL,KAAK;AAAA,EACL,MAAM;AAAA,EACN,MAAM;AAAA,EACN,KAAK;AAAA,EACL,cAAc;AAAA,EACd,WAAW;AAAA,EACX,SAAS;AAAA,EACT,UAAU;AAAA,EACV,WAAW;AACf;AAEA,SAASE,KAAKjB;AAAY,EAAAgB,EAAQC,KAAKjB,GAAUiB;AAEjD,OAAO,eAAeD,GAAS,UAAU;AAAA,EACrC,KAAI,WAAU;AAAC,WAAOZ;EAAc;AAAA,EACpC,KAAI,SAASc,GAAM;AAAC,IAAAhB,GAAagB,CAAK;AAAA,EAAE;AAC5C,CAAC;AAMD,MAAMC,GAAW;AAAA,EACb,YAAYC,GAAOC,GAAM;AACrB,SAAK,QAAQD,GACb,KAAK,OAAOC,KAAQ,KAAK;AAAA,EAC5B;AAAA,EAOD,OAAO,iBAAiBD,GAAO;AAC3B,QAAIE,IAAOF,GACPG,IAAcH;AAClB,OAAG;AACC,UAAIE,KAAQF,KAASE,MAASC;AAC1B,cAAMP,EAAQ,OAAO;AAEzB,MAAAM,IAAOA,EAAK,MACZC,IAAcA,EAAY,KAAK;AAAA,IAC3C,SAAiBD,KAAQF;AAAA,EACpB;AAAA,EAMD,IAAI,OAAO;AACP,QAAII,IAAU;AACd,aAASF,KAAQ;AACb,MAAAE;AAEJ,WAAOA;AAAA,EACV;AAAA,EAOD,QAAQC,IAAM,QAAWC,IAAI,QAAW;AACpC,QAAIC,IAAW,CAAA,GACXC,IAAOH,KAAS,KAAK,OACrBI,IAAKH,KAAO,KAAK,MACjBI,IAAUF;AACd,QAAIE,MAAY;AAAW,aAAOH;AAClC;AACI,MAAAA,EAAS,KAAKG,CAAO,GACrBA,IAAUA,EAAQ;AAAA,WACbA,MAAYD,EAAG;AACxB,WAAOF;AAAA,EACV;AAAA,EAQD,OAAOG,GAAS;AACZ,WAAI,KAAK,YACL,KAAK,QAAQA,KAEbA,EAAQ,OAAO,KAAK,MACpB,KAAK,KAAK,OAAOA,IAIrB,KAAK,OAAOA,GAGZ,KAAK,KAAK,OAAO,QACjB,KAAK,MAAM,OAAO,QACX;AAAA,EACV;AAAA,EAQD,OAAOC,GAAYC,GAAe;AAC9B,QAAI,KAAK;AACL,WAAK,QAAQD,GACb,KAAK,OAAOA;AAAA,aAEPC,KAAkB;AACvB,MAAAD,EAAW,OAAO,KAAK,OACvB,KAAK,MAAM,OAAOA,GAClB,KAAK,QAAQA;AAAA,SAEZ;AAED,UAAIE,IAAeD,EAAc;AACjC,MAAAA,EAAc,OAAOD,GACjBE,MAAcA,EAAa,OAAOF,IAGtCA,EAAW,OAAOC,GAClBD,EAAW,OAAOE,GAGd,KAAK,SAASD,MACd,KAAK,OAAOD;AAAA,IACnB;AAED,gBAAK,KAAK,OAAO,QACjB,KAAK,MAAM,OAAO,QACX;AAAA,EACV;AAAA,EAOD,OAAOD,GAAS;AAEZ,WAAIA,MAAY,KAAK,SAASA,MAAY,KAAK,QAC3C,KAAK,QAAQ,QACb,KAAK,OAAO,WAGRA,EAAQ,SAAMA,EAAQ,KAAK,OAAOA,EAAQ,OAC1CA,EAAQ,SAAMA,EAAQ,KAAK,OAAOA,EAAQ,OAE1CA,MAAY,KAAK,UACjB,KAAK,QAAQA,EAAQ,OAGrBA,MAAY,KAAK,SACjB,KAAK,OAAOA,EAAQ,QAGrB;AAAA,EACV;AAAA,EAMD,UAAU;AACN,WAAO,KAAK,UAAU;AAAA,EACzB;AAAA,EAED,CAAC,OAAO,YAAY;AAChB,QAAIZ;AACJ,WAAO;AAAA,MACH,MAAM,OACFA,IAAQA,IAAQA,EAAM,OAAO,KAAK,OAC3B,EAAC,OAAOA,GAAO,MAAMA,MAAU,OAAS;AAAA,IAE/D;AAAA,EACK;AACL;AAOA,SAASgB,GAAeZ,GAAMa,GAAIC,GAClC;AACI,MAAIC,IAAKD,EAAW,QAChBE,IAAShB,EAAK,MAAM,MAAMa,CAAE;AAGhC,MAAIG,EAAO,WAAW;AAAG;AAEzB,MAAIC,IAAM;AACV,EAAID,EAAO,OAAO,OACdC,IAAM,IAEDD,EAAO,OAAO,OACnBC,IAAMjB,EAAK,MAAM,SAGjBiB,IAAMD,EAAO,GAAG;AAGpB,MAAIE,IAAY3C;AAChB,EAAIW,GAAG+B,GAAK,CAAC,MACTC,KAAa1C,KAEbU,GAAG+B,GAAKjB,EAAK,MAAM,MAAM,MACzBkB,KAAazC;AAGjB,MAAI0C,IAAcD,IAAYzC,MAAeuB,EAAK,KAAK,eAAe,IAAI,IAAIA,EAAK,aAAaiB;AAEhG,EAAAH,EAAW,KAAK;AAAA,IACZ,IAAIC;AAAA,IACJ,IAAIF;AAAA,IACJ,YAAYM;AAAA,IACZ,aAAanB;AAAA,IACb,YAAY;AAAA,IACZ,MAAMA,EAAK;AAAA,IACX,WAAWkB;AAAA,EACnB,CAAK;AACL;AAEA,SAASE,GAAkBC,GAC3B;AAMI,EAAAA,EAAc,qBAAqBC,GAAeD,EAAc,WAAW,GAC3EA,EAAc,qBAAqBC,GAAeD,EAAc,WAAW;AAC/E;AAEA,SAASC,GAAeR,GACxB;AACI,MAAIS,IAAU,oBAAI,OACdR,IAAK;AAET,WAASS,KAAMV;AACX,IAAKS,EAAQ,IAAIC,EAAG,IAAI,MACpBD,EAAQ,IAAIC,EAAG,MAAMT,CAAE,GACvBA;AAIR,WAASS,KAAMV;AACX,IAAAU,EAAG,SAASD,EAAQ,IAAIC,EAAG,IAAI;AAInC,SADwBV,EAAW,MAAO,EAAC,KAAKW,EAAS;AAE7D;AAEA,SAASA,GAAUC,GAAKC,GACxB;AAEI,SAAID,EAAI,SAASC,EAAI,SACV,KAEPD,EAAI,SAASC,EAAI,SACV,IAGPD,EAAI,aAAaC,EAAI,aACd,KAEPD,EAAI,aAAaC,EAAI,aACd,IAEJ;AACX;AAEA,SAASC,GAAqBC,GAAMf,GAAY;AAC5C,SAAOA,EAAW,MAAO,EAAC,KAAM,CAACgB,GAAYC,MACrCF,EAAK,MAAMC,EAAW,EAAE,IAAID,EAAK,MAAME,EAAW,EAAE,IAC7C,KAEPF,EAAK,MAAMC,EAAW,EAAE,IAAID,EAAK,MAAME,EAAW,EAAE,IAC7C,IAEJ,CACV;AACL;AAEA,SAASC,GAA8BX,GACvC;AACI,MAAIA,EAAc,YAAY,SAAS;AAAG;AAE1C,MAAIY,IAAa,IAEbC,GACAC,GACAC,GACAC;AACJ,WAASC,IAAI,GAAGA,IAAIjB,EAAc,mBAAmB,QAAQiB;AAEzD,QAAIjB,EAAc,mBAAmBiB,GAAG,OAAO,IAG/C;AAAA,MAAAJ,IAAiBb,EAAc,mBAAmBiB,IAClDH,IAAiBd,EAAc,YAAYa,EAAe;AAE1D,eAASK,IAAED,IAAE,GAAGC,IAAIlB,EAAc,mBAAmB,WACjDe,IAAiBf,EAAc,mBAAmBkB,IAC9C,EAACrD,GAAGkD,EAAe,YAAYF,EAAe,UAAU,IAFHK;AAKzD,QAAIH,EAAe,OAAO,OAE1BC,IAAiBhB,EAAc,YAAYe,EAAe,KACtDC,EAAe,OAAO,MAEtBD,EAAe,gBAAgBF,EAAe,eAC9CE,EAAe,eAAeF,EAAe,cAC7CG,EAAe,gBAAgBF,EAAe,eAC9CE,EAAe,eAAeF,EAAe,eAC7CC,EAAe,KAAK,IAEpBC,EAAe,KAAK,IAEpBJ,IAAa;AAAA;AAKzB,EAAAE,IAAiBd,EAAc,mBAAmB,IAClDa,IAAiBb,EAAc,YAAYc,EAAe;AAC1D,WAASG,IAAI,GAAGA,IAAIjB,EAAc,mBAAmB,QAAQiB,KAAK;AAC9D,QAAID,IAAiBhB,EAAc,mBAAmBiB;AAEtD,QAAID,EAAe,MAAM;AAAI;AAG7B,QAAIF,EAAe,MAAM,MACrB,CAAEjD,GAAGmD,EAAe,YAAYF,EAAe,UAAU,GAAI;AAC7D,MAAAA,IAAiBE,GACjBH,IAAiBb,EAAc,YAAYc,EAAe;AAC1D;AAAA,IACH;AAED,QAAIC,IAAiBf,EAAc,YAAYgB,EAAe;AAC9D,IAAID,EAAe,gBAAgBF,EAAe,eAC9CE,EAAe,eAAeF,EAAe,cAC7CG,EAAe,gBAAgBF,EAAe,eAC9CE,EAAe,eAAeF,EAAe,eAC7CC,EAAe,KAAK,IAEpBC,EAAe,KAAK,IAEpBJ,IAAa;AAAA,EAEpB;AAED,EAAIA,MACAZ,EAAc,cAAcA,EAAc,YAAY,OAAO,CAACmB,MAAcA,EAAU,MAAM,CAAC,GAC7FnB,EAAc,cAAcA,EAAc,YAAY,OAAO,CAACmB,MAAcA,EAAU,MAAM,CAAC,GAG7FnB,EAAc,YAAY,QAAQ,CAACmB,GAAWC,MAAUD,EAAU,KAAKC,CAAK,GAC5EpB,EAAc,YAAY,QAAQ,CAACmB,GAAWC,MAAUD,EAAU,KAAKC,CAAK;AAEpF;AAEA,SAASC,GAAyB5B,GAClC;AACI,WAAS0B,KAAa1B;AAClB,IAAA0B,EAAU,YAAY,UAAU,QAChCA,EAAU,YAAY,QAAQ,QAC9BA,EAAU,YAAY,KAAK,QAC3BA,EAAU,YAAY,UAAU,QAEhCA,EAAU,WAAW,UAAU,QAC/BA,EAAU,WAAW,QAAQ,QAC7BA,EAAU,WAAW,KAAK,QAC1BA,EAAU,WAAW,UAAU;AAGnC,WAASA,KAAa1B;AAClB,IAAA0B,EAAU,YAAY,QAAQtE,GAC9BsE,EAAU,WAAW,UAAUtE;AAEvC;AAEA,SAASyE,GAAwB7B,GAAY8B,GAC7C;AACI,WAASJ,KAAa1B;AAClB,IAAA0B,EAAU,YAAY,aAAaI,CAAO,GAC1CJ,EAAU,WAAW,aAAaI,CAAO;AAEjD;AAEA,SAASC,GAAoBxB,GAC7B;AACI,MAAIyB,GACAC,GACAC,GACAC,IAAiB5B,EAAc,YAAY;AAE/C,WAASiB,IAAI,GAAGA,IAAIW,GAAgBX,KAAK;AACrC,QAAIY,IAAiB7B,EAAc,mBAAmBiB;AAGtD,IAAIY,EAAe,SAASJ,MACxBC,IAA6BT,GAC7BQ,IAAWI,EAAe;AAI9B,QAAIC,IAA4Bb,GAC5Bc,IAA0BC,GAAmBhC,EAAc,oBAAoBiB,GAAGQ,CAAQ,GAC1FQ;AACJ,IAAIH,IAA4BC,IAA0BH,KACtD5B,EAAc,mBAAmB8B,IAA4BC,GAAyB,SAASN,IAC/FQ,IAAoBH,IAA4BC,IAEhDE,IAAoBP;AAKxB,QAAIQ,IAA2BF,GAAmBhC,EAAc,oBAAoBiC,GAAmBR,CAAQ;AAC/G,IAAAE,IAAkB;AAClB,aAAST,IAAEe,GAAmBf,IAAIe,IAAoBC,GAA0BhB,KAAK;AACjF,UAAIiB,IAAsBnC,EAAc,mBAAmBkB;AAC3D,UAAIiB,EAAoB,SAASV,KAC7BzB,EAAc,YAAYmC,EAAoB,IAAI,SAASnC,EAAc,YAAY6B,EAAe,IAAI,MAAM;AAC9G,QAAAF,IAAkBQ;AAClB;AAAA,MACH;AAAA,IACJ;AACD,QAAIR,MAAoB;AACpB;AAEJ,QAAIS,IAAaP,EAAe,YAC5BQ,IAAWV,EAAgB;AAK/B,QAHI,EAAES,EAAW,OAAOvF,KAAYwF,EAAS,OAAOxF,MAGhDuF,MAAeC;AACf;AAGJ,QAAIC,IAAiBtC,EAAc,YAAY6B,EAAe,KAC1DU,IAAkBvC,EAAc,YAAY2B,EAAgB,KAE5Da,IAAaF,EAAe,YAC5BG,IAAWF,EAAgB;AAY/B,IARMC,EAAW,OAAO3F,KAAY4F,EAAS,OAAO5F,KAAY2F,MAAeC,MAC3EH,IAAiBtC,EAAc,YAAY2B,EAAgB,KAC3DY,IAAkBvC,EAAc,YAAY6B,EAAe,KAE3DW,IAAaF,EAAe,YAC5BG,IAAWF,EAAgB,cAGzBC,EAAW,OAAO3F,KAAY4F,EAAS,OAAO5F,KAAY2F,MAAeC,KAI/EL,EAAW,WAAWI,CAAU;AAAA,EACnC;AACL;AAEA,SAASR,GAAmBvC,GAAYiD,GAAmBjB,GAC3D;AACI,MAAIkB,GACAC,GAEAC,IAAsB;AAE1B,MAAIpD,EAAW,UAAU;AAAG,WAAO;AAEnC,EAAAkD,IAAoBlD,EAAWiD;AAE/B,WAASzB,IAAIyB,IAAoB,GAAGzB,IAAIxB,EAAW,UAC3C,EAAAkD,EAAkB,QAAQlB,MAI9BmB,IAAiBnD,EAAWwB,IAExB,EAAE2B,EAAe,GAAG,QAAQD,EAAkB,EAAE,KAChDC,EAAe,gBAAgBD,EAAkB,eACjDC,EAAe,eAAeD,EAAkB,eATG1B;AAavD,IAAA4B;AAEJ,SAAOA;AACX;AAEA,SAASC,GAAqBvB,GAAS9B,GACvC;AACI,MAAKA,GACL;AAAA,aAAS0B,KAAa1B,GAAY;AAC9B,UAAId,IAAOwC,EAAU;AAWrB,UARAA,EAAU,YAAYjE,IAClByB,EAAK,MAAM,SAASA,EAAK,MAAM,MAAM,QAAQwC,EAAU,EAAE,MACzDA,EAAU,aAAahE,KAEvBwB,EAAK,MAAM,OAAOA,EAAK,MAAM,IAAI,QAAQwC,EAAU,EAAE,MACrDA,EAAU,aAAa/D,KAGvB+D,EAAU,YAAYhE,IAAc;AACpC,QAAAgE,EAAU,cAAcxC,EAAK,MAC7BwC,EAAU,YAAY/D;AACtB;AAAA,MACH;AACD,UAAI+D,EAAU,YAAY/D;AACtB;AAGJ,UAAI2F,IAAUxB,EAAQ,UAAUJ,EAAU,IAAIxC,CAAI;AAClD,MAAAwC,EAAU,cAAc4B;AAAA,IAC3B;AAED,aAAS5B,KAAa1B;AAClB,MAAA0B,EAAU,aAAaA,EAAU,YAAY;AAAA;AAErD;AAEA,SAAS6B,GAAuBvC,GAAYC,GAAYuC,GAAU;AAC9D,MAAIC,IAAczC,EAAW,aACzB0C,IAAazC,EAAW;AAE5B,EAAAwC,EAAY,OAAOD,GACnBA,EAAS,OAAOC,GAEhBD,EAAS,OAAOE,GAChBA,EAAW,OAAOF;AACtB;AAMA,MAAM,EAAC,QAAQG,GAAU,SAASC,GAAW,UAAUC,GAAY,cAAcC,IAAgB,kBAAkBC,GAAkB,IAAInG,IACnI,EAAC,YAAYoG,IAAc,cAAcC,IAAgB,YAAYC,GAAY,IAAItG,IAErFuG,KAAgB,GAChBC,KAAoB,GACpBC,KAAmB;AAUzB,SAASC,GAAMC,GAAUC,GAAU;AAC/B,MAAI,CAACC,GAAUC,CAAQ,IAAIC,GAAgBJ,GAAUC,GAAUL,IAAe,EAAI;AAClF,SAAOM;AACX;AASA,SAASG,GAASL,GAAUC,GAAU;AAElC,MAAIK,IADeL,EAAS,QACS,WACjC,CAACC,GAAUC,CAAQ,IAAIC,GAAgBJ,GAAUM,GAAmBR,IAAkB,EAAI;AAC9F,SAAOI;AACX;AASA,SAASK,GAAUP,GAAUC,GAAU;AACnC,MAAI,CAACC,GAAUC,CAAQ,IAAIC,GAAgBJ,GAAUC,GAAUJ,IAAmB,EAAI;AACtF,SAAOK;AACX;AASA,SAASM,GAAUR,GAAUC,GAAU;AACnC,MAAI,CAACC,GAAUC,CAAQ,IAAIC,GAAgBJ,GAAUC,GAAUJ,IAAmB,EAAK,GAEnFY,IAAe,CAAA;AACnB,WAASC,KAAQR,EAAS;AACtB,IAAAO,IAAe,CAAC,GAAGA,GAAc,GAAG,CAAC,GAAGC,EAAK,KAAK,EAAE,IAAI,CAAA/F,MAAQA,EAAK,KAAK,CAAC;AAE/E,MAAIgG,IAAe,CAAA;AACnB,WAASD,KAAQP,EAAS;AACtB,IAAAQ,IAAe,CAAC,GAAGA,GAAc,GAAG,CAAC,GAAGD,EAAK,KAAK,EAAE,IAAI,CAAA/F,MAAQA,EAAK,KAAK,CAAC;AAE/E,SAAO,CAAC8F,GAAcE,CAAY;AACtC;AAQA,SAASC,GAAUZ,GAAUC,GAAU;AACnC,MAAI,CAACC,GAAUC,CAAQ,IAAIC,GAAgBJ,GAAUC,GAAUH,IAAkB,EAAK,GAElFW,IAAe,CAAA;AACnB,WAASC,KAAQR,EAAS;AACtB,IAAAO,IAAe,CAAC,GAAGA,GAAc,GAAG,CAAC,GAAGC,EAAK,KAAK,EAAE,IAAI,CAAA/F,MAAQA,EAAK,KAAK,CAAC;AAG/E,SAAO8F;AACX;AAUA,SAASI,GAAuBb,GAAUC,GAAU;AAChD,MAAIC,IAAWF,EAAS,SACpBG,IAAWF,EAAS,SAGpBjE,IAAgB8E,GAAiBZ,GAAUC,CAAQ;AAGvD,EAAApE,GAAkBC,CAAa,GAG/B8C,GAAqBoB,GAAUlE,EAAc,kBAAkB,GAC/D8C,GAAqBqB,GAAUnE,EAAc,kBAAkB,GAG/DW,GAA8BX,CAAa,GAG3CD,GAAkBC,CAAa;AAE/B,MAAI+E,IAAa/E,EAAc,mBAAmB,IAAK,CAAAmB,MAAaA,EAAU,EAAE,GAC5E6D,IAAahF,EAAc,mBAAmB,IAAK,CAAAmB,MAAaA,EAAU,EAAE;AAChF,SAAO,CAAC4D,GAAYC,CAAU;AAClC;AAEA,SAASC,GAAuBf,GAAUC,GAAUnE,GAAekF,GAAI;AAEnE,MAAIC,IAAyBC,GAAuBlB,GAAUlE,EAAc,WAAW,GACnFqF,IAAyBD,GAAuBjB,GAAUnE,EAAc,WAAW;AAevF,OAZAsF,GAAoCH,GAAwBhB,CAAQ,GACpEmB,GAAoCD,GAAwBnB,CAAQ,GAGpE7C,GAAyBrB,EAAc,WAAW,GAClDqB,GAAyBrB,EAAc,WAAW,GAGlDsB,GAAwBtB,EAAc,aAAamE,CAAQ,GAC3D7C,GAAwBtB,EAAc,aAAakE,CAAQ,GAGpDqB,GAAqBrB,GAAUC,GAAUnE,EAAc,aAAaA,EAAc,oBAAoBA,EAAc,aAAaA,CAAa;AAAE;AAIvJ,EAAAwB,GAAoBxB,CAAa,GAGjCwF,GAAwBtB,GAAUgB,GAAIlF,EAAc,oBAAoB,EAAI,GAC5EwF,GAAwBrB,GAAUe,GAAIlF,EAAc,oBAAoB,EAAK,GAK7EyF,GAAqCvB,GAAUiB,GAAwBD,GAAI,EAAI,GAC/EO,GAAqCtB,GAAUkB,GAAwBH,GAAI,EAAK;AACpF;AAEA,SAASQ,GAAoBxB,GAAUC,GAAUnE,GAAekF,GAAI;AAGhE,EAAAS,GAAazB,GAAUC,GAAUe,GAAIlF,EAAc,WAAW,GAG9D4F,GAAU1B,GAAUC,GAAUnE,CAAa,GAG3C6F,GAAe3B,GAAUlE,EAAc,WAAW,GAClD6F,GAAe1B,GAAUnE,EAAc,WAAW,GAGlD8F,GAAa5B,GAAUlE,EAAc,aAAaA,EAAc,WAAW,GAC3E8F,GAAa5B,GAAUlE,EAAc,aAAaA,EAAc,WAAW;AAI/E;AAGA,SAASoE,GAAgBJ,GAAUC,GAAUiB,GAAIa,GACjD;AACI,MAAI7B,IAAWF,EAAS,SACpBG,IAAWF,EAAS,SAGpBjE,IAAgB8E,GAAiBZ,GAAUC,CAAQ;AAGvD,SAAApE,GAAkBC,CAAa,GAG/B8C,GAAqBoB,GAAUlE,EAAc,kBAAkB,GAC/D8C,GAAqBqB,GAAUnE,EAAc,kBAAkB,GAG/DW,GAA8BX,CAAa,GAG3CD,GAAkBC,CAAa,GAG/BiF,GAAuBf,GAAUC,GAAUnE,GAAekF,CAAE,GAExDa,KACAL,GAAoBxB,GAAUC,GAAUnE,GAAekF,CAAE,GAGtD,CAAChB,GAAUC,CAAQ;AAC9B;AAEA,SAASW,GAAiBd,GAAUC,GACpC;AACI,MAAIjE,IAAgB;AAAA,IAChB,aAAa,CAAE;AAAA,IACf,aAAa,CAAE;AAAA,EACvB;AAGI,WAASgG,KAAShC,EAAS,OAAO;AAG9B,QAAIiC,IAAOhC,EAAS,MAAM,OAAO+B,EAAM,GAAG;AAG1C,aAASE,KAASD,GAAM;AAGpB,UAAI9F,IAAK6F,EAAM,MAAM,UAAUE,EAAM,KAAK;AAG1C,eAAS1G,KAAMW;AACX,QAAAZ,GAAeyG,GAAOxG,GAAIQ,EAAc,WAAW,GACnDT,GAAe2G,GAAO1G,GAAIQ,EAAc,WAAW;AAAA,IAE1D;AAAA,EACJ;AACD,SAAOA;AACX;AAEA,SAASoF,GAAuBe,GAAM1G,GACtC;AACI,MAAI2G,IAAiB,CAAA;AACrB,WAAS1B,KAAQyB,EAAK;AAClB,IAAK1G,EAAW,KAAK,CAACU,MAAOA,EAAG,SAASuE,CAAI,KACzC0B,EAAe,KAAK1B,CAAI;AAGhC,SAAO0B;AACX;AAEA,SAASd,GAAoCe,GAAqBC,GAClE;AACI,WAAS5B,KAAQ2B;AACb,IAAA3B,EAAK,MAAM,KAAKA,EAAK,MAAM,UAAUA,EAAK,MAAM,QAAQ,QACxDA,EAAK,MAAM,aAAa4B,CAAK;AAErC;AAEA,SAASf,GAAqBgB,GAAOD,GAAOE,GAAaC,GAAoBC,GAAa1G,GAC1F;AACI,MAAIyB,GACAC,GACAC,GACAC,IAAiB6E,EAAmB,QACpCE,IAAe;AAEnB,WAAS1F,IAAI,GAAGA,IAAIW,GAAgBX,KAAK;AACrC,QAAIY,IAAiB4E,EAAmBxF;AAGxC,IAAIY,EAAe,SAASJ,MACxBC,IAA6BT,GAC7BQ,IAAWI,EAAe;AAI9B,QAAIC,IAA4Bb,GAC5Bc,IAA0BC,GAAmByE,GAAoBxF,GAAGQ,CAAQ,GAC5EQ;AACJ,IAAIH,IAA4BC,IAA0BH,KACtD6E,EAAmB3E,IAA4BC,GAAyB,SAASN,IACjFQ,IAAoBH,IAA4BC,IAEhDE,IAAoBP;AAKxB,QAAIQ,IAA2BF,GAAmByE,GAAoBxE,GAAmBR,CAAQ;AACjG,IAAAE,IAAkB;AAClB,aAAST,IAAEe,GAAmBf,IAAIe,IAAoBC,GAA0BhB,KAAK;AACjF,UAAIiB,IAAsBsE,EAAmBvF;AAC7C,UAAIiB,EAAoB,SAASV,KAC7BiF,EAAYvE,EAAoB,IAAI,SAASuE,EAAY7E,EAAe,IAAI,MAAM;AAClF,QAAAF,IAAkBQ;AAClB;AAAA,MACH;AAAA,IACJ;AACD,QAAIR,MAAoB;AACpB;AAEJ,QAAIS,IAAaP,EAAe,YAC5BQ,IAAWV,EAAgB;AAG/B,QAAIS,EAAW,OAAOkB,KAAcjB,EAAS,MAAMiB,GAAY;AAC3D,MAAAlB,EAAW,KAAKC,EAAS;AACzB;AAAA,IACH;AAED,QAAID,EAAW,MAAMkB,KAAcjB,EAAS,OAAOiB,GAAY;AAC3D,MAAAjB,EAAS,KAAKD,EAAW;AACzB;AAAA,IACH;AAGD,QAAMA,EAAW,OAAOkB,KAAcjB,EAAS,OAAOiB,KAAclB,KAAcC,KACjFD,EAAW,OAAOgB,KAAYf,EAAS,OAAOgB,KAAcjB,EAAW,OAAOiB,KAAahB,EAAS,OAAOe,GAAa;AACrH,UAAIwD,IAAWxE,EAAW;AAC1B,aAAOwE,KAAYvE;AACf,QAAAuE,EAAS,UAAU,QACnBA,EAAS,QAAQ,QACjBA,EAAS,KAAK,QACdA,EAAS,aAAaN,CAAK,GAC3BM,IAAWA,EAAS;AAAA,IAE3B;AAID,QAAIxE,EAAW,OAAOkB,KAAcjB,EAAS,OAAOiB,KAAclB,KAAcC,GAAU;AACtF,UAAIuE,IAAWxE,EAAW,MACtByE;AACJ,aAAOD,KAAYvE,KAAU;AACzB,YAAIuE,EAAS,MAAMtD;AACf,cAAIuD,MAAW;AACX,YAAAA,IAASD,EAAS;AAAA,mBAGdA,EAAS,MAAMC;AACf,kBAAMzI,GAAO;AAAA;AAIzB,QAAAwI,IAAWA,EAAS;AAAA,MACvB;AAED,MAAIC,KAAU,SACVzE,EAAW,KAAKyE,GAChBxE,EAAS,KAAKwE;AAElB;AAAA,IACH;AAGD,QAAIzE,EAAW,OAAOgB,KAAYf,EAAS,OAAOgB,KAAcjB,EAAW,OAAOiB,KAAahB,EAAS,OAAOe,GAAW;AACtH,UAAIwD,IAAWxE;AAEf,aAAOwE,KAAYvE,KAAU;AACzB,YAAIuE,EAAS,YAAYxE,EAAW,MAAMwE,EAAS,UAAUvE,EAAS,IAAI;AACtE,cAAI,CAACyE,GAAMC,EAAO,IAAIH,EAAS,MAAM,WAAWN,CAAK;AACrD,cAAIQ,IAAO,KAAGzI,EAAQ,QAAQ;AAG1B,YAAAkB,GAAeqH,GAAUG,GAAQ,IAAIP,CAAW;AAGhD,gBAAI/F,IAAa+F,EAAYA,EAAY,SAAO;AAChD,gBAAI/F,EAAW,YAAYiD;AACvB,cAAAjD,EAAW,aAAamG,GACxBnG,EAAW,cAAcmG,EAAS,MAClCA,EAAS,UAAUtD,GACnBsD,EAAS,KAAK,QACdA,EAAS,aAAaN,CAAK;AAAA,qBAEtB7F,EAAW,YAAYkD;AAC5B,cAAAlD,EAAW,aAAamG,EAAS,MACjCA,EAAS,QAAQtD,GACjBsD,EAAS,KAAK,QACdA,EAAS,aAAaN,CAAK;AAAA,iBAE1B;AACD,kBAAIU,IAAWV,EAAM,UAAU7F,EAAW,IAAImG,CAAQ;AACtD,cAAAnG,EAAW,cAAcuG,GACzBvG,EAAW,aAAauG,EAAS,MAEjCA,EAAS,aAAaV,CAAK,GAE3BU,EAAS,KAAK,UAAU1D,GACxB0D,EAAS,KAAK,QAAQ,QACtBA,EAAS,KAAK,KAAK,QACnBA,EAAS,KAAK,aAAaV,CAAK;AAAA,YACnC;AAGD,gBAAIJ,KAAQI,EAAM,gBAAgBS,GAAQ,EAAE;AAC5C,YAAAxH,GAAe2G,IAAOa,GAAQ,IAAIL,CAAW;AAE7C,gBAAIhG,IAAagG,EAAYA,EAAY,SAAO;AAChD,gBAAIhG,EAAW,YAAYgD;AACvB,cAAAhD,EAAW,aAAawF,IACxBxF,EAAW,cAAcwF,GAAM;AAAA,qBAE1BxF,EAAW,YAAYiD;AAC5B,cAAAjD,EAAW,aAAawF,GAAM;AAAA,iBAE7B;AAGD,kBAAIe,IAAwBP,EAAY,KAAM,CAAAvF,OAAaA,GAAU,eAAe+E,KAEhFgB,IAAWZ,EAAM,UAAU5F,EAAW,IAAIwF,EAAK;AACnD,cAAAxF,EAAW,cAAcwG,GACzBxG,EAAW,aAAawG,EAAS,MAE7BD,MACAA,EAAsB,aAAaC,IAEvCA,EAAS,UAAU,QACnBA,EAAS,QAAQ5D,GACjB4D,EAAS,KAAK,QACdA,EAAS,aAAaX,CAAK,GAE3BW,EAAS,KAAK,UAAU5D,GACxB4D,EAAS,KAAK,QAAQ,QACtBA,EAAS,KAAK,KAAK,QACnBA,EAAS,KAAK,aAAaX,CAAK;AAAA,YACnC;AAED,YAAAxG,GAAkBC,CAAa,GAE/B2G,IAAe;AACf;AAAA,UACH;AAAA,QACJ;AACD,QAAAC,IAAWA,EAAS;AAAA,MACvB;AAGD,UAAID;AACA;AAEJ,YAAMvI,GAAO;AAAA,IAChB;AAAA,EACJ;AAED,SAAOuI;AACX;AAEA,SAASnB,GAAwBjE,GAAS2D,GAAIzF,GAAY0H,GAC1D;AACI,MAAI,CAAC1H;AAAY;AACjB,MAAIgC,GACA2F,GACAzE,GACAC;AAEJ,WAAS3B,IAAI,GAAGA,IAAIxB,EAAW,QAAQwB,KAAK;AAQxC,QAPA0B,IAAoBlD,EAAWwB,IAE3B0B,EAAkB,SAASlB,MAC3B2F,IAA8BnG,GAC9BQ,IAAWkB,EAAkB,OAG7BlB,EAAS,QAAS;AAClB;AAKJ,QAAI4F,IAA6BpG,GAC7BqG,IAA2BtF,GAAmBvC,GAAYwB,GAAGQ,CAAQ,GACrE8F;AACJ,IAAIF,IAA6BC,IAA2B7H,EAAW,UACnEA,EAAW4H,IAA6BC,GAA0B,SAAS3E,EAAkB,OAC7F4E,IAAqBF,IAA6BC,IAElDC,IAAqBH,GAEzBxE,IAAiBnD,EAAW8H;AAG5B,QAAIC,IAA2BD,GAC3BE,IAAyBzF,GAAmBvC,GAAY+H,GAA0B/F,CAAQ,GAG1FiG,IAAY/E,EAAkB,YAC9BgF,IAAU/E,EAAe;AAE7B,QAAK8E,EAAU,OAAOtE,KAAYuE,EAAQ,OAAOvE,KAAY8B,MAAOtB,MAC/D8D,EAAU,OAAOrE,KAAasE,EAAQ,OAAOtE,KAAa6B,MAAOrB,OAChE6D,EAAU,OAAOrE,KAAasE,EAAQ,OAAOtE,MAAc6B,MAAOpB,MAAoB,CAACqD,MACvFO,EAAU,OAAOtE,KAAYuE,EAAQ,OAAOvE,MAAa8B,MAAOpB,MAAoBqD,KACrFO,EAAU,OAAOpE,KAAcqE,EAAQ,OAAOrE,KAAeoE,EAAU,UAAUnE,MAAmB4D,KACpGO,EAAU,OAAOpE,KAAcqE,EAAQ,OAAOrE,KAAeoE,EAAU,UAAUlE,IAAsB;AAExG,MAAAjC,EAAQ,YAAYE,GAAUiG,GAAWC,CAAO;AAGhD,eAASC,IAAIP,GAA4BO,IAAIP,IAA6BC,GAA0BM;AAChG,QAAAnI,EAAWmI,GAAG,aAAa;AAI/B,eAASA,IAAIJ,GAA0BI,IAAIJ,IAA2BC,GAAwBG;AAC1F,QAAAnI,EAAWmI,GAAG,cAAc;AAAA,IAEnC;AAGD,IAAA3G,KAAKqG,IAA2B;AAAA,EACnC;AACL;AACA,SAAS3B,GAAakC,GAAaC,GAAa5C,GAAIzF,GACpD;AACI,WAASiF,KAAQoD,EAAY,OAAO;AAChC,aAASnJ,KAAQ+F;AACb,MAAAmD,EAAY,MAAM,IAAIlJ,CAAI;AAG9B,IACIc,EAAW,KAAK,CAACU,MAAQA,EAAG,SAASuE,CAAK,MAAM,UAChDmD,EAAY,QAAQnD,EAAK,OAAOA,EAAK,IAAI;AAAA,EAEhD;AACL;AAEA,SAASkB,GAAUiC,GAAaC,GAAa9H,GAC7C;AACI,MAAIA,EAAc,YAAY,WAAW;AAEzC,aAASiB,IAAI,GAAGA,IAAIjB,EAAc,YAAY,QAAQiB,KAAK;AACvD,UAAIR,IAAaT,EAAc,YAAYiB,IACvCP,IAAaV,EAAc,YAAYiB;AAiC3C,UA5BIR,EAAW,gBAAgB,UAAaA,EAAW,eAAe,UAC9DC,EAAW,gBAAgB,UAAaA,EAAW,eAAe,WAElED,EAAW,YAAY,OAAOC,EAAW,YACzCA,EAAW,WAAW,OAAOD,EAAW,aAGxCA,EAAW,aAAaC,EAAW,YACnCA,EAAW,cAAcD,EAAW,cAIxCC,EAAW,gBAAgB,UAAaA,EAAW,eAAe,UAC9DD,EAAW,gBAAgB,UAAaA,EAAW,eAAe,WAElEC,EAAW,YAAY,OAAOD,EAAW,YACzCA,EAAW,WAAW,OAAOC,EAAW,aAGxCA,EAAW,aAAaD,EAAW,YACnCA,EAAW,cAAcC,EAAW,cAQxCD,EAAW,gBAAgB,UAAaA,EAAW,eAAe;AAClE,iBAASU,KAAanB,EAAc;AAChC,UAAImB,MAAcV,KACdU,EAAU,gBAAgB,UAAaA,EAAU,eAAe,UAC5DA,EAAU,GAAG,QAAQV,EAAW,EAAE,MAElCA,EAAW,YAAY,OAAOU,EAAU,YACxCA,EAAU,WAAW,OAAOV,EAAW,aAGvCA,EAAW,aAAaU,EAAU,YAClCA,EAAU,cAAcV,EAAW;AAMnD,UAAIC,EAAW,gBAAgB,UAAaA,EAAW,eAAe;AAClE,iBAASS,KAAanB,EAAc;AAChC,UAAImB,MAAcT,KACdS,EAAU,gBAAgB,UAAaA,EAAU,eAAe,UAC5DA,EAAU,GAAG,QAAQT,EAAW,EAAE,MAElCA,EAAW,YAAY,OAAOS,EAAU,YACxCA,EAAU,WAAW,OAAOT,EAAW,aAGvCA,EAAW,aAAaS,EAAU,YAClCA,EAAU,cAAcT,EAAW;AAAA,IAKtD;AAEL;AAEA,SAASmF,GAAetE,GAAS9B,GACjC;AACI,WAAS0B,KAAa1B;AAClB,IAAA8B,EAAQ,MAAM,OAAOJ,EAAU,IAAI,GACnCA,EAAU,OAAO,QACbA,EAAU,gBACVA,EAAU,YAAY,OAAO,SAC7BA,EAAU,eACVA,EAAU,WAAW,OAAO;AAExC;AAEA,SAAS2E,GAAavE,GAAS9B,GAAYsI,GAC3C;AAEI,WAAS5G,KAAa1B,GAAY;AAM9B,QALI0B,EAAU,gBAAgB,UAAaA,EAAU,eAAe,UAEhEA,EAAU,QAGVA,EAAU,WAAW,QAAQA,EAAU,YAAY;AACnD;AAEJ,QAAI1C,IAAQ0C,EAAU,YAClBzC,IAAOyC,EAAU;AAErB,IAAA3C,GAAW,iBAAiBC,CAAK;AAEjC,QAAIiG,IAAOnD,EAAQ,QAAQ9C,GAAOC,CAAI;AAKtC,aAASsJ,KAAiBvI;AACtB,MAAIuI,EAAc,eAAeA,EAAc,cAC3CA,EAAc,YAAY,SAAStD,KAAQsD,EAAc,WAAW,SAAStD,MAC7EsD,EAAc,OAAOtD;AAI7B,aAASsD,KAAiBD;AACtB,MAAIC,EAAc,eAAeA,EAAc,cAC3CA,EAAc,YAAY,SAAStD,KAAQsD,EAAc,WAAW,SAAStD,MAC7EsD,EAAc,OAAOtD;AAAA,EAGhC;AACL;AAEA,SAASe,GAAqClE,GAAS8E,GAAqBnB,GAAIiC,GAChF;AACI,WAASzC,KAAQ2B,GAAqB;AAClC,QAAI4B,IAAMvD,EAAK,MAAM;AACrB,KAAIQ,MAAOtB,MAAiBqE,MAAQ7E,KAChC8B,MAAOpB,MAAoBmE,MAAQ7E,KAAY+D,KAC/CjC,MAAOpB,MAAoBmE,MAAQ5E,KAAa,CAAC8D,KACjDjC,MAAOrB,MAAqBoE,MAAQ5E,MAEpC9B,EAAQ,WAAWmD,CAAI;AAAA,EAE9B;AACL;AAEA,IAAIwD,KAAiC,uBAAO,OAAO;AAAA,EAC/C,eAAetE;AAAA,EACf,mBAAmBC;AAAA,EACnB,kBAAkBC;AAAA,EAClB,OAAOC;AAAA,EACP,UAAUM;AAAA,EACV,WAAWE;AAAA,EACX,WAAWC;AAAA,EACX,WAAWI;AAAA,EACX,wBAAwBC;AAAA,EACxB,yBAAyBW;AAAA,EACzB,gBAAgBK;AAAA,EAChB,cAAcC;AAClB,CAAC;AAOD,MAAMqC,KAAQ,OAAO,qBAAqB,GACpCC,KAAY,OAAO,yCAAyC,GAC5DC,KAAQ,OAAO,+BAA+B,GAC9CC,KAAW,OAAO,WAAW,GAC7BC,KAAU,OAAO,yCAAyC;AAEhE,MAAMC,GAAM;AAAA,EAIR,cAAc;AAKV,SAAK,IAAI,IAAI,MAAM,CAAC,EAAE,KAAK,MAAS;AAAA,EACvC;AAAA,EAMD,IAAI,MAAM;AACN,WAAO,KAAK,EAAE;AAAA,EACjB;AAAA,EAMD,IAAI,IAAIC,GAAM;AACV,SAAK,EAAE,KAAKA;AAAA,EACf;AAAA,EAMD,IAAI,MAAM;AACN,WAAO,KAAK,EAAE;AAAA,EACjB;AAAA,EAMD,IAAI,IAAIA,GAAM;AACV,SAAK,EAAE,KAAKA;AAAA,EACf;AAAA,EAMD,IAAI,MAAM;AACN,WAAO,KAAK,EAAE;AAAA,EACjB;AAAA,EAMD,IAAI,IAAIA,GAAM;AACV,SAAK,EAAE,KAAKA;AAAA,EACf;AAAA,EAMD,IAAI,MAAM;AACN,WAAO,KAAK,EAAE;AAAA,EACjB;AAAA,EAMD,IAAI,IAAIA,GAAM;AACV,SAAK,EAAE,KAAKA;AAAA,EACf;AAAA,EAMD,IAAI,MAAM;AACN,WAAO,KAAK,EAAE;AAAA,EACjB;AAAA,EAMD,IAAI,IAAIA,GAAM;AACV,SAAK,EAAE,KAAKA;AAAA,EACf;AAAA,EAMD,IAAI,MAAM;AACN,WAAO,KAAK,EAAE;AAAA,EACjB;AAAA,EAMD,IAAI,IAAIA,GAAM;AACV,SAAK,EAAE,KAAKA;AAAA,EACf;AAAA,EAMD,IAAI,MAAM;AACN,WAAO,KAAK,EAAE;AAAA,EACjB;AAAA,EAMD,IAAI,IAAIA,GAAM;AACV,SAAK,EAAE,KAAKA;AAAA,EACf;AAAA,EAMD,IAAI,MAAM;AACN,WAAO,KAAK,EAAE;AAAA,EACjB;AAAA,EAMD,IAAI,IAAIA,GAAM;AACV,SAAK,EAAE,KAAKA;AAAA,EACf;AAAA,EAMD,IAAI,MAAM;AACN,WAAO,KAAK,EAAE;AAAA,EACjB;AAAA,EAMD,IAAI,IAAIA,GAAM;AACV,SAAK,EAAE,KAAKA;AAAA,EACf;AAAA,EAUD,WAAW;AACP,WAAO,KAAK,EAAE,IAAK,CAAAC,MACXA,aAAa,SAASA,EAAE,SAAS,IAC1B,MAEFA,aAAa,SAASA,EAAE,WAAW,IACjC,MAGA,GAEd,EAAE,KAAK,EAAE;AAAA,EACb;AAAA,EAED,QAAQ;AACJ,WAAOP,GAAM,KAAK,KAAK,SAAU,CAAA;AAAA,EACpC;AAAA,EAED,YAAY;AACR,WAAOC,GAAU,KAAK,KAAK,SAAU,CAAA;AAAA,EACxC;AAAA,EAED,QAAQ;AACJ,WAAOC,GAAM,KAAK,KAAK,SAAU,CAAA;AAAA,EACpC;AAAA,EAED,SAAS;AACL,WAAOC,GAAS,KAAK,KAAK,SAAU,CAAA;AAAA,EACvC;AAAA,EAED,UAAU;AACN,WAAOC,GAAQ,KAAK,KAAK,SAAU,CAAA;AAAA,EACtC;AACL;AAOA,SAASI,GAAmBC,GAAOC,GAAO;AACtC,MAAI1I,IAAK,CAAA,GAEL,CAAC2I,GAAIC,GAAIC,CAAE,IAAIJ,EAAM,UACrB,CAACK,GAAIC,GAAIC,CAAE,IAAIN,EAAM,UAGrBO,IAAMN,IAAKI,IAAKH,IAAKE,GACrBI,IAAOL,IAAKE,IAAKH,IAAKI,GACtBG,IAAOR,IAAKK,IAAKH,IAAKC;AAE1B,MAAI,CAAC5K,EAAQ,MAAM,KAAK+K,CAAG,GAAG;AAC1B,QAAIxL,GAAGE;AAEP,IAAIiL,MAAO,KACPnL,IAAIoL,IAAGF,GACPhL,IAAIwL,IAAOF,KAENF,MAAO,KACZtL,IAAIuL,IAAGF,GACPnL,IAAIwL,IAAOF,KAENN,MAAO,KACZlL,IAAIyL,IAAOD,GACXtL,IAAIkL,IAAGD,KAEFE,MAAO,KACZrL,IAAIyL,IAAOD,GACXtL,IAAIqL,IAAGD,MAGPtL,IAAIyL,IAAOD,GACXtL,IAAIwL,IAAOF,IAGfjJ,EAAG,KAAK,IAAI9B,EAAQ,MAAMT,GAAGE,CAAC,CAAC;AAAA,EAClC;AAED,SAAOqC;AACX;AAEA,SAASoJ,GAAqB/I,GAAMgJ,GAAQ;AACxC,MAAIrJ,IAAK,CAAA,GACLsJ,IAAMD,EAAO,GAAG,aAAahJ,CAAI,GACjCsG,IAAO0C,EAAO,GAAG,WAAWC,CAAG,EAAE;AAErC,MAAIpL,EAAQ,MAAM,GAAGyI,GAAM0C,EAAO,CAAC;AAC/B,IAAArJ,EAAG,KAAKsJ,CAAG;AAAA,WACJpL,EAAQ,MAAM,GAAGyI,GAAM0C,EAAO,CAAC,GAAG;AACzC,QAAIE,IAAQ,KAAK,KAAKF,EAAO,IAAIA,EAAO,IAAI1C,IAAOA,CAAI,GACnD6C,GAASnK;AAEb,IAAAmK,IAAUnJ,EAAK,KAAK,YAAW,EAAG,SAASkJ,CAAK,GAChDlK,IAAKiK,EAAI,UAAUE,CAAO,GAC1BxJ,EAAG,KAAKX,CAAE,GAEVmK,IAAUnJ,EAAK,KAAK,WAAU,EAAG,SAASkJ,CAAK,GAC/ClK,IAAKiK,EAAI,UAAUE,CAAO,GAC1BxJ,EAAG,KAAKX,CAAE;AAAA,EACb;AACD,SAAOW;AACX;AAEA,SAASyJ,GAAkBpJ,GAAMqJ,GAAK;AAClC,MAAIC,IAAM,CAAA;AACV,WAASC,KAAOF,EAAI,cAAc;AAC9B,QAAIG,IAAUC,GAAsBF,GAAKvJ,CAAI;AAC7C,aAAShB,KAAMwK;AACX,MAAKE,GAAc1K,GAAIsK,CAAG,KACtBA,EAAI,KAAKtK,CAAE;AAAA,EAGtB;AACD,SAAOsK;AACX;AAEA,SAASK,GAAkB3J,GAAM4J,GAAK;AAClC,MAAIjK,IAAK,CAAA;AAET,MAAIyJ,GAAkBpJ,GAAM4J,EAAI,GAAG,EAAE,WAAW;AAC5C,WAAOjK;AAGX,MAAIqJ,IAAS,IAAInL,EAAQ,OAAO+L,EAAI,IAAIA,EAAI,CAAC,GACzCC,IAASd,GAAqB/I,GAAMgJ,CAAM;AAC9C,WAAShK,KAAM6K;AACX,IAAI7K,EAAG,GAAG4K,CAAG,KACTjK,EAAG,KAAKX,CAAE;AAIlB,SAAOW;AACX;AAEA,SAAS8J,GAAsBF,GAAKvJ,GAAM;AACtC,MAAIL,IAAK,CAAA;AAsBT,MAnBI4J,EAAI,GAAG,GAAGvJ,CAAI,KACdL,EAAG,KAAK4J,EAAI,EAAE,GAGdA,EAAI,GAAG,GAAGvJ,CAAI,KAAK,CAACuJ,EAAI,kBACxB5J,EAAG,KAAK4J,EAAI,EAAE,GAGd5J,EAAG,SAAS,KAKZ4J,EAAI,kBAMJA,EAAI,GAAG,OAAOvJ,CAAI,KAAKuJ,EAAI,GAAG,OAAOvJ,CAAI,KACzC,CAACuJ,EAAI,GAAG,OAAOvJ,CAAI,KAAK,CAACuJ,EAAI,GAAG,OAAOvJ,CAAI;AAC3C,WAAOL;AAIX,MAAIyI,IAAQ,IAAIvK,EAAQ,KAAK0L,EAAI,IAAIA,EAAI,EAAE;AAC3C,SAAOpB,GAAmBC,GAAOpI,CAAI;AACzC;AAEA,SAAS8J,GAAyBC,GAAMC,GAAM;AAC1C,MAAIrK,IAAK,CAAA;AAGT,MAAIoK,EAAK,IAAI,cAAcC,EAAK,GAAG;AAC/B,WAAOrK;AAIX,MAAIoK,EAAK;AACL,WAAIA,EAAK,GAAG,GAAGC,CAAI,KACfrK,EAAG,KAAKoK,EAAK,EAAE,GAEZpK;AAIX,MAAIqK,EAAK;AACL,WAAIA,EAAK,GAAG,GAAGD,CAAI,KACfpK,EAAG,KAAKqK,EAAK,EAAE,GAEZrK;AAIX,MAAIyI,IAAQ,IAAIvK,EAAQ,KAAKkM,EAAK,IAAIA,EAAK,EAAE,GACzC1B,IAAQ,IAAIxK,EAAQ,KAAKmM,EAAK,IAAIA,EAAK,EAAE;AAI7C,MAAI5B,EAAM,WAAWC,CAAK;AACtB,IAAI0B,EAAK,GAAG,GAAGC,CAAI,KACfrK,EAAG,KAAKoK,EAAK,EAAE,GAEfA,EAAK,GAAG,GAAGC,CAAI,KACfrK,EAAG,KAAKoK,EAAK,EAAE,GAEfC,EAAK,GAAG,GAAGD,CAAI,KAAK,CAACC,EAAK,GAAG,QAAQD,EAAK,EAAE,KAAK,CAACC,EAAK,GAAG,QAAQD,EAAK,EAAE,KACzEpK,EAAG,KAAKqK,EAAK,EAAE,GAEfA,EAAK,GAAG,GAAGD,CAAI,KAAK,CAACC,EAAK,GAAG,QAAQD,EAAK,EAAE,KAAK,CAACC,EAAK,GAAG,QAAQD,EAAK,EAAE,KACzEpK,EAAG,KAAKqK,EAAK,EAAE;AAAA,OAEhB;AAEH,QAAIC,IAAS9B,GAAmBC,GAAOC,CAAK;AAC5C,IAAI4B,EAAO,SAAS,KAAKA,EAAO,GAAG,GAAGF,CAAI,KAAKE,EAAO,GAAG,GAAGD,CAAI,KAC5DrK,EAAG,KAAKsK,EAAO,EAAE;AAAA,EAmBxB;AAED,SAAOtK;AACX;AAEA,SAASuK,GAAwB3D,GAASyC,GAAQ;AAC9C,MAAIM,IAAM,CAAA;AAEV,MAAI/C,EAAQ,IAAI,cAAcyC,EAAO,GAAG;AACpC,WAAOM;AAIX,MAAI/C,EAAQ,gBAAgB;AACxB,QAAI,CAACD,GAAM6D,CAAgB,IAAI5D,EAAQ,GAAG,WAAWyC,EAAO,EAAE;AAC9D,WAAInL,EAAQ,MAAM,GAAGyI,GAAM0C,EAAO,CAAC,KAC/BM,EAAI,KAAK/C,EAAQ,EAAE,GAEhB+C;AAAA,EACV;AAGD,MAAItJ,IAAO,IAAInC,EAAQ,KAAK0I,EAAQ,IAAIA,EAAQ,EAAE,GAE9CiD,IAAUT,GAAqB/I,GAAMgJ,CAAM;AAE/C,WAASrJ,KAAM6J;AACX,IAAI7J,EAAG,GAAG4G,CAAO,KACb+C,EAAI,KAAK3J,CAAE;AAInB,SAAO2J;AACX;AAEA,SAASc,GAAqB7D,GAASqD,GAAK;AACxC,MAAIjK,IAAK,CAAA;AAET,MAAI4G,EAAQ,IAAI,cAAcqD,EAAI,GAAG;AACjC,WAAOjK;AAIX,MAAI4G,EAAQ;AACR,WAAIA,EAAQ,GAAG,GAAGqD,CAAG,KACjBjK,EAAG,KAAK4G,EAAQ,EAAE,GAEf5G;AAIX,MAAIK,IAAO,IAAInC,EAAQ,KAAK0I,EAAQ,IAAIA,EAAQ,EAAE,GAC9CyC,IAAS,IAAInL,EAAQ,OAAO+L,EAAI,IAAIA,EAAI,CAAC,GAEzCC,IAASd,GAAqB/I,GAAMgJ,CAAM;AAE9C,WAAShK,KAAM6K;AACX,IAAI7K,EAAG,GAAGuH,CAAO,KAAKvH,EAAG,GAAG4K,CAAG,KAC3BjK,EAAG,KAAKX,CAAE;AAGlB,SAAOW;AAEX;AAEA,SAAS0K,GAAqB9D,GAAS8C,GAAK;AACxC,MAAIC,IAAM,CAAA;AACV,WAASC,KAAOF,EAAI,cAAc;AAC9B,QAAIG,IAAUM,GAAyBP,GAAKhD,CAAO;AACnD,aAAS5G,KAAM6J;AACX,MAAAF,EAAI,KAAK3J,CAAE;AAAA,EAElB;AACD,SAAO2J;AACX;AAEA,SAASgB,GAAuBC,GAASC,GAAS;AAC9C,MAAI7K,IAAK,CAAA;AAET,MAAI4K,EAAQ,IAAI,cAAcC,EAAQ,GAAG;AACrC,WAAO7K;AAGX,MAAI8K,IAAM,IAAI5M,EAAQ,OAAO0M,EAAQ,IAAIC,EAAQ,EAAE,GAE/CE,IAAKH,EAAQ,GACbI,IAAKH,EAAQ;AAGjB,MAAI3M,EAAQ,MAAM,KAAK6M,CAAE,KAAK7M,EAAQ,MAAM,KAAK8M,CAAE;AAC/C,WAAOhL;AAGX,MAAI9B,EAAQ,MAAM,KAAK4M,EAAI,CAAC,KAAK5M,EAAQ,MAAM,KAAK4M,EAAI,CAAC,KAAK5M,EAAQ,MAAM,GAAG6M,GAAIC,CAAE;AACjF,WAAAhL,EAAG,KAAK4K,EAAQ,GAAG,UAAU,CAACG,GAAI,CAAC,CAAC,GAC7B/K;AAGX,MAAI2G,IAAOiE,EAAQ,GAAG,WAAWC,EAAQ,EAAE,EAAE;AAK7C,MAHI3M,EAAQ,MAAM,GAAGyI,GAAMoE,IAAKC,CAAE,KAG9B9M,EAAQ,MAAM,GAAGyI,GAAM,KAAK,IAAIoE,IAAKC,CAAE,CAAC;AACxC,WAAOhL;AAGX,EAAA8K,EAAI,KAAKnE,GACTmE,EAAI,KAAKnE;AAET,MAAItH;AAIJ,MAAInB,EAAQ,MAAM,GAAGyI,GAAMoE,IAAKC,CAAE,KAAK9M,EAAQ,MAAM,GAAGyI,GAAM,KAAK,IAAIoE,IAAKC,CAAE,CAAC;AAC3E,WAAA3L,IAAKuL,EAAQ,GAAG,UAAUG,IAAKD,EAAI,GAAGC,IAAKD,EAAI,CAAC,GAChD9K,EAAG,KAAKX,CAAE,GACHW;AAQX,MAAIiL,IAAKF,IAAKA,KAAO,IAAIpE,KAASqE,IAAKA,KAAO,IAAIrE,KAAQA,IAAO,GAE7DuE,IAASN,EAAQ,GAAG,UAAUK,IAAIH,EAAI,GAAGG,IAAIH,EAAI,CAAC,GAClDK,IAAI,KAAK,KAAKJ,IAAKA,IAAKE,IAAIA,CAAC;AAIjC,SAAA5L,IAAK6L,EAAO,UAAUJ,EAAI,YAAW,EAAG,SAASK,CAAC,CAAC,GACnDnL,EAAG,KAAKX,CAAE,GAGVA,IAAK6L,EAAO,UAAUJ,EAAI,WAAU,EAAG,SAASK,CAAC,CAAC,GAClDnL,EAAG,KAAKX,CAAE,GAEHW;AACX;AAEA,SAASoL,GAAoB/B,GAAQK,GAAK;AACtC,MAAIC,IAAM,CAAA;AACV,WAASC,KAAOF,EAAI,cAAc;AAC9B,QAAIG,IAAUU,GAAwBX,GAAKP,CAAM;AACjD,aAASrJ,KAAM6J;AACX,MAAAF,EAAI,KAAK3J,CAAE;AAAA,EAElB;AACD,SAAO2J;AACX;AAEA,SAAS0B,GAAiBC,GAAMC,GAAM;AAClC,MAAIvL,IAAK,CAAA;AAET,MAAIsL,EAAK,IAAI,cAAcC,EAAK,GAAG;AAC/B,WAAOvL;AAKX,MAAIsL,EAAK,GAAG,QAAQC,EAAK,EAAE,KAAKrN,EAAQ,MAAM,GAAGoN,EAAK,GAAGC,EAAK,CAAC,GAAG;AAC9D,QAAIlM;AAEJ,WAAAA,IAAKiM,EAAK,OACNjM,EAAG,GAAGkM,CAAI,KACVvL,EAAG,KAAKX,CAAE,GAEdA,IAAKiM,EAAK,KACNjM,EAAG,GAAGkM,CAAI,KACVvL,EAAG,KAAKX,CAAE,GAEdA,IAAKkM,EAAK,OACNlM,EAAG,GAAGiM,CAAI,KAAGtL,EAAG,KAAKX,CAAE,GAE3BA,IAAKkM,EAAK,KACNlM,EAAG,GAAGiM,CAAI,KAAGtL,EAAG,KAAKX,CAAE,GAEpBW;AAAA,EACV;AAGD,MAAI4K,IAAU,IAAI1M,EAAQ,OAAOoN,EAAK,IAAIA,EAAK,CAAC,GAC5CT,IAAU,IAAI3M,EAAQ,OAAOqN,EAAK,IAAIA,EAAK,CAAC,GAC5CrB,IAASU,EAAQ,UAAUC,CAAO;AACtC,WAASxL,KAAM6K;AACX,IAAI7K,EAAG,GAAGiM,CAAI,KAAKjM,EAAG,GAAGkM,CAAI,KACzBvL,EAAG,KAAKX,CAAE;AAGlB,SAAOW;AACX;AAEA,SAASwL,GAAoBvB,GAAKZ,GAAQ;AACtC,MAAIrJ,IAAK,CAAA;AAET,MAAIiK,EAAI,IAAI,cAAcZ,EAAO,GAAG;AAChC,WAAOrJ;AAKX,MAAIqJ,EAAO,GAAG,QAAQY,EAAI,EAAE,KAAK/L,EAAQ,MAAM,GAAGmL,EAAO,GAAGY,EAAI,CAAC;AAC7D,WAAAjK,EAAG,KAAKiK,EAAI,KAAK,GACjBjK,EAAG,KAAKiK,EAAI,GAAG,GACRjK;AAIX,MAAI4K,IAAUvB,GACVwB,IAAU,IAAI3M,EAAQ,OAAO+L,EAAI,IAAIA,EAAI,CAAC,GAC1CC,IAASS,GAAuBC,GAASC,CAAO;AACpD,WAASxL,KAAM6K;AACX,IAAI7K,EAAG,GAAG4K,CAAG,KACTjK,EAAG,KAAKX,CAAE;AAGlB,SAAOW;AACX;AAEA,SAASyL,GAAiBxB,GAAKP,GAAK;AAChC,MAAIC,IAAM,CAAA;AACV,WAASC,KAAOF,EAAI,cAAc;AAC9B,QAAIG,IAAUY,GAAqBb,GAAKK,CAAG;AAC3C,aAASjK,KAAM6J;AACX,MAAAF,EAAI,KAAK3J,CAAE;AAAA,EAElB;AACD,SAAO2J;AACX;AAEA,SAAS+B,GAAsBlN,GAAMoI,GAAS;AAC1C,SAAOpI,EAAK,cAAc2L,GAAyB3L,EAAK,OAAOoI,CAAO,IAAI6D,GAAqB7D,GAASpI,EAAK,KAAK;AACtH;AAEA,SAASmN,GAAkBnN,GAAMyL,GAAK;AAClC,SAAOzL,EAAK,cAAciM,GAAqBjM,EAAK,OAAOyL,CAAG,IAAIoB,GAAiB7M,EAAK,OAAOyL,CAAG;AACtG;AAEA,SAAS2B,GAAmBpN,GAAM6B,GAAM;AACpC,SAAO7B,EAAK,cAAcsL,GAAsBtL,EAAK,OAAO6B,CAAI,IAAI2J,GAAkB3J,GAAM7B,EAAK,KAAK;AAC1G;AAEA,SAASqN,GAAqBrN,GAAM6K,GAAQ;AACxC,SAAO7K,EAAK,cAAc+L,GAAwB/L,EAAK,OAAO6K,CAAM,IAAImC,GAAoBhN,EAAK,OAAO6K,CAAM;AAClH;AAEA,SAASyC,GAAyBlF,GAASxF,GAAS;AAChD,MAAIpB,IAAK,CAAA;AAET,WAASxB,KAAQ4C,EAAQ;AACrB,aAAS/B,KAAMqM,GAAsBlN,GAAMoI,CAAO;AAC9C,MAAA5G,EAAG,KAAKX,CAAE;AAIlB,SAAOW;AACX;AAEA,SAAS+L,GAAqB9B,GAAK7I,GAAS;AACxC,MAAIpB,IAAK,CAAA;AAET,WAASxB,KAAQ4C,EAAQ;AACrB,aAAS/B,KAAMsM,GAAkBnN,GAAMyL,CAAG;AACtC,MAAAjK,EAAG,KAAKX,CAAE;AAIlB,SAAOW;AACX;AAEA,SAASgM,GAAsB3L,GAAMe,GAAS;AAC1C,MAAIpB,IAAK,CAAA;AAET,MAAIoB,EAAQ;AACR,WAAOpB;AAGX,WAASxB,KAAQ4C,EAAQ;AACrB,aAAS/B,KAAMuM,GAAmBpN,GAAM6B,CAAI;AACxC,MAAK0J,GAAc1K,GAAIW,CAAE,KACrBA,EAAG,KAAKX,CAAE;AAKtB,SAAOgB,EAAK,WAAWL,CAAE;AAC7B;AAEA,SAASiM,GAAwB5C,GAAQjI,GAAS;AAC9C,MAAIpB,IAAK,CAAA;AAET,MAAIoB,EAAQ;AACR,WAAOpB;AAGX,WAASxB,KAAQ4C,EAAQ;AACrB,aAAS/B,KAAMwM,GAAqBrN,GAAM6K,CAAM;AAC5C,MAAArJ,EAAG,KAAKX,CAAE;AAIlB,SAAOW;AACX;AAEA,SAASkM,GAAmBrG,GAAOE,GAAO;AACtC,QAAMoG,IAAStG,EAAM,OACfuG,IAASrG,EAAM;AACrB,SAAOF,EAAM,UAAW,IACnBE,EAAM,UAAW,IAAGoE,GAAyBgC,GAAQC,CAAM,IAAI3B,GAAqB0B,GAAQC,CAAM,IAClGrG,EAAM,cAAc0E,GAAqB2B,GAAQD,CAAM,IAAId,GAAiBc,GAAQC,CAAM;AACnG;AAEA,SAASC,GAAsB7N,GAAM4C,GAAS;AAC1C,MAAIpB,IAAK,CAAA;AAET,MAAIoB,EAAQ,QAAS,KAAI5C,EAAK,MAAM,IAAI,cAAc4C,EAAQ,GAAG;AAC7D,WAAOpB;AAGX,MAAIsM,IAAalL,EAAQ,MAAM,OAAO5C,EAAK,MAAM,GAAG;AAEpD,WAAS+N,KAAaD;AAClB,aAASjN,KAAM6M,GAAmB1N,GAAM+N,CAAS;AAC7C,MAAAvM,EAAG,KAAKX,CAAE;AAIlB,SAAOW;AACX;AAEA,SAASwM,GAAyB3I,GAAUC,GAAU;AAClD,MAAI9D,IAAK,CAAA;AAMT,MAJI6D,EAAS,QAAO,KAAMC,EAAS,QAAO,KAItCD,EAAS,IAAI,cAAcC,EAAS,GAAG;AACvC,WAAO9D;AAGX,WAAS6F,KAAShC,EAAS;AACvB,aAASxE,KAAMgN,GAAsBxG,GAAO/B,CAAQ;AAChD,MAAA9D,EAAG,KAAKX,CAAE;AAIlB,SAAOW;AACX;AAEA,SAASyM,GAAuBC,GAAOtL,GAAS;AAC5C,SAAIsL,aAAiBxO,EAAQ,OAClB8N,GAAsBU,GAAOtL,CAAO,IAEtCsL,aAAiBxO,EAAQ,UACvB4N,GAAyBY,GAAOtL,CAAO,IAEzCsL,aAAiBxO,EAAQ,MACvB6N,GAAqBW,GAAOtL,CAAO,IAGnC;AAEf;AAEA,SAAS2I,GAAc4C,GAAQ3M,GAAI;AAC/B,SAAOA,EAAG,KAAM,CAAAX,MAAMA,EAAG,QAAQsN,CAAM,CAAG;AAC9C;AAMA,MAAMC,UAAkBvO,GAAW;AAAA,EAC/B,eAAewO,GAAM;AAGjB,QAFA,SAEIA,EAAK,WAAW,KAIhBA,EAAK,UAAU,KACXA,EAAK,cAAc,OAAO;AAC1B,UAAIrN,IAASqN,EAAK;AAClB,UAAIrN,EAAO,UAAU;AACjB;AAKc,MAAAA,EAAO,MAAM,CAACkN,MACrBA,aAAiBxO,EAAQ,WAC5BwO,aAAiBxO,EAAQ,OACzBwO,aAAiBxO,EAAQ,OACzBwO,aAAiBxO,EAAQ,IAChC;AAED,eAASwO,KAASlN,GAAQ;AACtB,YAAIhB,IAAO,IAAIN,EAAQ,KAAKwO,CAAK;AACjC,aAAK,OAAOlO,CAAI;AAAA,MACnB;AAAA,IACJ;AAAA,EAER;AAAA,EAMD,IAAI,QAAQ;AACR,WAAO,CAAC,GAAG,IAAI;AAAA,EAClB;AAAA,EAMD,IAAI,MAAM;AACN,WAAO,KAAK,MAAM,OAAQ,CAACsO,GAAItO,MAASsO,IAAMA,EAAI,MAAMtO,EAAK,GAAG,GAAG,IAAIN,EAAQ,IAAG;EACrF;AAAA,EAMD,IAAI,WAAW;AACX,QAAI6O,IAAI,KAAK,MAAM,IAAI,CAAAvO,MAAQA,EAAK,KAAK;AACzC,WAAAuO,EAAE,KAAK,KAAK,KAAK,GAAG,GACbA;AAAA,EACV;AAAA,EAMD,QAAQ;AACJ,WAAO,IAAIH,EAAU,KAAK,SAAU,CAAA;AAAA,EACvC;AAAA,EAQD,UAAUvN,GAAIb,GAAM;AAChB,QAAIgB,IAAShB,EAAK,MAAM,MAAMa,CAAE;AAGhC,QAAIG,EAAO,OAAO;AACf,aAAOhB,EAAK;AAEf,QAAIgB,EAAO,OAAO;AACf,aAAOhB;AAEV,QAAIoE,IAAU,IAAI1E,EAAQ,KAAKsB,EAAO,EAAE,GACpCwN,IAAaxO,EAAK;AAGtB,gBAAK,OAAOoE,GAASoK,CAAU,GAG/BxO,EAAK,QAAQgB,EAAO,IAEboD;AAAA,EACV;AAAA,EAOD,MAAM5C,GAAI;AACN,aAASX,KAAMW,GAAI;AACf,UAAIxB,IAAO,KAAK,gBAAgBa,CAAE;AAClC,WAAK,UAAUA,GAAIb,CAAI;AAAA,IAC1B;AACD,WAAO;AAAA,EACV;AAAA,EAOD,gBAAgBa,GAAI;AAChB,QAAI4N;AACJ,aAASzO,KAAQ;AACb,UAAIA,EAAK,MAAM,SAASa,CAAE,GAAG;AACzB,QAAA4N,IAAYzO;AACZ;AAAA,MACH;AAEL,WAAOyO;AAAA,EACV;AAAA,EAOD,UAAUnC,GAAK;AACX,WAAO,IAAI8B,EAAU,KAAK,MAAM,IAAK,CAAApO,MAAQA,EAAK,MAAM,UAAUsM,CAAG,CAAC,CAAC;AAAA,EAC1E;AAAA,EAUD,OAAOoC,IAAQ,GAAGC,IAAS,IAAIjP,EAAQ,SAAS;AAC5C,WAAO,IAAI0O,EAAU,KAAK,MAAM,IAAK,CAAApO,MAAQA,EAAK,MAAM,OAAO0O,GAAOC,CAAM,CAAG,CAAA;AAAA,EAClF;AAAA,EAQD,UAAUC,IAAS,IAAIlP,EAAQ,OAAM,GAAI;AACrC,WAAO,IAAI0O,EAAU,KAAK,MAAM,IAAK,CAAApO,MAAQA,EAAK,MAAM,UAAU4O,CAAM,CAAC,CAAC;AAAA,EAC7E;AAAA,EAMD,WAAW;AACP,WAAO,KAAK,MAAM,IAAI,CAAA5O,MAAQA,EAAK,MAAM,OAAO;AAAA,EACnD;AAAA,EAOD,SAAS;AACL,WAAO,KAAK,MAAM,IAAI,CAAAA,MAAQA,EAAK,OAAM,CAAE;AAAA,EAC9C;AAAA,EAUD,IAAI6O,IAAQ,IAAI;AACZ,QAAI,EAAC,QAAAC,GAAQ,aAAAC,GAAa,MAAAC,GAAM,UAAAC,GAAU,aAAAC,GAAa,IAAAnO,GAAI,WAAAoO,EAAS,IAAIN,GACpEO,IAAUrO,KAAMA,EAAG,SAAS,IAAK,OAAOA,OAAQ,IAChDsO,IAAaF,KAAaA,EAAU,SAAS,IAAK,UAAUA,OAAe,IAE3EG,IAAS;AAAA,gBAAmBR,KAAU,0BAA0BC,KAAe,YAAYC,KAAQ,yBAAyBE,KAAe,MAAQE,KAAUC;AACjK,IAAAC,KAAU;AAAA,GAAM,KAAK,MAAM,MAAM,KAAK,KAAK,MAAM,MAAM;AACvD,aAAStP,KAAQ;AACb,MAAAsP,KAAUtP,EAAK;AAEnB,WAAAsP,KAAU;AAAA,UAEHA;AAAA,EACV;AACL;AAEA5P,EAAQ,YAAY0O;AAMpB,MAAMmB,KAAY,IAAIlB,MAAS,IAAI3O,EAAQ,UAAU,GAAG2O,CAAI;AAC5D3O,EAAQ,YAAY6P;AAWpB,SAASC,GAAU5M,GAAS6M,GAAO;AAC/B,MAAIC,GAOAC,IAAM,IAAIjQ,EAAQ,IAAI+P,CAAK,GAC3B5N,IAAO,IAAInC,EAAQ,KAAKiQ,EAAI,IAAIA,EAAI,IAAI;AAG5C,QAAMC,IAAY,IAAIlQ,EAAQ;AAAA,IAC1BiQ,EAAI,IAAI,OAAKjQ,EAAQ;AAAA,IAAQiQ,EAAI,IAAI,OAAKjQ,EAAQ;AAAA,IAClDiQ,EAAI,IAAI;AAAA,IAAMA,EAAI,IAAI,OAAKjQ,EAAQ;AAAA,EAC3C;AAEI,MAAIkD,EAAQ,IAAI,cAAcgN,CAAS;AACnC,WAAOlQ,EAAQ;AAGnB,MAAIoO,IAAalL,EAAQ,MAAM,OAAOgN,CAAS;AAE/C,MAAI9B,EAAW,UAAU;AACrB,WAAOpO,EAAQ;AAInB,WAASM,KAAQ8N;AACb,QAAI9N,EAAK,MAAM,SAASyP,CAAK;AACzB,aAAO/P,EAAQ;AAKvB,MAAI2B,IAAgB,CAAA;AACpB,WAASrB,KAAQ8N;AACb,aAAStM,KAAMmO,EAAI,UAAU3P,EAAK,KAAK,GAAG;AAGtC,UAAIwB,EAAG,QAAQiO,CAAK;AAChB,eAAO/P,EAAQ;AAGnB,MAAA2B,EAAc,KAAK;AAAA,QACf,IAAIG;AAAA,QACJ,MAAMxB;AAAA,MACtB,CAAa;AAAA,IACJ;AAIL,EAAAqB,EAAc,KAAK,CAACwO,GAAIC,MAChBxQ,GAAGuQ,EAAG,GAAG,GAAGC,EAAG,GAAG,CAAC,IACZ,KAEP1Q,GAAGyQ,EAAG,GAAG,GAAGC,EAAG,GAAG,CAAC,IACZ,IAEJ,CACV;AAGD,MAAI5P,IAAU;AAEd,WAASoC,IAAI,GAAGA,IAAIjB,EAAc,QAAQiB,KAAK;AAC3C,QAAIyN,IAAe1O,EAAciB;AACjC,QAAIyN,EAAa,GAAG,QAAQA,EAAa,KAAK,MAAM,KAAK,GAAG;AAExD,UAAIzN,IAAI,KAAKyN,EAAa,GAAG,QAAQ1O,EAAciB,IAAI,GAAG,EAAE,KACxDyN,EAAa,KAAK,SAAS1O,EAAciB,IAAI,GAAG;AAChD;AAEJ,UAAI0N,IAAYD,EAAa,KAAK;AAClC,aAAO/Q,GAAKgR,EAAU,MAAM;AACxB,QAAAA,IAAYA,EAAU;AAE1B,UAAIC,IAAeD,EAAU,MAAM,aAAY,GAC3CE,IAAaH,EAAa,GAAG,UAAUE,CAAY,GAEnDE,IAAcJ,EAAa,KAAK,MAAM,eAAc,GACpDK,IAAYL,EAAa,GAAG,UAAUI,CAAW,GAEjDE,IAAmBH,EAAW,OAAOrO,CAAI,GACzCyO,IAAkBF,EAAU,OAAOvO,CAAI;AAE3C,OAAKwO,KAAoB,CAACC,KAAqB,CAACD,KAAoBC,MAChEpQ;AAAA,IAEhB,WAAmB6P,EAAa,GAAG,QAAQA,EAAa,KAAK,MAAM,GAAG,GAAG;AAE7D,UAAIzN,IAAI,KAAKyN,EAAa,GAAG,QAAQ1O,EAAciB,IAAI,GAAG,EAAE,KACxDyN,EAAa,KAAK,SAAS1O,EAAciB,IAAI,GAAG;AAChD;AAEJ,UAAIiO,IAAYR,EAAa,KAAK;AAClC,aAAO/Q,GAAKuR,EAAU,MAAM;AACxB,QAAAA,IAAYA,EAAU;AAE1B,UAAIC,IAAeD,EAAU,MAAM,eAAc,GAC7CE,IAAaV,EAAa,GAAG,UAAUS,CAAY,GAEnDL,IAAcJ,EAAa,KAAK,MAAM,aAAY,GAClDK,IAAYL,EAAa,GAAG,UAAUI,CAAW,GAEjDO,IAAmBD,EAAW,OAAO5O,CAAI,GACzCyO,IAAkBF,EAAU,OAAOvO,CAAI;AAE3C,OAAK6O,KAAoB,CAACJ,KAAqB,CAACI,KAAoBJ,MAChEpQ;AAAA,IAEhB,WACgB6P,EAAa,KAAK,iBAAiBrQ,EAAQ;AAC3C,MAAAQ;AAAA,SACG;AAEH,UAAIgL,IAAM6E,EAAa,KAAK,MAAM;AAClC,MAAM7Q,GAAG6Q,EAAa,GAAG,GAAG7E,EAAI,IAAI,KAChChM,GAAG6Q,EAAa,GAAG,GAAG7E,EAAI,IAAI,KAC9BhL;AAAA,IAEP;AAAA,EAER;AAGD,SAAAwP,IAAWxP,IAAU,KAAK,IAAIlC,KAASC,IAEhCyR;AACX;AAcA,SAASiB,GAAMhD,GAAQC,GAAQ;AAC3B,SAAOgD,GAAOjD,GAAQC,CAAM,EAAE,MAAK;AACvC;AAQA,SAASiD,GAAYlD,GAAQC,GAAQ;AACjC,SAAOgD,GAAOjD,GAAQC,CAAM,EAAE,UAAS;AAC3C;AAQA,SAASkD,GAAMnD,GAAQC,GAAQ;AAC3B,SAAOgD,GAAOjD,GAAQC,CAAM,EAAE,MAAK;AACvC;AAQA,SAASmD,GAASpD,GAAQC,GAAQ;AAC9B,SAAO,CAACiD,GAAYlD,GAAQC,CAAM;AACtC;AAQA,SAASoD,GAAOrD,GAAQC,GAAQ;AAC5B,SAAOgD,GAAOjD,GAAQC,CAAM,EAAE,OAAM;AACxC;AAQA,SAASqD,GAAQtD,GAAQC,GAAQ;AAC7B,SAAQgD,GAAOjD,GAAQC,CAAM,EAAE,QAAO;AAC1C;AASA,SAASsD,GAAQvD,GAAQC,GAAQ;AAC7B,SAAOoD,GAAOpD,GAAQD,CAAM;AAChC;AAQA,SAASwD,GAAMxD,GAAQC,GAAQ;AAC3B,SAAOqD,GAAQrD,GAAQD,CAAM;AACjC;AAYA,SAASiD,GAAOjD,GAAQC,GAAQ;AAC5B,MAAID,aAAkBjO,EAAQ,QAAQkO,aAAkBlO,EAAQ;AAC5D,WAAO0R,GAAgBzD,GAASC,CAAM;AAErC,MAAID,aAAkBjO,EAAQ,QAAQkO,aAAkBlO,EAAQ;AACjE,WAAO2R,GAAkB1D,GAAQC,CAAM;AAEtC,MAAID,aAAkBjO,EAAQ,QAAQkO,aAAkBlO,EAAQ;AACjE,WAAO4R,GAAe3D,GAAQC,CAAM;AAEnC,MAAKD,aAAkBjO,EAAQ,QAASkO,aAAkBlO,EAAQ;AACnE,WAAO6R,GAAmB5D,GAAQC,CAAM;AAEvC,OAAMD,aAAkBjO,EAAQ,WAAWiO,aAAkBjO,EAAQ,QAASkO,aAAkBlO,EAAQ;AACzG,WAAO8R,GAAoB7D,GAAQC,CAAM;AAExC,OAAMD,aAAkBjO,EAAQ,WAAWiO,aAAkBjO,EAAQ,SACrEkO,aAAkBlO,EAAQ,UAAUkO,aAAkBlO,EAAQ;AAC/D,WAAO8R,GAAoB7D,GAAQ,IAAIjO,EAAQ,QAAQkO,CAAM,CAAC;AAE7D,MAAID,aAAkBjO,EAAQ,WAAWkO,aAAkBlO,EAAQ;AACpE,WAAO+R,GAAsB9D,GAAQC,CAAM;AAE1C,OAAKD,aAAkBjO,EAAQ,UAAUiO,aAAkBjO,EAAQ,SACnEkO,aAAmBlO,EAAQ,UAAUkO,aAAkBlO,EAAQ;AAChE,WAAO+R,GAAsB,IAAI/R,EAAQ,QAAQiO,CAAM,GAAG,IAAIjO,EAAQ,QAAQkO,CAAM,CAAC;AAEpF,OAAKD,aAAkBjO,EAAQ,UAAUiO,aAAkBjO,EAAQ,QAAQkO,aAAkBlO,EAAQ;AACtG,WAAO+R,GAAsB,IAAI/R,EAAQ,QAAQiO,CAAM,GAAGC,CAAM;AAE/D,MAAID,aAAkBjO,EAAQ,YAAYkO,aAAkBlO,EAAQ,UAAUkO,aAAkBlO,EAAQ;AACzG,WAAO+R,GAAsB9D,GAAQ,IAAIjO,EAAQ,QAAQkO,CAAM,CAAC;AAExE;AAEA,SAASwD,GAAgBnH,GAAOC,GAAO;AACnC,MAAIwH,IAAQ,IAAI7H,MACZrI,IAAKwI,GAAmBC,GAAOC,CAAK;AACxC,SAAI1I,EAAG,WAAW,IACVyI,EAAM,SAASC,EAAM,EAAE,KAAKA,EAAM,SAASD,EAAM,EAAE,KACnDyH,EAAM,MAAM,CAACzH,CAAK,GAClByH,EAAM,MAAM,IACZA,EAAM,MAAM,OAGZA,EAAM,MAAM,IACZA,EAAM,MAAM,CAACzH,CAAK,GAClByH,EAAM,MAAM,CAACxH,CAAK,MAItBwH,EAAM,MAAMlQ,GACZkQ,EAAM,MAAMzH,EAAM,MAAMzI,CAAE,GAC1BkQ,EAAM,MAAMxH,EAAM,MAAM1I,CAAE,IAEvBkQ;AACX;AAEA,SAASL,GAAkBxP,GAAKgJ,GAAQ;AACpC,MAAI6G,IAAQ,IAAI7H,MACZrI,IAAKoJ,GAAqB/I,GAAMgJ,CAAM;AAC1C,MAAIrJ,EAAG,WAAW;AACd,IAAAkQ,EAAM,MAAM,IACZA,EAAM,MAAM,IACZA,EAAM,MAAM,CAAC7P,CAAI,GACjB6P,EAAM,MAAM,CAAC7G,CAAM;AAAA,WAEdrJ,EAAG,WAAW;AACnB,IAAAkQ,EAAM,MAAM,IACZA,EAAM,MAAMlQ,GACZkQ,EAAM,MAAM7P,EAAK,MAAML,CAAE,GAEzBkQ,EAAM,MAAM,CAAC7G,CAAM;AAAA,OAElB;AACD,QAAI0E,IAAY,IAAInB,EAAU,CAACvM,CAAI,CAAC,GAChC8P,IAAY9P,EAAK,WAAWL,CAAE;AAClC,IAAA+N,EAAU,MAAMoC,CAAS;AACzB,QAAIC,IAAcrC,EAAU;AAE5B,IAAAmC,EAAM,MAAM,CAACE,EAAY,EAAE,GAC3BF,EAAM,MAAMC,GACZD,EAAM,MAAM,CAACE,EAAY,IAAIA,EAAY,EAAE,GAE3CF,EAAM,MAAM,IAAIhS,EAAQ,QAAQ,CAACmL,EAAO,OAAO,CAAC,EAAE,IAAI0E,CAAS;AAAA,EAClE;AAED,SAAOmC;AACX;AAEA,SAASJ,GAAezP,GAAMqJ,GAAK;AAC/B,MAAIwG,IAAQ,IAAI7H,MACZrI,IAAKyJ,GAAkBpJ,GAAMqJ,CAAG;AACpC,MAAI1J,EAAG,WAAW;AACd,IAAAkQ,EAAM,MAAM,IACZA,EAAM,MAAM,IACZA,EAAM,MAAM,CAAC7P,CAAI,GAEjB6P,EAAM,MAAM,CAACxG,CAAG;AAAA,WAEX1J,EAAG,WAAW;AACnB,IAAAkQ,EAAM,MAAM,IACZA,EAAM,MAAMlQ,GACZkQ,EAAM,MAAM7P,EAAK,MAAML,CAAE,GAEzBkQ,EAAM,MAAM,CAACxG,CAAG;AAAA,OAEf;AACD,QAAIqE,IAAY,IAAInB,EAAU,CAACvM,CAAI,CAAC,GAChC8P,IAAY9P,EAAK,WAAWL,CAAE;AAClC,IAAA+N,EAAU,MAAMoC,CAAS;AACzB,QAAIC,IAAcrC,EAAU;AAG5B,IAAIrE,EAAI,WAAY,EAAC,KAAM,CAAA9C,MAAWA,EAAQ,SAAS5G,EAAG,EAAE,KAAK4G,EAAQ,SAAS5G,EAAG,EAAE,MACnFkQ,EAAM,MAAM,IACZA,EAAM,MAAM,CAACE,EAAY,EAAE,GAC3BF,EAAM,MAAM,CAACE,EAAY,IAAIA,EAAY,EAAE,GAE3CF,EAAM,MAAM,CAACxG,CAAG,MAGhBwG,EAAM,MAAM,CAACE,EAAY,EAAE,GAC3BF,EAAM,MAAMC,GACZD,EAAM,MAAM,CAACE,EAAY,IAAIA,EAAY,EAAE,GAE3CF,EAAM,MAAM,IAAIhS,EAAQ,QAAQwL,EAAI,YAAY,EAAE,IAAIqE,CAAS;AAAA,EAEtE;AACD,SAAOmC;AACX;AAEA,SAASH,GAAmB1P,GAAMe,GAAS;AACvC,MAAI8O,IAAQ,IAAI7H,MACZrI,IAAKgM,GAAsB3L,GAAMe,CAAO,GACxC2M,IAAY,IAAInB,EAAU,CAACvM,CAAI,CAAC,GAChC8P,IAAYnQ,EAAG,SAAS,IAAIA,EAAG,MAAK,IAAKK,EAAK,WAAWL,CAAE;AAE/D,SAAA+N,EAAU,MAAMoC,CAAS,GAEzB,CAAC,GAAGpC,CAAS,EAAE,QAAQ,CAAAvP,MAAQA,EAAK,aAAa4C,CAAO,CAAC,GAEzD8O,EAAM,MAAM,CAAC,GAAGnC,CAAS,EAAE,OAAO,CAAAvP,MAAQA,EAAK,OAAON,EAAQ,MAAM,EAAE,IAAI,CAAAM,MAAQA,EAAK,KAAK,GAC5F0R,EAAM,MAAM,CAAC,GAAGnC,CAAS,EAAE,MAAM,CAAC,EAAE,IAAK,CAACvP,MAASA,EAAK,OAAON,EAAQ,WAAWM,EAAK,QAAQA,EAAK,MAAM,QAC1G0R,EAAM,MAAM,CAAC,GAAGnC,CAAS,EAAE,OAAO,CAAAvP,MAAQA,EAAK,OAAON,EAAQ,OAAO,EAAE,IAAI,CAAAM,MAAQA,EAAK,KAAK,GAE7F0R,EAAM,MAAM9O,EAAQ,IAAI2M,CAAS,GAE1BmC;AACX;AAEA,SAASF,GAAoBtD,GAAOtL,GAAS;AACzC,MAAI8O,IAAQ,IAAI7H,MACZrI,IAAKyM,GAAuBC,GAAOtL,CAAO,GAC1C+O,IAAYnQ,EAAG,SAAS,IAAIA,EAAG,MAAK,IAAK0M,EAAM,WAAW1M,CAAE,GAE5D+N,IAAY,IAAInB,EAAU,CAACF,CAAK,CAAC;AACrC,EAAAqB,EAAU,MAAMoC,CAAS,GAEzB,CAAC,GAAGpC,CAAS,EAAE,QAAQ,CAAAvP,MAAQA,EAAK,aAAa4C,CAAO,CAAC,GAEzD8O,EAAM,MAAM,CAAC,GAAGnC,CAAS,EAAE,OAAO,CAAAvP,MAAQA,EAAK,OAAON,EAAQ,MAAM,EAAE,IAAI,CAAAM,MAAQA,EAAK,KAAK,GAC5F0R,EAAM,MAAM,CAAC,GAAGnC,CAAS,EAAE,MAAM,CAAC,EAAE,IAAK,CAACvP,MAASA,EAAK,OAAON,EAAQ,WAAWM,EAAK,QAAQA,EAAK,MAAM,QAC1G0R,EAAM,MAAM,CAAC,GAAGnC,CAAS,EAAE,OAAO,CAAAvP,MAAQA,EAAK,OAAON,EAAQ,OAAO,EAAE,IAAI,CAAAM,MAAQA,EAAK,KAAK,GAG7F0R,EAAM,MAAM,IACZA,EAAM,MAAM,IACZA,EAAM,MAAM;AACZ,WAAS7Q,KAAM,CAACqN,EAAM,OAAOA,EAAM,GAAG;AAClC,YAAQsB,GAAU5M,GAAS/B,CAAE,GAAC;AAAA,MAC1B,KAAKnB,EAAQ;AACT,QAAAgS,EAAM,IAAI,KAAK7Q,CAAE;AACjB;AAAA,MACJ,KAAKnB,EAAQ;AACT,QAAAgS,EAAM,IAAI,KAAK7Q,CAAE;AACjB;AAAA,MACJ,KAAKnB,EAAQ;AACT,QAAAgS,EAAM,IAAI,KAAK7Q,CAAE;AACjB;AAAA,IAGP;AAKL,SAAO6Q;AACX;AAEA,SAASD,GAAsBpM,GAAUC,GAAU;AAC/C,MAAIoM,IAAQ,IAAI7H,MAEZ,CAACzD,GAAYC,CAAU,IAAIH,GAAuBb,GAAUC,CAAQ,GACpEuM,IAAuBjM,GAAUP,GAAUC,CAAQ,GACnDwM,IAAsBpM,GAASL,GAAUC,CAAQ,GACjDyM,IAAsBrM,GAASJ,GAAUD,CAAQ,GACjD,CAAC2M,GAAoBC,CAAkB,IAAIpM,GAAUR,GAAUC,CAAQ,GACvE4M,IAAqBjM,GAAUZ,GAAUC,CAAQ,GACjD6M,IAAqBlM,GAAUX,GAAUD,CAAQ;AAErD,SAAAqM,EAAM,MAAMG,EAAqB,QAAS,IAAG,CAAE,IAAG,CAACA,CAAoB,GACvEH,EAAM,MAAMO,GACZP,EAAM,MAAMI,EAAoB,QAAS,IAAG,CAAE,IAAG,CAACA,CAAmB,GAErEJ,EAAM,MAAMM,GACZN,EAAM,MAAMtL,GACZsL,EAAM,MAAMQ,GAEZR,EAAM,MAAMK,EAAoB,QAAS,IAAG,CAAE,IAAG,CAACA,CAAmB,GACrEL,EAAM,MAAMS,GAGLT;AACX;AAEA,IAAIU,KAAyB,uBAAO,OAAO;AAAA,EACvC,OAAOzB;AAAA,EACP,WAAWE;AAAA,EACX,OAAOC;AAAA,EACP,UAAUC;AAAA,EACV,QAAQC;AAAA,EACR,SAASC;AAAA,EACT,SAASC;AAAA,EACT,OAAOC;AAAA,EACP,QAAQP;AACZ,CAAC;AAWD,IAAAyB,KAAA,MAAa;AAAA,EAWT,YAAY5F,IAAI,GAAG6F,IAAI,GAAG3S,IAAI,GAAG4S,IAAI,GAAGC,IAAK,GAAGC,IAAK,GAAG;AACpD,SAAK,IAAIhG,GACT,KAAK,IAAI6F,GACT,KAAK,IAAI3S,GACT,KAAK,IAAI4S,GACT,KAAK,KAAKC,GACV,KAAK,KAAKC;AAAA,EACb;AAAA,EAMD,QAAQ;AACJ,WAAO,IAAIC,GAAO,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,IAAI,KAAK,EAAE;AAAA,EACrE;AAAA,EAcD,UAAUC,GAAQ;AACd,WAAO;AAAA,MACHA,EAAO,KAAK,KAAK,IAAIA,EAAO,KAAK,KAAK,IAAI,KAAK;AAAA,MAC/CA,EAAO,KAAK,KAAK,IAAIA,EAAO,KAAK,KAAK,IAAI,KAAK;AAAA,IAClD;AAAA,EACJ;AAAA,EAOD,SAASC,GAAc;AACnB,WAAO,IAAIF;AAAAA,MACP,KAAK,IAAIE,EAAa,IAAI,KAAK,IAAIA,EAAa;AAAA,MAChD,KAAK,IAAIA,EAAa,IAAI,KAAK,IAAIA,EAAa;AAAA,MAChD,KAAK,IAAIA,EAAa,IAAI,KAAK,IAAIA,EAAa;AAAA,MAChD,KAAK,IAAIA,EAAa,IAAI,KAAK,IAAIA,EAAa;AAAA,MAChD,KAAK,IAAIA,EAAa,KAAK,KAAK,IAAIA,EAAa,KAAK,KAAK;AAAA,MAC3D,KAAK,IAAIA,EAAa,KAAK,KAAK,IAAIA,EAAa,KAAK,KAAK;AAAA,IAC9D;AAAA,EACJ;AAAA,EASD,aAAavE,GAAM;AACf,QAAImE,GAAIC;AACR,QAAIpE,EAAK,UAAU,KAAMA,EAAK,cAAc3O,EAAQ;AAChD,MAAA8S,IAAKnE,EAAK,GAAG,GACboE,IAAKpE,EAAK,GAAG;AAAA,aACNA,EAAK,UAAU,KAAK,OAAQA,EAAK,MAAO,YAAY,OAAQA,EAAK,MAAO;AAC/E,MAAAmE,IAAKnE,EAAK,IACVoE,IAAKpE,EAAK;AAAA;AAEV,YAAM3O,EAAQ,OAAO;AAEzB,WAAO,KAAK,SAAS,IAAIgT,GAAO,GAAG,GAAG,GAAG,GAAGF,GAAIC,CAAE,CAAC;AAAA,EACtD;AAAA,EASD,OAAO/D,GAAO;AACV,QAAImE,IAAM,KAAK,IAAInE,CAAK,GACpBoE,IAAM,KAAK,IAAIpE,CAAK;AACxB,WAAO,KAAK,SAAS,IAAIgE,GAAOG,GAAKC,GAAK,CAACA,GAAKD,GAAK,GAAG,CAAC,CAAC;AAAA,EAC7D;AAAA,EASD,MAAME,GAAIC,GAAI;AACV,WAAO,KAAK,SAAS,IAAIN,GAAOK,GAAI,GAAG,GAAGC,GAAI,GAAG,CAAC,CAAC;AAAA,EACtD;AAAA,EAOD,QAAQpE,GAAQ;AAMZ,WALI,GAAClP,EAAQ,MAAM,GAAG,KAAK,IAAIkP,EAAO,EAAE,KACpC,CAAClP,EAAQ,MAAM,GAAG,KAAK,IAAIkP,EAAO,EAAE,KACpC,CAAClP,EAAQ,MAAM,GAAG,KAAK,GAAGkP,EAAO,CAAC,KAClC,CAAClP,EAAQ,MAAM,GAAG,KAAK,GAAGkP,EAAO,CAAC,KAClC,CAAClP,EAAQ,MAAM,GAAG,KAAK,GAAGkP,EAAO,CAAC,KAClC,CAAClP,EAAQ,MAAM,GAAG,KAAK,GAAGkP,EAAO,CAAC;AAAA,EAEzC;AACL;AACAlP,EAAQ,SAASgT;AAKjB,MAAM9D,KAAS,IAAIP,MAAS,IAAI3O,EAAQ,OAAO,GAAG2O,CAAI;AACtD3O,EAAQ,SAASkP;AAoBjB,MAAMqE,KAAW,MAAMA,GAAS;AAAA,EAO5B,YAAYC,GAAKC,GAAM;AACnB,SAAK,MAAMD,GACX,KAAK,OAAOC;AAAA,EACf;AAAA,EAMD,QAAQ;AACJ,WAAO,IAAIF,GAAS,KAAK,KAAK,KAAK,IAAI;AAAA,EAC1C;AAAA,EAMD,IAAI,MAAM;AACN,WAAO,KAAK;EACf;AAAA,EAOD,UAAUG,GAAgB;AACtB,WAAO,KAAK,MAAMA,EAAe,OAC7B,KAAK,OAAOA,EAAe,OAAO,KAAK,OAAOA,EAAe;AAAA,EACpE;AAAA,EAOD,SAASA,GAAgB;AACrB,WAAO,KAAK,OAAOA,EAAe,OAAO,KAAK,QAAQA,EAAe;AAAA,EACxE;AAAA,EAOD,UAAUA,GAAgB;AACtB,WAAO,CAAC,KAAK,cAAcA,CAAc;AAAA,EAC5C;AAAA,EAOD,cAAcA,GAAgB;AAC1B,WAAQ,KAAK,OAAOA,EAAe,OAAOA,EAAe,OAAO,KAAK;AAAA,EACxE;AAAA,EAOD,MAAMA,GAAgB;AAClB,WAAO,IAAIH;AAAA,MACP,KAAK,QAAQ,SAAYG,EAAe,MAAM,KAAK,IAAI,KAAK,KAAKA,EAAe,GAAG;AAAA,MACnF,KAAK,SAAS,SAAYA,EAAe,OAAO,KAAK,IAAI,KAAK,MAAMA,EAAe,IAAI;AAAA,IACnG;AAAA,EACK;AAAA,EAKD,SAAS;AACL,WAAO,CAAC,KAAK,KAAK,KAAK,IAAI;AAAA,EAC9B;AAAA,EAQD,OAAO,eAAeC,GAAWC,GAAW;AACxC,WAAOD,EAAU,MAAMC,CAAS;AAAA,EACnC;AAAA,EAQD,OAAO,qBAAqBC,GAAMC,GAAO;AACrC,WAAOD,IAAOC;AAAA,EACjB;AACL,GAWMC,IAAoB,GACpBC,IAAsB;AAM5B,MAAMC,GAAK;AAAA,EACP,YAAYC,IAAM,QAAWhU,IAAQ,QACzBiU,IAAO,MAAMC,IAAQ,MAAMC,IAAS,MAAMC,IAAQN,GAAqB;AAC/E,SAAK,OAAOG,GACZ,KAAK,QAAQC,GACb,KAAK,SAASC,GACd,KAAK,QAAQC,GAEb,KAAK,OAAO,EAAC,KAAKJ,GAAK,OAAOhU,EAAK,GAG/BgU,KAAOA,aAAe,SAASA,EAAI,UAAU,KACzC,CAAC,OAAO,MAAMA,EAAI,EAAE,KAAK,CAAC,OAAO,MAAMA,EAAI,EAAE,MAC7C,KAAK,KAAK,MAAM,IAAIX,GAAS,KAAK,IAAIW,EAAI,IAAIA,EAAI,EAAE,GAAG,KAAK,IAAIA,EAAI,IAAIA,EAAI,EAAE,CAAC,IAIvF,KAAK,MAAM,KAAK,KAAK,MAAM,KAAK,KAAK,IAAI,MAAM;AAAA,EAClD;AAAA,EAED,QAAQ;AACJ,WAAQ,KAAK,KAAK,QAAQ,UAAa,KAAK,KAAK,UAAU,UACvD,KAAK,SAAS,QAAQ,KAAK,UAAU,QAAQ,KAAK,UAAUF;AAAA,EACnE;AAAA,EAED,UAAUO,GAAY;AAElB,QAAI,KAAK,KAAK,UAAU,KAAK,KAAK,OAAOA,EAAW,KAAK,UAAUA,EAAW,KAAK;AAC/E,aAAO,KAAK,KAAK,IAAI,UAAUA,EAAW,KAAK,GAAG;AAEjD;AACD,UAAIC,IAAkB,KAAK,KAAK,SAASD,EAAW,KAAK,SAAS,KAAK,KAAK,MAAM,YAAY,KAAK,KAAK,MAAM,UAAUA,EAAW,KAAK,KAAK,IACzI,KAAK,KAAK,QAAQA,EAAW,KAAK;AACtC,aAAO,KAAK,KAAK,IAAI,UAAUA,EAAW,KAAK,GAAG,KAC9C,KAAK,KAAK,IAAI,SAAUA,EAAW,KAAK,GAAK,KAAIC;AAAA,IACxD;AAAA,EAWJ;AAAA,EAED,SAASD,GAAY;AAEjB,QAAI,KAAK,KAAK,UAAU,KAAK,KAAK,OAAOA,EAAW,KAAK,UAAUA,EAAW,KAAK;AAC/E,aAAO,KAAK,KAAK,IAAI,SAASA,EAAW,KAAK,GAAG;AAEhD;AACD,UAAIE,IAAc,KAAK,KAAK,SAASF,EAAW,KAAK,SAAS,KAAK,KAAK,MAAM,WAAW,KAAK,KAAK,MAAM,SAASA,EAAW,KAAK,KAAK,IACnI,KAAK,KAAK,SAASA,EAAW,KAAK;AACvC,aAAO,KAAK,KAAK,IAAI,SAASA,EAAW,KAAK,GAAG,KAAKE;AAAA,IACzD;AAAA,EAQJ;AAAA,EAED,UAAUF,GAAY;AAClB,WAAO,KAAK,KAAK,IAAI,UAAUA,EAAW,KAAK,GAAG;AAAA,EACrD;AAAA,EAED,UAAUA,GAAY;AAClB,SAAK,KAAK,MAAMA,EAAW,KAAK,KAChC,KAAK,KAAK,QAAQA,EAAW,KAAK;AAAA,EACrC;AAAA,EAED,aAAa;AAGT,QADA,KAAK,MAAM,KAAK,KAAK,MAAM,KAAK,KAAK,IAAI,MAAM,QAC3C,KAAK,SAAS,KAAK,MAAM,KAAK;AAC9B,YAAMG,IAAiB,KAAK,KAAK,IAAI,YAAY;AACjD,WAAK,MAAMA,EAAe,KAAK,KAAK,KAAK,MAAM,GAAG;AAAA,IACrD;AACD,QAAI,KAAK,QAAQ,KAAK,KAAK,KAAK;AAC5B,YAAMA,IAAiB,KAAK,KAAK,IAAI,YAAY;AACjD,WAAK,MAAMA,EAAe,KAAK,KAAK,KAAK,KAAK,GAAG;AAAA,IACpD;AAAA,EACJ;AAAA,EAGD,2BAA2BC,GAAa;AACpC,UAAMC,IAAuB,KAAK,KAAK,IAAI,YAAY;AACvD,QAAInB,IAAO,KAAK,KAAK,IAAI,SAAS,SAAY,KAAK,KAAK,IAAI,OAAO,KAAK,KAAK;AAC7E,WAAOmB,EAAqBnB,GAAMkB,EAAY,KAAK,IAAI,GAAG;AAAA,EAC7D;AAAA,EAGD,4BAA4BA,GAAa;AACrC,UAAMC,IAAuB,KAAK,KAAK,IAAI,YAAY;AACvD,QAAIpB,IAAM,KAAK,MAAM,IAAI,QAAQ,SAAY,KAAK,MAAM,IAAI,MAAM,KAAK,MAAM,KAAK,IAAI;AACtF,WAAOoB,EAAqBD,EAAY,KAAK,IAAI,MAAMnB,CAAG;AAAA,EAC7D;AACL;AAcA,MAAMqB,GAAa;AAAA,EAIf,cAAc;AACV,SAAK,OAAO,MACZ,KAAK,WAAW,IAAIZ;EACvB;AAAA,EAMD,IAAI,OAAO;AACP,QAAIa,IAAQ;AACZ,gBAAK,UAAU,KAAK,MAAM,MAAMA,GAAO,GAChCA;AAAA,EACV;AAAA,EAMD,IAAI,OAAO;AACP,QAAIC,IAAM,CAAA;AACV,gBAAK,UAAU,KAAK,MAAM,CAACC,MAASD,EAAI;AAAA,MACpCC,EAAK,KAAK,IAAI,SAASA,EAAK,KAAK,IAAI,OAAM,IAAKA,EAAK,KAAK;AAAA,IACtE,CAAS,GACMD;AAAA,EACV;AAAA,EAMD,IAAI,SAAS;AACT,QAAIA,IAAM,CAAA;AACV,gBAAK,UAAU,KAAK,MAAM,CAACC,MAASD,EAAI,KAAKC,EAAK,KAAK,KAAK,CAAC,GACtDD;AAAA,EACV;AAAA,EAMD,IAAI,QAAQ;AACR,QAAIA,IAAM,CAAA;AACV,gBAAK,UAAU,KAAK,MAAM,CAACC,MAASD,EAAI,KAAK;AAAA,MACzC,KAAKC,EAAK,KAAK,IAAI,SAASA,EAAK,KAAK,IAAI,OAAM,IAAKA,EAAK,KAAK;AAAA,MAC/D,OAAOA,EAAK,KAAK;AAAA,IACpB,CAAA,CAAC,GACKD;AAAA,EACV;AAAA,EAMD,UAAU;AACN,WAAQ,KAAK,QAAQ,QAAQ,KAAK,QAAQ,KAAK;AAAA,EAClD;AAAA,EAKD,QAAQ;AACJ,SAAK,OAAO;AAAA,EACf;AAAA,EAQD,OAAOb,GAAKhU,IAAQgU,GAAK;AACrB,QAAIA,MAAQ;AAAW;AACvB,QAAIe,IAAc,IAAIhB,GAAKC,GAAKhU,GAAO,KAAK,UAAU,KAAK,UAAU,MAAM6T,CAAiB;AAC5F,gBAAK,YAAYkB,CAAW,GAC5B,KAAK,WAAWA,CAAW,GACpBA;AAAA,EACV;AAAA,EAQD,MAAMf,GAAKhU,IAAQgU,GAAK;AACpB,QAAIS,IAAc,IAAIV,GAAKC,GAAKhU,CAAK;AACrC,WAAO,OAAK,YAAY,KAAK,MAAMyU,CAAW;AAAA,EACjD;AAAA,EAQD,OAAOT,GAAKhU,IAAQgU,GAAK;AACrB,QAAIS,IAAc,IAAIV,GAAKC,GAAKhU,CAAK,GACjCgV,IAAc,KAAK,YAAY,KAAK,MAAMP,CAAW;AACzD,WAAIO,KACA,KAAK,YAAYA,CAAW,GAEzBA;AAAA,EACV;AAAA,EASD,OAAOC,GAAUC,IAAiB,CAAClV,GAAOgU,MAAQhU,MAAUgU,IAAMA,EAAI,OAAM,IAAKhU,GAAO;AACpF,QAAIyU,IAAc,IAAIV,GAAKkB,CAAQ,GAC/BE,IAAa,CAAA;AACjB,gBAAK,qBAAqB,KAAK,MAAMV,GAAaU,CAAU,GACrDA,EAAW,IAAI,CAAAL,MAAQI,EAAeJ,EAAK,KAAK,OAAOA,EAAK,KAAK,GAAG,CAAC;AAAA,EAC/E;AAAA,EAOD,cAAcG,GAAU;AACpB,QAAIR,IAAc,IAAIV,GAAKkB,CAAQ;AAEnC,WADY,KAAK,uBAAuB,KAAK,MAAMR,CAAW;AAAA,EAEjE;AAAA,EAOD,QAAQW,GAAS;AACb,SAAK,UAAU,KAAK,MAAM,CAACN,MAASM,EAAQN,EAAK,KAAK,KAAKA,EAAK,KAAK,KAAK,CAAC;AAAA,EAC9E;AAAA,EAKD,IAAIO,GAAU;AACV,UAAMC,IAAO,IAAIX;AACjB,gBAAK,UAAU,KAAK,MAAM,CAACG,MAASQ,EAAK,OAAOR,EAAK,KAAK,KAAKO,EAASP,EAAK,KAAK,OAAOA,EAAK,KAAK,GAAG,CAAC,CAAC,GACjGQ;AAAA,EACV;AAAA,EAED,WAAWR,GAAM;AACb,QAAIS,IAAeT;AACnB,WAAOS,EAAa,UAAU;AAC1B,MAAAA,EAAa,OAAO,cACpBA,IAAeA,EAAa;AAAA,EAEnC;AAAA,EAED,YAAYR,GAAa;AACrB,QAAIS,IAAe,KAAK,MACpBC,IAAc;AAElB,QAAI,KAAK,QAAQ,QAAQ,KAAK,QAAQ,KAAK;AACvC,WAAK,OAAOV;AAAA,SAEX;AACD,aAAOS,KAAgB,KAAK;AACxB,QAAAC,IAAcD,GACVT,EAAY,UAAUS,CAAY,IAClCA,IAAeA,EAAa,OAG5BA,IAAeA,EAAa;AAIpC,MAAAT,EAAY,SAASU,GAEjBV,EAAY,UAAUU,CAAW,IACjCA,EAAY,OAAOV,IAGnBU,EAAY,QAAQV;AAAA,IAE3B;AAED,SAAK,aAAaA,CAAW;AAAA,EAChC;AAAA,EAID,aAAaA,GAAa;AACtB,QAAIS,GACAE;AAGJ,SADAF,IAAeT,GACRS,KAAgB,KAAK,QAAQA,EAAa,OAAO,SAAS3B;AAC7D,MAAI2B,EAAa,UAAUA,EAAa,OAAO,OAAO,QAClDE,IAAaF,EAAa,OAAO,OAAO,OACpCE,EAAW,SAAS7B,KAEpB2B,EAAa,OAAO,QAAQ1B,GAC5B4B,EAAW,QAAQ5B,GACnB0B,EAAa,OAAO,OAAO,QAAQ3B,GACnC2B,IAAeA,EAAa,OAAO,WAG/BA,KAAgBA,EAAa,OAAO,UAEpCA,IAAeA,EAAa,QAC5B,KAAK,YAAYA,CAAY,IAEjCA,EAAa,OAAO,QAAQ1B,GAE5B0B,EAAa,OAAO,OAAO,QAAQ3B,GACnC,KAAK,aAAa2B,EAAa,OAAO,MAAM,OAIhDE,IAAaF,EAAa,OAAO,OAAO,MACpCE,EAAW,SAAS7B,KAEpB2B,EAAa,OAAO,QAAQ1B,GAC5B4B,EAAW,QAAQ5B,GACnB0B,EAAa,OAAO,OAAO,QAAQ3B,GACnC2B,IAAeA,EAAa,OAAO,WAG/BA,KAAgBA,EAAa,OAAO,SAEpCA,IAAeA,EAAa,QAC5B,KAAK,aAAaA,CAAY,IAElCA,EAAa,OAAO,QAAQ1B,GAE5B0B,EAAa,OAAO,OAAO,QAAQ3B,GACnC,KAAK,YAAY2B,EAAa,OAAO,MAAM;AAKvD,SAAK,KAAK,QAAQ1B;AAAA,EACrB;AAAA,EAED,YAAYkB,GAAa;AACrB,QAAIW,GACAC;AAEJ,IAAIZ,EAAY,QAAQ,KAAK,YAAYA,EAAY,SAAS,KAAK,WAC/DW,IAAWX,IAGXW,IAAW,KAAK,eAAeX,CAAW,GAI1CW,EAAS,QAAQ,KAAK,WACtBC,IAAWD,EAAS,OAGpBC,IAAWD,EAAS,OAKpBC,EAAS,SAASD,EAAS,QAG3BA,KAAY,KAAK,OACjB,KAAK,OAAOC,KAGRD,KAAYA,EAAS,OAAO,OAC5BA,EAAS,OAAO,OAAOC,IAGvBD,EAAS,OAAO,QAAQC,GAE5BD,EAAS,OAAO,eAGpB,KAAK,WAAWC,CAAQ,GAKpBD,KAAYX,MACZA,EAAY,UAAUW,CAAQ,GAC9BX,EAAY,WAAU,GACtB,KAAK,WAAWA,CAAW,IAGMW,EAAS,SAAS7B,KACnD,KAAK,aAAa8B,CAAQ;AAAA,EAEjC;AAAA,EAED,aAAaA,GAAU;AACnB,QAAIJ,IAAeI,GACfC;AAEJ,WAAOL,KAAgB,KAAK,QAAQA,EAAa,UAAU,QAAQA,EAAa,SAAS1B;AACrF,MAAI0B,KAAgBA,EAAa,OAAO,QACpCK,IAAeL,EAAa,OAAO,OAC/BK,EAAa,SAAShC,MACtBgC,EAAa,QAAQ/B,GACrB0B,EAAa,OAAO,QAAQ3B,GAC5B,KAAK,YAAY2B,EAAa,MAAM,GACpCK,IAAeL,EAAa,OAAO,QAGnCK,EAAa,KAAK,SAAS/B,KAC3B+B,EAAa,MAAM,SAAS/B,KAC5B+B,EAAa,QAAQhC,GACrB2B,IAAeA,EAAa,WAGxBK,EAAa,MAAM,SAAS/B,MAC5B+B,EAAa,QAAQhC,GACrBgC,EAAa,KAAK,QAAQ/B,GAC1B,KAAK,aAAa+B,CAAY,GAC9BA,IAAeL,EAAa,OAAO,QAIvCK,EAAa,QAAQL,EAAa,OAAO,OACzCA,EAAa,OAAO,QAAQ1B,GAC5B+B,EAAa,MAAM,QAAQ/B,GAC3B,KAAK,YAAY0B,EAAa,MAAM,GACpCA,IAAe,KAAK,UAIxBK,IAAeL,EAAa,OAAO,MAC/BK,EAAa,SAAShC,MACtBgC,EAAa,QAAQ/B,GACrB0B,EAAa,OAAO,QAAQ3B,GAC5B,KAAK,aAAa2B,EAAa,MAAM,GACrCK,IAAeL,EAAa,OAAO,OAGnCK,EAAa,KAAK,SAAS/B,KAC3B+B,EAAa,MAAM,SAAS/B,KAC5B+B,EAAa,QAAQhC,GACrB2B,IAAeA,EAAa,WAGxBK,EAAa,KAAK,SAAS/B,MAC3B+B,EAAa,QAAQhC,GACrBgC,EAAa,MAAM,QAAQ/B,GAC3B,KAAK,YAAY+B,CAAY,GAC7BA,IAAeL,EAAa,OAAO,OAIvCK,EAAa,QAAQL,EAAa,OAAO,OACzCA,EAAa,OAAO,QAAQ1B,GAC5B+B,EAAa,KAAK,QAAQ/B,GAC1B,KAAK,aAAa0B,EAAa,MAAM,GACrCA,IAAe,KAAK;AAKhC,IAAAA,EAAa,QAAQ1B;AAAA,EACxB;AAAA,EAED,YAAYgB,GAAML,GAAa;AAC3B,QAAI,EAAAK,KAAQ,QAAQA,KAAQ,KAAK;AAGjC,aAAIL,EAAY,SAASK,CAAI,IAClBA,IAEPL,EAAY,UAAUK,CAAI,IACnB,KAAK,YAAYA,EAAK,MAAML,CAAW,IAGvC,KAAK,YAAYK,EAAK,OAAOL,CAAW;AAAA,EAEtD;AAAA,EAID,qBAAqBK,GAAML,GAAaI,GAAK;AACzC,IAAIC,KAAQ,QAAQA,KAAQ,KAAK,aAEzBA,EAAK,QAAQ,KAAK,YAAY,CAACA,EAAK,2BAA2BL,CAAW,KAC1E,KAAK,qBAAqBK,EAAK,MAAML,GAAaI,CAAG,GAGrDC,EAAK,UAAUL,CAAW,KAC1BI,EAAI,KAAKC,CAAI,GAGbA,EAAK,SAAS,KAAK,YAAY,CAACA,EAAK,4BAA4BL,CAAW,KAC5E,KAAK,qBAAqBK,EAAK,OAAOL,GAAaI,CAAG;AAAA,EAGjE;AAAA,EAED,uBAAuBC,GAAML,GAAa;AACtC,QAAIqB,IAAQ;AACZ,WAAIhB,KAAQ,QAAQA,KAAQ,KAAK,aAEzBA,EAAK,QAAQ,KAAK,YAAY,CAACA,EAAK,2BAA2BL,CAAW,MAC1EqB,IAAQ,KAAK,uBAAuBhB,EAAK,MAAML,CAAW,IAGzDqB,MACDA,IAAQhB,EAAK,UAAUL,CAAW,IAGlC,CAACqB,KAAShB,EAAK,SAAS,KAAK,YAAY,CAACA,EAAK,4BAA4BL,CAAW,MACtFqB,IAAQ,KAAK,uBAAuBhB,EAAK,OAAOL,CAAW,KAG5DqB;AAAA,EACV;AAAA,EAED,cAAchB,GAAM;AAChB,QAAIiB,IAAWjB;AACf,WAAOiB,EAAS,QAAQ,QAAQA,EAAS,QAAQ,KAAK;AAClD,MAAAA,IAAWA,EAAS;AAExB,WAAOA;AAAA,EACV;AAAA,EAGD,cAAcjB,GAAM;AAChB,QAAIkB,IAAWlB;AACf,WAAOkB,EAAS,SAAS,QAAQA,EAAS,SAAS,KAAK;AACpD,MAAAA,IAAWA,EAAS;AAExB,WAAOA;AAAA,EACV;AAAA,EAED,eAAelB,GAAM;AACjB,QAAImB,GACAT,GACAC;AAEJ,QAAIX,EAAK,SAAS,KAAK;AACnB,MAAAmB,IAAiB,KAAK,cAAcnB,EAAK,KAAK;AAAA,SAE7C;AAGD,WAFAU,IAAeV,GACfW,IAAcX,EAAK,QACZW,KAAe,QAAQA,EAAY,SAASD;AAC/C,QAAAA,IAAeC,GACfA,IAAcA,EAAY;AAE9B,MAAAQ,IAAiBR;AAAA,IACpB;AACD,WAAOQ;AAAA,EACV;AAAA,EASD,YAAY5W,GAAG;AACX,QAAIE,IAAIF,EAAE;AAEV,IAAAA,EAAE,QAAQE,EAAE,MAERA,EAAE,QAAQ,KAAK,aACfA,EAAE,KAAK,SAASF,IAEpBE,EAAE,SAASF,EAAE,QAETA,KAAK,KAAK,OACV,KAAK,OAAOE,IAGRF,KAAKA,EAAE,OAAO,OACdA,EAAE,OAAO,OAAOE,IAGhBF,EAAE,OAAO,QAAQE,GAGzBA,EAAE,OAAOF,GACTA,EAAE,SAASE,GAEPF,KAAK,QAAQA,KAAK,KAAK,YACvBA,EAAE,WAAU,GAGhBE,IAAIF,EAAE,QACFE,KAAK,QAAQA,KAAK,KAAK,YACvBA,EAAE,WAAU;AAAA,EAEnB;AAAA,EAED,aAAaA,GAAG;AACZ,QAAIF,IAAIE,EAAE;AAEV,IAAAA,EAAE,OAAOF,EAAE,OAEPA,EAAE,SAAS,KAAK,aAChBA,EAAE,MAAM,SAASE,IAErBF,EAAE,SAASE,EAAE,QAETA,KAAK,KAAK,OACV,KAAK,OAAOF,IAGRE,KAAKA,EAAE,OAAO,OACdA,EAAE,OAAO,OAAOF,IAGhBE,EAAE,OAAO,QAAQF,GAGzBA,EAAE,QAAQE,GACVA,EAAE,SAASF,GAEPE,KAAK,QAAQA,KAAK,KAAK,YACvBA,EAAE,WAAU,GAGhBF,IAAIE,EAAE,QACFF,KAAK,QAAQA,KAAK,KAAK,YACvBA,EAAE,WAAU;AAAA,EAEnB;AAAA,EAED,UAAUyV,GAAMoB,GAAQ;AACpB,IAAIpB,KAAQ,QAAQA,KAAQ,KAAK,aAC7B,KAAK,UAAUA,EAAK,MAAMoB,CAAM,GAEhCA,EAAOpB,CAAI,GACX,KAAK,UAAUA,EAAK,OAAOoB,CAAM;AAAA,EAExC;AAAA,EAGD,uBAAuB;AACnB,QAAIrB,IAAM;AACV,gBAAK,UAAU,KAAK,MAAM,SAAUC,GAAM;AACtC,MAAIA,EAAK,SAASjB,MACRiB,EAAK,KAAK,SAAShB,KAAuBgB,EAAK,MAAM,SAAShB,MAChEe,IAAM;AAAA,IAG1B,CAAS,GACMA;AAAA,EACV;AAAA,EAGD,wBAAwBC,GAAM;AAC1B,QAAIqB,IAAS,GACTC,IAAa,GACbC,IAAc;AAgBlB,QAfIvB,EAAK,SAAShB,KACdqC,KAEArB,EAAK,QAAQ,KAAK,WAClBsB,IAAa,KAAK,wBAAwBtB,EAAK,IAAI,IAGnDsB,IAAa,GAEbtB,EAAK,SAAS,KAAK,WACnBuB,IAAc,KAAK,wBAAwBvB,EAAK,KAAK,IAGrDuB,IAAc,GAEdD,KAAcC;AACd,YAAM,IAAI,MAAM,oCAAoC;AAExD,WAAAF,KAAUC,GACHD;AAAA,EACV;AACL;AAWA,MAAMG,WAAkB,IAAI;AAAA,EAMxB,YAAYlV,GAAQ;AAChB,UAAMA,CAAM,GACZ,KAAK,QAAQ,IAAIuT,MACjB,KAAK,QAAQ,CAAArG,MAAS,KAAK,MAAM,OAAOA,CAAK,CAAC;AAAA,EACjD;AAAA,EAWD,IAAIA,GAAO;AACP,QAAIiI,IAAO,KAAK;AAChB,iBAAM,IAAIjI,CAAK,GAEX,KAAK,OAAOiI,KACD,KAAK,MAAM,OAAOjI,EAAM,KAAKA,CAAK,GAE1C;AAAA,EACV;AAAA,EAOD,OAAOA,GAAO;AACV,QAAIkI,IAAU,MAAM,OAAOlI,CAAK;AAChC,WAAIkI,KACA,KAAK,MAAM,OAAOlI,EAAM,KAAKA,CAAK,GAE/BkI;AAAA,EACV;AAAA,EAKD,QAAQ;AACJ,UAAM,MAAK,GACX,KAAK,QAAQ,IAAI7B;EACpB;AAAA,EAQD,OAAOrJ,GAAK;AAER,WADW,KAAK,MAAM,OAAOA,CAAG;AAAA,EAEnC;AAAA,EAOD,IAAIuE,GAAO;AACP,QAAIvE,IAAM,IAAIxL,EAAQ,IAAI+P,EAAM,IAAI,GAAGA,EAAM,IAAI,GAAGA,EAAM,IAAI,GAAGA,EAAM,IAAI,CAAC;AAE5E,WADW,KAAK,MAAM,OAAOvE,CAAG,EACpB,OAAO,CAACgD,MAAUuB,EAAM,GAAGvB,CAAK,CAAC;AAAA,EAChD;AAAA,EAMD,MAAM;AAEF,WADiB,CAAC,GAAG,IAAI,EAAE,OAAO,CAACI,GAAKJ,MAAUI,IAAMJ,EAAM,IAAK,GAAE,EAAE;AAAA,EAE1E;AACL;AAEAxO,EAAQ,YAAYwW;AAWpB,MAAMG,GAAM;AAAA,EAMR,eAAehI,GAAM;AAYjB,QAPA,KAAK,IAAI,GAKT,KAAK,IAAI,GAELA,EAAK,WAAW,GAIpB;AAAA,UAAIA,EAAK,WAAW,KAAKA,EAAK,cAAc,SAASA,EAAK,GAAG,WAAW,GAAG;AACvE,YAAIiI,IAAMjI,EAAK;AACf,YAAI,OAAQiI,EAAI,MAAO,YAAY,OAAQA,EAAI,MAAO,UAAU;AAC5D,eAAK,IAAIA,EAAI,IACb,KAAK,IAAIA,EAAI;AACb;AAAA,QACH;AAAA,MACJ;AAED,UAAIjI,EAAK,WAAW,KAAKA,EAAK,cAAc,UAAUA,EAAK,GAAG,SAAS,SAAS;AAC5E,YAAI,EAAC,GAAApP,GAAG,GAAAE,EAAC,IAAIkP,EAAK;AAClB,aAAK,IAAIpP,GACT,KAAK,IAAIE;AACT;AAAA,MACH;AAED,UAAIkP,EAAK,WAAW,KACZ,OAAQA,EAAK,MAAO,YAAY,OAAQA,EAAK,MAAO,UAAU;AAC9D,aAAK,IAAIA,EAAK,IACd,KAAK,IAAIA,EAAK;AACd;AAAA,MACH;AAGL,YAAM3O,EAAQ,OAAO;AAAA;AAAA,EAExB;AAAA,EAMD,IAAI,MAAM;AACN,WAAO,IAAIA,EAAQ,IAAI,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AAAA,EACxD;AAAA,EAMD,QAAQ;AACJ,WAAO,IAAIA,EAAQ,MAAM,KAAK,GAAG,KAAK,CAAC;AAAA,EAC1C;AAAA,EAED,IAAI,WAAW;AACX,WAAO,CAAC,KAAK,MAAK,CAAE;AAAA,EACvB;AAAA,EAOD,QAAQmB,GAAI;AACR,WAAOnB,EAAQ,MAAM,GAAG,KAAK,GAAGmB,EAAG,CAAC,KAAKnB,EAAQ,MAAM,GAAG,KAAK,GAAGmB,EAAG,CAAC;AAAA,EACzE;AAAA,EASD,SAASA,GAAI;AAGT,WAFI,GAAAnB,EAAQ,MAAM,GAAG,KAAK,GAAGmB,EAAG,CAAC,KAE7BnB,EAAQ,MAAM,GAAG,KAAK,GAAGmB,EAAG,CAAC,KAAKnB,EAAQ,MAAM,GAAG,KAAK,GAAGmB,EAAG,CAAC;AAAA,EAGtE;AAAA,EAWD,OAAO6N,GAAOC,IAAS,EAAC,GAAG,GAAG,GAAG,EAAC,GAAG;AACjC,QAAI4H,IAAQ5H,EAAO,KAAK,KAAK,IAAIA,EAAO,KAAK,KAAK,IAAID,CAAK,KAAK,KAAK,IAAIC,EAAO,KAAK,KAAK,IAAID,CAAK,GAC/F8H,IAAQ7H,EAAO,KAAK,KAAK,IAAIA,EAAO,KAAK,KAAK,IAAID,CAAK,KAAK,KAAK,IAAIC,EAAO,KAAK,KAAK,IAAID,CAAK;AAEnG,WAAO,IAAIhP,EAAQ,MAAM6W,GAAOC,CAAK;AAAA,EACxC;AAAA,EASD,aAAanI,GAAM;AACf,QAAIA,EAAK,UAAU,MACdA,EAAK,cAAc3O,EAAQ,UAAU,CAAC,MAAM2O,EAAK,GAAG,CAAC,KAAK,CAAC,MAAMA,EAAK,GAAG,CAAC;AAC3E,aAAO,IAAI3O,EAAQ,MAAM,KAAK,IAAI2O,EAAK,GAAG,GAAG,KAAK,IAAIA,EAAK,GAAG,CAAC;AAGnE,QAAIA,EAAK,UAAU,KAAK,OAAQA,EAAK,MAAO,YAAY,OAAQA,EAAK,MAAO;AACxE,aAAO,IAAI3O,EAAQ,MAAM,KAAK,IAAI2O,EAAK,IAAI,KAAK,IAAIA,EAAK,EAAE;AAG/D,UAAM3O,EAAQ,OAAO;AAAA,EACxB;AAAA,EAOD,UAAU+W,GAAG;AAET,WAAO,IAAI/W,EAAQ,MAAM+W,EAAE,UAAU,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC;AAAA,EACzD;AAAA,EAOD,aAAa5U,GAAM;AACf,QAAI,KAAK,QAAQA,EAAK,EAAE;AACpB,aAAO,KAAK;AAEhB,QAAIyK,IAAM,IAAI5M,EAAQ,OAAO,MAAMmC,EAAK,EAAE;AAC1C,QAAInC,EAAQ,MAAM,KAAK4M,EAAI,MAAMzK,EAAK,IAAI,CAAC;AACvC,aAAOA,EAAK,GAAG;AAEnB,QAAIsG,IAAOmE,EAAI,IAAIzK,EAAK,IAAI,GACxB6U,IAAW7U,EAAK,KAAK,SAASsG,CAAI;AACtC,WAAO,KAAK,UAAUuO,CAAQ;AAAA,EACjC;AAAA,EAQD,OAAO7U,GAAM;AACT,QAAIyK,IAAM,IAAI5M,EAAQ,OAAOmC,EAAK,IAAI,IAAI;AAE1C,WADsBnC,EAAQ,MAAM,GAAG4M,EAAI,IAAIzK,EAAK,IAAI,GAAG,CAAC;AAAA,EAE/D;AAAA,EAQD,WAAWqM,GAAO;AACd,QAAIA,aAAiBmI,IAAO;AACxB,UAAIM,IAAKzI,EAAM,IAAI,KAAK,GACpB0I,IAAK1I,EAAM,IAAI,KAAK;AACxB,aAAO,CAAC,KAAK,KAAKyI,IAAKA,IAAKC,IAAKA,CAAE,GAAG,IAAIlX,EAAQ,QAAQ,MAAMwO,CAAK,CAAC;AAAA,IACzE;AAED,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOA,EAAQ,SAAS,WAAW,MAAMwO,CAAK;AAGlD,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOA,EAAQ,SAAS,aAAa,MAAMwO,CAAK;AAGpD,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOA,EAAQ,SAAS,cAAc,MAAMwO,CAAK;AAGrD,QAAIA,aAAiBxO,EAAQ;AAGzB,aAAOA,EAAQ,SAAS,UAAU,MAAMwO,CAAK;AAGjD,QAAIA,aAAiBxO,EAAQ;AAGzB,aAAOA,EAAQ,SAAS,cAAc,MAAMwO,CAAK;AAGrD,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOA,EAAQ,SAAS,gBAAgB,MAAMwO,CAAK;AAAA,EAE1D;AAAA,EAOD,GAAGA,GAAO;AACN,QAAIA,aAAiBxO,EAAQ;AACzB,aAAO,KAAK,QAAQwO,CAAK;AAG7B,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOwO,EAAM,SAAS,IAAI;AAG9B,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOwO,EAAM,SAAS,IAAI;AAG9B,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOwO,EAAM,SAAS,IAAI;AAG9B,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOwO,EAAM,SAAS,IAAI;AAG9B,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOwO,EAAM,SAAS,IAAI;AAAA,EAEjC;AAAA,EAOD,SAAS;AACL,WAAO,OAAO,OAAO,CAAE,GAAE,MAAM,EAAC,MAAM,QAAO,CAAC;AAAA,EACjD;AAAA,EAeD,IAAIW,IAAQ,IAAI;AACZ,QAAI,EAAC,GAAAgI,GAAG,QAAA/H,GAAQ,aAAAC,GAAa,MAAAC,GAAM,IAAAjO,GAAI,WAAAoO,EAAS,IAAIN,GAEhDO,IAAUrO,KAAMA,EAAG,SAAS,IAAK,OAAOA,OAAQ,IAChDsO,IAAaF,KAAaA,EAAU,SAAS,IAAK,UAAUA,OAAe;AAC/E,WAAO;AAAA,cAAiB,KAAK,UAAU,KAAK,SAAS0H,KAAK,cAAc/H,KAAU,0BAA0BC,KAAe,YAAYC,KAAQ,UAAUI,KAAUC;AAAA,EACtK;AAEL;AACA3P,EAAQ,QAAQ2W;AAKhB,MAAM5G,KAAQ,IAAIpB,MAAS,IAAI3O,EAAQ,MAAM,GAAG2O,CAAI;AACpD3O,EAAQ,QAAQ+P;AAYhB,MAAMqH,GAAO;AAAA,EAOT,eAAezI,GAAM;AAajB,QARA,KAAK,IAAI,GAKT,KAAK,IAAI,GAGLA,EAAK,WAAW,GAIpB;AAAA,UAAIA,EAAK,WAAW,KAAKA,EAAK,cAAc,SAASA,EAAK,GAAG,WAAW,GAAG;AACvE,YAAIiI,IAAMjI,EAAK;AACf,YAAI,OAAQiI,EAAI,MAAO,YAAY,OAAQA,EAAI,MAAO,UAAU;AAC5D,eAAK,IAAIA,EAAI,IACb,KAAK,IAAIA,EAAI;AACb;AAAA,QACH;AAAA,MACJ;AAED,UAAIjI,EAAK,WAAW,KAAKA,EAAK,cAAc,UAAUA,EAAK,GAAG,SAAS,UAAU;AAC7E,YAAI,EAAC,GAAApP,GAAG,GAAAE,EAAC,IAAIkP,EAAK;AAClB,aAAK,IAAIpP,GACT,KAAK,IAAIE;AACT;AAAA,MACH;AAED,UAAIkP,EAAK,WAAW,GAAG;AACnB,YAAI0I,IAAK1I,EAAK,IACV2I,IAAK3I,EAAK;AAEd,YAAI,OAAQ0I,KAAO,YAAY,OAAQC,KAAO,UAAU;AACpD,eAAK,IAAID,GACT,KAAK,IAAIC;AACT;AAAA,QACH;AAED,YAAID,aAAcrX,EAAQ,SAASsX,aAActX,EAAQ,OAAO;AAC5D,eAAK,IAAIsX,EAAG,IAAID,EAAG,GACnB,KAAK,IAAIC,EAAG,IAAID,EAAG;AACnB;AAAA,QACH;AAAA,MAEJ;AAED,YAAMrX,EAAQ,OAAO;AAAA;AAAA,EACxB;AAAA,EAMD,QAAQ;AACJ,WAAO,IAAIA,EAAQ,OAAO,KAAK,GAAG,KAAK,CAAC;AAAA,EAC3C;AAAA,EAMD,IAAI,QAAQ;AACR,QAAIgP,IAAQ,KAAK,MAAM,KAAK,GAAG,KAAK,CAAC;AACrC,WAAIA,IAAQ,MAAGA,IAAQ,IAAI,KAAK,KAAKA,IAC9BA;AAAA,EACV;AAAA,EAMD,IAAI,SAAS;AACT,WAAO,KAAK,KAAK,KAAK,IAAI,IAAI,CAAC;AAAA,EAClC;AAAA,EAQD,QAAQH,GAAG;AACP,WAAO7O,EAAQ,MAAM,GAAG,KAAK,GAAG6O,EAAE,CAAC,KAAK7O,EAAQ,MAAM,GAAG,KAAK,GAAG6O,EAAE,CAAC;AAAA,EACvE;AAAA,EAOD,SAAS0I,GAAQ;AACb,WAAQ,IAAIvX,EAAQ,OAAOuX,IAAS,KAAK,GAAGA,IAAS,KAAK,CAAC;AAAA,EAC9D;AAAA,EAQD,IAAI1I,GAAG;AACH,WAAQ,KAAK,IAAIA,EAAE,IAAI,KAAK,IAAIA,EAAE;AAAA,EACrC;AAAA,EAQD,MAAMA,GAAG;AACL,WAAQ,KAAK,IAAIA,EAAE,IAAI,KAAK,IAAIA,EAAE;AAAA,EACrC;AAAA,EAOD,YAAY;AACR,QAAI,CAAC7O,EAAQ,MAAM,KAAK,KAAK,MAAM;AAC/B,aAAQ,IAAIA,EAAQ,OAAO,KAAK,IAAI,KAAK,QAAQ,KAAK,IAAI,KAAK,MAAM;AAEzE,UAAMA,EAAQ,OAAO;AAAA,EACxB;AAAA,EASD,OAAOgP,GAAO;AAEV,QAAIwI,IADQ,IAAIxX,EAAQ,MAAM,KAAK,GAAG,KAAK,CAAC,EACzB,OAAOgP,CAAK;AAC/B,WAAO,IAAIhP,EAAQ,OAAOwX,EAAO,GAAGA,EAAO,CAAC;AAAA,EAC/C;AAAA,EAMD,cAAc;AACV,WAAO,IAAIxX,EAAQ,OAAO,CAAC,KAAK,GAAG,KAAK,CAAC;AAAA,EAC5C;AAAA,EAMD,aAAa;AACT,WAAO,IAAIA,EAAQ,OAAO,KAAK,GAAG,CAAC,KAAK,CAAC;AAAA,EAC5C;AAAA,EAMD,SAAS;AACL,WAAO,IAAIA,EAAQ,OAAO,CAAC,KAAK,GAAG,CAAC,KAAK,CAAC;AAAA,EAC7C;AAAA,EAOD,IAAI6O,GAAG;AACH,WAAO,IAAI7O,EAAQ,OAAO,KAAK,IAAI6O,EAAE,GAAG,KAAK,IAAIA,EAAE,CAAC;AAAA,EACvD;AAAA,EAOD,SAASA,GAAG;AACR,WAAO,IAAI7O,EAAQ,OAAO,KAAK,IAAI6O,EAAE,GAAG,KAAK,IAAIA,EAAE,CAAC;AAAA,EACvD;AAAA,EASD,QAAQA,GAAG;AACP,QAAI4I,IAAQ,KAAK,aACbC,IAAQ7I,EAAE,aACVG,IAAQ,KAAK,MAAMyI,EAAM,MAAMC,CAAK,GAAGD,EAAM,IAAIC,CAAK,CAAC;AAC3D,WAAI1I,IAAQ,MAAGA,KAAS,IAAI,KAAK,KAC1BA;AAAA,EACV;AAAA,EAOD,aAAaH,GAAG;AACZ,QAAI8I,IAAI9I,EAAE,aACNgE,IAAI,KAAK,IAAI8E,CAAC;AAClB,WAAOA,EAAE,SAAS9E,CAAC;AAAA,EACtB;AAAA,EAOD,SAAS;AACL,WAAO,OAAO,OAAO,CAAE,GAAE,MAAM,EAAC,MAAM,SAAQ,CAAC;AAAA,EAClD;AACL;AACA7S,EAAQ,SAASoX;AAMjB,MAAMnE,KAAS,IAAItE,MAAS,IAAI3O,EAAQ,OAAO,GAAG2O,CAAI;AACtD3O,EAAQ,SAASiT;AAUjB,MAAM2E,GAAQ;AAAA,EAMV,eAAejJ,GAAM;AAYjB,QAPA,KAAK,KAAK,IAAI3O,EAAQ,MAAK,GAK3B,KAAK,KAAK,IAAIA,EAAQ,MAAK,GAEvB2O,EAAK,WAAW,GAIpB;AAAA,UAAIA,EAAK,WAAW,KAAKA,EAAK,cAAc,SAASA,EAAK,GAAG,WAAW,GAAG;AACvE,YAAIkJ,IAASlJ,EAAK;AAClB,aAAK,KAAK,IAAI3O,EAAQ,MAAM6X,EAAO,IAAIA,EAAO,EAAE,GAChD,KAAK,KAAK,IAAI7X,EAAQ,MAAM6X,EAAO,IAAIA,EAAO,EAAE;AAChD;AAAA,MACH;AAED,UAAIlJ,EAAK,WAAW,KAAKA,EAAK,cAAc,UAAUA,EAAK,GAAG,SAAS,WAAW;AAC9E,YAAI,EAAC,IAAAmJ,GAAI,IAAAC,EAAE,IAAIpJ,EAAK;AACpB,aAAK,KAAK,IAAI3O,EAAQ,MAAM8X,EAAG,GAAGA,EAAG,CAAC,GACtC,KAAK,KAAK,IAAI9X,EAAQ,MAAM+X,EAAG,GAAGA,EAAG,CAAC;AACtC;AAAA,MACH;AAGD,UAAIpJ,EAAK,WAAW,KAAKA,EAAK,cAAc3O,EAAQ,OAAO;AACvD,aAAK,KAAK2O,EAAK,GAAG,MAAK;AACvB;AAAA,MACH;AAED,UAAIA,EAAK,WAAW,KAAKA,EAAK,cAAc3O,EAAQ,SAAS2O,EAAK,cAAc3O,EAAQ,OAAO;AAC3F,aAAK,KAAK2O,EAAK,GAAG,MAAK,GACvB,KAAK,KAAKA,EAAK,GAAG,MAAK;AACvB;AAAA,MACH;AAED,UAAIA,EAAK,WAAW,GAAG;AACnB,aAAK,KAAK,IAAI3O,EAAQ,MAAM2O,EAAK,IAAIA,EAAK,EAAE,GAC5C,KAAK,KAAK,IAAI3O,EAAQ,MAAM2O,EAAK,IAAIA,EAAK,EAAE;AAC5C;AAAA,MACH;AAED,YAAM3O,EAAQ,OAAO;AAAA;AAAA,EACxB;AAAA,EAMD,QAAQ;AACJ,WAAO,IAAIA,EAAQ,QAAQ,KAAK,OAAO,KAAK,GAAG;AAAA,EAClD;AAAA,EAMD,IAAI,QAAQ;AACR,WAAO,KAAK;AAAA,EACf;AAAA,EAMD,IAAI,MAAM;AACN,WAAO,KAAK;AAAA,EACf;AAAA,EAOD,IAAI,WAAW;AACX,WAAO,CAAC,KAAK,GAAG,MAAK,GAAI,KAAK,GAAG,MAAK,CAAE;AAAA,EAC3C;AAAA,EAMD,IAAI,SAAS;AACT,WAAO,KAAK,MAAM,WAAW,KAAK,GAAG,EAAE;AAAA,EAC1C;AAAA,EAMD,IAAI,QAAQ;AAER,WADU,IAAIA,EAAQ,OAAO,KAAK,OAAO,KAAK,GAAG,EACtC;AAAA,EACd;AAAA,EAMD,IAAI,MAAM;AACN,WAAO,IAAIA,EAAQ;AAAA,MACf,KAAK,IAAI,KAAK,MAAM,GAAG,KAAK,IAAI,CAAC;AAAA,MACjC,KAAK,IAAI,KAAK,MAAM,GAAG,KAAK,IAAI,CAAC;AAAA,MACjC,KAAK,IAAI,KAAK,MAAM,GAAG,KAAK,IAAI,CAAC;AAAA,MACjC,KAAK,IAAI,KAAK,MAAM,GAAG,KAAK,IAAI,CAAC;AAAA,IACpC;AAAA,EACJ;AAAA,EAOD,QAAQ0L,GAAK;AACT,WAAO,KAAK,GAAG,QAAQA,EAAI,EAAE,KAAK,KAAK,GAAG,QAAQA,EAAI,EAAE;AAAA,EAC3D;AAAA,EAOD,SAASvK,GAAI;AACT,WAAOnB,EAAQ,MAAM,KAAK,KAAK,gBAAgBmB,CAAE,CAAC;AAAA,EACrD;AAAA,EAOD,UAAUqN,GAAO;AACb,QAAIA,aAAiBxO,EAAQ;AACzB,aAAO,KAAK,SAASwO,CAAK,IAAI,CAACA,CAAK,IAAI;AAG5C,QAAIA,aAAiBxO,EAAQ;AACzB,aAAO4L,GAAsB,MAAM4C,CAAK;AAG5C,QAAIA,aAAiBxO,EAAQ;AACzB,aAAQiM,GAAyB,MAAMuC,CAAK;AAGhD,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOqM,GAAwB,MAAMmC,CAAK;AAG9C,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOwM,GAAqB,MAAMgC,CAAK;AAG3C,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOuM,GAAqB,MAAMiC,CAAK;AAG3C,QAAIA,aAAiBxO,EAAQ;AACzB,aAAQ4N,GAAyB,MAAMY,CAAK;AAAA,EAEnD;AAAA,EAQD,WAAWA,GAAO;AACd,QAAIA,aAAiBxO,EAAQ,OAAO;AAChC,UAAI,CAACyI,GAAM6D,CAAgB,IAAItM,EAAQ,SAAS,cAAcwO,GAAO,IAAI;AACzE,aAAAlC,IAAmBA,EAAiB,WAC7B,CAAC7D,GAAM6D,CAAgB;AAAA,IACjC;AAED,QAAIkC,aAAiBxO,EAAQ,QAAQ;AACjC,UAAI,CAACyI,GAAM6D,CAAgB,IAAItM,EAAQ,SAAS,eAAe,MAAMwO,CAAK;AAC1E,aAAO,CAAC/F,GAAM6D,CAAgB;AAAA,IACjC;AAED,QAAIkC,aAAiBxO,EAAQ,MAAM;AAC/B,UAAI,CAACyI,GAAM6D,CAAgB,IAAItM,EAAQ,SAAS,aAAa,MAAMwO,CAAK;AACxE,aAAO,CAAC/F,GAAM6D,CAAgB;AAAA,IACjC;AAED,QAAIkC,aAAiBxO,EAAQ,SAAS;AAClC,UAAI,CAACyI,GAAM6D,CAAgB,IAAItM,EAAQ,SAAS,gBAAgB,MAAMwO,CAAK;AAC3E,aAAO,CAAC/F,GAAM6D,CAAgB;AAAA,IACjC;AAED,QAAIkC,aAAiBxO,EAAQ,KAAK;AAC9B,UAAI,CAACyI,GAAM6D,CAAgB,IAAItM,EAAQ,SAAS,YAAY,MAAMwO,CAAK;AACvE,aAAO,CAAC/F,GAAM6D,CAAgB;AAAA,IACjC;AAED,QAAIkC,aAAiBxO,EAAQ,SAAS;AAClC,UAAI,CAACyI,GAAM6D,CAAgB,IAAItM,EAAQ,SAAS,cAAc,MAAMwO,CAAK;AACzE,aAAO,CAAC/F,GAAM6D,CAAgB;AAAA,IACjC;AAED,QAAIkC,aAAiBxO,EAAQ,WAAW;AACpC,UAAI,CAACyI,GAAM6D,CAAgB,IAAItM,EAAQ,SAAS,gBAAgB,MAAMwO,CAAK;AAC3E,aAAO,CAAC/F,GAAM6D,CAAgB;AAAA,IACjC;AAAA,EACJ;AAAA,EAMD,iBAAiB;AAEb,WADU,IAAItM,EAAQ,OAAO,KAAK,OAAO,KAAK,GAAG,EACtC;EACd;AAAA,EAMD,eAAe;AAEX,WADU,IAAIA,EAAQ,OAAO,KAAK,KAAK,KAAK,KAAK,EACtC;EACd;AAAA,EAMD,UAAU;AACN,WAAO,IAAI4X,GAAQ,KAAK,KAAK,KAAK,KAAK;AAAA,EAC1C;AAAA,EASD,MAAMzW,GAAI;AACN,WAAI,KAAK,MAAM,QAAQA,CAAE,IACd,CAAC,MAAM,KAAK,MAAO,CAAA,IAE1B,KAAK,IAAI,QAAQA,CAAE,IACZ,CAAC,KAAK,MAAO,GAAE,IAAI,IAEvB;AAAA,MACH,IAAInB,EAAQ,QAAQ,KAAK,OAAOmB,CAAE;AAAA,MAClC,IAAInB,EAAQ,QAAQmB,GAAI,KAAK,GAAG;AAAA,IACnC;AAAA,EACJ;AAAA,EAMD,SAAS;AACL,WAAO,IAAInB,EAAQ,OAAO,KAAK,MAAM,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK,MAAM,IAAI,KAAK,IAAI,KAAK,CAAC;AAAA,EAC5F;AAAA,EAOD,cAAcgY,GAAQ;AAClB,QAAIA,IAAS,KAAK,UAAUA,IAAS;AAAG,aAAO;AAC/C,QAAIA,KAAU;AAAG,aAAO,KAAK;AAC7B,QAAIA,KAAU,KAAK;AAAQ,aAAO,KAAK;AACvC,QAAIC,IAASD,IAAS,KAAK;AAC3B,WAAO,IAAIhY,EAAQ;AAAA,OACd,KAAK,IAAI,IAAI,KAAK,MAAM,KAAKiY,IAAS,KAAK,MAAM;AAAA,OACjD,KAAK,IAAI,IAAI,KAAK,MAAM,KAAKA,IAAS,KAAK,MAAM;AAAA,IAC9D;AAAA,EACK;AAAA,EAED,gBAAgB9W,GAAI;AAChB,QAAI,CAACsH,MAASyP,CAAI,IAAIlY,EAAQ,SAAS,cAAcmB,GAAI,IAAI;AAC7D,WAAOsH;AAAA,EACV;AAAA,EAED,iBAAiB0P,IAAO,GAAK;AACzB,QAAIlB,IAAK,KAAK,IAAI,IAAI,KAAK,MAAM,GAC7BmB,IAAM,KAAK,MAAM,IAAID,GACrBE,IAAM,KAAK,IAAI,IAAIF;AACvB,WAAQlB,KAAMmB,IAAMC,KAAO;AAAA,EAC9B;AAAA,EAOD,aAAa1J,GAAM;AACf,WAAO,IAAIiJ,GAAQ,KAAK,GAAG,UAAU,GAAGjJ,CAAI,GAAG,KAAK,GAAG,UAAU,GAAGA,CAAI,CAAC;AAAA,EAC5E;AAAA,EAUD,OAAOK,IAAQ,GAAGC,IAAS,IAAIjP,EAAQ,SAAS;AAC5C,QAAI+W,IAAI,IAAI/W,EAAQ;AACpB,WAAA+W,IAAIA,EAAE,UAAU9H,EAAO,GAAGA,EAAO,CAAC,EAAE,OAAOD,CAAK,EAAE,UAAU,CAACC,EAAO,GAAG,CAACA,EAAO,CAAC,GACzE,KAAK,UAAU8H,CAAC;AAAA,EAC1B;AAAA,EAOD,UAAU7H,IAAS,IAAIlP,EAAQ,OAAM,GAAI;AACrC,WAAO,IAAI4X,GAAQ,KAAK,GAAG,UAAU1I,CAAM,GAAG,KAAK,GAAG,UAAUA,CAAM,CAAC;AAAA,EAC1E;AAAA,EAMD,eAAe;AACX,WAAO,KAAK,GAAG,QAAQ,KAAK,EAAE;AAAA,EACjC;AAAA,EAOD,WAAWoJ,GAAK;AAEZ,WADW,IAAItY,EAAQ,KAAK,KAAK,OAAO,KAAK,GAAG,EACpC,WAAWsY,CAAG;AAAA,EAC7B;AAAA,EAOD,SAAS;AACL,WAAO,OAAO,OAAO,CAAE,GAAE,MAAM,EAAC,MAAM,UAAS,CAAC;AAAA,EACnD;AAAA,EASD,IAAInJ,IAAQ,IAAI;AACZ,QAAI,EAAC,QAAAC,GAAQ,aAAAC,GAAa,IAAAhO,GAAI,WAAAoO,EAAS,IAAIN,GAEvCO,IAAUrO,KAAMA,EAAG,SAAS,IAAK,OAAOA,OAAQ,IAChDsO,IAAaF,KAAaA,EAAU,SAAS,IAAK,UAAUA,OAAe;AAE/E,WAAO;AAAA,YAAe,KAAK,MAAM,UAAU,KAAK,MAAM,UAAU,KAAK,IAAI,UAAU,KAAK,IAAI,cAAcL,KAAU,0BAA0BC,KAAe,MAAMK,KAAUC;AAAA,EAEhL;AAEL;AACA3P,EAAQ,UAAU4X;AAIlB,MAAMlP,KAAU,IAAIiG,MAAS,IAAI3O,EAAQ,QAAQ,GAAG2O,CAAI;AACxD3O,EAAQ,UAAU0I;AAMlB,IAAI,EAAC,QAAQ6P,GAAQ,IAAIvY;AAMzB,MAAMwY,GAAK;AAAA,EAMP,eAAe7J,GAAM;AAcjB,QATA,KAAK,KAAK,IAAI3O,EAAQ,MAAK,GAO3B,KAAK,OAAO,IAAIA,EAAQ,OAAO,GAAG,CAAC,GAE/B2O,EAAK,UAAU,GAInB;AAAA,UAAIA,EAAK,UAAU,KAAKA,EAAK,cAAc,UAAUA,EAAK,GAAG,SAAS,QAAQ;AAC1E,YAAI,EAAC,IAAAxN,GAAI,MAAAsX,EAAI,IAAI9J,EAAK;AACtB,aAAK,KAAK,IAAI3O,EAAQ,MAAMmB,CAAE,GAC9B,KAAK,OAAO,IAAInB,EAAQ,OAAOyY,CAAI;AACnC;AAAA,MACH;AAED,UAAI9J,EAAK,UAAU,GAAG;AAClB,YAAI0I,IAAK1I,EAAK,IACV2I,IAAK3I,EAAK;AAEd,YAAI0I,aAAcrX,EAAQ,SAASsX,aAActX,EAAQ,OAAO;AAC5D,eAAK,KAAKqX,GACV,KAAK,OAAOmB,GAAK,YAAYnB,GAAIC,CAAE,GAC/B,KAAK,KAAK,IAAIiB,GAAS,KAAK,GAAG,GAAE,KAAK,GAAG,CAAC,CAAC,KAAK,KAChD,KAAK,KAAK;AAEd;AAAA,QACH;AAED,YAAIlB,aAAcrX,EAAQ,SAASsX,aAActX,EAAQ,QAAQ;AAC7D,cAAIA,EAAQ,MAAM,KAAKsX,EAAG,CAAC,KAAKtX,EAAQ,MAAM,KAAKsX,EAAG,CAAC;AACnD,kBAAMtX,EAAQ,OAAO;AAEzB,eAAK,KAAKqX,EAAG,SACb,KAAK,OAAOC,EAAG,SACf,KAAK,OAAO,KAAK,KAAK,UAAS,GAC3B,KAAK,KAAK,IAAIiB,GAAS,KAAK,GAAG,GAAE,KAAK,GAAG,CAAC,CAAC,KAAK,KAChD,KAAK,KAAK;AAEd;AAAA,QACH;AAED,YAAIlB,aAAcrX,EAAQ,UAAUsX,aAActX,EAAQ,OAAO;AAC7D,cAAIA,EAAQ,MAAM,KAAKqX,EAAG,CAAC,KAAKrX,EAAQ,MAAM,KAAKqX,EAAG,CAAC;AACnD,kBAAMrX,EAAQ,OAAO;AAEzB,eAAK,KAAKsX,EAAG,SACb,KAAK,OAAOD,EAAG,SACf,KAAK,OAAO,KAAK,KAAK,UAAS,GAC3B,KAAK,KAAK,IAAIkB,GAAS,KAAK,GAAG,GAAE,KAAK,GAAG,CAAC,CAAC,KAAK,KAChD,KAAK,KAAK;AAEd;AAAA,QACH;AAAA,MACJ;AAED,YAAMvY,EAAQ,OAAO;AAAA;AAAA,EACxB;AAAA,EAMD,QAAQ;AACJ,WAAO,IAAIA,EAAQ,KAAK,KAAK,IAAI,KAAK,IAAI;AAAA,EAC7C;AAAA,EAOD,IAAI,QAAQ;AAAA,EAAkB;AAAA,EAK9B,IAAI,MAAM;AAAA,EAAkB;AAAA,EAM5B,IAAI,SAAS;AAAC,WAAO,OAAO;AAAA,EAAkB;AAAA,EAM9C,IAAI,MAAM;AACN,WAAO,IAAIA,EAAQ;AAAA,MACf,OAAO;AAAA,MACP,OAAO;AAAA,MACP,OAAO;AAAA,MACP,OAAO;AAAA,IACV;AAAA,EACJ;AAAA,EAMD,IAAI,SAAS;AAAA,EAAiB;AAAA,EAM9B,IAAI,QAAQ;AAER,WADU,IAAIA,EAAQ,OAAO,KAAK,KAAK,GAAG,CAAC,KAAK,KAAK,CAAC,EAC3C;AAAA,EACd;AAAA,EAOD,IAAI,WAAW;AACX,QAAI0Y,IAAI,KAAK,KAAK,GACdC,IAAI,KAAK,KAAK,GACdC,IAAI,KAAK,KAAK,IAAI,KAAK,EAAE;AAE7B,WAAO,CAACF,GAAGC,GAAGC,CAAC;AAAA,EAClB;AAAA,EAOD,WAAWC,GAAY;AACnB,WAAO7Y,EAAQ,MAAM,KAAK,KAAK,KAAK,MAAM6Y,EAAW,IAAI,CAAC;AAAA,EAC7D;AAAA,EAOD,WAAWA,GAAY;AACnB,WAAO,KAAK,WAAWA,CAAU,KAAK,KAAK,GAAG,GAAGA,CAAU;AAAA,EAC9D;AAAA,EAOD,SAAS1X,GAAI;AACT,QAAI,KAAK,GAAG,QAAQA,CAAE;AAClB,aAAO;AAGX,QAAIyL,IAAM,IAAI5M,EAAQ,OAAO,KAAK,IAAImB,CAAE;AACxC,WAAOnB,EAAQ,MAAM,KAAK,KAAK,KAAK,IAAI4M,CAAG,CAAC;AAAA,EAC/C;AAAA,EAUD,MAAMzL,GAAI;AACN,WAAOoX,GAASpX,EAAG,GAAGA,EAAG,CAAC,EAAE,MAAM,KAAK,IAAI;AAAA,EAC9C;AAAA,EAOD,UAAUqN,GAAO;AACb,QAAIA,aAAiBxO,EAAQ;AACzB,aAAO,KAAK,SAASwO,CAAK,IAAI,CAACA,CAAK,IAAI;AAG5C,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOsK,GAAmB,MAAMkE,CAAK;AAGzC,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOkL,GAAqB,MAAMsD,CAAK;AAG3C,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOuL,GAAkB,MAAMiD,CAAK;AAGxC,QAAIA,aAAiBxO,EAAQ;AACzB,aAAO4L,GAAsB4C,GAAO,IAAI;AAG5C,QAAIA,aAAiBxO,EAAQ;AACzB,aAAO8L,GAAkB,MAAM0C,CAAK;AAGxC,QAAIA,aAAiBxO,EAAQ;AACzB,aAAQ8N,GAAsB,MAAMU,CAAK;AAAA,EAGhD;AAAA,EAQD,WAAWA,GAAO;AACd,QAAIA,aAAiBxO,EAAQ,OAAO;AAChC,UAAI,CAAC8Y,GAAUxM,CAAgB,IAAItM,EAAQ,SAAS,WAAWwO,GAAO,IAAI;AAC1E,aAAAlC,IAAmBA,EAAiB,WAC7B,CAACwM,GAAUxM,CAAgB;AAAA,IACrC;AAED,QAAIkC,aAAiBxO,EAAQ,QAAQ;AACjC,UAAI,CAAC8Y,GAAUxM,CAAgB,IAAItM,EAAQ,SAAS,YAAYwO,GAAO,IAAI;AAC3E,aAAAlC,IAAmBA,EAAiB,WAC7B,CAACwM,GAAUxM,CAAgB;AAAA,IACrC;AAED,QAAIkC,aAAiBxO,EAAQ,SAAS;AAClC,UAAI,CAAC8Y,GAAUxM,CAAgB,IAAItM,EAAQ,SAAS,aAAawO,GAAO,IAAI;AAC5E,aAAO,CAACsK,GAAUxM,EAAiB,QAAS,CAAA;AAAA,IAC/C;AAED,QAAIkC,aAAiBxO,EAAQ,KAAK;AAC9B,UAAI,CAAC8Y,GAAUxM,CAAgB,IAAItM,EAAQ,SAAS,SAASwO,GAAO,IAAI;AACxE,aAAO,CAACsK,GAAUxM,EAAiB,QAAS,CAAA;AAAA,IAC/C;AAED,QAAIkC,aAAiBxO,EAAQ,SAAS;AAClC,UAAI,CAAC8Y,GAAUxM,CAAgB,IAAItM,EAAQ,SAAS,cAAc,MAAMwO,CAAK;AAC7E,aAAO,CAACsK,GAAUxM,CAAgB;AAAA,IACrC;AAAA,EACJ;AAAA,EAQD,MAAMnL,GAAI;AACN,QAAIA,aAAcnB,EAAQ;AACtB,aAAO,CAAC,IAAIA,EAAQ,IAAImB,GAAI,KAAK,KAAK,OAAQ,CAAA,GAAG,IAAInB,EAAQ,IAAImB,GAAI,KAAK,IAAI,CAAC;AAE9E;AACD,UAAI0O,IAAY,IAAI7P,EAAQ,UAAU,CAAC,IAAI,CAAC,GACxC+Y,IAAgB,KAAK,WAAW5X,CAAE;AACtC,aAAA0O,EAAU,MAAMkJ,CAAa,GACtBlJ,EAAU;IACpB;AAAA,EACJ;AAAA,EAQD,WAAWyI,GAAK;AACZ,WAAOA,EAAI,MAAO,EAAC,KAAM,CAACU,GAAKC,MACvB,KAAK,MAAMD,CAAG,IAAI,KAAK,MAAMC,CAAG,IACzB,KAEP,KAAK,MAAMD,CAAG,IAAI,KAAK,MAAMC,CAAG,IACzB,IAEJ,CACV;AAAA,EACJ;AAAA,EAOD,SAAS;AACL,WAAO,OAAO,OAAO,CAAE,GAAE,MAAM,EAAC,MAAM,OAAM,CAAC;AAAA,EAChD;AAAA,EAOD,IAAIzN,GAAK2D,IAAQ,IAAI;AACjB,QAAIrN,IAAKyJ,GAAkB,MAAMC,CAAG;AACpC,QAAI1J,EAAG,WAAW;AACd,aAAO;AACX,QAAIgW,IAAKhW,EAAG,IACRiW,IAAKjW,EAAG,UAAU,IAAIA,EAAG,KAAKA,EAAG,KAAK,CAAAX,MAAM,CAACA,EAAG,QAAQ2W,CAAE,CAAC;AAC/D,WAAIC,MAAO,WAAWA,IAAKD,IACb,IAAI9X,EAAQ,QAAQ8X,GAAIC,CAAE,EACzB,IAAI5I,CAAK;AAAA,EAC3B;AAAA,EAED,OAAO,YAAY6J,GAAKC,GAAK;AACzB,QAAID,EAAI,QAAQC,CAAG;AACf,YAAMjZ,EAAQ,OAAO;AAIzB,WAFU,IAAIA,EAAQ,OAAOgZ,GAAKC,CAAG,EACtB,YACH;EACf;AACL;AACAjZ,EAAQ,OAAOwY;AAKf,MAAMrW,KAAO,IAAIwM,MAAS,IAAI3O,EAAQ,KAAK,GAAG2O,CAAI;AAClD3O,EAAQ,OAAOmC;AAUf,MAAM+W,GAAO;AAAA,EAMT,eAAevK,GAAM;AAYjB,QAPA,KAAK,KAAK,IAAI3O,EAAQ,MAAK,GAK3B,KAAK,IAAI,GAEL2O,EAAK,UAAU,KAAKA,EAAK,cAAc,UAAUA,EAAK,GAAG,SAAS,UAAU;AAC5E,UAAI,EAAC,IAAAwK,GAAI,GAAAhC,EAAC,IAAIxI,EAAK;AACnB,WAAK,KAAK,IAAI3O,EAAQ,MAAMmZ,CAAE,GAC9B,KAAK,IAAIhC;AACT;AAAA,IACZ,OAAe;AACH,UAAI,CAACgC,GAAIhC,CAAC,IAAI,CAAC,GAAGxI,CAAI;AACtB,MAAIwK,KAAMA,aAAcnZ,EAAQ,UAAO,KAAK,KAAKmZ,EAAG,UAChDhC,MAAM,WAAW,KAAK,IAAIA;AAC9B;AAAA,IACH;AAAA,EAGJ;AAAA,EAMD,QAAQ;AACJ,WAAO,IAAInX,EAAQ,OAAO,KAAK,GAAG,MAAO,GAAE,KAAK,CAAC;AAAA,EACpD;AAAA,EAMD,IAAI,SAAS;AACT,WAAO,KAAK;AAAA,EACf;AAAA,EAMD,IAAI,MAAM;AACN,WAAO,IAAIA,EAAQ;AAAA,MACf,KAAK,GAAG,IAAI,KAAK;AAAA,MACjB,KAAK,GAAG,IAAI,KAAK;AAAA,MACjB,KAAK,GAAG,IAAI,KAAK;AAAA,MACjB,KAAK,GAAG,IAAI,KAAK;AAAA,IAC7B;AAAA,EACK;AAAA,EAOD,SAASwO,GAAO;AACZ,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOA,EAAQ,MAAM,GAAGwO,EAAM,WAAW,KAAK,MAAM,EAAE,IAAI,KAAK,CAAC;AAGpE,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOA,EAAQ,MAAM,GAAGwO,EAAM,MAAM,WAAW,KAAK,MAAM,EAAE,IAAI,KAAK,CAAC,KAClExO,EAAQ,MAAM,GAAGwO,EAAM,IAAI,WAAW,KAAK,MAAM,EAAE,IAAI,KAAK,CAAC;AAGrE,QAAIA,aAAiBxO,EAAQ;AACzB,aAAO,KAAK,UAAUwO,CAAK,EAAE,WAAW,KACpCxO,EAAQ,MAAM,GAAGwO,EAAM,MAAM,WAAW,KAAK,MAAM,EAAE,IAAI,KAAK,CAAC,KAC/DxO,EAAQ,MAAM,GAAGwO,EAAM,IAAI,WAAW,KAAK,MAAM,EAAE,IAAI,KAAK,CAAC;AAGrE,QAAIA,aAAiBxO,EAAQ;AACzB,aAAO,KAAK,UAAUwO,CAAK,EAAE,WAAW,KACpCxO,EAAQ,MAAM,GAAGwO,EAAM,GAAG,KAAK,CAAC,KAChCxO,EAAQ,MAAM,GAAGwO,EAAM,OAAO,WAAW,KAAK,MAAM,EAAE,IAAI,KAAK,CAAC;AAAA,EAI3E;AAAA,EAOD,MAAM4K,IAAmB,IAAM;AAC3B,WAAO,IAAIpZ,EAAQ,IAAI,KAAK,QAAQ,KAAK,GAAG,KAAK,IAAI,CAAC,KAAK,IAAIoZ,CAAgB;AAAA,EAClF;AAAA,EAOD,UAAU5K,GAAO;AACb,QAAIA,aAAiBxO,EAAQ;AACzB,aAAO,KAAK,SAASwO,CAAK,IAAI,CAACA,CAAK,IAAI;AAE5C,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOkL,GAAqBsD,GAAO,IAAI;AAG3C,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOqM,GAAwBmC,GAAO,IAAI;AAG9C,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOyM,GAAuB+B,GAAO,IAAI;AAG7C,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOkN,GAAoB,MAAMsB,CAAK;AAG1C,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOsN,GAAoBkB,GAAO,IAAI;AAE1C,QAAIA,aAAiBxO,EAAQ;AACzB,aAAO+N,GAAwB,MAAMS,CAAK;AAAA,EAEjD;AAAA,EASD,WAAWA,GAAO;AACd,QAAIA,aAAiBxO,EAAQ,OAAO;AAChC,UAAI,CAAC8Y,GAAUxM,CAAgB,IAAItM,EAAQ,SAAS,aAAawO,GAAO,IAAI;AAC5E,aAAAlC,IAAmBA,EAAiB,WAC7B,CAACwM,GAAUxM,CAAgB;AAAA,IACrC;AAED,QAAIkC,aAAiBxO,EAAQ,QAAQ;AACjC,UAAI,CAAC8Y,GAAUxM,CAAgB,IAAItM,EAAQ,SAAS,cAAc,MAAMwO,CAAK;AAC7E,aAAO,CAACsK,GAAUxM,CAAgB;AAAA,IACrC;AAED,QAAIkC,aAAiBxO,EAAQ,MAAM;AAC/B,UAAI,CAAC8Y,GAAUxM,CAAgB,IAAItM,EAAQ,SAAS,YAAY,MAAMwO,CAAK;AAC3E,aAAO,CAACsK,GAAUxM,CAAgB;AAAA,IACrC;AAED,QAAIkC,aAAiBxO,EAAQ,SAAS;AAClC,UAAI,CAAC8Y,GAAUxM,CAAgB,IAAItM,EAAQ,SAAS,eAAewO,GAAO,IAAI;AAC9E,aAAAlC,IAAmBA,EAAiB,WAC7B,CAACwM,GAAUxM,CAAgB;AAAA,IACrC;AAED,QAAIkC,aAAiBxO,EAAQ,KAAK;AAC9B,UAAI,CAAC8Y,GAAUxM,CAAgB,IAAItM,EAAQ,SAAS,WAAWwO,GAAO,IAAI;AAC1E,aAAAlC,IAAmBA,EAAiB,WAC7B,CAACwM,GAAUxM,CAAgB;AAAA,IACrC;AAED,QAAIkC,aAAiBxO,EAAQ,SAAS;AAClC,UAAI,CAAC8Y,GAAUxM,CAAgB,IAAItM,EAAQ,SAAS,cAAc,MAAMwO,CAAK;AAC7E,aAAO,CAACsK,GAAUxM,CAAgB;AAAA,IACrC;AAED,QAAIkC,aAAiBxO,EAAQ,WAAW;AACpC,UAAI,CAACyI,GAAM6D,CAAgB,IAAItM,EAAQ,SAAS,gBAAgB,MAAMwO,CAAK;AAC3E,aAAO,CAAC/F,GAAM6D,CAAgB;AAAA,IACjC;AAAA,EACJ;AAAA,EAOD,SAAS;AACL,WAAO,OAAO,OAAO,CAAE,GAAE,MAAM,EAAC,MAAM,SAAQ,CAAC;AAAA,EAClD;AAAA,EASD,IAAI6C,IAAQ,IAAI;AACZ,QAAI,EAAC,QAAAC,GAAQ,aAAAC,GAAa,MAAAC,GAAM,aAAAE,GAAa,IAAAnO,GAAI,WAAAoO,EAAS,IAAIN,GAE1DO,IAAUrO,KAAMA,EAAG,SAAS,IAAK,OAAOA,OAAQ,IAChDsO,IAAaF,KAAaA,EAAU,SAAS,IAAK,UAAUA,OAAe;AAE/E,WAAO;AAAA,cAAiB,KAAK,GAAG,UAAU,KAAK,GAAG,SAAS,KAAK,cAAcL,KAAU,0BAA0BC,KAAe,YAAYC,KAAQ,yBAAyBE,KAAe,MAAQE,KAAUC;AAAA,EAClN;AAEL;AACA3P,EAAQ,SAASkZ;AAKjB,MAAM/N,KAAS,IAAIwD,MAAS,IAAI3O,EAAQ,OAAO,GAAG2O,CAAI;AACtD3O,EAAQ,SAASmL;AAUjB,MAAMkO,GAAI;AAAA,EASN,eAAe1K,GAAM;AA2BjB,QAtBA,KAAK,KAAK,IAAI3O,EAAQ,MAAK,GAK3B,KAAK,IAAI,GAKT,KAAK,aAAa,GAKlB,KAAK,WAAW,IAAI,KAAK,IAKzB,KAAK,mBAAmBA,EAAQ,KAE5B2O,EAAK,UAAU;AAGnB,UAAIA,EAAK,UAAU,KAAKA,EAAK,cAAc,UAAUA,EAAK,GAAG,SAAS,OAAO;AACzE,YAAI,EAAC,IAAAwK,GAAI,GAAAhC,GAAG,YAAAmC,GAAY,UAAAC,GAAU,kBAAAC,EAAgB,IAAI7K,EAAK;AAC3D,aAAK,KAAK,IAAI3O,EAAQ,MAAMmZ,EAAG,GAAGA,EAAG,CAAC,GACtC,KAAK,IAAIhC,GACT,KAAK,aAAamC,GAClB,KAAK,WAAWC,GAChB,KAAK,mBAAmBC;AACxB;AAAA,MACZ,OAAe;AACH,YAAI,CAACL,GAAIhC,GAAGmC,GAAYC,GAAUC,CAAgB,IAAI,CAAC,GAAG7K,CAAI;AAC9D,QAAIwK,KAAMA,aAAcnZ,EAAQ,UAAO,KAAK,KAAKmZ,EAAG,UAChDhC,MAAM,WAAW,KAAK,IAAIA,IAC1BmC,MAAe,WAAW,KAAK,aAAaA,IAC5CC,MAAa,WAAW,KAAK,WAAWA,IACxCC,MAAqB,WAAW,KAAK,mBAAmBA;AAC5D;AAAA,MACH;AAAA,EAGJ;AAAA,EAMD,QAAQ;AACJ,WAAO,IAAIxZ,EAAQ,IAAI,KAAK,GAAG,MAAK,GAAI,KAAK,GAAG,KAAK,YAAY,KAAK,UAAU,KAAK,gBAAgB;AAAA,EACxG;AAAA,EAMD,IAAI,QAAQ;AACR,QAAIA,EAAQ,MAAM,GAAG,KAAK,YAAY,KAAK,QAAQ;AAC/C,aAAO;AACX,QAAIA,EAAQ,MAAM,GAAG,KAAK,IAAI,KAAK,aAAa,KAAK,QAAQ,GAAGA,EAAQ,IAAI;AACxE,aAAOA,EAAQ;AAEnB,QAAIyZ;AACJ,WAAI,KAAK,mBACLA,IAAQzZ,EAAQ,MAAM,GAAG,KAAK,UAAU,KAAK,UAAU,IACnD,KAAK,WAAW,KAAK,aAAa,KAAK,WAAW,KAAK,aAAaA,EAAQ,OAEhFyZ,IAAQzZ,EAAQ,MAAM,GAAG,KAAK,YAAY,KAAK,QAAQ,IACnD,KAAK,aAAa,KAAK,WAAW,KAAK,aAAa,KAAK,WAAWA,EAAQ,MAGhFA,EAAQ,MAAM,GAAGyZ,GAAOzZ,EAAQ,IAAI,MACpCyZ,KAASzZ,EAAQ,OAEjBA,EAAQ,MAAM,GAAGyZ,GAAO,CAAC,MACzBA,KAASzZ,EAAQ,OAEdyZ;AAAA,EACV;AAAA,EAMD,IAAI,QAAQ;AAER,WADS,IAAIzZ,EAAQ,MAAM,KAAK,GAAG,IAAI,KAAK,GAAG,KAAK,GAAG,CAAC,EAC9C,OAAO,KAAK,YAAY,KAAK,EAAE;AAAA,EAC5C;AAAA,EAMD,IAAI,MAAM;AAEN,WADS,IAAIA,EAAQ,MAAM,KAAK,GAAG,IAAI,KAAK,GAAG,KAAK,GAAG,CAAC,EAC9C,OAAO,KAAK,UAAU,KAAK,EAAE;AAAA,EAC1C;AAAA,EAMD,IAAI,SAAS;AACT,WAAO,KAAK,GAAG;EAClB;AAAA,EAED,IAAI,WAAW;AACX,WAAO,CAAC,KAAK,MAAM,MAAK,GAAI,KAAK,IAAI,MAAK,CAAE;AAAA,EAC/C;AAAA,EAMD,IAAI,SAAS;AACT,WAAO,KAAK,IAAI,KAAK,QAAQ,KAAK,CAAC;AAAA,EACtC;AAAA,EAMD,IAAI,MAAM;AAEN,QAAIwL,IADY,KAAK,oBACD,OAAO,CAACoD,GAAK7C,MAAQ6C,EAAI,MAAM7C,EAAI,MAAM,GAAG,GAAG,IAAI/L,EAAQ,IAAG,CAAE;AACpF,WAAAwL,IAAMA,EAAI,MAAM,KAAK,IAAI,GAAG,GACrBA;AAAA,EACV;AAAA,EAOD,SAASrK,GAAI;AAET,QAAI,CAACnB,EAAQ,MAAM,GAAG,KAAK,GAAG,WAAWmB,CAAE,EAAE,IAAI,KAAK,CAAC;AACnD,aAAO;AAIX,QAAIA,EAAG,QAAQ,KAAK,KAAK;AACrB,aAAO;AAEX,QAAI6N,IAAQ,IAAIhP,EAAQ,OAAO,KAAK,IAAImB,CAAE,EAAE,OACxCuY,IAAW,IAAI1Z,EAAQ,IAAI,KAAK,IAAI,KAAK,GAAG,KAAK,YAAYgP,GAAO,KAAK,gBAAgB;AAC7F,WAAOhP,EAAQ,MAAM,GAAG0Z,EAAS,QAAQ,KAAK,MAAM;AAAA,EACvD;AAAA,EASD,MAAMvY,GAAI;AACN,QAAI,KAAK,MAAM,QAAQA,CAAE;AACrB,aAAO,CAAC,MAAM,KAAK,MAAO,CAAA;AAE9B,QAAI,KAAK,IAAI,QAAQA,CAAE;AACnB,aAAO,CAAC,KAAK,MAAO,GAAE,IAAI;AAE9B,QAAI6N,IAAQ,IAAIhP,EAAQ,OAAO,KAAK,IAAImB,CAAE,EAAE;AAE5C,WAAO;AAAA,MACH,IAAInB,EAAQ,IAAI,KAAK,IAAI,KAAK,GAAG,KAAK,YAAYgP,GAAO,KAAK,gBAAgB;AAAA,MAC9E,IAAIhP,EAAQ,IAAI,KAAK,IAAI,KAAK,GAAGgP,GAAO,KAAK,UAAU,KAAK,gBAAgB;AAAA,IAC/E;AAAA,EACJ;AAAA,EAMD,SAAS;AACL,QAAIuK,IAAW,KAAK,mBAAmB,KAAK,aAAa,KAAK,QAAQ,IAAI,KAAK,aAAa,KAAK,QAAQ;AAEzG,WADU,IAAIvZ,EAAQ,IAAI,KAAK,IAAI,KAAK,GAAG,KAAK,YAAYuZ,GAAU,KAAK,gBAAgB,EAChF;AAAA,EACd;AAAA,EAOD,cAAcvB,GAAQ;AAClB,QAAIA,IAAS,KAAK,UAAUA,IAAS;AAAG,aAAO;AAC/C,QAAIA,KAAU;AAAG,aAAO,KAAK;AAC7B,QAAIA,KAAU,KAAK;AAAQ,aAAO,KAAK;AACvC,QAAIC,IAASD,IAAS,KAAK,QACvBuB,IAAW,KAAK,mBAAmB,KAAK,aAAa,KAAK,QAAQtB,IAAS,KAAK,aAAa,KAAK,QAAQA;AAE9G,WADU,IAAIjY,EAAQ,IAAI,KAAK,IAAI,KAAK,GAAG,KAAK,YAAYuZ,GAAU,KAAK,gBAAgB,EAChF;AAAA,EACd;AAAA,EAMD,cAAc;AACV,YAAQ,IAAM,KAAK,IAAI,KAAK,IAAI,KAAK,QAAQ,CAAG,CAAC,KAAK,KAAK;AAAA,EAC9D;AAAA,EAOD,UAAU/K,GAAO;AACb,QAAIA,aAAiBxO,EAAQ;AACzB,aAAO,KAAK,SAASwO,CAAK,IAAI,CAACA,CAAK,IAAI;AAE5C,QAAIA,aAAiBxO,EAAQ;AACzB,aAAO8L,GAAkB0C,GAAO,IAAI;AAExC,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOsN,GAAoB,MAAMkB,CAAK;AAE1C,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOuM,GAAqBiC,GAAO,IAAI;AAE3C,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOuN,GAAiB,MAAMiB,CAAK;AAEvC,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOmN,GAAiB,MAAMqB,CAAK;AAEvC,QAAIA,aAAiBxO,EAAQ;AACzB,aAAO6N,GAAqB,MAAMW,CAAK;AAAA,EAE9C;AAAA,EASD,WAAWA,GAAO;AACd,QAAIA,aAAiBxO,EAAQ,OAAO;AAChC,UAAI,CAACyI,GAAM6D,CAAgB,IAAItM,EAAQ,SAAS,UAAUwO,GAAO,IAAI;AACrE,aAAAlC,IAAmBA,EAAiB,WAC7B,CAAC7D,GAAM6D,CAAgB;AAAA,IACjC;AAED,QAAIkC,aAAiBxO,EAAQ,QAAQ;AACjC,UAAI,CAACyI,GAAM6D,CAAgB,IAAItM,EAAQ,SAAS,WAAW,MAAMwO,CAAK;AACtE,aAAO,CAAC/F,GAAM6D,CAAgB;AAAA,IACjC;AAED,QAAIkC,aAAiBxO,EAAQ,MAAM;AAC/B,UAAI,CAACyI,GAAM6D,CAAgB,IAAItM,EAAQ,SAAS,SAAS,MAAMwO,CAAK;AACpE,aAAO,CAAC/F,GAAM6D,CAAgB;AAAA,IACjC;AAED,QAAIkC,aAAiBxO,EAAQ,SAAS;AAClC,UAAI,CAACyI,GAAM6D,CAAgB,IAAItM,EAAQ,SAAS,YAAYwO,GAAO,IAAI;AACvE,aAAAlC,IAAmBA,EAAiB,WAC7B,CAAC7D,GAAM6D,CAAgB;AAAA,IACjC;AAED,QAAIkC,aAAiBxO,EAAQ,KAAK;AAC9B,UAAI,CAACyI,GAAM6D,CAAgB,IAAItM,EAAQ,SAAS,QAAQ,MAAMwO,CAAK;AACnE,aAAO,CAAC/F,GAAM6D,CAAgB;AAAA,IACjC;AAED,QAAIkC,aAAiBxO,EAAQ,SAAS;AAClC,UAAI,CAACyI,GAAM6D,CAAgB,IAAItM,EAAQ,SAAS,cAAc,MAAMwO,CAAK;AACzE,aAAO,CAAC/F,GAAM6D,CAAgB;AAAA,IACjC;AAED,QAAIkC,aAAiBxO,EAAQ,WAAW;AACpC,UAAI,CAACyI,GAAM6D,CAAgB,IAAItM,EAAQ,SAAS,gBAAgB,MAAMwO,CAAK;AAC3E,aAAO,CAAC/F,GAAM6D,CAAgB;AAAA,IACjC;AAAA,EACJ;AAAA,EAMD,oBAAoB;AAChB,QAAIqN,IAAkB,CAAA,GAClBC,IAAS,CAAC,GAAG,KAAK,KAAK,GAAG,IAAI,KAAK,KAAK,GAAG,IAAI,KAAK,KAAK,CAAC,GAC1DtB,IAAM;AAAA,MACN,KAAK,GAAG,UAAU,KAAK,GAAG,CAAC;AAAA,MAC3B,KAAK,GAAG,UAAU,GAAG,KAAK,CAAC;AAAA,MAC3B,KAAK,GAAG,UAAU,CAAC,KAAK,GAAG,CAAC;AAAA,MAC5B,KAAK,GAAG,UAAU,GAAG,CAAC,KAAK,CAAC;AAAA,IACxC,GAIYuB,IAAY,CAAA;AAChB,aAASjX,IAAI,GAAGA,IAAI,GAAGA;AACnB,MAAI0V,EAAI1V,GAAG,GAAG,IAAI,KACdiX,EAAU,KAAK,IAAI7Z,EAAQ,IAAI,KAAK,IAAI,KAAK,GAAG,KAAK,YAAY4Z,EAAOhX,IAAI,KAAK,gBAAgB,CAAC;AAI1G,QAAIiX,EAAU,UAAU;AACpB,MAAAF,EAAgB,KAAK,KAAK,MAAO,CAAA;AAAA,SAC9B;AAEH,MAAAE,EAAU,KAAK,CAACzM,GAAMC,MAASD,EAAK,SAASC,EAAK,MAAM;AAExD,eAASzK,IAAI,GAAGA,IAAIiX,EAAU,QAAQjX,KAAK;AACvC,YAAIkX,IAAWH,EAAgB,SAAS,IAAIA,EAAgBA,EAAgB,SAAS,KAAK,QACtFI;AACJ,QAAID,IACAC,IAAU,IAAI/Z,EAAQ,IAAI,KAAK,IAAI,KAAK,GAAG8Z,EAAS,UAAUD,EAAUjX,GAAG,UAAU,KAAK,gBAAgB,IAE1GmX,IAAU,IAAI/Z,EAAQ,IAAI,KAAK,IAAI,KAAK,GAAG,KAAK,YAAY6Z,EAAUjX,GAAG,UAAU,KAAK,gBAAgB,GAEvG5C,EAAQ,MAAM,KAAK+Z,EAAQ,MAAM,KAClCJ,EAAgB,KAAKI,EAAQ,MAAO,CAAA;AAAA,MAE3C;AAGD,UAAID,IAAWH,EAAgB,SAAS,IAAIA,EAAgBA,EAAgB,SAAS,KAAK,QACtFI;AACJ,MAAID,IACAC,IAAU,IAAI/Z,EAAQ,IAAI,KAAK,IAAI,KAAK,GAAG8Z,EAAS,UAAU,KAAK,UAAU,KAAK,gBAAgB,IAElGC,IAAU,IAAI/Z,EAAQ,IAAI,KAAK,IAAI,KAAK,GAAG,KAAK,YAAY,KAAK,UAAU,KAAK,gBAAgB,GAGhG,CAACA,EAAQ,MAAM,KAAK+Z,EAAQ,MAAM,KAAK,CAAC/Z,EAAQ,MAAM,GAAG+Z,EAAQ,OAAO,IAAE,KAAK,EAAE,KACjFJ,EAAgB,KAAKI,EAAQ,MAAO,CAAA;AAAA,IAE3C;AACD,WAAOJ;AAAA,EACV;AAAA,EAMD,iBAAiB;AACb,QAAI/M,IAAM,IAAI5M,EAAQ,OAAO,KAAK,IAAI,KAAK,KAAK,GAC5CgP,IAAQ,KAAK,mBAAmB,KAAK,KAAK,IAAK,CAAC,KAAK,KAAK;AAE9D,WADcpC,EAAI,OAAOoC,CAAK,EAAE,UAAS;AAAA,EAE5C;AAAA,EAMD,eAAe;AACX,QAAIpC,IAAM,IAAI5M,EAAQ,OAAO,KAAK,IAAI,KAAK,GAAG,GAC1CgP,IAAQ,KAAK,mBAAmB,CAAC,KAAK,KAAK,IAAK,KAAK,KAAK;AAE9D,WADcpC,EAAI,OAAOoC,CAAK,EAAE,UAAS;AAAA,EAE5C;AAAA,EAMD,UAAU;AACN,WAAO,IAAIhP,EAAQ,IAAI,KAAK,IAAI,KAAK,GAAG,KAAK,UAAU,KAAK,YAAY,CAAC,KAAK,gBAAgB;AAAA,EACjG;AAAA,EAOD,aAAa2O,GAAM;AACf,QAAI5C,IAAM,KAAK;AACf,WAAAA,EAAI,KAAK,KAAK,GAAG,UAAU,GAAG4C,CAAI,GAC3B5C;AAAA,EACV;AAAA,EAUD,OAAOiD,IAAQ,GAAGC,IAAS,IAAIjP,EAAQ,SAAS;AAC5C,QAAI+W,IAAI,IAAI/W,EAAQ;AACpB,WAAA+W,IAAIA,EAAE,UAAU9H,EAAO,GAAGA,EAAO,CAAC,EAAE,OAAOD,CAAK,EAAE,UAAU,CAACC,EAAO,GAAG,CAACA,EAAO,CAAC,GACzE,KAAK,UAAU8H,CAAC;AAAA,EAC1B;AAAA,EAQD,MAAMiD,IAAS,GAAGC,IAAS,GAAG;AAC1B,QAAIlD,IAAI,IAAI/W,EAAQ;AACpB,WAAA+W,IAAIA,EAAE,MAAMiD,GAAQC,CAAM,GACnB,KAAK,UAAUlD,CAAC;AAAA,EAC1B;AAAA,EAWD,UAAU7H,IAAS,IAAIlP,EAAQ,OAAM,GAAI;AACrC,QAAIka,IAAW,KAAK,MAAM,UAAUhL,CAAM,GACtCiL,IAAS,KAAK,IAAI,UAAUjL,CAAM,GAClCkL,IAAY,KAAK,GAAG,UAAUlL,CAAM,GACpCmL,IAAe,KAAK;AACxB,WAAInL,EAAO,IAAIA,EAAO,IAAI,MACxBmL,IAAe,CAACA,IAERra,EAAQ,IAAI,MAAMoa,GAAWF,GAAUC,GAAQE,CAAY;AAAA,EAExE;AAAA,EAED,OAAO,MAAMpL,GAAQxO,GAAOC,GAAK8Y,GAAkB;AAC/C,QAAI,EAAC,QAAAvG,EAAM,IAAIjT,GACXsZ,IAAarG,EAAOhE,GAAQxO,CAAK,EAAE,OACnC8Y,IAAWtG,EAAOhE,GAAQvO,CAAG,EAAE;AACnC,IAAIV,EAAQ,MAAM,GAAGsZ,GAAYC,CAAQ,MACrCA,KAAY,IAAI,KAAK,IACrBC,IAAmB;AAEvB,QAAIrC,IAAIlE,EAAOhE,GAAQxO,CAAK,EAAE;AAE9B,WAAO,IAAIT,EAAQ,IAAIiP,GAAQkI,GAAGmC,GAAYC,GAAUC,CAAgB;AAAA,EAC3E;AAAA,EAED,iBAAiBrB,IAAO,GAAG;AAGvB,WAFa,KAAK,oBACA,OAAO,CAACvJ,GAAK7C,MAAQ6C,IAAM7C,EAAI,gCAAgCoM,CAAI,GAAG,CAAG;AAAA,EAE9F;AAAA,EAED,gCAAgCA,GAAM;AAClC,QAAIhW,IAAO,IAAInC,EAAQ,KAAK,KAAK,OAAO,KAAK,GAAG,GAC5Csa,IAAa,KAAK,GAAG,OAAOnY,CAAI,GAEhCoY,IADU,IAAIva,EAAQ,QAAQ,KAAK,OAAO,KAAK,GAAG,EAC7B,iBAAiBmY,CAAI,GAC1CqC,IAAsB,KAAK;AAE/B,WADWF,IAAaC,IAAaC,IAAsBD,IAAaC;AAAA,EAE3E;AAAA,EAED,sBAAsB;AAClB,WAAQ,MAAM,KAAK,IAAI,KAAK,KAAK,KAAK,QAAQ,KAAK,IAAI,KAAK,KAAK;AAAA,EACpE;AAAA,EAOD,WAAWlC,GAAK;AACZ,QAAI,EAAC,QAAArF,EAAM,IAAIjT;AACf,WAAOsY,EAAI,MAAO,EAAC,KAAM,CAACU,GAAKC,MAAQ;AACnC,UAAIwB,IAASxH,EAAO,KAAK,IAAI+F,CAAG,EAAE,OAC9B0B,IAASzH,EAAO,KAAK,IAAIgG,CAAG,EAAE;AAClC,aAAIwB,IAASC,IACF,KAEPD,IAASC,IACF,IAEJ;AAAA,IACnB,CAAS;AAAA,EACJ;AAAA,EAOD,SAAS;AACL,WAAO,OAAO,OAAO,CAAE,GAAE,MAAM,EAAC,MAAM,MAAK,CAAC;AAAA,EAC/C;AAAA,EASD,IAAIvL,IAAQ,IAAI;AACZ,QAAIwL,IAAe,KAAK,SAAS,KAAK,KAAK,MAAM,KAC7CC,IAAY,KAAK,mBAAmB,MAAM,KAC1C,EAAC,QAAAxL,GAAQ,aAAAC,GAAa,MAAAC,GAAM,IAAAjO,GAAI,WAAAoO,EAAS,IAAIN,GAE7CO,IAAUrO,KAAMA,EAAG,SAAS,IAAK,OAAOA,OAAQ,IAChDsO,IAAaF,KAAaA,EAAU,SAAS,IAAK,UAAUA,OAAe;AAE/E,WAAIzP,EAAQ,MAAM,GAAG,KAAK,OAAO,IAAI,KAAK,EAAE,IAC3B,IAAIA,EAAQ,OAAO,KAAK,IAAI,KAAK,CAAC,EACjC,IAAImP,CAAK,IAEhB;AAAA,YAAe,KAAK,MAAM,KAAK,KAAK,MAAM;AAAA,gCAC7B,KAAK,KAAK,KAAK,OAAOwL,KAAgBC,KAAa,KAAK,IAAI,KAAK,KAAK,IAAI;AAAA,8BAC5ExL,KAAU,0BAA0BC,KAAe,YAAYC,KAAQ,WAAWI,KAAUC;AAAA,EAErH;AAEL;AACA3P,EAAQ,MAAMqZ;AAKd,MAAMtN,KAAM,IAAI4C,MAAS,IAAI3O,EAAQ,IAAI,GAAG2O,CAAI;AAChD3O,EAAQ,MAAM+L;AAUd,MAAM8O,GAAI;AAAA,EAQN,YAAYC,IAAO,QAAW3C,IAAO,QAAW4C,IAAO,QAAWC,IAAO,QAAW;AAKhF,SAAK,OAAOF,GAKZ,KAAK,OAAO3C,GAKZ,KAAK,OAAO4C,GAKZ,KAAK,OAAOC;AAAA,EACf;AAAA,EAMD,QAAQ;AACJ,WAAO,IAAIH,GAAI,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK,IAAI;AAAA,EAC5D;AAAA,EAMD,IAAI,MAAM;AACN,WAAO,IAAI7a,EAAQ,MAAM,KAAK,MAAM,KAAK,IAAI;AAAA,EAChD;AAAA,EAMD,IAAI,OAAO;AACP,WAAO,IAAIA,EAAQ,MAAM,KAAK,MAAM,KAAK,IAAI;AAAA,EAChD;AAAA,EAMD,IAAI,MAAM;AACN,WAAO,KAAK;EACf;AAAA,EAMD,IAAI,SAAS;AACT,WAAO,IAAIA,EAAQ,OAAO,KAAK,OAAO,KAAK,QAAQ,IAAI,KAAK,OAAO,KAAK,QAAQ,CAAC;AAAA,EACpF;AAAA,EAMD,IAAI,QAAQ;AACR,WAAO,KAAK,IAAI,KAAK,OAAO,KAAK,IAAI;AAAA,EACxC;AAAA,EAMD,IAAI,SAAS;AACT,WAAO,KAAK,IAAI,KAAK,OAAO,KAAK,IAAI;AAAA,EACxC;AAAA,EAMD,IAAI,MAAM;AACN,WAAO,KAAK;EACf;AAAA,EAOD,cAAcib,GAAW;AACrB,WACI,KAAK,OAAOA,EAAU,QACtB,KAAK,OAAOA,EAAU,QACtB,KAAK,OAAOA,EAAU,QACtB,KAAK,OAAOA,EAAU;AAAA,EAE7B;AAAA,EAOD,UAAUA,GAAW;AACjB,WAAO,CAAC,KAAK,cAAcA,CAAS;AAAA,EACvC;AAAA,EAOD,MAAMA,GAAW;AACb,WAAO,IAAIJ;AAAA,MACP,KAAK,SAAS,SAAYI,EAAU,OAAO,KAAK,IAAI,KAAK,MAAMA,EAAU,IAAI;AAAA,MAC7E,KAAK,SAAS,SAAYA,EAAU,OAAO,KAAK,IAAI,KAAK,MAAMA,EAAU,IAAI;AAAA,MAC7E,KAAK,SAAS,SAAYA,EAAU,OAAO,KAAK,IAAI,KAAK,MAAMA,EAAU,IAAI;AAAA,MAC7E,KAAK,SAAS,SAAYA,EAAU,OAAO,KAAK,IAAI,KAAK,MAAMA,EAAU,IAAI;AAAA,IACzF;AAAA,EACK;AAAA,EAOD,UAAUA,GAAW;AAGjB,WAFI,QAAK,IAAI,SAASA,EAAU,GAAG,KAE/B,KAAK,IAAI,QAAQA,EAAU,GAAG,KAAK,KAAK,KAAK,SAASA,EAAU,IAAI;AAAA,EAG3E;AAAA,EAOD,SAASA,GAAW;AAChB,WAAQ,KAAK,IAAI,QAAQA,EAAU,GAAG,KAAK,KAAK,KAAK,QAAQA,EAAU,IAAI;AAAA,EAC9E;AAAA,EAED,SAAS;AACL,WAAO,KAAK;EACf;AAAA,EAED,OAAO,eAAeC,GAAMC,GAAM;AAE9B,WAAOD,EAAK,MAAMC,CAAI;AAAA,EACzB;AAAA,EAED,OAAO,qBAAqBnC,GAAKC,GAAK;AAClC,WAAOD,EAAI,SAASC,CAAG;AAAA,EAC1B;AAAA,EASD,IAAI6B,GAAM3C,GAAM4C,GAAMC,GAAM;AACxB,SAAK,OAAOF,GACZ,KAAK,OAAO3C,GACZ,KAAK,OAAO4C,GACZ,KAAK,OAAOC;AAAA,EACf;AAAA,EAMD,WAAW;AACP,WAAO;AAAA,MACH,IAAIhb,EAAQ,MAAM,KAAK,MAAM,KAAK,IAAI;AAAA,MACtC,IAAIA,EAAQ,MAAM,KAAK,MAAM,KAAK,IAAI;AAAA,MACtC,IAAIA,EAAQ,MAAM,KAAK,MAAM,KAAK,IAAI;AAAA,MACtC,IAAIA,EAAQ,MAAM,KAAK,MAAM,KAAK,IAAI;AAAA,IAClD;AAAA,EACK;AAAA,EAMD,aAAa;AACT,QAAIsY,IAAM,KAAK;AACf,WAAO;AAAA,MACH,IAAItY,EAAQ,QAAQsY,EAAI,IAAIA,EAAI,EAAE;AAAA,MAClC,IAAItY,EAAQ,QAAQsY,EAAI,IAAIA,EAAI,EAAE;AAAA,MAClC,IAAItY,EAAQ,QAAQsY,EAAI,IAAIA,EAAI,EAAE;AAAA,MAClC,IAAItY,EAAQ,QAAQsY,EAAI,IAAIA,EAAI,EAAE;AAAA,IAC9C;AAAA,EACK;AAAA,EASD,IAAInJ,IAAQ,IAAI;AACZ,QAAI,EAAC,QAAAC,GAAQ,aAAAC,GAAa,MAAAC,GAAM,IAAAjO,GAAI,WAAAoO,EAAS,IAAIN,GAE7CO,IAAUrO,KAAMA,EAAG,SAAS,IAAK,OAAOA,OAAQ,IAChDsO,IAAaF,KAAaA,EAAU,SAAS,IAAK,UAAUA,OAAe,IAC3E2L,IAAQ,KAAK,OAAO,KAAK,MACzB/E,IAAS,KAAK,OAAO,KAAK;AAE9B,WAAO;AAAA,WAAc,KAAK,YAAY,KAAK,eAAe+E,YAAgB/E,aAAkBjH,KAAU,0BAA0BC,KAAe,YAAYC,KAAQ,WAAWI,KAAUC;AAAA,EAC3L;AACL;AACA3P,EAAQ,MAAM6a;AAMd,MAAMrP,KAAM,IAAImD,MAAS,IAAI3O,EAAQ,IAAI,GAAG2O,CAAI;AAChD3O,EAAQ,MAAMwL;AAYd,MAAM6P,GAAK;AAAA,EAKP,YAAY7M,GAAO;AAKf,SAAK,QAAQA,GAKb,KAAK,OAAO,QAKZ,KAAK,OAAO,QAKZ,KAAK,OAAO,QAKZ,KAAK,aAAa,GAKlB,KAAK,UAAU,QAKf,KAAK,QAAQ,QAKb,KAAK,KAAK,QAKV,KAAK,UAAU;AAAA,EAClB;AAAA,EAKD,IAAI,QAAQ;AACR,WAAO,KAAK,MAAM;AAAA,EACrB;AAAA,EAKD,IAAI,MAAM;AACN,WAAO,KAAK,MAAM;AAAA,EACrB;AAAA,EAKD,IAAI,SAAS;AACT,WAAO,KAAK,MAAM;AAAA,EACrB;AAAA,EAMD,IAAI,MAAM;AACN,WAAO,KAAK,MAAM;AAAA,EACrB;AAAA,EAED,YAAY;AACR,WAAO,KAAK,iBAAiBxO,EAAQ;AAAA,EACxC;AAAA,EAED,QAAQ;AACJ,WAAO,KAAK,iBAAiBA,EAAQ;AAAA,EACxC;AAAA,EAMD,SAAS;AACL,WAAO,KAAK,MAAM;EACrB;AAAA,EAOD,cAAcgY,GAAQ;AAClB,WAAO,KAAK,MAAM,cAAcA,CAAM;AAAA,EACzC;AAAA,EAMD,SAAS7W,GAAI;AACT,WAAO,KAAK,MAAM,SAASA,CAAE;AAAA,EAChC;AAAA,EAOD,aAAa+B,GAAS;AAClB,QAAI,KAAK,OAAO;AAAW,aAAO,KAAK;AAEvC,QAAI,KAAK,iBAAiBlD,EAAQ,QAAQ,KAAK,iBAAiBA,EAAQ;AACpE,kBAAK,KAAKA,EAAQ,SACX,KAAK;AAUhB,QAPI,KAAK,YAAY,WACjB,KAAK,UAAU8P,GAAU5M,GAAS,KAAK,KAAK,IAE5C,KAAK,UAAU,WACf,KAAK,QAAQ4M,GAAU5M,GAAS,KAAK,GAAG,IAGxC,KAAK,YAAYlD,EAAQ,WAAW,KAAK,SAASA,EAAQ;AAC1D,WAAK,KAAKA,EAAQ;AAAA,aAGb,KAAK,YAAYA,EAAQ,UAAU,KAAK,SAASA,EAAQ;AAC9D,WAAK,KAAKA,EAAQ;AAAA,SAGjB;AACD,UAAIsb,IAAWxL,GAAU5M,GAAS,KAAK,OAAQ,CAAA;AAG/C,WAAK,KAAKoY;AAAA,IACb;AACD,WAAO,KAAK;AAAA,EACf;AAAA,EAOD,WAAWhb,GAAM;AACb,QAAIib,GACAtN,IAAS,KAAK,OACdC,IAAS5N,EAAK;AAElB,IAAI2N,aAAkBjO,EAAQ,WAAWkO,aAAkBlO,EAAQ,UAC3DiO,EAAO,MAAM,QAAQC,EAAO,KAAK,KAAKD,EAAO,IAAI,QAAQC,EAAO,GAAG,IACnEqN,IAAOvb,EAAQ,eACRiO,EAAO,MAAM,QAAQC,EAAO,GAAG,KAAKD,EAAO,IAAI,QAAQC,EAAO,KAAK,MAC1EqN,IAAOvb,EAAQ,qBAEZiO,aAAkBjO,EAAQ,OAAOkO,aAAkBlO,EAAQ,OAQ3DiO,aAAkBjO,EAAQ,WAAWkO,aAAkBlO,EAAQ,OACtEiO,aAAkBjO,EAAQ,OAAOkO,aAAkBlO,EAAQ,aACvDiO,EAAO,MAAM,QAAQC,EAAO,KAAK,KAAKD,EAAO,IAAI,QAAQC,EAAO,GAAG,KAAKD,EAAO,OAAM,EAAG,QAAQC,EAAO,OAAM,CAAE,IAC/GqN,IAAOvb,EAAQ,eACRiO,EAAO,MAAM,QAAQC,EAAO,GAAG,KAAKD,EAAO,IAAI,QAAQC,EAAO,KAAK,KAAKD,EAAO,OAAM,EAAG,QAAQC,EAAO,OAAM,CAAE,MACtHqN,IAAOvb,EAAQ,oBAKnB,KAAK,YAAY,WAAW,KAAK,UAAUub,IAC3Cjb,EAAK,YAAY,WAAWA,EAAK,UAAUib;AAAA,EAClD;AAAA,EAED,MAAM;AACF,QAAI,KAAK,iBAAiBvb,EAAQ;AAC9B,aAAO,KAAK,KAAK,MAAM,IAAI,KAAK,KAAK,MAAM,IAAI;AAC5C,QAAI,KAAK,iBAAiBA,EAAQ,KAAK;AAC1C,UAAI+L,IAAM,KAAK,OACX4O,GACAC,IAAY7O,EAAI,mBAAmB,MAAM;AAG7C,UAAI/L,EAAQ,MAAM,GAAG+L,EAAI,OAAO,IAAI,KAAK,EAAE,GAAG;AAC1C,YAAIyP,IAAOzP,EAAI,mBAAmB,IAAI,IAClC0P,IAAW,IAAIzb,EAAQ,IAAI+L,EAAI,IAAIA,EAAI,GAAGA,EAAI,YAAYA,EAAI,aAAayP,IAAO,KAAK,IAAIzP,EAAI,gBAAgB,GAC/G2P,IAAW,IAAI1b,EAAQ,IAAI+L,EAAI,IAAIA,EAAI,GAAGA,EAAI,aAAayP,IAAO,KAAK,IAAIzP,EAAI,UAAUA,EAAI,gBAAgB;AAEjH,eAAA4O,IAAe,KAER,KAAKc,EAAS,KAAKA,EAAS,OAAOd,KAAgBC,KAAaa,EAAS,IAAI,KAAKA,EAAS,IAAI;AAAA,uBAC/FC,EAAS,KAAKA,EAAS,OAAOf,KAAgBC,KAAac,EAAS,IAAI,KAAKA,EAAS,IAAI;AAAA,MACjH;AACgB,eAAAf,IAAe5O,EAAI,SAAS,KAAK,KAAK,MAAM,KAErC,KAAKA,EAAI,KAAKA,EAAI,OAAO4O,KAAgBC,KAAa7O,EAAI,IAAI,KAAKA,EAAI,IAAI;AAAA,IAEzF;AAAA,EACJ;AAAA,EAED,SAAS;AACL,WAAO,KAAK,MAAM;EACrB;AACL;AACA/L,EAAQ,OAAOqb;AAMf,MAAMM,WAA2Bxb,GAAW;AAAA,EACxC,YAAYC,GAAOC,GAAM;AACrB,UAAMD,GAAOC,CAAI,GACjB,KAAK,iBAAgB;AAAA,EACxB;AAAA,EAED,mBAAmB;AACf,IAAI,KAAK,QAAO,MAChB,KAAK,KAAK,OAAO,KAAK,OACtB,KAAK,MAAM,OAAO,KAAK;AAAA,EAC1B;AAAA,EAED,CAAC,OAAO,YAAY;AAChB,QAAIS;AACJ,WAAO;AAAA,MACH,MAAM,MAAM;AACR,YAAIZ,IAAQY,KAAoB,KAAK,OACjC8a,IAAO,KAAK,QAAS9a,IAAUA,MAAY,KAAK,QAAQ,KAAS;AACrE,eAAAA,IAAUZ,IAAQA,EAAM,OAAO,QACxB,EAAC,OAAOA,GAAO,MAAM0b,EAAI;AAAA,MACnC;AAAA,IACb;AAAA,EACK;AAAA,EAOD,OAAO9a,GAAS;AACZ,iBAAM,OAAOA,CAAO,GACpB,KAAK,iBAAgB,GACd;AAAA,EACV;AAAA,EAQD,OAAOC,GAAYC,GAAe;AAC9B,iBAAM,OAAOD,GAAYC,CAAa,GACtC,KAAK,iBAAgB,GACd;AAAA,EACV;AAAA,EAOD,OAAOF,GAAS;AACZ,iBAAM,OAAOA,CAAO,GAEb;AAAA,EACV;AACL;AA4BA,MAAM+a,WAAaF,GAAmB;AAAA,EAClC,YAAYzY,MAAYyL,GAAM;AAc1B,QAbA,SAUA,KAAK,OAAO,QACZ,KAAK,eAAe,QAEhBA,EAAK,UAAU,GAQnB;AAAA,UAAIA,EAAK,UAAU;AACf,YAAIA,EAAK,cAAc,OAAO;AAE1B,cAAIrN,IAASqN,EAAK;AAClB,cAAIrN,EAAO,UAAU;AACjB;AAGJ,cAAIA,EAAO,MAAM,CAACkN,MAAkBA,aAAiBxO,EAAQ,KAAM,GAAG;AAClE,gBAAI8b,IAAWD,GAAK,gBAAgBva,CAAM;AAC1C,iBAAK,YAAY4B,EAAQ,OAAO4Y,CAAQ;AAAA,UAC3C,WAEQxa,EAAO,MAAM,CAACkN,MAAkBA,aAAiB,SAASA,EAAM,WAAW,CAAE,GAAG;AACrF,gBAAIuN,IAASza,EAAO,IAAI,CAACkN,MAAU,IAAIxO,EAAQ,MAAMwO,EAAM,IAAGA,EAAM,EAAE,CAAC,GACnEsN,IAAWD,GAAK,gBAAgBE,CAAM;AAC1C,iBAAK,YAAY7Y,EAAQ,OAAO4Y,CAAQ;AAAA,UAC3C,WAEQxa,EAAO,MAAM,CAACkN,MACXA,aAAiBxO,EAAQ,WAAWwO,aAAiBxO,EAAQ,GACxE;AACG,iBAAK,YAAYkD,EAAQ,OAAO5B,CAAM;AAAA,mBAGjCA,EAAO,MAAM,CAACkN,MACXA,EAAM,SAAS,aAAaA,EAAM,SAAS,KACtD,GAAG;AACA,gBAAIwN,IAAgB,CAAA;AACpB,qBAASxN,KAASlN,GAAQ;AACtB,kBAAI2a;AACJ,cAAIzN,EAAM,SAAS,YACfyN,IAAe,IAAIjc,EAAQ,QAAQwO,CAAK,IAExCyN,IAAe,IAAIjc,EAAQ,IAAIwO,CAAK,GAExCwN,EAAc,KAAKC,CAAY;AAAA,YAClC;AACD,iBAAK,YAAY/Y,EAAQ,OAAO8Y,CAAa;AAAA,UAChD;AAAA,QACJ,WAEQrN,EAAK,cAAckN,IAAM;AAC9B,cAAIxV,IAAOsI,EAAK;AAChB,eAAK,QAAQtI,EAAK,OAClB,KAAK,OAAOA,EAAK;AACjB,mBAAS/F,KAAQ+F;AACb,YAAAnD,EAAQ,MAAM,IAAI5C,CAAI;AAAA,QAE7B,WAEQqO,EAAK,cAAc3O,EAAQ;AAChC,eAAK,YAAYkD,EAAQ,OAAO,CAACyL,EAAK,GAAG,MAAM3O,EAAQ,GAAG,CAAC,CAAC;AAAA,iBAGvD2O,EAAK,cAAc3O,EAAQ,KAAK;AACrC,cAAIwL,IAAMmD,EAAK;AACf,eAAK,YAAYzL,EAAQ,OAAO;AAAA,YAC5B,IAAIlD,EAAQ,QAAQ,IAAIA,EAAQ,MAAMwL,EAAI,MAAMA,EAAI,IAAI,GAAG,IAAIxL,EAAQ,MAAMwL,EAAI,MAAMA,EAAI,IAAI,CAAC;AAAA,YAChG,IAAIxL,EAAQ,QAAQ,IAAIA,EAAQ,MAAMwL,EAAI,MAAMA,EAAI,IAAI,GAAG,IAAIxL,EAAQ,MAAMwL,EAAI,MAAMA,EAAI,IAAI,CAAC;AAAA,YAChG,IAAIxL,EAAQ,QAAQ,IAAIA,EAAQ,MAAMwL,EAAI,MAAMA,EAAI,IAAI,GAAG,IAAIxL,EAAQ,MAAMwL,EAAI,MAAMA,EAAI,IAAI,CAAC;AAAA,YAChG,IAAIxL,EAAQ,QAAQ,IAAIA,EAAQ,MAAMwL,EAAI,MAAMA,EAAI,IAAI,GAAG,IAAIxL,EAAQ,MAAMwL,EAAI,MAAMA,EAAI,IAAI,CAAC;AAAA,UACpH,CAAiB;AAAA,QACJ;AAAA;AAKL,MAAImD,EAAK,UAAU,KAAKA,EAAK,cAAc3O,EAAQ,QAAQ2O,EAAK,cAAc3O,EAAQ,SAClF,KAAK,QAAQ2O,EAAK,IAClB,KAAK,OAAOA,EAAK,IACjB,KAAK,KAAK,OAAO,KAAK,OACtB,KAAK,MAAM,OAAO,KAAK,MAGvB,KAAK,aAAY;AAAA;AAAA,EAKxB;AAAA,EAMD,IAAI,QAAQ;AACR,WAAO,KAAK;EACf;AAAA,EAMD,IAAI,SAAS;AACT,WAAO,KAAK,MAAM,IAAI,CAAArO,MAAQA,EAAK,MAAM,MAAK,CAAE;AAAA,EACnD;AAAA,EAMD,IAAI,MAAM;AACN,QAAI,KAAK,SAAS,QAAW;AACzB,UAAIkL,IAAM,IAAIxL,EAAQ;AACtB,eAASM,KAAQ;AACb,QAAAkL,IAAMA,EAAI,MAAMlL,EAAK,GAAG;AAE5B,WAAK,OAAOkL;AAAA,IACf;AACD,WAAO,KAAK;AAAA,EACf;AAAA,EAMD,IAAI,YAAY;AACZ,WAAO,KAAK,KAAK,aAAa,KAAK,KAAK;AAAA,EAC3C;AAAA,EAOD,cAAcwM,GAAQ;AAClB,QAAIA,IAAS,KAAK,aAAaA,IAAS;AAAG,aAAO;AAClD,QAAIjI,IAAQ;AACZ,aAASzP,KAAQ;AACb,UAAI0X,KAAU1X,EAAK,eACdA,MAAS,KAAK,QAAQ0X,IAAS1X,EAAK,KAAK,aAAa;AACvD,QAAAyP,IAAQzP,EAAK,cAAc0X,IAAS1X,EAAK,UAAU;AACnD;AAAA,MACH;AAEL,WAAOyP;AAAA,EACV;AAAA,EAED,OAAO,gBAAgBgM,GAAQ;AAC3B,QAAID,IAAW,CAAA;AACf,aAASlZ,IAAI,GAAGA,IAAImZ,EAAO,QAAQnZ;AAE/B,MAAImZ,EAAOnZ,GAAG,QAAQmZ,GAAQnZ,IAAI,KAAKmZ,EAAO,OAAO,KAErDD,EAAS,KAAK,IAAI9b,EAAQ,QAAQ+b,EAAOnZ,IAAImZ,GAAQnZ,IAAI,KAAKmZ,EAAO,OAAO,CAAC;AAEjF,WAAOD;AAAA,EACV;AAAA,EAED,YAAYI,GAAO5a,GAAQ;AACvB,aAASkN,KAASlN,GAAQ;AACtB,UAAIhB,IAAO,IAAIN,EAAQ,KAAKwO,CAAK;AACjC,WAAK,OAAOlO,CAAI,GAEhB4b,EAAM,IAAI5b,CAAI;AAAA,IACjB;AAAA,EAEJ;AAAA,EAOD,OAAOA,GAAM;AACT,iBAAM,OAAOA,CAAI,GAEjB,KAAK,oBAAoBA,CAAI,GAC7BA,EAAK,OAAO,MAEL;AAAA,EACV;AAAA,EAQD,OAAOoE,GAASoK,GAAY;AACxB,iBAAM,OAAOpK,GAASoK,CAAU,GAEhC,KAAK,oBAAoBpK,CAAO,GAChCA,EAAQ,OAAO,MACR;AAAA,EACV;AAAA,EAOD,OAAOpE,GAAM;AACT,iBAAM,OAAOA,CAAI,GAEjB,KAAK,aAAY,GACV;AAAA,EACV;AAAA,EAOD,UAAU;AAEN,QAAI4b,IAAQ,CAAA,GACR3T,IAAW,KAAK;AACpB;AAEI,MAAAA,EAAS,QAAQA,EAAS,MAAM,QAAO,GACvC2T,EAAM,KAAK3T,CAAQ,GACnBA,IAAWA,EAAS;AAAA,WACfA,MAAa,KAAK;AAG3B,SAAK,QAAQ,QACb,KAAK,OAAO;AACZ,aAASjI,KAAQ4b;AACb,MAAI,KAAK,UAAU,UACf5b,EAAK,OAAOA,GACZA,EAAK,OAAOA,GACZ,KAAK,QAAQA,GACb,KAAK,OAAOA,MAGZA,EAAK,OAAO,KAAK,MACjB,KAAK,KAAK,OAAOA,GAGjB,KAAK,OAAOA,GAGZ,KAAK,KAAK,OAAO,KAAK,OACtB,KAAK,MAAM,OAAO,KAAK,OAI3B,KAAK,oBAAoBA,CAAI;AAIjC,IAAI,KAAK,iBAAiB,WACtB,KAAK,eAAe,QACpB,KAAK,eAAe,KAAK;EAEhC;AAAA,EAOD,eAAe;AACX,aAASA,KAAQ;AACb,WAAK,oBAAoBA,CAAI,GAC7BA,EAAK,OAAO;AAAA,EAEnB;AAAA,EAED,oBAAoBA,GAAM;AACtB,IAAIA,MAAS,KAAK,QACdA,EAAK,aAAa,IAElBA,EAAK,aAAaA,EAAK,KAAK,aAAaA,EAAK,KAAK;AAAA,EAE1D;AAAA,EAMD,OAAO;AACH,WAAO,KAAK,IAAI,KAAK,WAAY,CAAA;AAAA,EACpC;AAAA,EAUD,aAAa;AACT,QAAI6b,IAAQ,GACRhE,IAAO,KAAK,IAAI;AACpB,aAAS7X,KAAQ;AACb,MAAA6b,KAAS7b,EAAK,MAAM,iBAAiB6X,CAAI;AAE7C,WAAOgE;AAAA,EACV;AAAA,EAWD,cAAc;AACV,QAAI,KAAK,iBAAiB,QAAW;AACjC,UAAIC,IAAO,KAAK;AAChB,MAAIpc,EAAQ,MAAM,KAAKoc,CAAI,IACvB,KAAK,eAAepc,EAAQ,YAAY,iBACjCA,EAAQ,MAAM,GAAGoc,GAAM,CAAC,IAC/B,KAAK,eAAepc,EAAQ,YAAY,MAExC,KAAK,eAAeA,EAAQ,YAAY;AAAA,IAE/C;AACD,WAAO,KAAK;AAAA,EACf;AAAA,EASD,SAASkc,GAAO;AAEZ,WADSL,GAAK,qBAAqB,MAAMK,GAAO,EAAI,EAC1C,UAAU;AAAA,EACvB;AAAA,EAED,OAAO,qBAAqB7V,GAAM6V,GAAOG,IAAc,IAAO;AAC1D,QAAIjb,IAAa,CAAA;AAGjB,aAASuG,KAAStB,GAAM;AAGpB,UAAIuB,IAAOsU,EAAM,OAAOvU,EAAM,GAAG;AAGjC,eAASE,KAASD,GAAM;AAWpB,YARID,MAAUE,KAIVA,EAAM,SAASxB,KAIfsB,EAAM,iBAAiB3H,EAAQ,WAAW6H,EAAM,iBAAiB7H,EAAQ,YACxE2H,EAAM,SAASE,KAASF,EAAM,SAASE;AACxC;AAGJ,YAAI/F,IAAK6F,EAAM,MAAM,UAAUE,EAAM,KAAK;AAG1C,iBAAS1G,KAAMW;AAGX,cAAI,EAAAX,EAAG,QAAQwG,EAAM,KAAK,KAAKxG,EAAG,QAAQ0G,EAAM,GAAG,KAAKA,MAAUF,EAAM,SAEpE,EAAAxG,EAAG,QAAQwG,EAAM,GAAG,KAAKxG,EAAG,QAAQ0G,EAAM,KAAK,KAAKA,MAAUF,EAAM,UAGxEvG,EAAW,KAAKD,CAAE,GAEdkb;AACA;AAGR,YAAIjb,EAAW,SAAS,KAAKib;AACzB;AAAA,MACP;AAED,UAAIjb,EAAW,SAAS,KAAKib;AACzB;AAAA,IAEP;AACD,WAAOjb;AAAA,EACV;AAAA,EAOD,gBAAgBD,GAAI;AAChB,QAAI4N;AACJ,aAASzO,KAAQ;AACb,UAAIA,EAAK,MAAM,SAASa,CAAE,GAAG;AACzB,QAAA4N,IAAYzO;AACZ;AAAA,MACH;AAEL,WAAOyO;AAAA,EACV;AAAA,EAMD,YAAY;AACR,WAAO,IAAI/O,EAAQ,QAAQ,KAAK,MAAM;AAAA,EACzC;AAAA,EAED,SAAS;AACL,WAAO,KAAK,MAAM,IAAI,CAAAM,MAAQA,EAAK,OAAM,CAAE;AAAA,EAC9C;AAAA,EAMD,MAAM;AACF,QAAIsP,IAAS;AAAA,GAAM,KAAK,MAAM,MAAM,KAAK,KAAK,MAAM,MAAM;AAC1D,aAAStP,KAAQ;AACb,MAAAsP,KAAUtP,EAAK;AAEnB,WAAAsP,KAAU,MACHA;AAAA,EACV;AAEL;AACA5P,EAAQ,OAAO6b;AAMf,MAAMS,GAAI;AAAA,EAWN,eAAe3N,GAAM;AAIjB,QAHA,KAAK,KAAK,IAAI3O,EAAQ,MAAK,GAC3B,KAAK,OAAO,IAAIA,EAAQ,OAAO,GAAE,CAAC,GAE9B2O,EAAK,UAAU,MAIfA,EAAK,UAAU,KAAKA,EAAK,cAAc3O,EAAQ,UAC/C,KAAK,KAAK2O,EAAK,GAAG,MAAK,IAGvBA,EAAK,WAAW,IAIpB;AAAA,UAAIA,EAAK,WAAW,KAAKA,EAAK,cAAc3O,EAAQ,QAAQ;AACxD,aAAK,OAAO2O,EAAK,GAAG,MAAK;AACzB;AAAA,MACH;AAOD,YAAM3O,EAAQ,OAAO;AAAA;AAAA,EACxB;AAAA,EAMD,QAAQ;AACJ,WAAO,IAAIsc,GAAI,KAAK,IAAI,KAAK,IAAI;AAAA,EACpC;AAAA,EAMD,IAAI,QAAQ;AAER,WADU,IAAItc,EAAQ,OAAO,KAAK,KAAK,GAAG,CAAC,KAAK,KAAK,CAAC,EAC3C;AAAA,EACd;AAAA,EAMD,IAAI,MAAM;AACN,QAAIuc,IAAQ,KAAK;AACjB,WAAO,IAAIvc,EAAQ;AAAA,MACfuc,IAAQ,KAAK,KAAG,KAAKA,IAAQ,IAAE,KAAK,KAAG,IAAI,OAAO,oBAAoB,KAAK,GAAG;AAAA,MAC9EA,KAAS,KAAKA,KAAS,KAAK,KAAK,KAAK,GAAG,IAAI,OAAO;AAAA,MACpDA,KAAS,KAAK,KAAG,KAAKA,KAAS,IAAE,KAAK,KAAG,IAAI,KAAK,GAAG,IAAI,OAAO;AAAA,MAChEA,KAAS,KAAK,MAAMA,KAAS,IAAE,KAAK,MAAMA,KAAS,IAAI,KAAK,GAAG,IAAI,OAAO;AAAA,IAC7E;AAAA,EACJ;AAAA,EAMD,IAAI,QAAQ;AACR,WAAO,KAAK;AAAA,EACf;AAAA,EAMD,IAAI,MAAM;AAAA,EAAkB;AAAA,EAM5B,IAAI,SAAS;AAAC,WAAO,OAAO;AAAA,EAAkB;AAAA,EAO9C,SAASpb,GAAI;AACT,QAAI,KAAK,GAAG,QAAQA,CAAE;AAClB,aAAO;AAIX,QAAIyL,IAAM,IAAI5M,EAAQ,OAAO,KAAK,IAAImB,CAAE;AACxC,WAAOnB,EAAQ,MAAM,KAAK,KAAK,KAAK,IAAI4M,CAAG,CAAC,KAAK5M,EAAQ,MAAM,GAAG4M,EAAI,MAAM,KAAK,IAAI,GAAE,CAAC;AAAA,EAC3F;AAAA,EAOD,MAAMzL,GAAI;AACN,WAAK,KAAK,SAASA,CAAE,IAGjB,KAAK,GAAG,QAAQA,CAAE,IACX,CAAC,IAAI,IAGT;AAAA,MACH,IAAInB,EAAQ,QAAQ,KAAK,IAAImB,CAAE;AAAA,MAC/B,IAAInB,EAAQ,IAAImB,GAAI,KAAK,IAAI;AAAA,IAChC,IATU;EAUd;AAAA,EAOD,UAAUqN,GAAO;AACb,QAAIA,aAAiBxO,EAAQ;AACzB,aAAO,KAAK,qBAAqB,MAAMwO,CAAK;AAGhD,QAAIA,aAAiBxO,EAAQ;AACzB,aAAO,KAAK,iBAAiB,MAAMwO,CAAK;AAAA,EAE/C;AAAA,EAED,qBAAqByB,GAAKvH,GAAS;AAC/B,QAAI5G,IAAK,CAAA,GAMLK,IAAO,IAAInC,EAAQ,KAAKiQ,EAAI,OAAOA,EAAI,IAAI,GAC3CjE,IAAS7J,EAAK,UAAUuG,CAAO;AAEnC,aAASvH,KAAM6K;AAEX,MAAIiE,EAAI,SAAS9O,CAAE,KACfW,EAAG,KAAKX,CAAE;AAOlB,WAAI6K,EAAO,UAAU,KAAKlK,EAAG,UAAU,KAAKmO,EAAI,MAAM,GAAG9N,CAAI,KACzDL,EAAG,KAAKmO,EAAI,KAAK,GAGdnO;AAAA,EACV;AAAA,EAED,iBAAiBmO,GAAKlE,GAAK;AACvB,QAAIjK,IAAK,CAAA,GAOLkK,IADO,IAAIhM,EAAQ,KAAKiQ,EAAI,OAAOA,EAAI,IAAI,EAC7B,UAAUlE,CAAG;AAE/B,aAAS5K,KAAM6K;AAEX,MAAIiE,EAAI,SAAS9O,CAAE,KACfW,EAAG,KAAKX,CAAE;AAGlB,WAAOW;AAAA,EACV;AAAA,EAOD,IAAI0J,GAAK2D,IAAQ,IAAI;AACjB,QAAIhN,IAAO,IAAInC,EAAQ,KAAK,KAAK,IAAI,KAAK,IAAI,GAC1C8B,IAAKyJ,GAAkBpJ,GAAMqJ,CAAG;AAEpC,WADA1J,IAAKA,EAAG,OAAQ,CAAAX,MAAM,KAAK,SAASA,CAAE,IAClCW,EAAG,WAAW,KAAKA,EAAG,WAAW,IAC1B,KACG,IAAI9B,EAAQ,QAAQ,KAAK,IAAI8B,EAAG,EAAE,EACjC,IAAIqN,CAAK;AAAA,EAC3B;AAEL;AACAnP,EAAQ,MAAMsc;AAEd,MAAMrM,KAAM,IAAItB,MAAS,IAAI3O,EAAQ,IAAI,GAAG2O,CAAI;AAChD3O,EAAQ,MAAMiQ;AAYd,MAAMuM,GAAQ;AAAA,EAaV,cAAc;AAKV,SAAK,QAAQ,IAAIxc,EAAQ,UAAS,GAKlC,KAAK,QAAQ,IAAIA,EAAQ,UAAS;AAKlC,QAAI2O,IAAO,CAAC,GAAG,SAAS;AACxB,QAAIA,EAAK,WAAW,MACdA,EAAK,cAAc,SAASA,EAAK,GAAG,SAAS,KAC3CA,EAAK,cAAc3O,EAAQ,UAAU2O,EAAK,cAAc3O,EAAQ,MAAM;AAC1E,UAAIyc,IAAY9N,EAAK;AACrB,UAAIA,EAAK,cAAc,SAASA,EAAK,GAAG,MAAM,CAAC+N,MACpCA,aAAgB,KAC1B;AACG,YAAID,EAAU,MAAM,CAAAE,MACTA,aAAc,SAASA,EAAG,WAAW,KAAK,OAAQA,EAAG,MAAQ,YAAY,OAAQA,EAAG,MAAQ,QACtG;AACG,eAAK,MAAM,IAAI,IAAI3c,EAAQ,KAAK,MAAMyc,CAAS,CAAC;AAAA;AAEhD,mBAASC,KAAQD;AAEb,gBAAIC,aAAgB,SAASA,EAAK,cAAc,SAC5CA,EAAK,GAAG,MAAM,CAAAC,MACHA,aAAc,SAASA,EAAG,WAAW,KAAK,OAAQA,EAAG,MAAQ,YAAY,OAAQA,EAAG,MAAQ,QACtG;AACD,uBAASC,KAASF;AACd,qBAAK,MAAM,IAAI,IAAI1c,EAAQ,KAAK,MAAM4c,CAAK,CAAC;AAAA;AAGhD,mBAAK,MAAM,IAAI,IAAI5c,EAAQ,KAAK,MAAM0c,CAAI,CAAC;AAAA;AAKvD,aAAK,MAAM,IAAI,IAAI1c,EAAQ,KAAK,MAAMyc,CAAS,CAAC;AAAA,IAEvD;AAAA,EACJ;AAAA,EAMD,IAAI,MAAM;AACN,WAAO,CAAC,GAAG,KAAK,KAAK,EAAE,OAAO,CAAC7N,GAAKvI,MAASuI,EAAI,MAAMvI,EAAK,GAAG,GAAG,IAAIrG,EAAQ,IAAG,CAAE;AAAA,EACtF;AAAA,EAMD,IAAI,WAAW;AACX,WAAO,CAAC,GAAG,KAAK,KAAK,EAAE,IAAI,CAAAM,MAAQA,EAAK,KAAK;AAAA,EAChD;AAAA,EAMD,QAAQ;AACJ,QAAI4C,IAAU,IAAIsZ;AAClB,aAASnW,KAAQ,KAAK;AAClB,MAAAnD,EAAQ,QAAQmD,EAAK,MAAM;AAE/B,WAAOnD;AAAA,EACV;AAAA,EAMD,UAAU;AACN,WAAO,KAAK,MAAM,SAAS;AAAA,EAC9B;AAAA,EAUD,UAAU;AACN,QAAI2Z,IAAQ;AAEZ,aAASxW,KAAQ,KAAK;AAClB,UAAI,CAACA,EAAK,SAAS,KAAK,KAAK,GAAG;AAC5B,QAAAwW,IAAQ;AACR;AAAA,MACH;AAIL,WAAOA;AAAA,EACV;AAAA,EAMD,OAAO;AACH,QAAIC,IAAa,CAAC,GAAG,KAAK,KAAK,EAAE,OAAO,CAAClO,GAAKvI,MAASuI,IAAMvI,EAAK,WAAY,GAAE,CAAC;AACjF,WAAO,KAAK,IAAIyW,CAAU;AAAA,EAC7B;AAAA,EAYD,WAAWnO,GAAM;AACb,QAAItI,IAAO,IAAIrG,EAAQ,KAAK,MAAM,GAAG2O,CAAI;AACzC,gBAAK,MAAM,IAAItI,CAAI,GACZA;AAAA,EACV;AAAA,EAOD,WAAWA,GAAM;AACb,aAAS/F,KAAQ+F;AACb,WAAK,MAAM,OAAO/F,CAAI;AAE1B,WAAO,KAAK,MAAM,OAAO+F,CAAI;AAAA,EAChC;AAAA,EAKD,gBAAgB;AAEZ,SAAK,MAAM;AACX,aAAS/F,KAAQ,KAAK;AAClB,MAAAA,EAAK,OAAO;AAIhB,QAAIF,GACA2c,IAAsB;AAC1B,WAAOA,KAAqB;AACxB,MAAAA,IAAsB;AACtB,eAASzc,KAAQ,KAAK;AAClB,YAAIA,EAAK,SAAS,MAAM;AACpB,UAAAF,IAAQE,GACRyc,IAAsB;AACtB;AAAA,QACH;AAGL,UAAIA,GAAqB;AACrB,YAAI1c,IAAOD;AACX;AACI,UAAAC,IAAOA,EAAK;AAAA,eACPA,EAAK,SAASD;AAEvB,aAAK,QAAQA,GAAOC,CAAI;AAAA,MAC3B;AAAA,IACJ;AAAA,EACJ;AAAA,EAQD,YAAYgG,GAAM2W,GAAUC,GAAQ;AAEhC,QAAIA,EAAO,SAASD,GAAU;AAC1B,WAAK,WAAW3W,CAAI;AACpB;AAAA,IACH;AACD,aAAS/F,IAAO0c,GAAU1c,MAAS2c,EAAO,MAAM3c,IAAOA,EAAK;AAGxD,UAFA+F,EAAK,OAAO/F,CAAI,GAChB,KAAK,MAAM,OAAOA,CAAI,GAClB+F,EAAK,WAAW;AAChB,aAAK,WAAWA,CAAI;AACpB;AAAA,MACH;AAAA,EAER;AAAA,EAYD,UAAUlF,GAAIb,GAAM;AAChB,QAAIgB,IAAShB,EAAK,MAAM,MAAMa,CAAE;AAGhC,QAAIG,EAAO,OAAO;AACd,aAAOhB,EAAK;AAEhB,QAAIgB,EAAO,OAAO;AACd,aAAOhB;AAEX,QAAIoE,IAAU,IAAI1E,EAAQ,KAAKsB,EAAO,EAAE,GACpCwN,IAAaxO,EAAK;AAGtB,WAAAA,EAAK,KAAK,OAAOoE,GAASoK,CAAU,GAGpC,KAAK,MAAM,OAAOxO,CAAI,GAGtB,KAAK,MAAM,IAAIoE,CAAO,GAGtBpE,EAAK,QAAQgB,EAAO,IAGpB,KAAK,MAAM,IAAIhB,CAAI,GAEZoE;AAAA,EACV;AAAA,EASD,IAAImL,GAAW;AACX,QAAIqN,IAAc,CAAC,KAAK,MAAO,CAAA;AAC/B,aAAS5c,KAAQuP,GAAW;AACxB,UAAIvP,EAAK,aAAa,IAAI,MAAMhC;AAC5B;AAEJ,UAAI6e,IAAiB7c,EAAK,MAAM,OAC5B8c,IAAe9c,EAAK,MAAM,KAE1B+c,IAAiB,CAAA;AACrB,eAASna,KAAWga;AAChB,YAAIha,EAAQ,gBAAgBia,CAAc,MAAM;AAC5C,UAAAE,EAAe,KAAKna,CAAO;AAAA,aACxB;AACH,cAAI,CAACoa,GAAUC,CAAQ,IAAIra,EAAQ,QAAQia,GAAgBC,CAAY;AACvE,UAAAC,EAAe,KAAKC,GAAUC,CAAQ;AAAA,QACzC;AAEL,MAAAL,IAAcG;AAAA,IACjB;AACD,WAAOH;AAAA,EACV;AAAA,EASD,QAAQlE,GAAKC,GAAK;AACd,QAAItR,IAAQ,KAAK,gBAAgBqR,CAAG,GAChCnR,IAAQ,KAAK,gBAAgBoR,CAAG;AACpC,QAAItR,EAAM,SAASE,EAAM;AACrB,aAAO;AAGX,QAAI2V,IAAc,KAAK,UAAUxE,GAAKrR,CAAK;AAC3C,IAAAE,IAAQ,KAAK,gBAAgBoR,CAAG;AAChC,QAAIwE,IAAc,KAAK,UAAUxE,GAAKpR,CAAK,GAEvCxB,IAAOmX,EAAY,MACnB7U,IAAW,IAAI3I,EAAQ;AAAA,MACvB,IAAIA,EAAQ,QAAQwd,EAAY,KAAKC,EAAY,GAAG;AAAA,IAChE,GACY5U,IAAW,IAAI7I,EAAQ;AAAA,MACvB,IAAIA,EAAQ,QAAQyd,EAAY,KAAKD,EAAY,GAAG;AAAA,IAChE;AAGQ,IAAAA,EAAY,KAAK,OAAO3U,GACxBA,EAAS,OAAO2U,EAAY,MAE5BA,EAAY,OAAO7U,GACnBA,EAAS,OAAO6U,GAEhBC,EAAY,KAAK,OAAO9U,GACxBA,EAAS,OAAO8U,EAAY,MAE5BA,EAAY,OAAO5U,GACnBA,EAAS,OAAO4U,GAGhB,KAAK,MAAM,IAAI9U,CAAQ,GACvB,KAAK,MAAM,IAAIE,CAAQ;AAGvB,QAAI6U,IAAQ,KAAK,QAAQ/U,GAAU6U,CAAW,GAC1CG,IAAQ,KAAK,QAAQ9U,GAAU4U,CAAW;AAG9C,gBAAK,MAAM,OAAOpX,CAAI,GAEf,CAACqX,EAAM,UAAS,GAAIC,EAAM,UAAW,CAAA;AAAA,EAC/C;AAAA,EAOD,YAAYxb,GAAM;AACd,QAAIyb,IAAU,KAAK,SAEf/N,IAAY,IAAInB,EAAU,CAACvM,CAAI,CAAC,GAGhCR,IAAgB;AAAA,MAChB,aAAa,CAAE;AAAA,MACf,aAAa,CAAE;AAAA,MACf,oBAAoB,CAAE;AAAA,MACtB,oBAAoB,CAAE;AAAA,IAClC;AAIQ,aAASrB,KAAQsd,EAAQ,OAAO;AAC5B,UAAI9b,IAAK4L,GAAmBpN,GAAM6B,CAAI;AAEtC,eAAShB,KAAMW;AACX,QAAAZ,GAAe2O,EAAU,OAAO1O,GAAIQ,EAAc,WAAW,GAC7DT,GAAeZ,GAAMa,GAAIQ,EAAc,WAAW;AAAA,IAEzD;AAGD,QAAIA,EAAc,YAAY,WAAW;AACrC,aAAOic;AAGX,IAAAjc,EAAc,qBAAqBO,GAAqBC,GAAMR,EAAc,WAAW,GACvFA,EAAc,qBAAqBC,GAAeD,EAAc,WAAW,GAG3E8C,GAAqBoL,GAAWlO,EAAc,kBAAkB,GAChE8C,GAAqBmZ,GAASjc,EAAc,kBAAkB,GAG9DW,GAA8BX,CAAa,GAG3CA,EAAc,qBAAqBO,GAAqBC,GAAMR,EAAc,WAAW,GACvFA,EAAc,qBAAqBC,GAAeD,EAAc,WAAW,GAG3EqB,GAAyBrB,EAAc,WAAW,GAGlDsB,GAAwBtB,EAAc,aAAaic,CAAO;AAG1D,aAASxb,KAAcT,EAAc;AACjC,MAAIS,EAAW,YAAY,OAAOA,EAAW,WAAW,OACpDT,EAAc,YAAYS,EAAW,MAAM,IAC3CA,EAAW,KAAK;AAOxB,QAJAT,EAAc,cAAcA,EAAc,YAAY,OAAQ,CAAAmB,MAAaA,EAAU,MAAM,CAAC,GAC5FnB,EAAc,cAAcA,EAAc,YAAY,OAAQ,CAAAmB,MAAaA,EAAU,MAAM,CAAC,GAGxFnB,EAAc,YAAY,WAAW;AACrC,aAAOic;AAGX,IAAAjc,EAAc,qBAAqBO,GAAqBC,GAAMR,EAAc,WAAW,GACvFA,EAAc,qBAAqBC,GAAeD,EAAc,WAAW;AAG3E,QAAIkc,IAAkBlc,EAAc,YAAY,IAC5CiD;AACJ,aAASkZ,KAAmBnc,EAAc;AACtC,MAAImc,EAAgB,YAAY,OAAOxf,OACnCsG,IAAW,IAAI5E,EAAQ,KAAK,IAAIA,EAAQ,QAAQ6d,EAAgB,IAAIC,EAAgB,EAAE,CAAC,GACvFnZ,GAAuBhD,EAAc,YAAYkc,EAAgB,KAAKlc,EAAc,YAAYmc,EAAgB,KAAKlZ,CAAQ,GAC7HgZ,EAAQ,MAAM,IAAIhZ,CAAQ,GAE1BA,IAAW,IAAI5E,EAAQ,KAAK,IAAIA,EAAQ,QAAQ8d,EAAgB,IAAID,EAAgB,EAAE,CAAC,GACvFlZ,GAAuBhD,EAAc,YAAYmc,EAAgB,KAAKnc,EAAc,YAAYkc,EAAgB,KAAKjZ,CAAQ,GAC7HgZ,EAAQ,MAAM,IAAIhZ,CAAQ,IAE9BiZ,IAAkBC;AAItB,WAAAF,EAAQ,cAAa,GACdA;AAAA,EACV;AAAA,EAOD,gBAAgBzc,GAAI;AAChB,QAAIb;AACJ,aAAS+F,KAAQ,KAAK;AAElB,UADA/F,IAAO+F,EAAK,gBAAgBlF,CAAE,GAC1Bb,MAAS;AACT;AAER,WAAOA;AAAA,EACV;AAAA,EAOD,iBAAiB;AACb,QAAI,KAAK;AAAW,aAAO;AAC3B,QAAIyd,IAAW,KAAK;AAEpB,IAAAA,EAAS,KAAK,CAACpY,GAAUC,MAAaA,EAAS,SAASD,EAAS,KAAI,CAAE;AAEvE,QAAIqY,IAAc,CAAC,GAAGD,EAAS,GAAG,KAAK,EAAE,GAAG,eAExCE,IAAcF,EAAS,OAAO,CAAA7a,MAAW,CAAC,GAAGA,EAAQ,KAAK,EAAE,GAAG,YAAa,MAAK8a,CAAW;AAChG,aAAS9a,KAAW6a,GAAU;AAC1B,UAAI1X,IAAO,CAAC,GAAGnD,EAAQ,KAAK,EAAE;AAC9B,UAAImD,EAAK,kBAAkB2X;AAG3B,iBAASE,KAAiBD;AACtB,cAAI5X,EAAK,OAAO,MAAM,CAAAmI,MAAS0P,EAAc,SAAS1P,CAAK,CAAC,GAAG;AAC3D,YAAA0P,EAAc,QAAQ7X,EAAK,MAAM;AACjC;AAAA,UACH;AAAA;AAAA,IAER;AAED,WAAO4X;AAAA,EACV;AAAA,EAMD,UAAU;AACN,aAAS5X,KAAQ,KAAK;AAClB,MAAAA,EAAK,QAAO;AAEhB,WAAO;AAAA,EACV;AAAA,EAQD,SAASmI,GAAO;AACZ,QAAIA,aAAiBxO,EAAQ,OAAO;AAChC,UAAI4J,IAAMkG,GAAU,MAAMtB,CAAK;AAC/B,aAAO5E,MAAQtL,MAAUsL,MAAQpL;AAAA,IAC7C;AACY,aAAOiT,GAAM,MAAMjD,CAAK;AAAA,EAE/B;AAAA,EAOD,WAAWA,GAAO;AAGd,QAAIA,aAAiBxO,EAAQ,OAAO;AAChC,UAAI,CAACyI,GAAM6D,CAAgB,IAAItM,EAAQ,SAAS,cAAcwO,GAAO,IAAI;AACzE,aAAAlC,IAAmBA,EAAiB,WAC7B,CAAC7D,GAAM6D,CAAgB;AAAA,IACjC;AAED,QAAIkC,aAAiBxO,EAAQ,UACzBwO,aAAiBxO,EAAQ,QACzBwO,aAAiBxO,EAAQ,WACzBwO,aAAiBxO,EAAQ,KAAK;AAC9B,UAAI,CAACyI,GAAM6D,CAAgB,IAAItM,EAAQ,SAAS,cAAcwO,GAAO,IAAI;AACzE,aAAAlC,IAAmBA,EAAiB,WAC7B,CAAC7D,GAAM6D,CAAgB;AAAA,IACjC;AAGD,QAAIkC,aAAiBxO,EAAQ,SAAS;AAClC,UAAIme,IAAuB,CAAC,OAAO,mBAAmB,IAAIne,EAAQ,QAAO,CAAE,GACvEyI,GAAM6D;AAEV,eAAShM,KAAQ,KAAK,OAAO;AAEzB,YAAI8d,IAAWD,EAAqB;AACpC,SAAC1V,GAAM6D,CAAgB,IAAItM,EAAQ,SAAS,gBAAgBM,EAAK,OAAOkO,EAAM,OAAO4P,CAAQ,GACzFpe,EAAQ,MAAM,GAAGyI,GAAM2V,CAAQ,MAC/BD,IAAuB,CAAC1V,GAAM6D,CAAgB;AAAA,MAErD;AACD,aAAO6R;AAAA,IACV;AAAA,EACJ;AAAA,EAOD,UAAU3P,GAAO;AACb,QAAIA,aAAiBxO,EAAQ;AACzB,aAAO,KAAK,SAASwO,CAAK,IAAI,CAACA,CAAK,IAAI;AAG5C,QAAIA,aAAiBxO,EAAQ;AACzB,aAAO8N,GAAsBU,GAAO,IAAI;AAG5C,QAAIA,aAAiBxO,EAAQ;AACzB,aAAO+N,GAAwBS,GAAO,IAAI;AAG9C,QAAIA,aAAiBxO,EAAQ;AACzB,aAAO4N,GAAyBY,GAAO,IAAI;AAG/C,QAAIA,aAAiBxO,EAAQ;AACzB,aAAO6N,GAAqBW,GAAO,IAAI;AAG3C,QAAIA,aAAiBxO,EAAQ;AACzB,aAAOsO,GAAyBE,GAAO,IAAI;AAAA,EAElD;AAAA,EAOD,UAAU5B,GAAK;AACX,QAAIyR,IAAa,IAAI7B;AACrB,aAASnW,KAAQ,KAAK;AAClB,MAAAgY,EAAW,QAAQhY,EAAK,OAAO,IAAI,CAAAmI,MAASA,EAAM,UAAU5B,CAAG,CAAC,CAAC;AAErE,WAAOyR;AAAA,EACV;AAAA,EAUD,OAAOrP,IAAQ,GAAGC,IAAS,IAAIjP,EAAQ,SAAS;AAC5C,QAAIqe,IAAa,IAAI7B;AACrB,aAASnW,KAAQ,KAAK;AAClB,MAAAgY,EAAW,QAAQhY,EAAK,OAAO,IAAI,CAAAmI,MAASA,EAAM,OAAOQ,GAAOC,CAAM,CAAC,CAAC;AAE5E,WAAOoP;AAAA,EACV;AAAA,EAOD,UAAUnP,IAAS,IAAIlP,EAAQ,OAAM,GAAI;AACrC,QAAIqe,IAAa,IAAI7B;AACrB,aAASnW,KAAQ,KAAK;AAClB,MAAAgY,EAAW,QAAQhY,EAAK,OAAO,IAAI,CAAAmI,MAASA,EAAM,UAAUU,CAAM,CAAC,CAAC;AAExE,WAAOmP;AAAA,EACV;AAAA,EAOD,SAAS;AACL,WAAO,CAAC,GAAG,KAAK,KAAK,EAAE,IAAI,CAAAhY,MAAQA,EAAK,OAAM,CAAE;AAAA,EACnD;AAAA,EAMD,UAAU;AACN,WAAO,CAAC,GAAG,KAAK,KAAK,EAAE,IAAI,CAAAA,MAAQA,EAAK,UAAS,CAAE;AAAA,EACtD;AAAA,EASD,IAAI8I,IAAQ,IAAI;AACZ,QAAI,EAAC,QAAAC,GAAQ,aAAAC,GAAa,MAAAC,GAAM,UAAAC,GAAU,aAAAC,GAAa,IAAAnO,GAAI,WAAAoO,EAAS,IAAIN,GAEpEO,IAAUrO,KAAMA,EAAG,SAAS,IAAK,OAAOA,OAAQ,IAChDsO,IAAaF,KAAaA,EAAU,SAAS,IAAK,UAAUA,OAAe,IAE3EG,IAAS;AAAA,gBAAmBR,KAAU,0BAA0BC,KAAe,YAAYC,KAAQ,2BAA2BC,KAAY,4BAA4BC,KAAe,MAAQE,KAAUC;AAC3M,aAAStJ,KAAQ,KAAK;AAClB,MAAAuJ,KAAUvJ,EAAK;AAEnB,WAAAuJ,KAAU;AAAA,UACHA;AAAA,EACV;AACL;AAEA5P,EAAQ,UAAUwc;AAKlB,MAAMtZ,KAAU,IAAIyL,MAAS,IAAI3O,EAAQ,QAAQ,GAAG2O,CAAI;AACxD3O,EAAQ,UAAUkD;AAElB,MAAM,EAAC,QAAQob,IAAU,MAAMC,IAAQ,OAAOC,IAAS,QAAQC,IAAU,OAAOC,GAAO,IAAI1e;AAS3F,MAAM2e,GAAU;AAAA,EAKZ,YAAYC,GAAkB;AAC1B,SAAK,SAASA;AAAA,EACjB;AAAA,EAGD,IAAI,mBAAmB;AACnB,WAAO,KAAK;AAAA,EACf;AAAA,EAED,OAAO,aAAaA,GAAkB7O,GAAO;AACzC,UAAMlB,IAAI,IAAI4P,GAASG,EAAiB,IAAI7O,CAAK,GAC3C8O,IAAKD,EAAiB,IAAIA,EAAiB,GAC3CE,IAAOjQ,EAAE,IAAIA,CAAC;AAIpB,WAHwB6P,GAAQ,KAAKI,CAAI,IACrC,IAAIN,GAAQ,OAAO,mBAAmB,OAAO,iBAAiB,IAC9DI,EAAiB,GAAG,UAAU/P,EAAE,SAASgQ,IAAKC,CAAI,CAAC;AAAA,EAE1D;AAAA,EAED,OAAO,cAAcF,GAAkBzT,GAAQ;AAC3C,UAAM1C,IAAOmW,EAAiB,GAAG,WAAWzT,EAAO,EAAE,EAAE;AACvD,QAAIuT,GAAQ,GAAGjW,GAAM0C,EAAO,CAAC,GAAG;AAC5B,UAAI0H,IAAK+L,EAAiB,IAAIA,EAAiB,KAAM,IAAIzT,EAAO,IAC5D0D,IAAI,IAAI4P,GAASG,EAAiB,IAAIzT,EAAO,EAAE;AACnD,MAAA0D,IAAIA,EAAE;AACN,UAAI1N,IAAKyd,EAAiB,GAAG,UAAU/P,EAAE,SAASgE,CAAC,CAAC;AAEpD,aAAO,IAAI0L,GAAOpd,GAAI0N,CAAC;AAAA,IACnC,OAAe;AAEH,UAAIA,IAAI,IAAI4P,GAASG,EAAiB,IAAIzT,EAAO,EAAE,GAC/C4T,IAAIH,EAAiB,IAAIA,EAAiB,KAAK/P,EAAE,IAAIA,CAAC,IAAI1D,EAAO,IAAIA,EAAO,IAC5EgO,IAAKyF,EAAiB,GAAG,UAAU/P,EAAE,SAASkQ,CAAC,CAAC,GAChD5H,IAAI,KAAK,IAAI4H,CAAC,IAAI5T,EAAO;AAE7B,aAAO,IAAImT,GAASnF,GAAIhC,CAAC;AAAA,IAC5B;AAAA,EACJ;AAAA,EAED,OAAO,YAAYyH,GAAkBzc,GAAM;AACvC,UAAM,CAACsG,GAAM6D,CAAgB,IAAIsS,EAAiB,GAAG,WAAWzc,CAAI;AACpE,QAAIuc,GAAQ,KAAKjW,CAAI;AACjB,aAAOtG,EAAK;AACT;AACH,UAAIgV,IAAIyH,EAAiB,IAAIA,EAAiB,KAAK,IAAInW,IACnDoG,IAAI,IAAI4P,GAASG,EAAiB,IAAItS,EAAiB,GAAG;AAC9D,aAAAuC,IAAIA,EAAE,SAASsI,IAAI1O,CAAI,GAChB,IAAI6V,GAASM,EAAiB,GAAG,UAAU/P,CAAC,GAAGsI,CAAC;AAAA,IAC1D;AAAA,EACJ;AAAA,EAED,QAAQ3I,GAAO;AACX,QAAIA,aAAiBgQ;AACjB,aAAOG,GAAU,aAAa,KAAK,QAAQnQ,CAAK;AAE/C,QAAIA,aAAiB8P;AACtB,aAAOK,GAAU,cAAc,KAAK,QAAQnQ,CAAK;AAEhD,QAAIA,aAAiB+P;AACtB,aAAOI,GAAU,YAAY,KAAK,QAAQnQ,CAAK;AAAA,EAEtD;AACL;AACAxO,EAAQ,YAAY2e;AAOpB,MAAMK,KAAY,CAAC7T,MAAW,IAAInL,EAAQ,UAAUmL,CAAM;AAC1DnL,EAAQ,YAAYgf;AAEpB,MAAMC,EAAS;AAAA,EAOX,OAAO,YAAYjG,GAAKC,GAAK;AACzB,WAAOD,EAAI,WAAWC,CAAG;AAAA,EAC5B;AAAA,EAQD,OAAO,WAAW9X,GAAIgB,GAAM;AACxB,QAAI+c,IAAgB/d,EAAG,aAAagB,CAAI;AAExC,WAAO,CADG,IAAInC,EAAQ,OAAOmB,GAAI+d,CAAa,EAClC,QAAQ,IAAIlf,EAAQ,QAAQmB,GAAI+d,CAAa,CAAC;AAAA,EAC7D;AAAA,EAQD,OAAO,aAAa/d,GAAIgK,GAAQ;AAC5B,QAAI,CAACgU,GAAaC,CAAa,IAAIje,EAAG,WAAWgK,EAAO,MAAM;AAC9D,QAAInL,EAAQ,MAAM,KAAKmf,CAAW;AAC9B,aAAO,CAAChU,EAAO,GAAG,IAAInL,EAAQ,QAAQmB,GAAIgK,EAAO,QAAQ,KAAK,CAAC;AAC5D;AACH,UAAI1C,IAAO,KAAK,IAAI0W,IAAchU,EAAO,CAAC,GACtC0D,IAAI,IAAI7O,EAAQ,OAAOmL,EAAO,IAAIhK,CAAE,EAAE,UAAS,EAAG,SAASgK,EAAO,CAAC,GACnE+T,IAAgB/T,EAAO,GAAG,UAAU0D,CAAC;AACzC,aAAO,CAACpG,GAAM,IAAIzI,EAAQ,QAAQmB,GAAI+d,CAAa,CAAC;AAAA,IACvD;AAAA,EACJ;AAAA,EAQD,OAAO,cAAc/d,GAAIuH,GAAS;AAE9B,QAAIA,EAAQ,MAAM,QAAQA,EAAQ,GAAG;AACjC,aAAOuW,EAAS,YAAY9d,GAAIuH,EAAQ,KAAK;AAGjD,QAAI2W,IAAQ,IAAIrf,EAAQ,OAAO0I,EAAQ,OAAOA,EAAQ,GAAG,GACrD4W,IAAU,IAAItf,EAAQ,OAAO0I,EAAQ,OAAOvH,CAAE,GAC9Coe,IAAU,IAAIvf,EAAQ,OAAO0I,EAAQ,KAAKvH,CAAE,GAC5Cqe,IAAWH,EAAM,IAAIC,CAAO,GAE5BG,IAAS,CAACJ,EAAM,IAAIE,CAAO,GAG3B9W,GACAyW;AACJ,QAAIlf,EAAQ,MAAM,GAAGwf,GAAU,CAAC,KAAKxf,EAAQ,MAAM,GAAGyf,GAAQ,CAAC,GAAG;AAC9D,UAAIC,IAAShX,EAAQ;AAErB,aAAAD,IAAO,KAAK,IAAIiX,EAAO,MAAMJ,CAAO,CAAC,GAErCJ,IAAgBxW,EAAQ,MAAM,UAAUgX,EAAO,SAASA,EAAO,IAAIJ,CAAO,CAAC,CAAC,GACrE,CAAC7W,GAAM,IAAIzI,EAAQ,QAAQmB,GAAI+d,CAAa,CAAC;AAAA,IAChE;AAAe,aAAIM,IAAW,IACXre,EAAG,WAAWuH,EAAQ,KAAK,IAE3BvH,EAAG,WAAWuH,EAAQ,GAAG;AAAA,EAEvC;AAAA,EAQD,OAAO,UAAUvH,GAAI4K,GAAK;AACtB,QAAIZ,IAAS,IAAInL,EAAQ,OAAO+L,EAAI,IAAIA,EAAI,CAAC,GACzC4T,IAAmB,CAAA,GACnBlX,GAAM6D;AACV,YAAC7D,GAAM6D,CAAgB,IAAI2S,EAAS,aAAa9d,GAAIgK,CAAM,GACvDmB,EAAiB,IAAI,GAAGP,CAAG,KAC3B4T,EAAiB,KAAKV,EAAS,aAAa9d,GAAIgK,CAAM,CAAC,GAE3DwU,EAAiB,KAAKV,EAAS,YAAY9d,GAAI4K,EAAI,KAAK,CAAC,GACzD4T,EAAiB,KAAKV,EAAS,YAAY9d,GAAI4K,EAAI,GAAG,CAAC,GAEvDkT,EAAS,KAAKU,CAAgB,GAEvBA,EAAiB;AAAA,EAC3B;AAAA,EAQD,OAAO,aAAajU,GAAKvJ,GAAM;AAC3B,QAAIL,IAAK4J,EAAI,UAAUvJ,CAAI;AAC3B,QAAIL,EAAG,SAAS;AACZ,aAAO,CAAC,GAAG,IAAI9B,EAAQ,QAAQ8B,EAAG,IAAIA,EAAG,EAAE,CAAC;AAEhD,QAAI6d,IAAmB,CAAA;AACvB,WAAAA,EAAiB,KAAKV,EAAS,WAAWvT,EAAI,OAAOvJ,CAAI,CAAC,GAC1Dwd,EAAiB,KAAKV,EAAS,WAAWvT,EAAI,KAAKvJ,CAAI,CAAC,GAExD8c,EAAS,KAAKU,CAAgB,GACvBA,EAAiB;AAAA,EAE3B;AAAA,EAQD,OAAO,gBAAgBzT,GAAMC,GAAM;AAC/B,QAAIrK,IAAKmK,GAAyBC,GAAMC,CAAI;AAC5C,QAAIrK,EAAG,SAAS;AACZ,aAAO,CAAC,GAAG,IAAI9B,EAAQ,QAAQ8B,EAAG,IAAIA,EAAG,EAAE,CAAC;AAIhD,QAAI6d,IAAmB,CAAA,GACnBC,GAAUC;AACd,YAACD,GAAUC,CAAoB,IAAIZ,EAAS,cAAc9S,EAAK,OAAOD,CAAI,GAC1EyT,EAAiB,KAAK,CAACC,GAAUC,EAAqB,QAAS,CAAA,CAAC,GAChE,CAACD,GAAUC,CAAoB,IAAIZ,EAAS,cAAc9S,EAAK,KAAKD,CAAI,GACxEyT,EAAiB,KAAK,CAACC,GAAUC,EAAqB,QAAS,CAAA,CAAC,GAChEF,EAAiB,KAAKV,EAAS,cAAc/S,EAAK,OAAOC,CAAI,CAAC,GAC9DwT,EAAiB,KAAKV,EAAS,cAAc/S,EAAK,KAAKC,CAAI,CAAC,GAE5D8S,EAAS,KAAKU,CAAgB,GACvBA,EAAiB;AAAA,EAC3B;AAAA,EAQD,OAAO,eAAejU,GAAKP,GAAQ;AAE/B,QAAIrJ,IAAK4J,EAAI,UAAUP,CAAM;AAC7B,QAAIrJ,EAAG,SAAS;AACZ,aAAO,CAAC,GAAG,IAAI9B,EAAQ,QAAQ8B,EAAG,IAAIA,EAAG,EAAE,CAAC;AAQhD,QAAIK,IAAO,IAAInC,EAAQ,KAAK0L,EAAI,IAAIA,EAAI,EAAE,GACtC,CAACjD,GAAM6D,CAAgB,IAAI2S,EAAS,WAAW9T,EAAO,QAAQhJ,CAAI;AACtE,QAAInC,EAAQ,MAAM,GAAGyI,GAAM0C,EAAO,CAAC,KAAKmB,EAAiB,IAAI,GAAGZ,CAAG;AAC/D,aAAOuT,EAAS,aAAa3S,EAAiB,KAAKnB,CAAM;AAGxD;AACD,UAAI,CAAC2U,GAAiBC,CAA2B,IAAId,EAAS,aAAavT,EAAI,OAAOP,CAAM,GACxF,CAAC6U,GAAeC,CAAyB,IAAIhB,EAAS,aAAavT,EAAI,KAAKP,CAAM;AACtF,aAAOnL,EAAQ,MAAM,GAAG8f,GAAiBE,CAAa,IAClD,CAACF,GAAiBC,CAA2B,IAC7C,CAACC,GAAeC,CAAyB;AAAA,IAChD;AAAA,EACJ;AAAA,EAQD,OAAO,YAAYvU,GAAKK,GAAK;AAEzB,QAAIjK,IAAK4J,EAAI,UAAUK,CAAG;AAC1B,QAAIjK,EAAG,SAAS;AACZ,aAAO,CAAC,GAAG,IAAI9B,EAAQ,QAAQ8B,EAAG,IAAIA,EAAG,EAAE,CAAC;AAIhD,QAAIK,IAAO,IAAInC,EAAQ,KAAK0L,EAAI,IAAIA,EAAI,EAAE,GACtCP,IAAS,IAAInL,EAAQ,OAAO+L,EAAI,IAAIA,EAAI,CAAC,GAMzC,CAACmU,GAAkBC,CAA4B,IAAIlB,EAAS,WAAW9T,EAAO,QAAQhJ,CAAI;AAC9F,QAAInC,EAAQ,MAAM,GAAGkgB,GAAkB/U,EAAO,CAAC,KAAKgV,EAA6B,IAAI,GAAGzU,CAAG,GAAG;AAC1F,UAAI,CAAC0U,GAAsBC,CAAgC,IACvDpB,EAAS,aAAakB,EAA6B,KAAKhV,CAAM;AAClE,UAAIkV,EAAiC,IAAI,GAAGtU,CAAG;AAC3C,eAAO,CAACqU,GAAsBC,CAAgC;AAAA,IAErE;AAED,QAAIV,IAAmB,CAAA;AACvB,IAAAA,EAAiB,KAAKV,EAAS,UAAUvT,EAAI,OAAOK,CAAG,CAAC,GACxD4T,EAAiB,KAAKV,EAAS,UAAUvT,EAAI,KAAKK,CAAG,CAAC;AAEtD,QAAI6T,GAAUU;AACd,YAACV,GAAUU,CAAW,IAAIrB,EAAS,cAAclT,EAAI,OAAOL,CAAG,GAC/DiU,EAAiB,KAAK,CAACC,GAAUU,EAAY,QAAS,CAAA,CAAC,GAEvD,CAACV,GAAUU,CAAW,IAAIrB,EAAS,cAAclT,EAAI,KAAKL,CAAG,GAC7DiU,EAAiB,KAAK,CAACC,GAAUU,EAAY,QAAS,CAAA,CAAC,GAEvDrB,EAAS,KAAKU,CAAgB,GACvBA,EAAiB;AAAA,EAC3B;AAAA,EAQD,OAAO,cAAcjT,GAASC,GAAS;AACnC,QAAI7K,IAAK4K,EAAQ,UAAUC,CAAO;AAClC,QAAI7K,EAAG,SAAS;AACZ,aAAO,CAAC,GAAG,IAAI9B,EAAQ,QAAQ8B,EAAG,IAAIA,EAAG,EAAE,CAAC;AAIhD,QAAI4K,EAAQ,OAAO,QAAQC,EAAQ,MAAM,GAAG;AACxC,UAAIS,IAAOV,EAAQ,SACfW,IAAOV,EAAQ;AACnB,aAAOsS,EAAS,YAAY7R,EAAK,OAAOC,EAAK,KAAK;AAAA,IAC9D,OAAe;AAEH,UAAIlL,IAAO,IAAInC,EAAQ,KAAK0M,EAAQ,QAAQC,EAAQ,MAAM,GACtD3K,IAAMG,EAAK,UAAUuK,CAAO,GAC5BzK,IAAME,EAAK,UAAUwK,CAAO,GAE5BgT,IAAmB,CAAA;AAEvB,aAAAA,EAAiB,KAAKV,EAAS,YAAYjd,EAAI,IAAIC,EAAI,EAAE,CAAC,GAC1D0d,EAAiB,KAAKV,EAAS,YAAYjd,EAAI,IAAIC,EAAI,EAAE,CAAC,GAC1D0d,EAAiB,KAAKV,EAAS,YAAYjd,EAAI,IAAIC,EAAI,EAAE,CAAC,GAC1D0d,EAAiB,KAAKV,EAAS,YAAYjd,EAAI,IAAIC,EAAI,EAAE,CAAC,GAE1Dgd,EAAS,KAAKU,CAAgB,GACvBA,EAAiB;AAAA,IAC3B;AAAA,EACJ;AAAA,EAQD,OAAO,YAAYxU,GAAQhJ,GAAM;AAC7B,QAAIL,IAAKqJ,EAAO,UAAUhJ,CAAI;AAC9B,QAAIL,EAAG,SAAS;AACZ,aAAO,CAAC,GAAG,IAAI9B,EAAQ,QAAQ8B,EAAG,IAAIA,EAAG,EAAE,CAAC;AAGhD,QAAI,CAACoe,GAAkBC,CAA4B,IAAIlB,EAAS,WAAW9T,EAAO,QAAQhJ,CAAI,GAC1F,CAACsG,GAAM6D,CAAgB,IAAI2S,EAAS,aAAakB,EAA6B,KAAKhV,CAAM;AAC7F,WAAAmB,IAAmBA,EAAiB,WAC7B,CAAC7D,GAAM6D,CAAgB;AAAA,EACjC;AAAA,EAQD,OAAO,SAASP,GAAK5J,GAAM;AAEvB,QAAIL,IAAKK,EAAK,UAAU4J,CAAG;AAC3B,QAAIjK,EAAG,SAAS;AACZ,aAAO,CAAC,GAAG,IAAI9B,EAAQ,QAAQ8B,EAAG,IAAIA,EAAG,EAAE,CAAC;AAGhD,QAAIqJ,IAAS,IAAInL,EAAQ,OAAO+L,EAAI,QAAQA,EAAI,CAAC,GAM7C,CAACmU,GAAkBC,CAA4B,IAAIlB,EAAS,WAAW9T,EAAO,QAAQhJ,CAAI;AAC9F,QAAInC,EAAQ,MAAM,GAAGkgB,GAAkB/U,EAAO,CAAC,GAAG;AAC9C,UAAI,CAACiV,GAAsBC,CAAgC,IACvDpB,EAAS,aAAakB,EAA6B,KAAKhV,CAAM;AAClE,UAAIkV,EAAiC,IAAI,GAAGtU,CAAG;AAC3C,eAAO,CAACqU,GAAsBC,CAAgC;AAAA,IAE9E,OAAe;AACH,UAAIV,IAAmB,CAAA;AACvB,aAAAA,EAAiB,KAAKV,EAAS,WAAWlT,EAAI,OAAO5J,CAAI,CAAC,GAC1Dwd,EAAiB,KAAKV,EAAS,WAAWlT,EAAI,KAAK5J,CAAI,CAAC,GAExD8c,EAAS,KAAKU,CAAgB,GACvBA,EAAiB;AAAA,IAC3B;AAAA,EACJ;AAAA,EAQD,OAAO,WAAW5T,GAAKY,GAAS;AAC5B,QAAI7K,IAAKiK,EAAI,UAAUY,CAAO;AAC9B,QAAI7K,EAAG,SAAS;AACZ,aAAO,CAAC,GAAG,IAAI9B,EAAQ,QAAQ8B,EAAG,IAAIA,EAAG,EAAE,CAAC;AAGhD,QAAI4K,IAAU,IAAI1M,EAAQ,OAAO+L,EAAI,QAAQA,EAAI,CAAC,GAE9C,CAACtD,GAAM6D,CAAgB,IAAI2S,EAAS,cAAcvS,GAASC,CAAO;AACtE,QAAIL,EAAiB,MAAM,GAAGP,CAAG;AAC7B,aAAO,CAACtD,GAAM6D,CAAgB;AAC3B;AACH,UAAIqT,IAAmB,CAAA;AAEvB,aAAAA,EAAiB,KAAKV,EAAS,aAAalT,EAAI,OAAOY,CAAO,CAAC,GAC/DgT,EAAiB,KAAKV,EAAS,aAAalT,EAAI,KAAKY,CAAO,CAAC,GAE7DsS,EAAS,KAAKU,CAAgB,GAEvBA,EAAiB;AAAA,IAC3B;AAAA,EACJ;AAAA,EAQD,OAAO,QAAQvS,GAAMC,GAAM;AACvB,QAAIvL,IAAKsL,EAAK,UAAUC,CAAI;AAC5B,QAAIvL,EAAG,SAAS;AACZ,aAAO,CAAC,GAAG,IAAI9B,EAAQ,QAAQ8B,EAAG,IAAIA,EAAG,EAAE,CAAC;AAGhD,QAAI4K,IAAU,IAAI1M,EAAQ,OAAOoN,EAAK,QAAQA,EAAK,CAAC,GAChDT,IAAU,IAAI3M,EAAQ,OAAOqN,EAAK,QAAQA,EAAK,CAAC,GAEhD,CAAC5E,GAAM6D,CAAgB,IAAI2S,EAAS,cAAcvS,GAASC,CAAO;AACtE,QAAIL,EAAiB,MAAM,GAAGc,CAAI,KAAKd,EAAiB,IAAI,GAAGe,CAAI;AAC/D,aAAO,CAAC5E,GAAM6D,CAAgB;AAC3B;AACH,UAAIqT,IAAmB,CAAA,GAEnBC,GAAUU;AAEd,cAACV,GAAUU,CAAW,IAAIrB,EAAS,UAAU7R,EAAK,OAAOC,CAAI,GACzDiT,EAAY,IAAI,GAAGjT,CAAI,KACvBsS,EAAiB,KAAK,CAACC,GAAUU,CAAW,CAAC,GAGjD,CAACV,GAAUU,CAAW,IAAIrB,EAAS,UAAU7R,EAAK,KAAKC,CAAI,GACvDiT,EAAY,IAAI,GAAGjT,CAAI,KACvBsS,EAAiB,KAAK,CAACC,GAAUU,CAAW,CAAC,GAGjD,CAACV,GAAUU,CAAW,IAAIrB,EAAS,UAAU5R,EAAK,OAAOD,CAAI,GACzDkT,EAAY,IAAI,GAAGlT,CAAI,KACvBuS,EAAiB,KAAK,CAACC,GAAUU,EAAY,QAAS,CAAA,CAAC,GAG3D,CAACV,GAAUU,CAAW,IAAIrB,EAAS,UAAU5R,EAAK,KAAKD,CAAI,GACvDkT,EAAY,IAAI,GAAGlT,CAAI,KACvBuS,EAAiB,KAAK,CAACC,GAAUU,EAAY,QAAS,CAAA,CAAC,GAG3D,CAACV,GAAUU,CAAW,IAAIrB,EAAS,YAAY7R,EAAK,OAAOC,EAAK,KAAK,GACrEsS,EAAiB,KAAK,CAACC,GAAUU,CAAW,CAAC,GAE7C,CAACV,GAAUU,CAAW,IAAIrB,EAAS,YAAY7R,EAAK,OAAOC,EAAK,GAAG,GACnEsS,EAAiB,KAAK,CAACC,GAAUU,CAAW,CAAC,GAE7C,CAACV,GAAUU,CAAW,IAAIrB,EAAS,YAAY7R,EAAK,KAAKC,EAAK,KAAK,GACnEsS,EAAiB,KAAK,CAACC,GAAUU,CAAW,CAAC,GAE7C,CAACV,GAAUU,CAAW,IAAIrB,EAAS,YAAY7R,EAAK,KAAKC,EAAK,GAAG,GACjEsS,EAAiB,KAAK,CAACC,GAAUU,CAAW,CAAC,GAE7CrB,EAAS,KAAKU,CAAgB,GAEvBA,EAAiB;AAAA,IAC3B;AAAA,EACJ;AAAA,EAQD,OAAO,cAAc5P,GAAO7M,GAAS;AACjC,QAAIib,IAAuB,CAAC,OAAO,mBAAmB,IAAIne,EAAQ,QAAO,CAAE;AAC3E,aAASM,KAAQ4C,EAAQ,OAAO;AAC5B,UAAI,CAACuF,GAAM6D,CAAgB,IAAKhM,EAAK,iBAAiBN,EAAQ,UAC1Dif,EAAS,cAAclP,GAAOzP,EAAK,KAAK,IAAI2e,EAAS,UAAUlP,GAAOzP,EAAK,KAAK;AACpF,MAAIN,EAAQ,MAAM,GAAGyI,GAAM0V,EAAqB,EAAE,MAC9CA,IAAuB,CAAC1V,GAAM6D,CAAgB;AAAA,IAErD;AACD,WAAO6R;AAAA,EACV;AAAA,EAED,OAAO,cAAc3P,GAAOtL,GAAS;AACjC,QAAIib,IAAuB,CAAC,OAAO,mBAAmB,IAAIne,EAAQ,QAAO,CAAE;AAC3E,aAASM,KAAQ4C,EAAQ,OAAO;AAC5B,UAAI,CAACuF,GAAM6D,CAAgB,IAAIkC,EAAM,WAAWlO,EAAK,KAAK;AAC1D,MAAIN,EAAQ,MAAM,GAAGyI,GAAM0V,EAAqB,EAAE,MAC9CA,IAAuB,CAAC1V,GAAM6D,CAAgB;AAAA,IAErD;AACD,WAAO6R;AAAA,EACV;AAAA,EAQD,OAAO,gBAAgBxY,GAAUC,GAAU;AACvC,QAAIuY,IAAuB,CAAC,OAAO,mBAAmB,IAAIne,EAAQ,QAAO,CAAE;AAC3E,aAAS2H,KAAShC,EAAS;AACvB,eAASkC,KAASjC,EAAS,OAAO;AAC9B,YAAI,CAAC6C,GAAM6D,CAAgB,IAAI3E,EAAM,MAAM,WAAWE,EAAM,KAAK;AACjE,QAAI7H,EAAQ,MAAM,GAAGyI,GAAM0V,EAAqB,EAAE,MAC9CA,IAAuB,CAAC1V,GAAM6D,CAAgB;AAAA,MAErD;AAEL,WAAO6R;AAAA,EACV;AAAA,EAgBD,OAAO,eAAejD,GAAMC,GAAM;AAC9B,QAAIoF,IAAY,KAAK,IAAI,KAAK,IAAIrF,EAAK,OAAOC,EAAK,MAAM,CAAC,GAAG,KAAK,IAAIA,EAAK,OAAOD,EAAK,MAAM,CAAC,CAAC,GAC3FsF,IAAY,KAAK,IAAI,KAAK,IAAItF,EAAK,OAAOC,EAAK,MAAM,CAAC,GAAG,KAAK,IAAIA,EAAK,OAAOD,EAAK,MAAM,CAAC,CAAC,GAC3FuF,IAAUF,IAAYA,IAAYC,IAAYA,GAE9ChV,IAAM0P,EAAK,MAAMC,CAAI,GACrBlE,IAAKzL,EAAI,OAAOA,EAAI,MACpB0L,IAAK1L,EAAI,OAAOA,EAAI,MACpBkV,IAAUzJ,IAAKA,IAAKC,IAAKA;AAE7B,WAAO,CAACuJ,GAASC,CAAO;AAAA,EAC3B;AAAA,EAED,OAAO,0BAA0BlS,GAAOmS,GAAOvC,GAAU5I,GAAM;AAI3D,QAAIiL,GAASC;AACb,aAAS1L,KAAQ2L;AAOb,OAACF,GAASC,CAAO,IAAIzB,EAAS,eAAezQ,EAAM,KAAKwG,EAAK,KAAK,GAAG,GACjEA,EAAK,KAAK,iBAAiBhV,EAAQ,OACnCwV,EAAK,OAAO,CAACiL,GAASC,CAAO,GAAG1L,EAAK,KAAK,MAAM,KAAK,IAErDQ,EAAK,OAAO,CAACiL,GAASC,CAAO,GAAG1L,EAAK,KAAK,KAAK,GAE/ChV,EAAQ,MAAM,GAAG0gB,GAAStC,CAAQ,MAClCA,IAAWsC;AAInB,QAAIC,EAAM,WAAW;AACjB,aAAOvC;AAGX,QAAIwC,IAAiBD,EAAM,IAAI,CAAA3L,MAAQA,EAAK,KAAK,MAAK,IAAK,SAAYA,EAAK,IAAI,EAAE,OAAO,CAAAA,MAAQA,MAAS,MAAS,GAC/G6L,IAAkBF,EAAM,IAAI,CAAA3L,MAAQA,EAAK,MAAM,MAAK,IAAK,SAAYA,EAAK,KAAK,EAAE,OAAO,CAAAA,MAAQA,MAAS,MAAS,GAElH8L,IAAY,CAAC,GAAGF,GAAgB,GAAGC,CAAe,EAAE,OAAO,CAAA7L,MAAQ;AAEnE,UAAI,CAACyL,GAASC,CAAO,IAAIzB,EAAS,eAAezQ,EAAM,KAAKwG,EAAK,GAAG;AACpE,aAAQhV,EAAQ,MAAM,GAAGygB,GAASrC,CAAQ;AAAA,IACtD,CAAS;AAED,WAAAA,IAAWa,EAAS,0BAA0BzQ,GAAOsS,GAAW1C,GAAU5I,CAAI,GACvE4I;AAAA,EACV;AAAA,EAQD,OAAO,YAAY5P,GAAOuS,GAAK3C,GAAU;AACrC,QAAI5I,IAAO,IAAIX,MACX8L,IAAQ,CAACI,EAAI,MAAM,IAAI,GACvBC,IAAmB5C,IAAW,OAAO,oBAAoBA,IAAWA,IAAW,OAAO;AAC1F,WAAA4C,IAAmB/B,EAAS,0BAA0BzQ,GAAOmS,GAAOK,GAAkBxL,CAAI,GACnFA;AAAA,EACV;AAAA,EAED,OAAO,0BAA0BhH,GAAOwG,GAAMmJ,GAAsB;AAChE,QAAI8C,GAA0BC;AAC9B,QAAIlM,KAAQ,QAAQ,CAACA,EAAK,MAAK,GAAI;AAG/B,UAFA,CAACiM,GAA0BC,CAAI,IAAIjC,EAAS,0BAA0BzQ,GAAOwG,EAAK,MAAMmJ,CAAoB,GAExG+C;AACA,eAAO,CAACD,GAA0BC,CAAI;AAG1C,UAAIlhB,EAAQ,MAAM,GAAGihB,EAAyB,IAAI,KAAK,KAAKjM,EAAK,KAAK,IAAI,GAAG,CAAC;AAC1E,eAAO,CAACiM,GAA0B,EAAI;AAG1C,UAAI,CAACxY,GAAM6D,CAAgB,IAAI2S,EAAS,SAASzQ,GAAOwG,EAAK,KAAK,KAAK;AAEvE,aAAIhV,EAAQ,MAAM,GAAGyI,GAAMwY,EAAyB,EAAE,MAClDA,IAA2B,CAACxY,GAAM6D,CAAgB,IAGtD,CAAC2U,GAA0BC,CAAI,IAAIjC,EAAS,0BAA0BzQ,GAAOwG,EAAK,OAAOiM,CAAwB,GAE1G,CAACA,GAA0BC,CAAI;AAAA,IACzC;AAED,WAAO,CAAC/C,GAAsB,EAAK;AAAA,EACtC;AAAA,EASD,OAAO,gBAAgB3P,GAAOuS,GAAK3C,IAAW,OAAO,mBAAmB;AACpE,QAAID,IAAuB,CAACC,GAAU,IAAIpe,EAAQ,QAAS,CAAA,GACvDkhB,IAAO;AACX,QAAIH,aAAe/gB,EAAQ,WAAW;AAClC,UAAIwV,IAAOyJ,EAAS,YAAYzQ,GAAOuS,GAAK3C,CAAQ;AACpD,OAACD,GAAsB+C,CAAI,IAAIjC,EAAS,0BAA0BzQ,GAAOgH,EAAK,MAAM2I,CAAoB;AAAA,IAC3G;AACD,WAAOA;AAAA,EACV;AAAA,EAED,OAAO,KAAKwB,GAAkB;AAC1B,IAAAA,EAAiB,KAAK,CAACwB,GAAIC,MACnBphB,EAAQ,MAAM,GAAGmhB,EAAG,IAAIC,EAAG,EAAE,IACtB,KAEPphB,EAAQ,MAAM,GAAGmhB,EAAG,IAAIC,EAAG,EAAE,IACtB,IAEJ,CACV;AAAA,EACJ;AAAA,EAED,OAAO,SAASnT,GAAQC,GAAQ;AAC5B,WAAOD,EAAO,WAAWC,CAAM;AAAA,EAClC;AACL;AAEAlO,EAAQ,WAAWif;AAMnBjf,EAAQ,oBAAoB6J;AAC5B7J,EAAQ,YAAY0S;AC73QpB,MAAOM,KAAShT,EAAQ,QAIlBqhB,KAAe,IACfC,KAAsB,IAKfC,IAAN,cACKC,GAAK;AAAA,EAkDb,YAAYC,GAA0BC,GAA8B;AAIhE,QAHM,SAEDC,GAAA,WAAW,MAAMD,CAAO,GACzBD,KAAU;AACV,YAAM,MAAM,iBAAiB;AAEjC,IAAAC,IAAUA,KAAW,IAChB,KAAA,UAAUE,GAAE,OAAOH,CAAM,GAC9B,KAAK,WAAWC,EAAQ,SACxB,KAAK,UAAUA,EAAQ,QACvB,KAAK,SAASA,EAAQ,OACjB,KAAA,iBAAiBA,EAAQ,YAAY;AAAA,EAC9C;AAAA,EASU,WAAW;AACZ,SAAA,sBAAsB,KAAK,4BAC3B,KAAA,uBAAuB,KAAK;AAE3B,UAAAG,IAAS,IAAIC;AACnB,aAASlf,IAAI,GAAGA,IAAI,KAAK,oBAAoB,QAAQA,KAAK;AAChD,YAAAmN,IAAQ,KAAK,oBAAoBnN;AACvC,MAAAif,EAAO,OAAO9R,CAAK;AAAA,IACvB;AACI,QAAA,KAAK,yBAAyB;AAC9B,eAASnN,IAAI,GAAGA,IAAI,KAAK,qBAAqB,QAAQA,KAAK;AACjD,cAAAmN,IAAQ,KAAK,oBAAoBnN;AACvC,QAAAif,EAAO,OAAO9R,CAAK;AAAA,MACvB;AAEJ,SAAK,iBAAiB8R,GACtB,KAAK,uBAAuB,IAAIE;AAAA,MAC5B,KAAK,KAAK,mBAAmBF,EAAO,eAAe;AAAA,MACnD,KAAK,KAAK,mBAAmBA,EAAO,aAAa;AAAA,IAAA;AAAA,EAEzD;AAAA,EAOU,UAAU;AACZ,QAAA,CAAC,KAAK;AACN;AAEJ,QAAIG,IAAWT,EAAY,WAAW,KAAK,qBAAqB,EAAI;AAChE,IAAA,KAAK,yBAAyB,WAC9BS,KAAY,MAAMT,EAAY,WAAW,KAAK,sBAAsB,EAAK,IAE7E,KAAK,WAAW,EAAE,aAAa,KAAKS,CAAQ;AAAA,EAChD;AAAA,EASQ,iBAAiBC,GAAwC;AAC7D,SAAK,gBAAgBA,KAAgB;AAAA,MACjC,YAAYX;AAAAA,MACZ,iBAAiBC,EAAY;AAAA,IAAA,GAE7B,KAAK,cAAc,eAAe,WAClC,KAAK,cAAc,aAAaD,KAEhC,KAAK,cAAc,oBAAoB,WAClC,KAAA,cAAc,kBAAkBC,EAAY,oBAEjD,KAAK,cAAc,oBAAoB,UAClC,KAAA,cAAc,gBACd,KAAK,CAACxU,GAAG6F,MAAMA,EAAE,eAAe7F,EAAE,YAAY;AAAA,EAE3D;AAAA,EAUO,UAAU0U,GAAgC;AAC7C,UAAMS,IAAY,KAAK;AAClB,gBAAA,UAAUN,GAAE,OAAOH,CAAM,GAC9B,KAAK,KAAK,QAAQ;AAAA,MACd,WAAAS;AAAA,MACA,QAAQ,KAAK;AAAA,IAAA,CAChB,GACM,KAAK;EAChB;AAAA,EAQO,WAAWC,GAAmC;AACjD,gBAAK,WAAWA,GACT,KAAK;EAChB;AAAA,EAQO,UAAUC,GAAkC;AAC/C,gBAAK,UAAUA,GACR,KAAK;EAChB;AAAA,EAQO,SAASC,GAAiC;AAC7C,gBAAK,SAASA,GACP,KAAK;EAChB;AAAA,EAQO,gBAAgBJ,GAAkC;AACrD,gBAAK,iBAAiBA,CAAY,GAC3B,KAAK;EAChB;AAAA,EAOO,YAA0B;AAC7B,WAAO,KAAK;AAAA,EAChB;AAAA,EAOO,YAAoB;AACvB,WAAO,KAAK;AAAA,EAChB;AAAA,EAOO,WAA+B;AAClC,WAAO,KAAK;AAAA,EAChB;AAAA,EAOO,aAAiC;AACpC,WAAO,KAAK;AAAA,EAChB;AAAA,EAOO,YAAgC;AACnC,WAAO,KAAK;AAAA,EAChB;AAAA,EASA,OAAc,YAAYlG,GAAgBtF,GAAqB;AACpD,WAAA;AAAA,MACH,QAAAsF;AAAA,MACA,QAAQtF;AAAA,MACR,SAASA;AAAA,MACT,OAAO;AAAA,IAAA;AAAA,EAEf;AAAA,EAQA,OAAc,eAAeA,GAAwB;AAC1C,WAAA;AAAA,MACH,aAAa8K,EAAY,YAAYA,EAAY,8BAA8B9K,CAAI;AAAA,MACnF,gBAAgB8K,EAAY,YAAYA,EAAY,gCAAgC9K,CAAI;AAAA,IAAA;AAAA,EAEhG;AAAA,EAQQ,cAAcvW,GAAe;AACjC,WAAQA,IAAQ,WAAY;AAAA,EAChC;AAAA,EAQQ,cAAcA,GAAe;AACxB,WAAAA,IAAQ,WAAY,MAAO,KAAK,IAAK,KAAK,KAAK,MAAO,KAAK,QAAQ,GAAG;AAAA,EACnF;AAAA,EAQQ,uBAAuBoiB,GAA4B;AAChD,WAAAA,IAAa,KAAK,KAAK;AAAA,EAClC;AAAA,EAOQ,wBAA6C;AACjD,QAAK,KAAK,YAAY,UAAe,KAAK,WAAW;AAC1C;AAEX,UAAMtT,IAAQ,KAAK,uBAAuB,KAAK,OAAO,GAChDuT,IAAe,KAAK,SAAS,KAAK,cAAc,YAChDC,IAAkB,KAAK,oBAAoB,KAAK,SAASD,GAAcvT,CAAK;AAClF,WAAO,KAAK,sBAAsB,KAAK,SAASwT,CAAe;AAAA,EACnE;AAAA,EAUQ,oBAAoBf,GAAgB3I,GAAkB9J,GAAuB;AACjF,WAAO,IAAIyT;AAAA,MACPhB,EAAO,MAAM,KAAK,cAAc3I,IAAW,KAAK,IAAI9J,CAAK,CAAC;AAAA,MAC1DyS,EAAO,MAAM,KAAK,cAAc3I,IAAW,KAAK,IAAI9J,CAAK,CAAC;AAAA,IAAA;AAAA,EAElE;AAAA,EAQQ,yBAAyB0T,GAA4B;AACzD,WAAOA,EAAQ,IAAI,CAAAjB,MAAU,KAAK,KAAK,mBAAmBA,CAAM,CAAC;AAAA,EACrE;AAAA,EAOQ,eAAyB;AACxB,QAAA,KAAK,cAAc,oBAAoB,UACpC,KAAK,cAAc,gBAAgB,UAAU;AACjD,aAAO,KAAK,cAAc;AAExB,UAAAkB,IAAY,KAAK,KAAK,QAAQ,GAC9BC,IAA0B,KAAK,cAAc,gBAC9C,KAAK,CAAC7V,GAAG6F,MAAMA,EAAE,eAAe7F,EAAE,YAAY,EAC9C,OAAO,CAAiB8V,MAAAF,KAAaE,EAAc,YAAY;AAChE,WAAAD,EAAwB,SAAS,IAC1BA,EAAwB,GAAG,WAE3B,KAAK,cAAc;AAAA,EAElC;AAAA,EAOQ,YAAmB;AACjB,UAAAE,IAAW,KAAK;AACtB,WAAQ,KAAK,aAAa,SAAaA,EAAS,cAAcA,EAAS;AAAA,EAC3E;AAAA,EAOQ,6BAA8C;AAC5C,UAAAtU,IAAQ,KAAK;AACf,QAAAuI,IAAI,IAAI/D;AACR,QAAA,KAAK,aAAa,QAAW;AAC7B,YAAM+P,IAAe,KAAK,uBAAuB,KAAK,QAAQ;AAC1D,MAAAhM,IAAAA,EAAE,OAAOgM,CAAY;AAAA,IAC7B;AACI,WAAAvU,EAAM,WAAW,WACbuI,IAAAA,EAAE,UAAU,CAACvI,EAAM,OAAO,IAAI,CAACA,EAAM,OAAO,EAAE,IAEtDuI,IAAIA,EAAE,MAAMvI,EAAM,QAAQA,EAAM,OAAO,GAEhC,CADQA,EAAM,OAAO,IAAI,OAASuI,EAAE,UAAUhH,CAAK,CAAC,GAC3CvB,EAAM,KAAK;AAAA,EAC/B;AAAA,EAOQ,2BAAoC;AACxC,UAAM,CAACuN,GAAQiH,CAAK,IAAI,KAAK,2BAA2B;AACxD,YAAQA,GAAO;AAAA,MACX,KAAK,UAAU;AACX,cAAMC,IAAI,KAAK,KAAK,mBAAmB,KAAK,OAAO,GAC7ClM,IAAI,IAAI/D,KAAS,UAAUiQ,EAAE,GAAGA,EAAE,CAAC;AAClC,eAAAlH,EAAO,IAAI,CAAShM,MAAA;AACjB,gBAAAmT,IAAKnM,EAAE,UAAUhH,CAAK;AAC5B,iBAAO,IAAI4G,GAAMuM,EAAG,IAAIA,EAAG,EAAE;AAAA,QAAA,CAChC;AAAA,MACL;AAAA,MACA,KAAK;AACD,eAAOnH,EAAO,IAAI,CAAShM,MAAA,KAAK,KAAK;AAAA,UACjC,IAAI0S;AAAA,YACA,KAAK,QAAQ,MAAM,KAAK,cAAc1S,EAAM,EAAE;AAAA,YAC9C,KAAK,QAAQ,MAAM,KAAK,cAAcA,EAAM,EAAE;AAAA,UAClD;AAAA,QAAA,CACH;AAAA,IAIT;AAAA,EACJ;AAAA,EASA,OAAe,WAAWgM,GAAiBoH,GAAwB;AAC/D,QAAIC,IAAS;AACb,aAASxgB,IAAI,GAAGA,IAAImZ,EAAO,QAAQnZ,KAAK;AACpC,YAAMmN,IAAQgM,EAAOnZ;AACrB,MAAIwgB,MAAW,KACFA,IAAA,KAAKrT,EAAM,KAAKA,EAAM,OAErBqT,KAAA,KAAKrT,EAAM,KAAKA,EAAM;AAAA,IAExC;AACA,WAAIoT,MACUC,KAAA,MAEPA;AAAA,EACX;AACJ;AA3bO,IAAMC,IAAN9B;AAAM8B,EAIK,+BAAuC,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,GAAG,GAAG,CAAC,OAAO,IAAI,CAAC;AAJnFA,EAOK,iCAAyC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC;AAPvFA,EAUM,oBAA8B;AAAA,EACzC,aAAa;AAAA,IACT,QAAQ9B,EAAY;AAAA,IACpB,QAAQF;AAAAA,IACR,SAASA;AAAAA,IACT,OAAO;AAAA,EACX;AAAA,EACA,gBAAgB;AAAA,IACZ,QAAQE,EAAY;AAAA,IACpB,QAAQF;AAAAA,IACR,SAASA;AAAAA,IACT,OAAO;AAAA,EACX;AACJ;AC7BJ,MAAMA,KAAe,IACfiC,KAAyB,IACzBhC,KAAsB,IACtBiC,KAA6B,OAQ7BC,KAAiB,WACjBC,KAAsB,WACtBC,IAAY,WACZC,IAAiB,WACjBC,KAAgB,WAChBC,KAAqB,WACrBC,IAAY,WACZC,IAAiB,WACjBC,IAAgB,WAChBC,IAAqB,WACrBC,IAAkB,WAClBC,IAAuB,WACvBC,IAAc,WACdC,IAAmB,WACnBC,IAAe,WACfC,IAAoB,WACpBC,IAAc,WACdC,IAAmB,WAEnBC,KAAQ;AAAA,EACV,GAAGC,EAAY,iBAAiBjB,GAAWC,CAAc;AAAA,EACzD,IAAIgB,EAAY,gDAAgDjB,GAAWC,CAAc;AAAA,EACzF,IAAIgB,EAAY,8CAA8CjB,GAAWC,CAAc;AAAA,EACvF,IAAIgB,EAAY,8CAA8CjB,GAAWC,CAAc;AAAA,EACvF,IAAIgB,EAAY,8CAA8CjB,GAAWC,CAAc;AAAA,EACvF,IAAIgB,EAAY,8CAA8CjB,GAAWC,CAAc;AAAA,EACvF,IAAIgB,EAAY,iDAAiDjB,GAAWC,CAAc;AAAA,EAC1F,IAAIgB,EAAY,iDAAiDjB,GAAWC,CAAc;AAAA,EAC1F,IAAIgB,EAAY,iDAAiDjB,GAAWC,CAAc;AAAA,EAC1F,IAAIgB,EAAY,iDAAiDjB,GAAWC,CAAc;AAAA,EAC1F,IAAIgB,EAAY,iDAAiDjB,GAAWC,CAAc;AAAA,EAC1F,IAAIgB,EAAY,WAAWf,IAAeC,EAAkB;AAAA,EAC5D,IAAIc,EAAY,UAAUf,IAAeC,EAAkB;AAAA,EAC3D,IAAIc,EAAY,sDAAsDf,IAAeC,EAAkB;AAAA,EACvG,IAAIc,EAAY,8BAA8Bf,IAAeC,EAAkB;AAAA,EAC/E,IAAIc,EAAY,cAAcf,IAAeC,EAAkB;AAAA,EAC/D,IAAIc,EAAY,gBAAgBf,IAAeC,EAAkB;AAAA,EACjE,IAAIc,EAAY,WAAWf,IAAeC,EAAkB;AAAA,EAC5D,IAAIc,EAAY,kBAAkBf,IAAeC,EAAkB;AAAA,EACnE,IAAIc,EAAY,kDAAkDb,GAAWC,CAAc;AAAA,EAC3F,IAAIY,EAAY,gDAAgDb,GAAWC,CAAc;AAAA,EACzF,IAAIY,EAAY,gDAAgDb,GAAWC,CAAc;AAAA,EACzF,IAAIY,EAAY,gDAAgDb,GAAWC,CAAc;AAAA,EACzF,IAAIY,EAAY,gDAAgDb,GAAWC,CAAc;AAAA,EACzF,IAAIY,EAAY,mDAAmDb,GAAWC,CAAc;AAAA,EAC5F,IAAIY,EAAY,mDAAmDb,GAAWC,CAAc;AAAA,EAC5F,IAAIY,EAAY,mDAAmDb,GAAWC,CAAc;AAAA,EAC5F,IAAIY,EAAY,mDAAmDb,GAAWC,CAAc;AAAA,EAC5F,IAAIY,EAAY,qDAAqDb,GAAWC,CAAc;AAAA,EAC9F,IAAIY,EAAY,gBAAgBX,GAAeC,CAAkB;AAAA,EACjE,IAAIU,EAAY,4BAA4BX,GAAeC,CAAkB;AAAA,EAC7E,IAAIU,EAAY,OAAOX,GAAeC,CAAkB;AAAA,EACxD,IAAIU,EAAY,eAAeX,GAAeC,CAAkB;AAAA,EAChE,IAAIU,EAAY,4BAA4BX,GAAeC,CAAkB;AAAA,EAC7E,IAAIU,EAAY,mBAAmBX,GAAeC,CAAkB;AAAA,EACpE,IAAIU,EAAY,wBAAwBX,GAAeC,CAAkB;AAAA,EACzE,IAAIU,EAAY,wBAAwBX,GAAeC,CAAkB;AAAA,EACzE,IAAIU,EAAY,qBAAqBX,GAAeC,CAAkB;AAAA,EACtE,IAAIU,EAAY,uDAAuD,IAAI,EAAE;AAAA,EAC7E,IAAIA,EAAY,qCAAqCT,GAAiBC,CAAoB;AAAA,EAC1F,IAAIQ,EAAY,mCAAmCT,GAAiBC,CAAoB;AAAA,EACxF,IAAIQ,EAAY,mCAAmCT,GAAiBC,CAAoB;AAAA,EACxF,IAAIQ,EAAY,mCAAmCT,GAAiBC,CAAoB;AAAA,EACxF,IAAIQ,EAAY,mCAAmCT,GAAiBC,CAAoB;AAAA,EACxF,IAAIQ,EAAY,sCAAsCT,GAAiBC,CAAoB;AAAA,EAC3F,IAAIQ,EAAY,sCAAsCT,GAAiBC,CAAoB;AAAA,EAC3F,IAAIQ,EAAY,sCAAsCT,GAAiBC,CAAoB;AAAA,EAC3F,IAAIQ,EAAY,sCAAsCT,GAAiBC,CAAoB;AAAA,EAC3F,IAAIQ,EAAY,wCAAwCT,GAAiBC,CAAoB;AAAA,EAC7F,IAAIQ,EAAY,iCAAiCP,GAAaC,CAAgB;AAAA,EAC9E,IAAIM,EAAY,+BAA+BP,GAAaC,CAAgB;AAAA,EAC5E,IAAIM,EAAY,+BAA+BP,GAAaC,CAAgB;AAAA,EAC5E,IAAIM,EAAY,+BAA+BP,GAAaC,CAAgB;AAAA,EAC5E,IAAIM,EAAY,+BAA+BP,GAAaC,CAAgB;AAAA,EAC5E,IAAIM,EAAY,kCAAkCP,GAAaC,CAAgB;AAAA,EAC/E,IAAIM,EAAY,kCAAkCP,GAAaC,CAAgB;AAAA,EAC/E,IAAIM,EAAY,kCAAkCP,GAAaC,CAAgB;AAAA,EAC/E,IAAIM,EAAY,kCAAkCP,GAAaC,CAAgB;AAAA,EAC/E,IAAIM,EAAY,oCAAoCP,GAAaC,CAAgB;AAAA,EACjF,IAAIM,EAAY,kCAAkCL,GAAcC,CAAiB;AAAA,EACjF,IAAII,EAAY,gCAAgCL,GAAcC,CAAiB;AAAA,EAC/E,IAAII,EAAY,gCAAgCL,GAAcC,CAAiB;AAAA,EAC/E,IAAII,EAAY,gCAAgCL,GAAcC,CAAiB;AAAA,EAC/E,IAAII,EAAY,gCAAgCL,GAAcC,CAAiB;AAAA,EAC/E,IAAII,EAAY,mCAAmCL,GAAcC,CAAiB;AAAA,EAClF,IAAII,EAAY,mCAAmCL,GAAcC,CAAiB;AAAA,EAClF,IAAII,EAAY,mCAAmCL,GAAcC,CAAiB;AAAA,EAClF,IAAII,EAAY,mCAAmCL,GAAcC,CAAiB;AAAA,EAClF,IAAII,EAAY,qCAAqCL,GAAcC,CAAiB;AAAA,EACpF,IAAII,EAAY,sCAAsCH,GAAaC,CAAgB;AAAA,EACnF,IAAIE,EAAY,oCAAoCH,GAAaC,CAAgB;AAAA,EACjF,IAAIE,EAAY,oCAAoCH,GAAaC,CAAgB;AAAA,EACjF,IAAIE,EAAY,oCAAoCH,GAAaC,CAAgB;AAAA,EACjF,IAAIE,EAAY,oCAAoCH,GAAaC,CAAgB;AAAA,EACjF,IAAIE,EAAY,uCAAuCH,GAAaC,CAAgB;AAAA,EACpF,IAAIE,EAAY,uCAAuCH,GAAaC,CAAgB;AAAA,EACpF,IAAIE,EAAY,uCAAuCH,GAAaC,CAAgB;AAAA,EACpF,IAAIE,EAAY,uCAAuCH,GAAaC,CAAgB;AAAA,EACpF,IAAIE,EAAY,yCAAyCH,GAAaC,CAAgB;AAC1F,GACMG,KAAgBD,EAAY,YAAYnB,IAAgBC,EAAmB,GAC3EoB,KAAeF,EAAY,WAAWnB,IAAgBC,EAAmB,GAElEqB,KAAN,cACKzB,EAAY;AAAA,EAiBpB,YAAY0B,GAAgCrD,GAAiC;AACzE,UAAM,CAACqD,EAAe,UAAUA,EAAe,SAAS,GAAGrD,CAAO,GAE7DC,GAAA,WAAW,MAAMD,CAAO,GAC7BA,IAAUA,KAAW,IAChB,KAAA,cAAcA,EAAQ,cAAcJ,IACpC,KAAA,gBAAgBI,EAAQ,gBAAgB4B,IACxC,KAAA,QAAQ5B,EAAQ,QAAQL,IAC7B,KAAK,kBAAkB0D,CAAc,GAChC,KAAA,kBAAkBrD,EAAQ,cAAc;AAAA,EACjD;AAAA,EAQO,kBAAkBqD,GAAsC;AAC3D,gBAAK,kBAAkBA,GACvB,KAAK,UAAU,CAACA,EAAe,UAAUA,EAAe,SAAS,CAAC,GAC9D,CAACC,EAAkBD,EAAe,WAAW,KAAMA,EAAe,eAAe,MACjF,KAAK,WAAWE,GAAUF,EAAe,WAAW,CAAC,IAErD,KAAK,WAAW,MAAS,GAEzB,CAACC,EAAkBD,EAAe,GAAG,KAAMA,EAAe,MAAM,MAChE,KAAK,UAAUE,GAAUF,EAAe,GAAG,CAAC,IAE5C,KAAK,UAAU,MAAS,GAExB,CAACC,EAAkBD,EAAe,GAAG,KAAMA,EAAe,MAAM,QAC3D,KAAA,SAASA,EAAe,MAAMxB,EAA0B,IAE7D,KAAK,SAAS,MAAS,GAEpB,KAAK;EAChB;AAAA,EAQO,kBAAkB2B,GAAuC;AAC5D,SAAK,kBAAkBA;AACvB,UAAMC,IAAW,CAACH,EAAkBE,CAAc,KAAK,CAACF,EAAkBE,EAAe,IAAI,IACvFE,GAAYF,EAAe,IAAI,IAAIR,GAAM;AAC/C,gBAAK,SAAS;AAAA,MACV,OAAOS,EAAS;AAAA,MAChB,MAAM;AAAA,MACN,aAAa;AAAA,MACb,WAAWA,EAAS;AAAA,IAAA,CACvB,GACD,KAAK,UAAU,KAAK,iBAAiB,KAAK,iBAAiBD,CAAc,CAAC,GACnE,KAAK,gBAAgBJ,GAAe;AAAA,MAAiB,KAAK;AAAA,MAAa,KAAK;AAAA,MAAe,KAAK;AAAA,MACnGI;AAAA,IAAA,CAAe;AAAA,EACvB;AAAA,EAEA,OAAe,iBAAiBG,GAAoBC,GAAsB7O,GAC1CyO,GAA+C;AAC3E,UAAMjD,IAA6B;AAAA,MAC/B,YAAAoD;AAAA,MACA,iBAAiBhC,EAAY,eAAe5M,CAAI;AAAA,IAAA,GAE9CqM,IAAWgC,GAAe,aAAarO,GAAMyO,CAAc;AACjE,WAAIpC,MAAa,SACbb,EAAa,kBAAkB,CAAC;AAAA,MAC5B,UAAAa;AAAA,MACA,cAAAwC;AAAA,IAAA,CACH,IAEErD;AAAA,EACX;AAAA,EAEA,OAAe,aAAaxL,GAAcyO,GAAkD;AACpF,WAAAF,EAAkBE,CAAc,KAAKF,EAAkBE,EAAe,SAAS,KAC5E,CAACK,GAAiBL,EAAe,SAAS,IACtC,OAEJ;AAAA,MACH,aAAa;AAAA,QACT,QAAQJ,GAAe;AAAA,QACvB,QAAQ,CAACI,EAAe,UAAU,GAAGA,EAAe,UAAU,CAAC;AAAA,QAC/D,QAAQA,EAAe,UAAU,IAAIA,EAAe,UAAU;AAAA,QAC9D,SAASA,EAAe,UAAU,IAAIA,EAAe,UAAU;AAAA,QAC/D,OAAO;AAAA,MACX;AAAA,MACA,gBAAgB7B,EAAY,YAAYA,EAAY,gCAAgC5M,CAAI;AAAA,IAAA;AAAA,EAEhG;AAAA,EAEQ,iBAAiBsO,GAAiCG,GAA8C;AACpG,QAAIM,IAAU;AACV,IAACR,EAAkBE,CAAc,MACtBM,KAAAC,EAAe,WAAWP,EAAe,MAAM,GAC/CM,KAAAC,EAAe,cAAcP,EAAe,SAAS,GACrDM,KAAAC,EAAe,aAAaP,EAAe,QAAQ,GACnDM,KAAAC,EAAe,QAAQP,EAAe,IAAI,IAEpDF,EAAkBD,CAAc,MACjCS,KAAWC,EAAe,YAAY,GAAGV,EAAe,aAAaA,EAAe,WAAW,GAC/FS,KAAWC,EAAe,OAAQT,EAAkBD,EAAe,GAAG,IAChC,SAAhCA,EAAe,IAAI,QAAQ,CAAC,GAAe,OAAO,GACxDS,KAAWC,EAAe,OAAQT,EAAkBD,EAAe,GAAG,IAChC,SAAhCA,EAAe,IAAI,QAAQ,CAAC,GAAe,GAAG,GACpDS,KAAWC,EAAe,WAAYT,EAAkBD,EAAe,WAAW,IACpC,SAAxCA,EAAe,YAAY,QAAQ,CAAC,GAAe,GAAG,GACjDS,KAAAC;AAAA,MAAe;AAAA,MACtBC,GAAyBX,EAAe,kBAAkB;AAAA,IAAA,IAE7DC,EAAkBE,CAAc,MACjCM,KAAWC,EAAe,QAAQE,GAAaT,EAAe,IAAI,CAAC,GAC/D,CAACF,EAAkBE,EAAe,SAAS,KAAKK,GAAiBL,EAAe,SAAS,MAC9EM,KAAAC;AAAA,MAAe;AAAA,MACtBP,EAAe,UAAU,IAAIA,EAAe,UAAU;AAAA,MAAG;AAAA,IAAA,GAClDM,KAAAC;AAAA,MAAe;AAAA,MACtBP,EAAe,UAAU,IAAIA,EAAe,UAAU;AAAA,MAAG;AAAA,IAAA,IAEjEM,KAAWC,EAAe,YAAYG,GAAgBV,EAAe,OAAO,CAAC,GAC7EM,KAAWC,EAAe,OAAOI,GAAYX,EAAe,GAAG,CAAC,GACrDM,KAAAC;AAAA,MAAe;AAAA,MACrBT,EAAkBE,EAAe,oBAAoB,IACC,SAAjDA,EAAe,qBAAqB,QAAQ,CAAC;AAAA,MAAe;AAAA,IAAA,GAC3DM,KAAAC,EAAe,eAAeP,EAAe,WAAW,GACxDM,KAAAC,EAAe,OAAOP,EAAe,GAAG,IAE5CM,KAAA;AACL,UAAAM,IAAeC,GAAQ,OAAO,KAAK;AACzC,WAAAD,EAAa,YAAYN,GAClBM;AAAA,EACX;AACJ;AAvJO,IAAME,KAANlB;AAAMkB,GAIK,kCAA0C,CAAC,CAAC,GAAG,GAAG,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;AAqJ3G,SAASL,GAAaM,GAAkC;AAChD,SAAAjB,EAAkBiB,CAAI,IACf,SAEMb,GAAYa,CAAI,EACjB;AACpB;AAEA,SAASL,GAAgBM,GAAqC;AACtD,MAAA,CAAAlB,EAAkBkB,CAAO;AAG7B,YAAQA,GAAS;AAAA,MACb,KAAK;AACM;AAAA,MACX,KAAK;AACM,eAAA;AAAA,MACX,KAAK;AACM,eAAA;AAAA,MACX,KAAK;AACM,eAAA;AAAA,MACX,KAAK;AACM,eAAA;AAAA,MACX,KAAK;AACM,eAAA;AAAA,MACX,KAAK;AACM,eAAA;AAAA,MACX,KAAK;AACM,eAAA;AAAA,MACX,KAAK;AACM,eAAA;AAAA,MACX,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACD,eAAO,aAAaA;AAAA,MACxB,KAAK;AACM,eAAA;AAAA,MACX;AACI,eAAO,YAAYA;AAAA,IAC3B;AACJ;AAEA,SAASR,GAAyBS,GAA8C;AACxE,MAAA,CAAAnB,EAAkBmB,CAAgB;AAGtC,YAAQA,GAAkB;AAAA,MACtB,KAAK;AACM,eAAA;AAAA,MACX,KAAK;AACM,eAAA;AAAA,MACX,KAAK;AACM,eAAA;AAAA,MACX,KAAK;AACM,eAAA;AAAA,MACX,KAAK;AACM,eAAA;AAAA,MACX,KAAK;AACM,eAAA;AAAA,MACX,KAAK;AACM,eAAA;AAAA,MACX,KAAK;AACM,eAAA;AAAA,MACX,KAAK;AACM,eAAA;AAAA,MACX,KAAK;AACM,eAAA;AAAA,MACX,KAAK;AACM,eAAA;AAAA,MACX,KAAK;AACM,eAAA;AAAA,MACX,KAAK;AACM,eAAA;AAAA,MACX,KAAK;AACM,eAAA;AAAA,MACX,KAAK;AACM,eAAA;AAAA,MACX,KAAK;AACM,eAAA;AAAA,MACX;AACI,eAAO,YAAYA;AAAA,IAC3B;AACJ;AAEA,SAASN,GAAYO,GAA8B;AAC3C,MAAA,CAAApB,EAAkBoB,CAAG;AAGzB,WAAO,GAAGA,EAAI,MAAM,SAAW,EAAA,SAAS,GAAG,GAAG,KAAKA,EAAI,IAAI,WAAW,SAAS,GAAG,GAAG,KAAKA,EAAI,KAAK,SAAS,EAAE,SAAS,GAAG,GAAG,KAAKA,EAAI,OAAO,SAAA,EAAW,SAAS,GAAG,GAAG;AAC3K;AAEA,SAASnB,GAAUoB,GAAqD;AAC/D,MAAAA,KAAS;AAGP,WAAAA,IAAO,KAAK,KAAK;AAC5B;AAEA,SAASrB,EAAkBnW,GAAiB;AAChC,SAAAA,KAAM;AAClB;AAEA,SAAS0W,GAAiBe,GAAgC;AACtD,SAAO,CAACtB,EAAkBsB,CAAS,KAC3BA,EAAU,IAAI,KAAOA,EAAU,IAAI,KAAOA,EAAU,IAAI,KAAOA,EAAU,IAAI;AACzF;AAEA,SAASb,EAAec,GAAcrmB,GAAYsmB,GAAuB;AACjE,SAAAxB,EAAkB9kB,CAAK,IAChB,KAEJ,WAAWqmB,aAAgBrmB,KAAS8kB,EAAkBwB,CAAI,IAAI,KAAKA;AAC9E;AASA,SAAS7B,EAAY4B,GAAcjS,GAAemS,GAAqB;AAC5D,SAAA;AAAA,IACH,MAAAF;AAAA,IACA,OAAAjS;AAAA,IACA,WAAAmS;AAAA,EAAA;AAER;AAEA,SAASrB,GAAYa,GAAwB;AACpC,MAAAA,IAAO,KAAOA,IAAO;AACf,WAAApB;AAEX,QAAMM,IAAWT,GAAMuB;AACnB,SAACjB,EAAkBG,CAAQ,IAGxBP,KAFIO;AAGf;ACjYAvD,GAAE,cAAiB,SAASH,GAA0BC,GAA2C;AACtF,SAAA,IAAI2B,EAAY5B,GAAQC,CAAO;AAC1C;AACAE,GAAE,cAAiByB;AAEnBzB,GAAE,iBAAoB,SAASmD,GAAgCrD,GAAiD;AACrG,SAAA,IAAIsE,GAAejB,GAAgBrD,CAAO;AACrD;AACAE,GAAE,iBAAoBoE;"}